[INFO] 2017-05-24: 21:05:12 org.springframework.web.context.ContextLoader.initWebApplicationContext(ContextLoader.java:305) :  Root WebApplicationContext: initialization started
[DEBUG] 2017-05-24: 21:05:12 org.springframework.core.env.MutablePropertySources.addLast(MutablePropertySources.java:109) :  Adding [servletConfigInitParams] PropertySource with lowest search precedence
[DEBUG] 2017-05-24: 21:05:12 org.springframework.core.env.MutablePropertySources.addLast(MutablePropertySources.java:109) :  Adding [servletContextInitParams] PropertySource with lowest search precedence
[DEBUG] 2017-05-24: 21:05:12 org.springframework.core.env.MutablePropertySources.addLast(MutablePropertySources.java:109) :  Adding [jndiProperties] PropertySource with lowest search precedence
[DEBUG] 2017-05-24: 21:05:12 org.springframework.core.env.MutablePropertySources.addLast(MutablePropertySources.java:109) :  Adding [systemProperties] PropertySource with lowest search precedence
[DEBUG] 2017-05-24: 21:05:12 org.springframework.core.env.MutablePropertySources.addLast(MutablePropertySources.java:109) :  Adding [systemEnvironment] PropertySource with lowest search precedence
[DEBUG] 2017-05-24: 21:05:12 org.springframework.core.env.AbstractEnvironment.<init>(AbstractEnvironment.java:124) :  Initialized StandardServletEnvironment with PropertySources [servletConfigInitParams,servletContextInitParams,jndiProperties,systemProperties,systemEnvironment]
[DEBUG] 2017-05-24: 21:05:12 org.springframework.core.env.MutablePropertySources.replace(MutablePropertySources.java:174) :  Replacing [servletContextInitParams] PropertySource with [servletContextInitParams]
[INFO] 2017-05-24: 21:05:12 org.springframework.context.support.AbstractApplicationContext.prepareRefresh(AbstractApplicationContext.java:581) :  Refreshing Root WebApplicationContext: startup date [Wed May 24 21:05:12 CST 2017]; root of context hierarchy
[DEBUG] 2017-05-24: 21:05:12 org.springframework.core.env.MutablePropertySources.addLast(MutablePropertySources.java:109) :  Adding [systemProperties] PropertySource with lowest search precedence
[DEBUG] 2017-05-24: 21:05:12 org.springframework.core.env.MutablePropertySources.addLast(MutablePropertySources.java:109) :  Adding [systemEnvironment] PropertySource with lowest search precedence
[DEBUG] 2017-05-24: 21:05:12 org.springframework.core.env.AbstractEnvironment.<init>(AbstractEnvironment.java:124) :  Initialized StandardEnvironment with PropertySources [systemProperties,systemEnvironment]
[INFO] 2017-05-24: 21:05:12 org.springframework.beans.factory.xml.XmlBeanDefinitionReader.loadBeanDefinitions(XmlBeanDefinitionReader.java:317) :  Loading XML bean definitions from class path resource [spring-core.xml]
[DEBUG] 2017-05-24: 21:05:12 org.springframework.beans.factory.xml.DefaultDocumentLoader.loadDocument(DefaultDocumentLoader.java:73) :  Using JAXP provider [com.sun.org.apache.xerces.internal.jaxp.DocumentBuilderFactoryImpl]
[DEBUG] 2017-05-24: 21:05:12 org.springframework.beans.factory.xml.PluggableSchemaResolver.getSchemaMappings(PluggableSchemaResolver.java:141) :  Loading schema mappings from [META-INF/spring.schemas]
[DEBUG] 2017-05-24: 21:05:12 org.springframework.beans.factory.xml.PluggableSchemaResolver.getSchemaMappings(PluggableSchemaResolver.java:147) :  Loaded schema mappings: {http://www.springframework.org/schema/tx/spring-tx-2.5.xsd=org/springframework/transaction/config/spring-tx-2.5.xsd, http://www.springframework.org/schema/tx/spring-tx-4.3.xsd=org/springframework/transaction/config/spring-tx-4.3.xsd, http://www.springframework.org/schema/cache/spring-cache-4.2.xsd=org/springframework/cache/config/spring-cache-4.2.xsd, http://www.springframework.org/schema/aop/spring-aop-4.1.xsd=org/springframework/aop/config/spring-aop-4.1.xsd, http://www.springframework.org/schema/context/spring-context-3.1.xsd=org/springframework/context/config/spring-context-3.1.xsd, http://www.springframework.org/schema/jdbc/spring-jdbc-4.1.xsd=org/springframework/jdbc/config/spring-jdbc-4.1.xsd, http://www.springframework.org/schema/util/spring-util-3.0.xsd=org/springframework/beans/factory/xml/spring-util-3.0.xsd, http://www.springframework.org/schema/tool/spring-tool.xsd=org/springframework/beans/factory/xml/spring-tool-4.3.xsd, http://www.springframework.org/schema/aop/spring-aop-3.2.xsd=org/springframework/aop/config/spring-aop-3.2.xsd, http://www.springframework.org/schema/lang/spring-lang-4.1.xsd=org/springframework/scripting/config/spring-lang-4.1.xsd, http://www.springframework.org/schema/context/spring-context-4.0.xsd=org/springframework/context/config/spring-context-4.0.xsd, http://www.springframework.org/schema/beans/spring-beans-4.2.xsd=org/springframework/beans/factory/xml/spring-beans-4.2.xsd, http://www.springframework.org/schema/tool/spring-tool-4.1.xsd=org/springframework/beans/factory/xml/spring-tool-4.1.xsd, http://www.springframework.org/schema/lang/spring-lang-3.2.xsd=org/springframework/scripting/config/spring-lang-3.2.xsd, http://www.springframework.org/schema/cache/spring-cache-3.2.xsd=org/springframework/cache/config/spring-cache-3.2.xsd, http://www.springframework.org/schema/jee/spring-jee-4.1.xsd=org/springframework/ejb/config/spring-jee-4.1.xsd, http://www.springframework.org/schema/jdbc/spring-jdbc-3.1.xsd=org/springframework/jdbc/config/spring-jdbc-3.1.xsd, http://www.springframework.org/schema/util/spring-util-2.0.xsd=org/springframework/beans/factory/xml/spring-util-2.0.xsd, http://www.springframework.org/schema/task/spring-task-4.2.xsd=org/springframework/scheduling/config/spring-task-4.2.xsd, http://www.springframework.org/schema/tool/spring-tool-3.2.xsd=org/springframework/beans/factory/xml/spring-tool-3.2.xsd, http://www.springframework.org/schema/context/spring-context.xsd=org/springframework/context/config/spring-context-4.3.xsd, http://www.springframework.org/schema/tx/spring-tx-4.2.xsd=org/springframework/transaction/config/spring-tx-4.2.xsd, http://www.springframework.org/schema/cache/spring-cache-4.1.xsd=org/springframework/cache/config/spring-cache-4.1.xsd, http://www.springframework.org/schema/aop/spring-aop-4.0.xsd=org/springframework/aop/config/spring-aop-4.0.xsd, http://www.springframework.org/schema/jee/spring-jee-3.2.xsd=org/springframework/ejb/config/spring-jee-3.2.xsd, http://www.springframework.org/schema/context/spring-context-3.0.xsd=org/springframework/context/config/spring-context-3.0.xsd, http://www.springframework.org/schema/jdbc/spring-jdbc-4.0.xsd=org/springframework/jdbc/config/spring-jdbc-4.0.xsd, http://www.springframework.org/schema/util/spring-util-4.3.xsd=org/springframework/beans/factory/xml/spring-util-4.3.xsd, http://www.springframework.org/schema/util/spring-util-2.5.xsd=org/springframework/beans/factory/xml/spring-util-2.5.xsd, http://www.springframework.org/schema/beans/spring-beans-3.2.xsd=org/springframework/beans/factory/xml/spring-beans-3.2.xsd, http://www.springframework.org/schema/aop/spring-aop-3.1.xsd=org/springframework/aop/config/spring-aop-3.1.xsd, http://www.springframework.org/schema/lang/spring-lang-4.0.xsd=org/springframework/scripting/config/spring-lang-4.0.xsd, http://www.springframework.org/schema/beans/spring-beans-4.1.xsd=org/springframework/beans/factory/xml/spring-beans-4.1.xsd, http://www.springframework.org/schema/tool/spring-tool-4.0.xsd=org/springframework/beans/factory/xml/spring-tool-4.0.xsd, http://www.springframework.org/schema/lang/spring-lang-3.1.xsd=org/springframework/scripting/config/spring-lang-3.1.xsd, http://www.springframework.org/schema/tx/spring-tx-3.2.xsd=org/springframework/transaction/config/spring-tx-3.2.xsd, http://www.springframework.org/schema/cache/spring-cache-3.1.xsd=org/springframework/cache/config/spring-cache-3.1.xsd, http://www.springframework.org/schema/jee/spring-jee-4.0.xsd=org/springframework/ejb/config/spring-jee-4.0.xsd, http://www.springframework.org/schema/jdbc/spring-jdbc-3.0.xsd=org/springframework/jdbc/config/spring-jdbc-3.0.xsd, http://www.springframework.org/schema/task/spring-task-4.1.xsd=org/springframework/scheduling/config/spring-task-4.1.xsd, http://www.springframework.org/schema/tool/spring-tool-3.1.xsd=org/springframework/beans/factory/xml/spring-tool-3.1.xsd, http://www.springframework.org/schema/jdbc/spring-jdbc.xsd=org/springframework/jdbc/config/spring-jdbc-4.3.xsd, http://www.springframework.org/schema/tx/spring-tx-4.1.xsd=org/springframework/transaction/config/spring-tx-4.1.xsd, http://www.springframework.org/schema/cache/spring-cache-4.0.xsd=org/springframework/cache/config/spring-cache-4.0.xsd, http://www.springframework.org/schema/jee/spring-jee-3.1.xsd=org/springframework/ejb/config/spring-jee-3.1.xsd, http://www.springframework.org/schema/util/spring-util-4.2.xsd=org/springframework/beans/factory/xml/spring-util-4.2.xsd, http://www.springframework.org/schema/task/spring-task-3.2.xsd=org/springframework/scheduling/config/spring-task-3.2.xsd, http://www.springframework.org/schema/beans/spring-beans-3.1.xsd=org/springframework/beans/factory/xml/spring-beans-3.1.xsd, http://www.springframework.org/schema/util/spring-util.xsd=org/springframework/beans/factory/xml/spring-util-4.3.xsd, http://www.springframework.org/schema/aop/spring-aop-3.0.xsd=org/springframework/aop/config/spring-aop-3.0.xsd, http://www.springframework.org/schema/beans/spring-beans-4.0.xsd=org/springframework/beans/factory/xml/spring-beans-4.0.xsd, http://www.springframework.org/schema/beans/spring-beans.xsd=org/springframework/beans/factory/xml/spring-beans-4.3.xsd, http://www.springframework.org/schema/lang/spring-lang-3.0.xsd=org/springframework/scripting/config/spring-lang-3.0.xsd, http://www.springframework.org/schema/tx/spring-tx-3.1.xsd=org/springframework/transaction/config/spring-tx-3.1.xsd, http://www.springframework.org/schema/context/spring-context-2.5.xsd=org/springframework/context/config/spring-context-2.5.xsd, http://www.springframework.org/schema/context/spring-context-4.3.xsd=org/springframework/context/config/spring-context-4.3.xsd, http://www.springframework.org/schema/task/spring-task-4.0.xsd=org/springframework/scheduling/config/spring-task-4.0.xsd, http://www.springframework.org/schema/tool/spring-tool-3.0.xsd=org/springframework/beans/factory/xml/spring-tool-3.0.xsd, http://www.springframework.org/schema/tx/spring-tx-4.0.xsd=org/springframework/transaction/config/spring-tx-4.0.xsd, http://www.springframework.org/schema/aop/spring-aop-2.0.xsd=org/springframework/aop/config/spring-aop-2.0.xsd, http://www.springframework.org/schema/jee/spring-jee-3.0.xsd=org/springframework/ejb/config/spring-jee-3.0.xsd, http://www.springframework.org/schema/util/spring-util-4.1.xsd=org/springframework/beans/factory/xml/spring-util-4.1.xsd, http://www.springframework.org/schema/task/spring-task-3.1.xsd=org/springframework/scheduling/config/spring-task-3.1.xsd, http://www.springframework.org/schema/beans/spring-beans-3.0.xsd=org/springframework/beans/factory/xml/spring-beans-3.0.xsd, http://www.springframework.org/schema/jee/spring-jee.xsd=org/springframework/ejb/config/spring-jee-4.3.xsd, http://www.springframework.org/schema/aop/spring-aop-2.5.xsd=org/springframework/aop/config/spring-aop-2.5.xsd, http://www.springframework.org/schema/aop/spring-aop-4.3.xsd=org/springframework/aop/config/spring-aop-4.3.xsd, http://www.springframework.org/schema/lang/spring-lang-2.0.xsd=org/springframework/scripting/config/spring-lang-2.0.xsd, http://www.springframework.org/schema/jdbc/spring-jdbc-4.3.xsd=org/springframework/jdbc/config/spring-jdbc-4.3.xsd, http://www.springframework.org/schema/util/spring-util-3.2.xsd=org/springframework/beans/factory/xml/spring-util-3.2.xsd, http://www.springframework.org/schema/task/spring-task.xsd=org/springframework/scheduling/config/spring-task-4.3.xsd, http://www.springframework.org/schema/tool/spring-tool-2.0.xsd=org/springframework/beans/factory/xml/spring-tool-2.0.xsd, http://www.springframework.org/schema/tx/spring-tx-3.0.xsd=org/springframework/transaction/config/spring-tx-3.0.xsd, http://www.springframework.org/schema/lang/spring-lang-2.5.xsd=org/springframework/scripting/config/spring-lang-2.5.xsd, http://www.springframework.org/schema/lang/spring-lang-4.3.xsd=org/springframework/scripting/config/spring-lang-4.3.xsd, http://www.springframework.org/schema/context/spring-context-4.2.xsd=org/springframework/context/config/spring-context-4.2.xsd, http://www.springframework.org/schema/jee/spring-jee-2.0.xsd=org/springframework/ejb/config/spring-jee-2.0.xsd, http://www.springframework.org/schema/tool/spring-tool-4.3.xsd=org/springframework/beans/factory/xml/spring-tool-4.3.xsd, http://www.springframework.org/schema/tool/spring-tool-2.5.xsd=org/springframework/beans/factory/xml/spring-tool-2.5.xsd, http://www.springframework.org/schema/jee/spring-jee-4.3.xsd=org/springframework/ejb/config/spring-jee-4.3.xsd, http://www.springframework.org/schema/jee/spring-jee-2.5.xsd=org/springframework/ejb/config/spring-jee-2.5.xsd, http://www.springframework.org/schema/util/spring-util-4.0.xsd=org/springframework/beans/factory/xml/spring-util-4.0.xsd, http://www.springframework.org/schema/task/spring-task-3.0.xsd=org/springframework/scheduling/config/spring-task-3.0.xsd, http://www.springframework.org/schema/cache/spring-cache-4.3.xsd=org/springframework/cache/config/spring-cache-4.3.xsd, http://www.springframework.org/schema/aop/spring-aop-4.2.xsd=org/springframework/aop/config/spring-aop-4.2.xsd, http://www.springframework.org/schema/lang/spring-lang.xsd=org/springframework/scripting/config/spring-lang-4.3.xsd, http://www.springframework.org/schema/context/spring-context-3.2.xsd=org/springframework/context/config/spring-context-3.2.xsd, http://www.springframework.org/schema/jdbc/spring-jdbc-4.2.xsd=org/springframework/jdbc/config/spring-jdbc-4.2.xsd, http://www.springframework.org/schema/util/spring-util-3.1.xsd=org/springframework/beans/factory/xml/spring-util-3.1.xsd, http://www.springframework.org/schema/beans/spring-beans-2.0.xsd=org/springframework/beans/factory/xml/spring-beans-2.0.xsd, http://www.springframework.org/schema/cache/spring-cache.xsd=org/springframework/cache/config/spring-cache-4.3.xsd, http://www.springframework.org/schema/tx/spring-tx.xsd=org/springframework/transaction/config/spring-tx-4.3.xsd, http://www.springframework.org/schema/lang/spring-lang-4.2.xsd=org/springframework/scripting/config/spring-lang-4.2.xsd, http://www.springframework.org/schema/context/spring-context-4.1.xsd=org/springframework/context/config/spring-context-4.1.xsd, http://www.springframework.org/schema/beans/spring-beans-4.3.xsd=org/springframework/beans/factory/xml/spring-beans-4.3.xsd, http://www.springframework.org/schema/beans/spring-beans-2.5.xsd=org/springframework/beans/factory/xml/spring-beans-2.5.xsd, http://www.springframework.org/schema/tool/spring-tool-4.2.xsd=org/springframework/beans/factory/xml/spring-tool-4.2.xsd, http://www.springframework.org/schema/tx/spring-tx-2.0.xsd=org/springframework/transaction/config/spring-tx-2.0.xsd, http://www.springframework.org/schema/jee/spring-jee-4.2.xsd=org/springframework/ejb/config/spring-jee-4.2.xsd, http://www.springframework.org/schema/jdbc/spring-jdbc-3.2.xsd=org/springframework/jdbc/config/spring-jdbc-3.2.xsd, http://www.springframework.org/schema/task/spring-task-4.3.xsd=org/springframework/scheduling/config/spring-task-4.3.xsd, http://www.springframework.org/schema/aop/spring-aop.xsd=org/springframework/aop/config/spring-aop-4.3.xsd}
[DEBUG] 2017-05-24: 21:05:12 org.springframework.beans.factory.xml.PluggableSchemaResolver.resolveEntity(PluggableSchemaResolver.java:119) :  Found XML schema [http://www.springframework.org/schema/beans/spring-beans.xsd] in classpath: org/springframework/beans/factory/xml/spring-beans-4.3.xsd
[DEBUG] 2017-05-24: 21:05:12 org.springframework.beans.factory.xml.PluggableSchemaResolver.resolveEntity(PluggableSchemaResolver.java:119) :  Found XML schema [http://www.springframework.org/schema/context/spring-context.xsd] in classpath: org/springframework/context/config/spring-context-4.3.xsd
[DEBUG] 2017-05-24: 21:05:12 org.springframework.beans.factory.xml.PluggableSchemaResolver.resolveEntity(PluggableSchemaResolver.java:119) :  Found XML schema [http://www.springframework.org/schema/tool/spring-tool-4.3.xsd] in classpath: org/springframework/beans/factory/xml/spring-tool-4.3.xsd
[DEBUG] 2017-05-24: 21:05:12 org.springframework.beans.factory.xml.PluggableSchemaResolver.resolveEntity(PluggableSchemaResolver.java:119) :  Found XML schema [http://www.springframework.org/schema/tx/spring-tx.xsd] in classpath: org/springframework/transaction/config/spring-tx-4.3.xsd
[DEBUG] 2017-05-24: 21:05:12 org.springframework.beans.factory.xml.DefaultBeanDefinitionDocumentReader.registerBeanDefinitions(DefaultBeanDefinitionDocumentReader.java:92) :  Loading bean definitions
[DEBUG] 2017-05-24: 21:05:12 org.springframework.beans.factory.xml.DefaultNamespaceHandlerResolver.getHandlerMappings(DefaultNamespaceHandlerResolver.java:157) :  Loaded NamespaceHandler mappings: {http://www.springframework.org/schema/p=org.springframework.beans.factory.xml.SimplePropertyNamespaceHandler, http://www.springframework.org/schema/util=org.springframework.beans.factory.xml.UtilNamespaceHandler, http://www.springframework.org/schema/jee=org.springframework.ejb.config.JeeNamespaceHandler, http://www.springframework.org/schema/aop=org.springframework.aop.config.AopNamespaceHandler, http://www.springframework.org/schema/jdbc=org.springframework.jdbc.config.JdbcNamespaceHandler, http://www.springframework.org/schema/cache=org.springframework.cache.config.CacheNamespaceHandler, http://www.springframework.org/schema/c=org.springframework.beans.factory.xml.SimpleConstructorNamespaceHandler, http://www.springframework.org/schema/tx=org.springframework.transaction.config.TxNamespaceHandler, http://www.springframework.org/schema/task=org.springframework.scheduling.config.TaskNamespaceHandler, http://www.springframework.org/schema/lang=org.springframework.scripting.config.LangNamespaceHandler, http://www.springframework.org/schema/context=org.springframework.context.config.ContextNamespaceHandler}
[DEBUG] 2017-05-24: 21:05:12 org.springframework.core.env.MutablePropertySources.addLast(MutablePropertySources.java:109) :  Adding [systemProperties] PropertySource with lowest search precedence
[DEBUG] 2017-05-24: 21:05:12 org.springframework.core.env.MutablePropertySources.addLast(MutablePropertySources.java:109) :  Adding [systemEnvironment] PropertySource with lowest search precedence
[DEBUG] 2017-05-24: 21:05:12 org.springframework.core.env.AbstractEnvironment.<init>(AbstractEnvironment.java:124) :  Initialized StandardEnvironment with PropertySources [systemProperties,systemEnvironment]
[DEBUG] 2017-05-24: 21:05:12 org.springframework.context.annotation.ClassPathScanningCandidateComponentProvider.registerDefaultFilters(ClassPathScanningCandidateComponentProvider.java:244) :  JSR-250 'javax.annotation.ManagedBean' found and supported for component scanning
[DEBUG] 2017-05-24: 21:05:12 org.springframework.context.annotation.ClassPathScanningCandidateComponentProvider.registerDefaultFilters(ClassPathScanningCandidateComponentProvider.java:252) :  JSR-330 'javax.inject.Named' annotation found and supported for component scanning
[DEBUG] 2017-05-24: 21:05:12 org.springframework.core.io.support.PathMatchingResourcePatternResolver.findAllClassPathResources(PathMatchingResourcePatternResolver.java:317) :  Resolved classpath location [com/ittx/usermanager/] to resources [URL [file:/D:/projects/workspace_mavens/ssh/ssh-usermanager_annotaion/target/classes/com/ittx/usermanager/]]
[DEBUG] 2017-05-24: 21:05:12 org.springframework.core.io.support.PathMatchingResourcePatternResolver.doFindMatchingFileSystemResources(PathMatchingResourcePatternResolver.java:711) :  Looking for matching resources in directory tree [D:\projects\workspace_mavens\ssh\ssh-usermanager_annotaion\target\classes\com\ittx\usermanager]
[DEBUG] 2017-05-24: 21:05:12 org.springframework.core.io.support.PathMatchingResourcePatternResolver.doRetrieveMatchingFiles(PathMatchingResourcePatternResolver.java:773) :  Searching directory [D:\projects\workspace_mavens\ssh\ssh-usermanager_annotaion\target\classes\com\ittx\usermanager] for files matching pattern [D:/projects/workspace_mavens/ssh/ssh-usermanager_annotaion/target/classes/com/ittx/usermanager/**/*.class]
[DEBUG] 2017-05-24: 21:05:12 org.springframework.core.io.support.PathMatchingResourcePatternResolver.doRetrieveMatchingFiles(PathMatchingResourcePatternResolver.java:773) :  Searching directory [D:\projects\workspace_mavens\ssh\ssh-usermanager_annotaion\target\classes\com\ittx\usermanager\action] for files matching pattern [D:/projects/workspace_mavens/ssh/ssh-usermanager_annotaion/target/classes/com/ittx/usermanager/**/*.class]
[DEBUG] 2017-05-24: 21:05:12 org.springframework.core.io.support.PathMatchingResourcePatternResolver.doRetrieveMatchingFiles(PathMatchingResourcePatternResolver.java:773) :  Searching directory [D:\projects\workspace_mavens\ssh\ssh-usermanager_annotaion\target\classes\com\ittx\usermanager\dao] for files matching pattern [D:/projects/workspace_mavens/ssh/ssh-usermanager_annotaion/target/classes/com/ittx/usermanager/**/*.class]
[DEBUG] 2017-05-24: 21:05:12 org.springframework.core.io.support.PathMatchingResourcePatternResolver.doRetrieveMatchingFiles(PathMatchingResourcePatternResolver.java:773) :  Searching directory [D:\projects\workspace_mavens\ssh\ssh-usermanager_annotaion\target\classes\com\ittx\usermanager\dao\impl] for files matching pattern [D:/projects/workspace_mavens/ssh/ssh-usermanager_annotaion/target/classes/com/ittx/usermanager/**/*.class]
[DEBUG] 2017-05-24: 21:05:12 org.springframework.core.io.support.PathMatchingResourcePatternResolver.doRetrieveMatchingFiles(PathMatchingResourcePatternResolver.java:773) :  Searching directory [D:\projects\workspace_mavens\ssh\ssh-usermanager_annotaion\target\classes\com\ittx\usermanager\model] for files matching pattern [D:/projects/workspace_mavens/ssh/ssh-usermanager_annotaion/target/classes/com/ittx/usermanager/**/*.class]
[DEBUG] 2017-05-24: 21:05:12 org.springframework.core.io.support.PathMatchingResourcePatternResolver.doRetrieveMatchingFiles(PathMatchingResourcePatternResolver.java:773) :  Searching directory [D:\projects\workspace_mavens\ssh\ssh-usermanager_annotaion\target\classes\com\ittx\usermanager\service] for files matching pattern [D:/projects/workspace_mavens/ssh/ssh-usermanager_annotaion/target/classes/com/ittx/usermanager/**/*.class]
[DEBUG] 2017-05-24: 21:05:12 org.springframework.core.io.support.PathMatchingResourcePatternResolver.doRetrieveMatchingFiles(PathMatchingResourcePatternResolver.java:773) :  Searching directory [D:\projects\workspace_mavens\ssh\ssh-usermanager_annotaion\target\classes\com\ittx\usermanager\service\impl] for files matching pattern [D:/projects/workspace_mavens/ssh/ssh-usermanager_annotaion/target/classes/com/ittx/usermanager/**/*.class]
[DEBUG] 2017-05-24: 21:05:12 org.springframework.core.io.support.PathMatchingResourcePatternResolver.doRetrieveMatchingFiles(PathMatchingResourcePatternResolver.java:773) :  Searching directory [D:\projects\workspace_mavens\ssh\ssh-usermanager_annotaion\target\classes\com\ittx\usermanager\util] for files matching pattern [D:/projects/workspace_mavens/ssh/ssh-usermanager_annotaion/target/classes/com/ittx/usermanager/**/*.class]
[DEBUG] 2017-05-24: 21:05:12 org.springframework.core.io.support.PathMatchingResourcePatternResolver.findPathMatchingResources(PathMatchingResourcePatternResolver.java:483) :  Resolved location pattern [classpath*:com/ittx/usermanager/**/*.class] to resources [file [D:\projects\workspace_mavens\ssh\ssh-usermanager_annotaion\target\classes\com\ittx\usermanager\action\BaseAction.class], file [D:\projects\workspace_mavens\ssh\ssh-usermanager_annotaion\target\classes\com\ittx\usermanager\action\LoginAction.class], file [D:\projects\workspace_mavens\ssh\ssh-usermanager_annotaion\target\classes\com\ittx\usermanager\action\UserAction.class], file [D:\projects\workspace_mavens\ssh\ssh-usermanager_annotaion\target\classes\com\ittx\usermanager\dao\impl\UserDaoImpl$1.class], file [D:\projects\workspace_mavens\ssh\ssh-usermanager_annotaion\target\classes\com\ittx\usermanager\dao\impl\UserDaoImpl$2.class], file [D:\projects\workspace_mavens\ssh\ssh-usermanager_annotaion\target\classes\com\ittx\usermanager\dao\impl\UserDaoImpl.class], file [D:\projects\workspace_mavens\ssh\ssh-usermanager_annotaion\target\classes\com\ittx\usermanager\dao\UserDao.class], file [D:\projects\workspace_mavens\ssh\ssh-usermanager_annotaion\target\classes\com\ittx\usermanager\model\User.class], file [D:\projects\workspace_mavens\ssh\ssh-usermanager_annotaion\target\classes\com\ittx\usermanager\service\impl\UserServiceImpl.class], file [D:\projects\workspace_mavens\ssh\ssh-usermanager_annotaion\target\classes\com\ittx\usermanager\service\UserService.class], file [D:\projects\workspace_mavens\ssh\ssh-usermanager_annotaion\target\classes\com\ittx\usermanager\util\ConnectDB.class], file [D:\projects\workspace_mavens\ssh\ssh-usermanager_annotaion\target\classes\com\ittx\usermanager\util\DBConnection.class], file [D:\projects\workspace_mavens\ssh\ssh-usermanager_annotaion\target\classes\com\ittx\usermanager\util\EncodeFilter.class], file [D:\projects\workspace_mavens\ssh\ssh-usermanager_annotaion\target\classes\com\ittx\usermanager\util\HibernateUtil.class], file [D:\projects\workspace_mavens\ssh\ssh-usermanager_annotaion\target\classes\com\ittx\usermanager\util\LoginFilter.class], file [D:\projects\workspace_mavens\ssh\ssh-usermanager_annotaion\target\classes\com\ittx\usermanager\util\MyHibernateDaoSupport.class], file [D:\projects\workspace_mavens\ssh\ssh-usermanager_annotaion\target\classes\com\ittx\usermanager\util\Pager.class], file [D:\projects\workspace_mavens\ssh\ssh-usermanager_annotaion\target\classes\com\ittx\usermanager\util\PagerUtil.class]]
[DEBUG] 2017-05-24: 21:05:12 org.springframework.context.annotation.ClassPathScanningCandidateComponentProvider.findCandidateComponents(ClassPathScanningCandidateComponentProvider.java:286) :  Identified candidate component class: file [D:\projects\workspace_mavens\ssh\ssh-usermanager_annotaion\target\classes\com\ittx\usermanager\action\UserAction.class]
[DEBUG] 2017-05-24: 21:05:12 org.springframework.context.annotation.ClassPathScanningCandidateComponentProvider.findCandidateComponents(ClassPathScanningCandidateComponentProvider.java:286) :  Identified candidate component class: file [D:\projects\workspace_mavens\ssh\ssh-usermanager_annotaion\target\classes\com\ittx\usermanager\dao\impl\UserDaoImpl.class]
[DEBUG] 2017-05-24: 21:05:12 org.springframework.context.annotation.ClassPathScanningCandidateComponentProvider.findCandidateComponents(ClassPathScanningCandidateComponentProvider.java:286) :  Identified candidate component class: file [D:\projects\workspace_mavens\ssh\ssh-usermanager_annotaion\target\classes\com\ittx\usermanager\service\impl\UserServiceImpl.class]
[DEBUG] 2017-05-24: 21:05:12 org.springframework.beans.factory.support.AbstractBeanDefinitionReader.loadBeanDefinitions(AbstractBeanDefinitionReader.java:224) :  Loaded 19 bean definitions from location pattern [classpath:spring-core.xml]
[DEBUG] 2017-05-24: 21:05:12 org.springframework.context.support.AbstractApplicationContext.obtainFreshBeanFactory(AbstractApplicationContext.java:615) :  Bean factory for Root WebApplicationContext: org.springframework.beans.factory.support.DefaultListableBeanFactory@9e5e75: defining beans [userAction,userDao,userService,org.springframework.context.annotation.internalConfigurationAnnotationProcessor,org.springframework.context.annotation.internalAutowiredAnnotationProcessor,org.springframework.context.annotation.internalRequiredAnnotationProcessor,org.springframework.context.annotation.internalCommonAnnotationProcessor,org.springframework.context.annotation.internalPersistenceAnnotationProcessor,org.springframework.context.event.internalEventListenerProcessor,org.springframework.context.event.internalEventListenerFactory,org.springframework.context.support.PropertySourcesPlaceholderConfigurer#0,dataSource,sessionFactory,transactionManager,org.springframework.transaction.config.internalTransactionalEventListenerFactory,org.springframework.aop.config.internalAutoProxyCreator,org.springframework.transaction.annotation.AnnotationTransactionAttributeSource#0,org.springframework.transaction.interceptor.TransactionInterceptor#0,org.springframework.transaction.config.internalTransactionAdvisor]; root of factory hierarchy
[DEBUG] 2017-05-24: 21:05:12 org.springframework.beans.factory.support.AbstractBeanFactory.registerScope(AbstractBeanFactory.java:879) :  Registering scope 'request' with implementation [org.springframework.web.context.request.RequestScope@16b00fb]
[DEBUG] 2017-05-24: 21:05:12 org.springframework.beans.factory.support.AbstractBeanFactory.registerScope(AbstractBeanFactory.java:879) :  Registering scope 'session' with implementation [org.springframework.web.context.request.SessionScope@191288e]
[DEBUG] 2017-05-24: 21:05:12 org.springframework.beans.factory.support.AbstractBeanFactory.registerScope(AbstractBeanFactory.java:879) :  Registering scope 'globalSession' with implementation [org.springframework.web.context.request.SessionScope@2c969f]
[DEBUG] 2017-05-24: 21:05:12 org.springframework.beans.factory.support.AbstractBeanFactory.registerScope(AbstractBeanFactory.java:879) :  Registering scope 'application' with implementation [org.springframework.web.context.support.ServletContextScope@12f505b]
[DEBUG] 2017-05-24: 21:05:12 org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:221) :  Creating shared instance of singleton bean 'org.springframework.context.annotation.internalConfigurationAnnotationProcessor'
[DEBUG] 2017-05-24: 21:05:12 org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:448) :  Creating instance of bean 'org.springframework.context.annotation.internalConfigurationAnnotationProcessor'
[DEBUG] 2017-05-24: 21:05:12 org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:529) :  Eagerly caching bean 'org.springframework.context.annotation.internalConfigurationAnnotationProcessor' to allow for resolving potential circular references
[DEBUG] 2017-05-24: 21:05:12 org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:484) :  Finished creating instance of bean 'org.springframework.context.annotation.internalConfigurationAnnotationProcessor'
[DEBUG] 2017-05-24: 21:05:12 org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:221) :  Creating shared instance of singleton bean 'org.springframework.context.support.PropertySourcesPlaceholderConfigurer#0'
[DEBUG] 2017-05-24: 21:05:12 org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:448) :  Creating instance of bean 'org.springframework.context.support.PropertySourcesPlaceholderConfigurer#0'
[DEBUG] 2017-05-24: 21:05:12 org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:529) :  Eagerly caching bean 'org.springframework.context.support.PropertySourcesPlaceholderConfigurer#0' to allow for resolving potential circular references
[DEBUG] 2017-05-24: 21:05:12 org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:484) :  Finished creating instance of bean 'org.springframework.context.support.PropertySourcesPlaceholderConfigurer#0'
[DEBUG] 2017-05-24: 21:05:12 org.springframework.core.env.MutablePropertySources.addLast(MutablePropertySources.java:109) :  Adding [environmentProperties] PropertySource with lowest search precedence
[INFO] 2017-05-24: 21:05:12 org.springframework.core.io.support.PropertiesLoaderSupport.loadProperties(PropertiesLoaderSupport.java:172) :  Loading properties file from class path resource [jdbc.properties]
[DEBUG] 2017-05-24: 21:05:12 org.springframework.core.env.MutablePropertySources.addLast(MutablePropertySources.java:109) :  Adding [localProperties] PropertySource with lowest search precedence
[DEBUG] 2017-05-24: 21:05:12 org.springframework.jndi.JndiTemplate.lookup(JndiTemplate.java:150) :  Looking up JNDI object with name [java:comp/env/jdbc.driverClassName]
[DEBUG] 2017-05-24: 21:05:12 org.springframework.jndi.JndiLocatorSupport.lookup(JndiLocatorSupport.java:101) :  Converted JNDI name [java:comp/env/jdbc.driverClassName] not found - trying original name [jdbc.driverClassName]. javax.naming.NameNotFoundException; remaining name 'jdbc.driverClassName'
[DEBUG] 2017-05-24: 21:05:12 org.springframework.jndi.JndiTemplate.lookup(JndiTemplate.java:150) :  Looking up JNDI object with name [jdbc.driverClassName]
[DEBUG] 2017-05-24: 21:05:12 org.springframework.jndi.JndiPropertySource.getProperty(JndiPropertySource.java:99) :  JNDI lookup for name [jdbc.driverClassName] threw NamingException with message: null. Returning null.
[DEBUG] 2017-05-24: 21:05:12 org.springframework.core.env.PropertySourcesPropertyResolver.getProperty(PropertySourcesPropertyResolver.java:91) :  Could not find key 'jdbc.driverClassName' in any property source
[DEBUG] 2017-05-24: 21:05:12 org.springframework.core.env.PropertySourcesPropertyResolver.logKeyFound(PropertySourcesPropertyResolver.java:151) :  Found key 'jdbc.driverClassName' in [localProperties] with type [String]
[DEBUG] 2017-05-24: 21:05:12 org.springframework.jndi.JndiTemplate.lookup(JndiTemplate.java:150) :  Looking up JNDI object with name [java:comp/env/jdbc.url]
[DEBUG] 2017-05-24: 21:05:12 org.springframework.jndi.JndiLocatorSupport.lookup(JndiLocatorSupport.java:101) :  Converted JNDI name [java:comp/env/jdbc.url] not found - trying original name [jdbc.url]. javax.naming.NameNotFoundException; remaining name 'jdbc.url'
[DEBUG] 2017-05-24: 21:05:12 org.springframework.jndi.JndiTemplate.lookup(JndiTemplate.java:150) :  Looking up JNDI object with name [jdbc.url]
[DEBUG] 2017-05-24: 21:05:12 org.springframework.jndi.JndiPropertySource.getProperty(JndiPropertySource.java:99) :  JNDI lookup for name [jdbc.url] threw NamingException with message: null. Returning null.
[DEBUG] 2017-05-24: 21:05:12 org.springframework.core.env.PropertySourcesPropertyResolver.getProperty(PropertySourcesPropertyResolver.java:91) :  Could not find key 'jdbc.url' in any property source
[DEBUG] 2017-05-24: 21:05:12 org.springframework.core.env.PropertySourcesPropertyResolver.logKeyFound(PropertySourcesPropertyResolver.java:151) :  Found key 'jdbc.url' in [localProperties] with type [String]
[DEBUG] 2017-05-24: 21:05:12 org.springframework.jndi.JndiTemplate.lookup(JndiTemplate.java:150) :  Looking up JNDI object with name [java:comp/env/jdbc.username]
[DEBUG] 2017-05-24: 21:05:12 org.springframework.jndi.JndiLocatorSupport.lookup(JndiLocatorSupport.java:101) :  Converted JNDI name [java:comp/env/jdbc.username] not found - trying original name [jdbc.username]. javax.naming.NameNotFoundException; remaining name 'jdbc.username'
[DEBUG] 2017-05-24: 21:05:12 org.springframework.jndi.JndiTemplate.lookup(JndiTemplate.java:150) :  Looking up JNDI object with name [jdbc.username]
[DEBUG] 2017-05-24: 21:05:12 org.springframework.jndi.JndiPropertySource.getProperty(JndiPropertySource.java:99) :  JNDI lookup for name [jdbc.username] threw NamingException with message: null. Returning null.
[DEBUG] 2017-05-24: 21:05:12 org.springframework.core.env.PropertySourcesPropertyResolver.getProperty(PropertySourcesPropertyResolver.java:91) :  Could not find key 'jdbc.username' in any property source
[DEBUG] 2017-05-24: 21:05:12 org.springframework.core.env.PropertySourcesPropertyResolver.logKeyFound(PropertySourcesPropertyResolver.java:151) :  Found key 'jdbc.username' in [localProperties] with type [String]
[DEBUG] 2017-05-24: 21:05:12 org.springframework.jndi.JndiTemplate.lookup(JndiTemplate.java:150) :  Looking up JNDI object with name [java:comp/env/jdbc.password]
[DEBUG] 2017-05-24: 21:05:12 org.springframework.jndi.JndiLocatorSupport.lookup(JndiLocatorSupport.java:101) :  Converted JNDI name [java:comp/env/jdbc.password] not found - trying original name [jdbc.password]. javax.naming.NameNotFoundException; remaining name 'jdbc.password'
[DEBUG] 2017-05-24: 21:05:12 org.springframework.jndi.JndiTemplate.lookup(JndiTemplate.java:150) :  Looking up JNDI object with name [jdbc.password]
[DEBUG] 2017-05-24: 21:05:12 org.springframework.jndi.JndiPropertySource.getProperty(JndiPropertySource.java:99) :  JNDI lookup for name [jdbc.password] threw NamingException with message: null. Returning null.
[DEBUG] 2017-05-24: 21:05:12 org.springframework.core.env.PropertySourcesPropertyResolver.getProperty(PropertySourcesPropertyResolver.java:91) :  Could not find key 'jdbc.password' in any property source
[DEBUG] 2017-05-24: 21:05:12 org.springframework.core.env.PropertySourcesPropertyResolver.logKeyFound(PropertySourcesPropertyResolver.java:151) :  Found key 'jdbc.password' in [localProperties] with type [String]
[DEBUG] 2017-05-24: 21:05:12 org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:221) :  Creating shared instance of singleton bean 'org.springframework.context.annotation.internalAutowiredAnnotationProcessor'
[DEBUG] 2017-05-24: 21:05:12 org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:448) :  Creating instance of bean 'org.springframework.context.annotation.internalAutowiredAnnotationProcessor'
[INFO] 2017-05-24: 21:05:12 org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor.<init>(AutowiredAnnotationBeanPostProcessor.java:155) :  JSR-330 'javax.inject.Inject' annotation found and supported for autowiring
[DEBUG] 2017-05-24: 21:05:12 org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:529) :  Eagerly caching bean 'org.springframework.context.annotation.internalAutowiredAnnotationProcessor' to allow for resolving potential circular references
[DEBUG] 2017-05-24: 21:05:12 org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:484) :  Finished creating instance of bean 'org.springframework.context.annotation.internalAutowiredAnnotationProcessor'
[DEBUG] 2017-05-24: 21:05:12 org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:221) :  Creating shared instance of singleton bean 'org.springframework.context.annotation.internalRequiredAnnotationProcessor'
[DEBUG] 2017-05-24: 21:05:12 org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:448) :  Creating instance of bean 'org.springframework.context.annotation.internalRequiredAnnotationProcessor'
[DEBUG] 2017-05-24: 21:05:12 org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:529) :  Eagerly caching bean 'org.springframework.context.annotation.internalRequiredAnnotationProcessor' to allow for resolving potential circular references
[DEBUG] 2017-05-24: 21:05:12 org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:484) :  Finished creating instance of bean 'org.springframework.context.annotation.internalRequiredAnnotationProcessor'
[DEBUG] 2017-05-24: 21:05:12 org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:221) :  Creating shared instance of singleton bean 'org.springframework.context.annotation.internalCommonAnnotationProcessor'
[DEBUG] 2017-05-24: 21:05:12 org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:448) :  Creating instance of bean 'org.springframework.context.annotation.internalCommonAnnotationProcessor'
[DEBUG] 2017-05-24: 21:05:12 org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:529) :  Eagerly caching bean 'org.springframework.context.annotation.internalCommonAnnotationProcessor' to allow for resolving potential circular references
[DEBUG] 2017-05-24: 21:05:12 org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:484) :  Finished creating instance of bean 'org.springframework.context.annotation.internalCommonAnnotationProcessor'
[DEBUG] 2017-05-24: 21:05:12 org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:221) :  Creating shared instance of singleton bean 'org.springframework.context.annotation.internalPersistenceAnnotationProcessor'
[DEBUG] 2017-05-24: 21:05:12 org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:448) :  Creating instance of bean 'org.springframework.context.annotation.internalPersistenceAnnotationProcessor'
[DEBUG] 2017-05-24: 21:05:12 org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:529) :  Eagerly caching bean 'org.springframework.context.annotation.internalPersistenceAnnotationProcessor' to allow for resolving potential circular references
[DEBUG] 2017-05-24: 21:05:12 org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:484) :  Finished creating instance of bean 'org.springframework.context.annotation.internalPersistenceAnnotationProcessor'
[DEBUG] 2017-05-24: 21:05:12 org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:221) :  Creating shared instance of singleton bean 'org.springframework.context.annotation.ConfigurationClassPostProcessor.importAwareProcessor'
[DEBUG] 2017-05-24: 21:05:12 org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:448) :  Creating instance of bean 'org.springframework.context.annotation.ConfigurationClassPostProcessor.importAwareProcessor'
[DEBUG] 2017-05-24: 21:05:12 org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:529) :  Eagerly caching bean 'org.springframework.context.annotation.ConfigurationClassPostProcessor.importAwareProcessor' to allow for resolving potential circular references
[DEBUG] 2017-05-24: 21:05:12 org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:484) :  Finished creating instance of bean 'org.springframework.context.annotation.ConfigurationClassPostProcessor.importAwareProcessor'
[DEBUG] 2017-05-24: 21:05:12 org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:221) :  Creating shared instance of singleton bean 'org.springframework.context.annotation.ConfigurationClassPostProcessor.enhancedConfigurationProcessor'
[DEBUG] 2017-05-24: 21:05:12 org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:448) :  Creating instance of bean 'org.springframework.context.annotation.ConfigurationClassPostProcessor.enhancedConfigurationProcessor'
[DEBUG] 2017-05-24: 21:05:12 org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:529) :  Eagerly caching bean 'org.springframework.context.annotation.ConfigurationClassPostProcessor.enhancedConfigurationProcessor' to allow for resolving potential circular references
[DEBUG] 2017-05-24: 21:05:12 org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:484) :  Finished creating instance of bean 'org.springframework.context.annotation.ConfigurationClassPostProcessor.enhancedConfigurationProcessor'
[DEBUG] 2017-05-24: 21:05:12 org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:221) :  Creating shared instance of singleton bean 'org.springframework.aop.config.internalAutoProxyCreator'
[DEBUG] 2017-05-24: 21:05:12 org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:448) :  Creating instance of bean 'org.springframework.aop.config.internalAutoProxyCreator'
[DEBUG] 2017-05-24: 21:05:12 org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:529) :  Eagerly caching bean 'org.springframework.aop.config.internalAutoProxyCreator' to allow for resolving potential circular references
[DEBUG] 2017-05-24: 21:05:12 org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:484) :  Finished creating instance of bean 'org.springframework.aop.config.internalAutoProxyCreator'
[DEBUG] 2017-05-24: 21:05:12 org.springframework.context.support.AbstractApplicationContext.initMessageSource(AbstractApplicationContext.java:728) :  Unable to locate MessageSource with name 'messageSource': using default [org.springframework.context.support.DelegatingMessageSource@7b523b]
[DEBUG] 2017-05-24: 21:05:12 org.springframework.context.support.AbstractApplicationContext.initApplicationEventMulticaster(AbstractApplicationContext.java:752) :  Unable to locate ApplicationEventMulticaster with name 'applicationEventMulticaster': using default [org.springframework.context.event.SimpleApplicationEventMulticaster@10216f]
[DEBUG] 2017-05-24: 21:05:12 org.springframework.ui.context.support.UiApplicationContextUtils.initThemeSource(UiApplicationContextUtils.java:85) :  Unable to locate ThemeSource with name 'themeSource': using default [org.springframework.ui.context.support.ResourceBundleThemeSource@16b3ed6]
[DEBUG] 2017-05-24: 21:05:12 org.springframework.beans.factory.support.DefaultListableBeanFactory.preInstantiateSingletons(DefaultListableBeanFactory.java:720) :  Pre-instantiating singletons in org.springframework.beans.factory.support.DefaultListableBeanFactory@9e5e75: defining beans [userAction,userDao,userService,org.springframework.context.annotation.internalConfigurationAnnotationProcessor,org.springframework.context.annotation.internalAutowiredAnnotationProcessor,org.springframework.context.annotation.internalRequiredAnnotationProcessor,org.springframework.context.annotation.internalCommonAnnotationProcessor,org.springframework.context.annotation.internalPersistenceAnnotationProcessor,org.springframework.context.event.internalEventListenerProcessor,org.springframework.context.event.internalEventListenerFactory,org.springframework.context.support.PropertySourcesPlaceholderConfigurer#0,dataSource,sessionFactory,transactionManager,org.springframework.transaction.config.internalTransactionalEventListenerFactory,org.springframework.aop.config.internalAutoProxyCreator,org.springframework.transaction.annotation.AnnotationTransactionAttributeSource#0,org.springframework.transaction.interceptor.TransactionInterceptor#0,org.springframework.transaction.config.internalTransactionAdvisor,org.springframework.context.annotation.ConfigurationClassPostProcessor.importAwareProcessor,org.springframework.context.annotation.ConfigurationClassPostProcessor.enhancedConfigurationProcessor]; root of factory hierarchy
[DEBUG] 2017-05-24: 21:05:12 org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:221) :  Creating shared instance of singleton bean 'userAction'
[DEBUG] 2017-05-24: 21:05:12 org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:448) :  Creating instance of bean 'userAction'
[DEBUG] 2017-05-24: 21:05:12 org.springframework.beans.factory.annotation.InjectionMetadata.checkConfigMembers(InjectionMetadata.java:72) :  Registered injected element on class [com.ittx.usermanager.action.UserAction]: AutowiredFieldElement for private com.ittx.usermanager.service.UserService com.ittx.usermanager.action.UserAction.userService
[DEBUG] 2017-05-24: 21:05:12 org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:529) :  Eagerly caching bean 'userAction' to allow for resolving potential circular references
[DEBUG] 2017-05-24: 21:05:12 org.springframework.beans.factory.annotation.InjectionMetadata.inject(InjectionMetadata.java:86) :  Processing injected element of bean 'userAction': AutowiredFieldElement for private com.ittx.usermanager.service.UserService com.ittx.usermanager.action.UserAction.userService
[DEBUG] 2017-05-24: 21:05:12 org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:221) :  Creating shared instance of singleton bean 'userService'
[DEBUG] 2017-05-24: 21:05:12 org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:448) :  Creating instance of bean 'userService'
[DEBUG] 2017-05-24: 21:05:12 org.springframework.beans.factory.annotation.InjectionMetadata.checkConfigMembers(InjectionMetadata.java:72) :  Registered injected element on class [com.ittx.usermanager.service.impl.UserServiceImpl]: AutowiredFieldElement for private com.ittx.usermanager.dao.UserDao com.ittx.usermanager.service.impl.UserServiceImpl.userDao
[DEBUG] 2017-05-24: 21:05:12 org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:529) :  Eagerly caching bean 'userService' to allow for resolving potential circular references
[DEBUG] 2017-05-24: 21:05:12 org.springframework.beans.factory.annotation.InjectionMetadata.inject(InjectionMetadata.java:86) :  Processing injected element of bean 'userService': AutowiredFieldElement for private com.ittx.usermanager.dao.UserDao com.ittx.usermanager.service.impl.UserServiceImpl.userDao
[DEBUG] 2017-05-24: 21:05:12 org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:221) :  Creating shared instance of singleton bean 'userDao'
[DEBUG] 2017-05-24: 21:05:12 org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:448) :  Creating instance of bean 'userDao'
[DEBUG] 2017-05-24: 21:05:12 org.springframework.beans.factory.annotation.InjectionMetadata.checkConfigMembers(InjectionMetadata.java:72) :  Registered injected element on class [com.ittx.usermanager.dao.impl.UserDaoImpl]: ResourceElement for public void com.ittx.usermanager.util.MyHibernateDaoSupport.setSuperSessionFactory(org.hibernate.SessionFactory)
[DEBUG] 2017-05-24: 21:05:12 org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:529) :  Eagerly caching bean 'userDao' to allow for resolving potential circular references
[DEBUG] 2017-05-24: 21:05:12 org.springframework.beans.factory.annotation.InjectionMetadata.inject(InjectionMetadata.java:86) :  Processing injected element of bean 'userDao': ResourceElement for public void com.ittx.usermanager.util.MyHibernateDaoSupport.setSuperSessionFactory(org.hibernate.SessionFactory)
[DEBUG] 2017-05-24: 21:05:12 org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:221) :  Creating shared instance of singleton bean 'sessionFactory'
[DEBUG] 2017-05-24: 21:05:12 org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:448) :  Creating instance of bean 'sessionFactory'
[DEBUG] 2017-05-24: 21:05:12 org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:529) :  Eagerly caching bean 'sessionFactory' to allow for resolving potential circular references
[DEBUG] 2017-05-24: 21:05:12 org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:221) :  Creating shared instance of singleton bean 'dataSource'
[DEBUG] 2017-05-24: 21:05:12 org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:448) :  Creating instance of bean 'dataSource'
[DEBUG] 2017-05-24: 21:05:12 org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:529) :  Eagerly caching bean 'dataSource' to allow for resolving potential circular references
[INFO] 2017-05-24: 21:05:12 org.springframework.jdbc.datasource.DriverManagerDataSource.setDriverClassName(DriverManagerDataSource.java:133) :  Loaded JDBC driver: com.mysql.jdbc.Driver
[DEBUG] 2017-05-24: 21:05:12 org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:221) :  Creating shared instance of singleton bean 'org.springframework.transaction.config.internalTransactionAdvisor'
[DEBUG] 2017-05-24: 21:05:12 org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:448) :  Creating instance of bean 'org.springframework.transaction.config.internalTransactionAdvisor'
[DEBUG] 2017-05-24: 21:05:12 org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:529) :  Eagerly caching bean 'org.springframework.transaction.config.internalTransactionAdvisor' to allow for resolving potential circular references
[DEBUG] 2017-05-24: 21:05:12 org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:221) :  Creating shared instance of singleton bean 'org.springframework.transaction.annotation.AnnotationTransactionAttributeSource#0'
[DEBUG] 2017-05-24: 21:05:12 org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:448) :  Creating instance of bean 'org.springframework.transaction.annotation.AnnotationTransactionAttributeSource#0'
[DEBUG] 2017-05-24: 21:05:12 org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:529) :  Eagerly caching bean 'org.springframework.transaction.annotation.AnnotationTransactionAttributeSource#0' to allow for resolving potential circular references
[DEBUG] 2017-05-24: 21:05:12 org.springframework.aop.framework.autoproxy.BeanFactoryAdvisorRetrievalHelper.findAdvisorBeans(BeanFactoryAdvisorRetrievalHelper.java:87) :  Skipping currently created advisor 'org.springframework.transaction.config.internalTransactionAdvisor'
[DEBUG] 2017-05-24: 21:05:12 org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:484) :  Finished creating instance of bean 'org.springframework.transaction.annotation.AnnotationTransactionAttributeSource#0'
[DEBUG] 2017-05-24: 21:05:12 org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:484) :  Finished creating instance of bean 'org.springframework.transaction.config.internalTransactionAdvisor'
[DEBUG] 2017-05-24: 21:05:12 org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:484) :  Finished creating instance of bean 'dataSource'
[DEBUG] 2017-05-24: 21:05:13 org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.invokeInitMethods(AbstractAutowireCapableBeanFactory.java:1625) :  Invoking afterPropertiesSet() on bean with name 'sessionFactory'
[DEBUG] 2017-05-24: 21:05:13 org.hibernate.cfg.Configuration.<clinit>(Configuration.java:194) :  Logging Provider: org.jboss.logging.Log4jLoggerProvider
[DEBUG] 2017-05-24: 21:05:13 org.hibernate.type.BasicTypeRegistry.register(BasicTypeRegistry.java:146) :  Adding type registration boolean -> org.hibernate.type.BooleanType@db0b17
[DEBUG] 2017-05-24: 21:05:13 org.hibernate.type.BasicTypeRegistry.register(BasicTypeRegistry.java:146) :  Adding type registration boolean -> org.hibernate.type.BooleanType@db0b17
[DEBUG] 2017-05-24: 21:05:13 org.hibernate.type.BasicTypeRegistry.register(BasicTypeRegistry.java:146) :  Adding type registration java.lang.Boolean -> org.hibernate.type.BooleanType@db0b17
[DEBUG] 2017-05-24: 21:05:13 org.hibernate.type.BasicTypeRegistry.register(BasicTypeRegistry.java:146) :  Adding type registration numeric_boolean -> org.hibernate.type.NumericBooleanType@f4a0e4
[DEBUG] 2017-05-24: 21:05:13 org.hibernate.type.BasicTypeRegistry.register(BasicTypeRegistry.java:146) :  Adding type registration true_false -> org.hibernate.type.TrueFalseType@a8ff32
[DEBUG] 2017-05-24: 21:05:13 org.hibernate.type.BasicTypeRegistry.register(BasicTypeRegistry.java:146) :  Adding type registration yes_no -> org.hibernate.type.YesNoType@6a7e4
[DEBUG] 2017-05-24: 21:05:13 org.hibernate.type.BasicTypeRegistry.register(BasicTypeRegistry.java:146) :  Adding type registration byte -> org.hibernate.type.ByteType@1b05003
[DEBUG] 2017-05-24: 21:05:13 org.hibernate.type.BasicTypeRegistry.register(BasicTypeRegistry.java:146) :  Adding type registration byte -> org.hibernate.type.ByteType@1b05003
[DEBUG] 2017-05-24: 21:05:13 org.hibernate.type.BasicTypeRegistry.register(BasicTypeRegistry.java:146) :  Adding type registration java.lang.Byte -> org.hibernate.type.ByteType@1b05003
[DEBUG] 2017-05-24: 21:05:13 org.hibernate.type.BasicTypeRegistry.register(BasicTypeRegistry.java:146) :  Adding type registration character -> org.hibernate.type.CharacterType@1f02095
[DEBUG] 2017-05-24: 21:05:13 org.hibernate.type.BasicTypeRegistry.register(BasicTypeRegistry.java:146) :  Adding type registration char -> org.hibernate.type.CharacterType@1f02095
[DEBUG] 2017-05-24: 21:05:13 org.hibernate.type.BasicTypeRegistry.register(BasicTypeRegistry.java:146) :  Adding type registration java.lang.Character -> org.hibernate.type.CharacterType@1f02095
[DEBUG] 2017-05-24: 21:05:13 org.hibernate.type.BasicTypeRegistry.register(BasicTypeRegistry.java:146) :  Adding type registration short -> org.hibernate.type.ShortType@f52d68
[DEBUG] 2017-05-24: 21:05:13 org.hibernate.type.BasicTypeRegistry.register(BasicTypeRegistry.java:146) :  Adding type registration short -> org.hibernate.type.ShortType@f52d68
[DEBUG] 2017-05-24: 21:05:13 org.hibernate.type.BasicTypeRegistry.register(BasicTypeRegistry.java:146) :  Adding type registration java.lang.Short -> org.hibernate.type.ShortType@f52d68
[DEBUG] 2017-05-24: 21:05:13 org.hibernate.type.BasicTypeRegistry.register(BasicTypeRegistry.java:146) :  Adding type registration integer -> org.hibernate.type.IntegerType@1288c47
[DEBUG] 2017-05-24: 21:05:13 org.hibernate.type.BasicTypeRegistry.register(BasicTypeRegistry.java:146) :  Adding type registration int -> org.hibernate.type.IntegerType@1288c47
[DEBUG] 2017-05-24: 21:05:13 org.hibernate.type.BasicTypeRegistry.register(BasicTypeRegistry.java:146) :  Adding type registration java.lang.Integer -> org.hibernate.type.IntegerType@1288c47
[DEBUG] 2017-05-24: 21:05:13 org.hibernate.type.BasicTypeRegistry.register(BasicTypeRegistry.java:146) :  Adding type registration long -> org.hibernate.type.LongType@7345aa
[DEBUG] 2017-05-24: 21:05:13 org.hibernate.type.BasicTypeRegistry.register(BasicTypeRegistry.java:146) :  Adding type registration long -> org.hibernate.type.LongType@7345aa
[DEBUG] 2017-05-24: 21:05:13 org.hibernate.type.BasicTypeRegistry.register(BasicTypeRegistry.java:146) :  Adding type registration java.lang.Long -> org.hibernate.type.LongType@7345aa
[DEBUG] 2017-05-24: 21:05:13 org.hibernate.type.BasicTypeRegistry.register(BasicTypeRegistry.java:146) :  Adding type registration float -> org.hibernate.type.FloatType@a55742
[DEBUG] 2017-05-24: 21:05:13 org.hibernate.type.BasicTypeRegistry.register(BasicTypeRegistry.java:146) :  Adding type registration float -> org.hibernate.type.FloatType@a55742
[DEBUG] 2017-05-24: 21:05:13 org.hibernate.type.BasicTypeRegistry.register(BasicTypeRegistry.java:146) :  Adding type registration java.lang.Float -> org.hibernate.type.FloatType@a55742
[DEBUG] 2017-05-24: 21:05:13 org.hibernate.type.BasicTypeRegistry.register(BasicTypeRegistry.java:146) :  Adding type registration double -> org.hibernate.type.DoubleType@ce1629
[DEBUG] 2017-05-24: 21:05:13 org.hibernate.type.BasicTypeRegistry.register(BasicTypeRegistry.java:146) :  Adding type registration double -> org.hibernate.type.DoubleType@ce1629
[DEBUG] 2017-05-24: 21:05:13 org.hibernate.type.BasicTypeRegistry.register(BasicTypeRegistry.java:146) :  Adding type registration java.lang.Double -> org.hibernate.type.DoubleType@ce1629
[DEBUG] 2017-05-24: 21:05:13 org.hibernate.type.BasicTypeRegistry.register(BasicTypeRegistry.java:146) :  Adding type registration big_decimal -> org.hibernate.type.BigDecimalType@8b1faf
[DEBUG] 2017-05-24: 21:05:13 org.hibernate.type.BasicTypeRegistry.register(BasicTypeRegistry.java:146) :  Adding type registration java.math.BigDecimal -> org.hibernate.type.BigDecimalType@8b1faf
[DEBUG] 2017-05-24: 21:05:13 org.hibernate.type.BasicTypeRegistry.register(BasicTypeRegistry.java:146) :  Adding type registration big_integer -> org.hibernate.type.BigIntegerType@14971bd
[DEBUG] 2017-05-24: 21:05:13 org.hibernate.type.BasicTypeRegistry.register(BasicTypeRegistry.java:146) :  Adding type registration java.math.BigInteger -> org.hibernate.type.BigIntegerType@14971bd
[DEBUG] 2017-05-24: 21:05:13 org.hibernate.type.BasicTypeRegistry.register(BasicTypeRegistry.java:146) :  Adding type registration string -> org.hibernate.type.StringType@13987a6
[DEBUG] 2017-05-24: 21:05:13 org.hibernate.type.BasicTypeRegistry.register(BasicTypeRegistry.java:146) :  Adding type registration java.lang.String -> org.hibernate.type.StringType@13987a6
[DEBUG] 2017-05-24: 21:05:13 org.hibernate.type.BasicTypeRegistry.register(BasicTypeRegistry.java:146) :  Adding type registration nstring -> org.hibernate.type.StringNVarcharType@5eed0b
[DEBUG] 2017-05-24: 21:05:13 org.hibernate.type.BasicTypeRegistry.register(BasicTypeRegistry.java:146) :  Adding type registration ncharacter -> org.hibernate.type.CharacterNCharType@ff0feb
[DEBUG] 2017-05-24: 21:05:13 org.hibernate.type.BasicTypeRegistry.register(BasicTypeRegistry.java:146) :  Adding type registration url -> org.hibernate.type.UrlType@12a1dd
[DEBUG] 2017-05-24: 21:05:13 org.hibernate.type.BasicTypeRegistry.register(BasicTypeRegistry.java:146) :  Adding type registration java.net.URL -> org.hibernate.type.UrlType@12a1dd
[DEBUG] 2017-05-24: 21:05:13 org.hibernate.type.BasicTypeRegistry.register(BasicTypeRegistry.java:146) :  Adding type registration date -> org.hibernate.type.DateType@1c15c32
[DEBUG] 2017-05-24: 21:05:13 org.hibernate.type.BasicTypeRegistry.register(BasicTypeRegistry.java:146) :  Adding type registration java.sql.Date -> org.hibernate.type.DateType@1c15c32
[DEBUG] 2017-05-24: 21:05:13 org.hibernate.type.BasicTypeRegistry.register(BasicTypeRegistry.java:146) :  Adding type registration time -> org.hibernate.type.TimeType@85c3a2
[DEBUG] 2017-05-24: 21:05:13 org.hibernate.type.BasicTypeRegistry.register(BasicTypeRegistry.java:146) :  Adding type registration java.sql.Time -> org.hibernate.type.TimeType@85c3a2
[DEBUG] 2017-05-24: 21:05:13 org.hibernate.type.BasicTypeRegistry.register(BasicTypeRegistry.java:146) :  Adding type registration timestamp -> org.hibernate.type.TimestampType@1407424
[DEBUG] 2017-05-24: 21:05:13 org.hibernate.type.BasicTypeRegistry.register(BasicTypeRegistry.java:146) :  Adding type registration java.sql.Timestamp -> org.hibernate.type.TimestampType@1407424
[DEBUG] 2017-05-24: 21:05:13 org.hibernate.type.BasicTypeRegistry.register(BasicTypeRegistry.java:146) :  Adding type registration java.util.Date -> org.hibernate.type.TimestampType@1407424
[DEBUG] 2017-05-24: 21:05:13 org.hibernate.type.BasicTypeRegistry.register(BasicTypeRegistry.java:146) :  Adding type registration dbtimestamp -> org.hibernate.type.DbTimestampType@e78666
[DEBUG] 2017-05-24: 21:05:13 org.hibernate.type.BasicTypeRegistry.register(BasicTypeRegistry.java:146) :  Adding type registration calendar -> org.hibernate.type.CalendarType@104b29d
[DEBUG] 2017-05-24: 21:05:13 org.hibernate.type.BasicTypeRegistry.register(BasicTypeRegistry.java:146) :  Adding type registration java.util.Calendar -> org.hibernate.type.CalendarType@104b29d
[DEBUG] 2017-05-24: 21:05:13 org.hibernate.type.BasicTypeRegistry.register(BasicTypeRegistry.java:146) :  Adding type registration java.util.GregorianCalendar -> org.hibernate.type.CalendarType@104b29d
[DEBUG] 2017-05-24: 21:05:13 org.hibernate.type.BasicTypeRegistry.register(BasicTypeRegistry.java:146) :  Adding type registration calendar_date -> org.hibernate.type.CalendarDateType@ed42d6
[DEBUG] 2017-05-24: 21:05:13 org.hibernate.type.BasicTypeRegistry.register(BasicTypeRegistry.java:146) :  Adding type registration locale -> org.hibernate.type.LocaleType@8f13dc
[DEBUG] 2017-05-24: 21:05:13 org.hibernate.type.BasicTypeRegistry.register(BasicTypeRegistry.java:146) :  Adding type registration java.util.Locale -> org.hibernate.type.LocaleType@8f13dc
[DEBUG] 2017-05-24: 21:05:13 org.hibernate.type.BasicTypeRegistry.register(BasicTypeRegistry.java:146) :  Adding type registration currency -> org.hibernate.type.CurrencyType@ba7366
[DEBUG] 2017-05-24: 21:05:13 org.hibernate.type.BasicTypeRegistry.register(BasicTypeRegistry.java:146) :  Adding type registration java.util.Currency -> org.hibernate.type.CurrencyType@ba7366
[DEBUG] 2017-05-24: 21:05:13 org.hibernate.type.BasicTypeRegistry.register(BasicTypeRegistry.java:146) :  Adding type registration timezone -> org.hibernate.type.TimeZoneType@18e9130
[DEBUG] 2017-05-24: 21:05:13 org.hibernate.type.BasicTypeRegistry.register(BasicTypeRegistry.java:146) :  Adding type registration java.util.TimeZone -> org.hibernate.type.TimeZoneType@18e9130
[DEBUG] 2017-05-24: 21:05:13 org.hibernate.type.BasicTypeRegistry.register(BasicTypeRegistry.java:146) :  Adding type registration class -> org.hibernate.type.ClassType@27cc16
[DEBUG] 2017-05-24: 21:05:13 org.hibernate.type.BasicTypeRegistry.register(BasicTypeRegistry.java:146) :  Adding type registration java.lang.Class -> org.hibernate.type.ClassType@27cc16
[DEBUG] 2017-05-24: 21:05:13 org.hibernate.type.BasicTypeRegistry.register(BasicTypeRegistry.java:146) :  Adding type registration uuid-binary -> org.hibernate.type.UUIDBinaryType@1c89a33
[DEBUG] 2017-05-24: 21:05:13 org.hibernate.type.BasicTypeRegistry.register(BasicTypeRegistry.java:146) :  Adding type registration java.util.UUID -> org.hibernate.type.UUIDBinaryType@1c89a33
[DEBUG] 2017-05-24: 21:05:13 org.hibernate.type.BasicTypeRegistry.register(BasicTypeRegistry.java:146) :  Adding type registration uuid-char -> org.hibernate.type.UUIDCharType@b472b4
[DEBUG] 2017-05-24: 21:05:13 org.hibernate.type.BasicTypeRegistry.register(BasicTypeRegistry.java:146) :  Adding type registration pg-uuid -> org.hibernate.type.PostgresUUIDType@19286ad
[DEBUG] 2017-05-24: 21:05:13 org.hibernate.type.BasicTypeRegistry.register(BasicTypeRegistry.java:146) :  Adding type registration binary -> org.hibernate.type.BinaryType@1d631c5
[DEBUG] 2017-05-24: 21:05:13 org.hibernate.type.BasicTypeRegistry.register(BasicTypeRegistry.java:146) :  Adding type registration byte[] -> org.hibernate.type.BinaryType@1d631c5
[DEBUG] 2017-05-24: 21:05:13 org.hibernate.type.BasicTypeRegistry.register(BasicTypeRegistry.java:146) :  Adding type registration [B -> org.hibernate.type.BinaryType@1d631c5
[DEBUG] 2017-05-24: 21:05:13 org.hibernate.type.BasicTypeRegistry.register(BasicTypeRegistry.java:146) :  Adding type registration wrapper-binary -> org.hibernate.type.WrapperBinaryType@1a26221
[DEBUG] 2017-05-24: 21:05:13 org.hibernate.type.BasicTypeRegistry.register(BasicTypeRegistry.java:146) :  Adding type registration Byte[] -> org.hibernate.type.WrapperBinaryType@1a26221
[DEBUG] 2017-05-24: 21:05:13 org.hibernate.type.BasicTypeRegistry.register(BasicTypeRegistry.java:146) :  Adding type registration [Ljava.lang.Byte; -> org.hibernate.type.WrapperBinaryType@1a26221
[DEBUG] 2017-05-24: 21:05:13 org.hibernate.type.BasicTypeRegistry.register(BasicTypeRegistry.java:146) :  Adding type registration image -> org.hibernate.type.ImageType@dc940
[DEBUG] 2017-05-24: 21:05:13 org.hibernate.type.BasicTypeRegistry.register(BasicTypeRegistry.java:146) :  Adding type registration characters -> org.hibernate.type.CharArrayType@a7decd
[DEBUG] 2017-05-24: 21:05:13 org.hibernate.type.BasicTypeRegistry.register(BasicTypeRegistry.java:146) :  Adding type registration char[] -> org.hibernate.type.CharArrayType@a7decd
[DEBUG] 2017-05-24: 21:05:13 org.hibernate.type.BasicTypeRegistry.register(BasicTypeRegistry.java:146) :  Adding type registration [C -> org.hibernate.type.CharArrayType@a7decd
[DEBUG] 2017-05-24: 21:05:13 org.hibernate.type.BasicTypeRegistry.register(BasicTypeRegistry.java:146) :  Adding type registration wrapper-characters -> org.hibernate.type.CharacterArrayType@1af2bc6
[DEBUG] 2017-05-24: 21:05:13 org.hibernate.type.BasicTypeRegistry.register(BasicTypeRegistry.java:146) :  Adding type registration [Ljava.lang.Character; -> org.hibernate.type.CharacterArrayType@1af2bc6
[DEBUG] 2017-05-24: 21:05:13 org.hibernate.type.BasicTypeRegistry.register(BasicTypeRegistry.java:146) :  Adding type registration Character[] -> org.hibernate.type.CharacterArrayType@1af2bc6
[DEBUG] 2017-05-24: 21:05:13 org.hibernate.type.BasicTypeRegistry.register(BasicTypeRegistry.java:146) :  Adding type registration text -> org.hibernate.type.TextType@1df8b1d
[DEBUG] 2017-05-24: 21:05:13 org.hibernate.type.BasicTypeRegistry.register(BasicTypeRegistry.java:146) :  Adding type registration ntext -> org.hibernate.type.NTextType@2bfa5e
[DEBUG] 2017-05-24: 21:05:13 org.hibernate.type.BasicTypeRegistry.register(BasicTypeRegistry.java:146) :  Adding type registration blob -> org.hibernate.type.BlobType@1801b8d
[DEBUG] 2017-05-24: 21:05:13 org.hibernate.type.BasicTypeRegistry.register(BasicTypeRegistry.java:146) :  Adding type registration java.sql.Blob -> org.hibernate.type.BlobType@1801b8d
[DEBUG] 2017-05-24: 21:05:13 org.hibernate.type.BasicTypeRegistry.register(BasicTypeRegistry.java:146) :  Adding type registration materialized_blob -> org.hibernate.type.MaterializedBlobType@224bd8
[DEBUG] 2017-05-24: 21:05:13 org.hibernate.type.BasicTypeRegistry.register(BasicTypeRegistry.java:146) :  Adding type registration clob -> org.hibernate.type.ClobType@10d5321
[DEBUG] 2017-05-24: 21:05:13 org.hibernate.type.BasicTypeRegistry.register(BasicTypeRegistry.java:146) :  Adding type registration java.sql.Clob -> org.hibernate.type.ClobType@10d5321
[DEBUG] 2017-05-24: 21:05:13 org.hibernate.type.BasicTypeRegistry.register(BasicTypeRegistry.java:146) :  Adding type registration nclob -> org.hibernate.type.NClobType@1f19f87
[DEBUG] 2017-05-24: 21:05:13 org.hibernate.type.BasicTypeRegistry.register(BasicTypeRegistry.java:146) :  Adding type registration java.sql.NClob -> org.hibernate.type.NClobType@1f19f87
[DEBUG] 2017-05-24: 21:05:13 org.hibernate.type.BasicTypeRegistry.register(BasicTypeRegistry.java:146) :  Adding type registration materialized_clob -> org.hibernate.type.MaterializedClobType@5abd8f
[DEBUG] 2017-05-24: 21:05:13 org.hibernate.type.BasicTypeRegistry.register(BasicTypeRegistry.java:146) :  Adding type registration materialized_nclob -> org.hibernate.type.MaterializedNClobType@4a1973
[DEBUG] 2017-05-24: 21:05:13 org.hibernate.type.BasicTypeRegistry.register(BasicTypeRegistry.java:146) :  Adding type registration serializable -> org.hibernate.type.SerializableType@3da033
[DEBUG] 2017-05-24: 21:05:13 org.hibernate.type.BasicTypeRegistry.register(BasicTypeRegistry.java:146) :  Adding type registration object -> org.hibernate.type.ObjectType@10431bf
[DEBUG] 2017-05-24: 21:05:13 org.hibernate.type.BasicTypeRegistry.register(BasicTypeRegistry.java:146) :  Adding type registration java.lang.Object -> org.hibernate.type.ObjectType@10431bf
[DEBUG] 2017-05-24: 21:05:13 org.hibernate.type.BasicTypeRegistry.register(BasicTypeRegistry.java:146) :  Adding type registration imm_date -> org.hibernate.type.AdaptedImmutableType@f2593b
[DEBUG] 2017-05-24: 21:05:13 org.hibernate.type.BasicTypeRegistry.register(BasicTypeRegistry.java:146) :  Adding type registration imm_time -> org.hibernate.type.AdaptedImmutableType@a307d3
[DEBUG] 2017-05-24: 21:05:13 org.hibernate.type.BasicTypeRegistry.register(BasicTypeRegistry.java:146) :  Adding type registration imm_timestamp -> org.hibernate.type.AdaptedImmutableType@17affc1
[DEBUG] 2017-05-24: 21:05:13 org.hibernate.type.BasicTypeRegistry.register(BasicTypeRegistry.java:146) :  Adding type registration imm_dbtimestamp -> org.hibernate.type.AdaptedImmutableType@1306ed7
[DEBUG] 2017-05-24: 21:05:13 org.hibernate.type.BasicTypeRegistry.register(BasicTypeRegistry.java:146) :  Adding type registration imm_calendar -> org.hibernate.type.AdaptedImmutableType@16dd64b
[DEBUG] 2017-05-24: 21:05:13 org.hibernate.type.BasicTypeRegistry.register(BasicTypeRegistry.java:146) :  Adding type registration imm_calendar_date -> org.hibernate.type.AdaptedImmutableType@1c4daea
[DEBUG] 2017-05-24: 21:05:13 org.hibernate.type.BasicTypeRegistry.register(BasicTypeRegistry.java:146) :  Adding type registration imm_binary -> org.hibernate.type.AdaptedImmutableType@102a1a4
[DEBUG] 2017-05-24: 21:05:13 org.hibernate.type.BasicTypeRegistry.register(BasicTypeRegistry.java:146) :  Adding type registration imm_serializable -> org.hibernate.type.AdaptedImmutableType@1d63185
[INFO] 2017-05-24: 21:05:13 org.hibernate.annotations.common.reflection.java.JavaReflectionManager.<clinit>(JavaReflectionManager.java:66) :  HCANN000001: Hibernate Commons Annotations {4.0.5.Final}
[INFO] 2017-05-24: 21:05:13 org.hibernate.Version.logVersion(Version.java:54) :  HHH000412: Hibernate Core {4.3.8.Final}
[INFO] 2017-05-24: 21:05:13 org.hibernate.cfg.Environment.<clinit>(Environment.java:239) :  HHH000206: hibernate.properties not found
[INFO] 2017-05-24: 21:05:13 org.hibernate.cfg.Environment.buildBytecodeProvider(Environment.java:346) :  HHH000021: Bytecode provider name : javassist
[DEBUG] 2017-05-24: 21:05:13 org.hibernate.id.factory.internal.DefaultIdentifierGeneratorFactory.register(DefaultIdentifierGeneratorFactory.java:93) :  Registering IdentifierGenerator strategy [uuid2] -> [org.hibernate.id.UUIDGenerator]
[DEBUG] 2017-05-24: 21:05:13 org.hibernate.id.factory.internal.DefaultIdentifierGeneratorFactory.register(DefaultIdentifierGeneratorFactory.java:93) :  Registering IdentifierGenerator strategy [guid] -> [org.hibernate.id.GUIDGenerator]
[DEBUG] 2017-05-24: 21:05:13 org.hibernate.id.factory.internal.DefaultIdentifierGeneratorFactory.register(DefaultIdentifierGeneratorFactory.java:93) :  Registering IdentifierGenerator strategy [uuid] -> [org.hibernate.id.UUIDHexGenerator]
[DEBUG] 2017-05-24: 21:05:13 org.hibernate.id.factory.internal.DefaultIdentifierGeneratorFactory.register(DefaultIdentifierGeneratorFactory.java:93) :  Registering IdentifierGenerator strategy [uuid.hex] -> [org.hibernate.id.UUIDHexGenerator]
[DEBUG] 2017-05-24: 21:05:13 org.hibernate.id.factory.internal.DefaultIdentifierGeneratorFactory.register(DefaultIdentifierGeneratorFactory.java:93) :  Registering IdentifierGenerator strategy [hilo] -> [org.hibernate.id.TableHiLoGenerator]
[DEBUG] 2017-05-24: 21:05:13 org.hibernate.id.factory.internal.DefaultIdentifierGeneratorFactory.register(DefaultIdentifierGeneratorFactory.java:93) :  Registering IdentifierGenerator strategy [assigned] -> [org.hibernate.id.Assigned]
[DEBUG] 2017-05-24: 21:05:13 org.hibernate.id.factory.internal.DefaultIdentifierGeneratorFactory.register(DefaultIdentifierGeneratorFactory.java:93) :  Registering IdentifierGenerator strategy [identity] -> [org.hibernate.id.IdentityGenerator]
[DEBUG] 2017-05-24: 21:05:13 org.hibernate.id.factory.internal.DefaultIdentifierGeneratorFactory.register(DefaultIdentifierGeneratorFactory.java:93) :  Registering IdentifierGenerator strategy [select] -> [org.hibernate.id.SelectGenerator]
[DEBUG] 2017-05-24: 21:05:13 org.hibernate.id.factory.internal.DefaultIdentifierGeneratorFactory.register(DefaultIdentifierGeneratorFactory.java:93) :  Registering IdentifierGenerator strategy [sequence] -> [org.hibernate.id.SequenceGenerator]
[DEBUG] 2017-05-24: 21:05:13 org.hibernate.id.factory.internal.DefaultIdentifierGeneratorFactory.register(DefaultIdentifierGeneratorFactory.java:93) :  Registering IdentifierGenerator strategy [seqhilo] -> [org.hibernate.id.SequenceHiLoGenerator]
[DEBUG] 2017-05-24: 21:05:13 org.hibernate.id.factory.internal.DefaultIdentifierGeneratorFactory.register(DefaultIdentifierGeneratorFactory.java:93) :  Registering IdentifierGenerator strategy [increment] -> [org.hibernate.id.IncrementGenerator]
[DEBUG] 2017-05-24: 21:05:13 org.hibernate.id.factory.internal.DefaultIdentifierGeneratorFactory.register(DefaultIdentifierGeneratorFactory.java:93) :  Registering IdentifierGenerator strategy [foreign] -> [org.hibernate.id.ForeignGenerator]
[DEBUG] 2017-05-24: 21:05:13 org.hibernate.id.factory.internal.DefaultIdentifierGeneratorFactory.register(DefaultIdentifierGeneratorFactory.java:93) :  Registering IdentifierGenerator strategy [sequence-identity] -> [org.hibernate.id.SequenceIdentityGenerator]
[DEBUG] 2017-05-24: 21:05:13 org.hibernate.id.factory.internal.DefaultIdentifierGeneratorFactory.register(DefaultIdentifierGeneratorFactory.java:93) :  Registering IdentifierGenerator strategy [enhanced-sequence] -> [org.hibernate.id.enhanced.SequenceStyleGenerator]
[DEBUG] 2017-05-24: 21:05:13 org.hibernate.id.factory.internal.DefaultIdentifierGeneratorFactory.register(DefaultIdentifierGeneratorFactory.java:93) :  Registering IdentifierGenerator strategy [enhanced-table] -> [org.hibernate.id.enhanced.TableGenerator]
[DEBUG] 2017-05-24: 21:05:13 org.hibernate.internal.util.xml.DTDEntityResolver.resolveEntity(DTDEntityResolver.java:69) :  Trying to resolve system-id [http://hibernate.sourceforge.net/hibernate-mapping-3.0.dtd]
[WARN] 2017-05-24: 21:05:13 org.hibernate.internal.util.xml.DTDEntityResolver.resolveEntity(DTDEntityResolver.java:75) :  HHH000223: Recognized obsolete hibernate namespace http://hibernate.sourceforge.net/. Use namespace http://www.hibernate.org/dtd/ instead. Refer to Hibernate 3.6 Migration Guide!
[DEBUG] 2017-05-24: 21:05:13 org.hibernate.internal.util.xml.DTDEntityResolver.resolveEntity(DTDEntityResolver.java:76) :  Attempting to resolve on classpath under org/hibernate/
[DEBUG] 2017-05-24: 21:05:13 org.hibernate.internal.util.xml.DTDEntityResolver.resolveOnClassPath(DTDEntityResolver.java:108) :  Located [http://hibernate.sourceforge.net/hibernate-mapping-3.0.dtd] in classpath
[DEBUG] 2017-05-24: 21:05:13 org.hibernate.integrator.internal.IntegratorServiceImpl.addIntegrator(IntegratorServiceImpl.java:63) :  Adding Integrator [org.hibernate.cfg.beanvalidation.BeanValidationIntegrator].
[DEBUG] 2017-05-24: 21:05:13 org.hibernate.integrator.internal.IntegratorServiceImpl.addIntegrator(IntegratorServiceImpl.java:63) :  Adding Integrator [org.hibernate.secure.spi.JaccIntegrator].
[DEBUG] 2017-05-24: 21:05:13 org.hibernate.integrator.internal.IntegratorServiceImpl.addIntegrator(IntegratorServiceImpl.java:63) :  Adding Integrator [org.hibernate.cache.internal.CollectionCacheInvalidator].
[DEBUG] 2017-05-24: 21:05:13 org.hibernate.boot.registry.selector.internal.StrategySelectorImpl.registerStrategyImplementor(StrategySelectorImpl.java:79) :  Registering named strategy selector [org.hibernate.dialect.Dialect] : [MySQL5] -> [org.hibernate.dialect.MySQL5Dialect] (replacing [org.hibernate.dialect.MySQL5Dialect])
[DEBUG] 2017-05-24: 21:05:13 org.hibernate.boot.registry.selector.internal.StrategySelectorImpl.registerStrategyImplementor(StrategySelectorImpl.java:79) :  Registering named strategy selector [org.hibernate.dialect.Dialect] : [MySQL5InnoDB] -> [org.hibernate.dialect.MySQL5InnoDBDialect] (replacing [org.hibernate.dialect.MySQL5InnoDBDialect])
[DEBUG] 2017-05-24: 21:05:13 org.hibernate.service.spi.ServiceBinding.setService(ServiceBinding.java:85) :  Overriding existing service binding [org.hibernate.secure.spi.JaccService]
[DEBUG] 2017-05-24: 21:05:13 org.hibernate.cfg.Configuration.buildSessionFactory(Configuration.java:1843) :  Preparing to build session factory with filters : {}
[DEBUG] 2017-05-24: 21:05:13 org.springframework.jdbc.datasource.DriverManagerDataSource.getConnectionFromDriver(DriverManagerDataSource.java:142) :  Creating new JDBC DriverManager Connection to [jdbc:mysql://localhost:3306/usermanager?characterEncoding=utf8&useSSL=true]
[DEBUG] 2017-05-24: 21:05:13 org.hibernate.engine.jdbc.internal.JdbcServicesImpl.configure(JdbcServicesImpl.java:128) :  Database ->
       name : MySQL
    version : 5.7.16
      major : 5
      minor : 7
[DEBUG] 2017-05-24: 21:05:13 org.hibernate.engine.jdbc.internal.JdbcServicesImpl.configure(JdbcServicesImpl.java:139) :  Driver ->
       name : MySQL Connector Java
    version : mysql-connector-java-5.1.38 ( Revision: fe541c166cec739c74cc727c5da96c1028b4834a )
      major : 5
      minor : 1
[DEBUG] 2017-05-24: 21:05:13 org.hibernate.engine.jdbc.internal.JdbcServicesImpl.configure(JdbcServicesImpl.java:150) :  JDBC version : 4.0
[DEBUG] 2017-05-24: 21:05:13 org.hibernate.engine.jdbc.cursor.internal.StandardRefCursorSupport.supportsRefCursors(StandardRefCursorSupport.java:187) :  Unexpected error trying to gauge level of JDBC REF_CURSOR support : null
[INFO] 2017-05-24: 21:05:13 org.hibernate.dialect.Dialect.<init>(Dialect.java:145) :  HHH000400: Using dialect: org.hibernate.dialect.MySQLDialect
[DEBUG] 2017-05-24: 21:05:13 org.hibernate.cfg.Configuration$MetadataSourceQueue.processHbmXmlQueue(Configuration.java:3805) :  Processing hbm.xml files
[DEBUG] 2017-05-24: 21:05:13 org.hibernate.cfg.HbmBinder.bindRootPersistentClassCommonValues(HbmBinder.java:355) :  Mapping class: com.ittx.usermanager.model.User -> user
[DEBUG] 2017-05-24: 21:05:13 org.hibernate.cfg.HbmBinder.bindProperty(HbmBinder.java:1374) :  Mapped property: id -> id
[DEBUG] 2017-05-24: 21:05:13 org.hibernate.cfg.HbmBinder.bindProperty(HbmBinder.java:1374) :  Mapped property: name -> name
[DEBUG] 2017-05-24: 21:05:13 org.hibernate.cfg.HbmBinder.bindProperty(HbmBinder.java:1374) :  Mapped property: age -> age
[DEBUG] 2017-05-24: 21:05:13 org.hibernate.cfg.HbmBinder.bindProperty(HbmBinder.java:1374) :  Mapped property: sex -> sex
[DEBUG] 2017-05-24: 21:05:13 org.hibernate.cfg.HbmBinder.bindProperty(HbmBinder.java:1374) :  Mapped property: headerUri -> headuri
[DEBUG] 2017-05-24: 21:05:13 org.hibernate.cfg.Configuration$MetadataSourceQueue.processAnnotatedClassesQueue(Configuration.java:3835) :  Process annotated classes
[DEBUG] 2017-05-24: 21:05:13 org.hibernate.cfg.Configuration.processFkSecondPassInOrder(Configuration.java:1484) :  Processing fk mappings (*ToOne and JoinedSubclass)
[DEBUG] 2017-05-24: 21:05:13 org.hibernate.cfg.Configuration.originalSecondPassCompile(Configuration.java:1689) :  Processing extends queue
[DEBUG] 2017-05-24: 21:05:13 org.hibernate.cfg.Configuration.processExtendsQueue(Configuration.java:1747) :  Processing extends queue
[DEBUG] 2017-05-24: 21:05:13 org.hibernate.cfg.Configuration.originalSecondPassCompile(Configuration.java:1692) :  Processing collection mappings
[DEBUG] 2017-05-24: 21:05:13 org.hibernate.cfg.Configuration.originalSecondPassCompile(Configuration.java:1702) :  Processing native query and ResultSetMapping mappings
[DEBUG] 2017-05-24: 21:05:13 org.hibernate.cfg.Configuration.originalSecondPassCompile(Configuration.java:1710) :  Processing association property references
[DEBUG] 2017-05-24: 21:05:13 org.hibernate.cfg.Configuration.originalSecondPassCompile(Configuration.java:1732) :  Creating tables' unique integer identifiers
[DEBUG] 2017-05-24: 21:05:13 org.hibernate.cfg.Configuration.originalSecondPassCompile(Configuration.java:1733) :  Processing foreign key constraints
[DEBUG] 2017-05-24: 21:05:13 org.hibernate.engine.transaction.jta.platform.internal.JtaPlatformInitiator.initiateService(JtaPlatformInitiator.java:59) :  No JtaPlatform was specified, checking resolver
[DEBUG] 2017-05-24: 21:05:13 org.hibernate.engine.transaction.jta.platform.internal.JtaPlatformResolverInitiator.initiateService(JtaPlatformResolverInitiator.java:50) :  No JtaPlatformResolver was specified, using default [org.hibernate.engine.transaction.jta.platform.internal.StandardJtaPlatformResolver]
[DEBUG] 2017-05-24: 21:05:13 org.hibernate.engine.transaction.jta.platform.internal.StandardJtaPlatformResolver.resolveJtaPlatform(StandardJtaPlatformResolver.java:118) :  Could not resolve JtaPlatform, using default [org.hibernate.engine.transaction.jta.platform.internal.NoJtaPlatform]
[DEBUG] 2017-05-24: 21:05:13 org.hibernate.cfg.SettingsFactory.buildSettings(SettingsFactory.java:122) :  Automatic flush during beforeCompletion(): disabled
[DEBUG] 2017-05-24: 21:05:13 org.hibernate.cfg.SettingsFactory.buildSettings(SettingsFactory.java:128) :  Automatic session close at end of transaction: disabled
[DEBUG] 2017-05-24: 21:05:13 org.hibernate.cfg.SettingsFactory.buildSettings(SettingsFactory.java:139) :  JDBC batch size: 15
[DEBUG] 2017-05-24: 21:05:13 org.hibernate.cfg.SettingsFactory.buildSettings(SettingsFactory.java:145) :  JDBC batch updates for versioned data: disabled
[DEBUG] 2017-05-24: 21:05:13 org.hibernate.cfg.SettingsFactory.buildSettings(SettingsFactory.java:155) :  Scrollable result sets: enabled
[DEBUG] 2017-05-24: 21:05:13 org.hibernate.cfg.SettingsFactory.buildSettings(SettingsFactory.java:161) :  Wrap result sets: disabled
[DEBUG] 2017-05-24: 21:05:13 org.hibernate.cfg.SettingsFactory.buildSettings(SettingsFactory.java:167) :  JDBC3 getGeneratedKeys(): enabled
[DEBUG] 2017-05-24: 21:05:13 org.hibernate.cfg.SettingsFactory.buildSettings(SettingsFactory.java:179) :  multi-tenancy strategy : NONE
[DEBUG] 2017-05-24: 21:05:13 org.hibernate.cfg.SettingsFactory.buildSettings(SettingsFactory.java:185) :  Connection release mode: auto
[INFO] 2017-05-24: 21:05:13 org.hibernate.engine.transaction.internal.TransactionFactoryInitiator.initiateService(TransactionFactoryInitiator.java:62) :  HHH000399: Using default transaction strategy (direct JDBC transactions)
[DEBUG] 2017-05-24: 21:05:13 org.hibernate.cfg.SettingsFactory.buildSettings(SettingsFactory.java:207) :  Using BatchFetchStyle : LEGACY
[DEBUG] 2017-05-24: 21:05:13 org.hibernate.cfg.SettingsFactory.buildSettings(SettingsFactory.java:226) :  Maximum outer join fetch depth: 2
[DEBUG] 2017-05-24: 21:05:13 org.hibernate.cfg.SettingsFactory.buildSettings(SettingsFactory.java:232) :  Default batch fetch size: 1
[DEBUG] 2017-05-24: 21:05:13 org.hibernate.cfg.SettingsFactory.buildSettings(SettingsFactory.java:238) :  Generate SQL with comments: disabled
[DEBUG] 2017-05-24: 21:05:13 org.hibernate.cfg.SettingsFactory.buildSettings(SettingsFactory.java:244) :  Order SQL updates by primary key: disabled
[DEBUG] 2017-05-24: 21:05:13 org.hibernate.cfg.SettingsFactory.buildSettings(SettingsFactory.java:250) :  Order SQL inserts for batching: disabled
[DEBUG] 2017-05-24: 21:05:13 org.hibernate.cfg.SettingsFactory.buildSettings(SettingsFactory.java:258) :  Default null ordering: none
[DEBUG] 2017-05-24: 21:05:13 org.hibernate.cfg.SettingsFactory.createQueryTranslatorFactory(SettingsFactory.java:501) :  Query translator: org.hibernate.hql.internal.ast.ASTQueryTranslatorFactory
[INFO] 2017-05-24: 21:05:13 org.hibernate.hql.internal.ast.ASTQueryTranslatorFactory.<init>(ASTQueryTranslatorFactory.java:47) :  HHH000397: Using ASTQueryTranslatorFactory
[DEBUG] 2017-05-24: 21:05:13 org.hibernate.cfg.SettingsFactory.buildSettings(SettingsFactory.java:268) :  Query language substitutions: {}
[DEBUG] 2017-05-24: 21:05:13 org.hibernate.cfg.SettingsFactory.buildSettings(SettingsFactory.java:274) :  JPA-QL strict compliance: disabled
[DEBUG] 2017-05-24: 21:05:13 org.hibernate.cfg.SettingsFactory.buildSettings(SettingsFactory.java:282) :  Second-level cache: enabled
[DEBUG] 2017-05-24: 21:05:13 org.hibernate.cfg.SettingsFactory.buildSettings(SettingsFactory.java:288) :  Query cache: disabled
[DEBUG] 2017-05-24: 21:05:13 org.hibernate.cache.internal.RegionFactoryInitiator.initiateService(RegionFactoryInitiator.java:105) :  Cache region factory : org.hibernate.cache.internal.NoCachingRegionFactory
[DEBUG] 2017-05-24: 21:05:13 org.hibernate.cfg.SettingsFactory.buildSettings(SettingsFactory.java:301) :  Optimize cache for minimal puts: disabled
[DEBUG] 2017-05-24: 21:05:13 org.hibernate.cfg.SettingsFactory.buildSettings(SettingsFactory.java:316) :  Structured second-level cache entries: disabled
[DEBUG] 2017-05-24: 21:05:13 org.hibernate.cfg.SettingsFactory.buildSettings(SettingsFactory.java:326) :  Second-level cache direct-reference entries: disabled
[DEBUG] 2017-05-24: 21:05:13 org.hibernate.cfg.SettingsFactory.buildSettings(SettingsFactory.java:332) :  Automatic eviction of collection cache: disabled
[DEBUG] 2017-05-24: 21:05:13 org.hibernate.cfg.SettingsFactory.buildSettings(SettingsFactory.java:340) :  Statistics: disabled
[DEBUG] 2017-05-24: 21:05:13 org.hibernate.cfg.SettingsFactory.buildSettings(SettingsFactory.java:346) :  Deleted entity synthetic identifier rollback: disabled
[DEBUG] 2017-05-24: 21:05:13 org.hibernate.cfg.SettingsFactory.buildSettings(SettingsFactory.java:373) :  Default entity-mode: pojo
[DEBUG] 2017-05-24: 21:05:13 org.hibernate.cfg.SettingsFactory.buildSettings(SettingsFactory.java:379) :  Named query checking : enabled
[DEBUG] 2017-05-24: 21:05:13 org.hibernate.cfg.SettingsFactory.buildSettings(SettingsFactory.java:385) :  Check Nullability in Core (should be disabled when Bean Validation is on): enabled
[DEBUG] 2017-05-24: 21:05:13 org.hibernate.cfg.SettingsFactory.buildSettings(SettingsFactory.java:403) :  Allow initialization of lazy state outside session : : disabled
[DEBUG] 2017-05-24: 21:05:13 org.hibernate.cfg.SettingsFactory.buildSettings(SettingsFactory.java:413) :  JTA Track by Thread: enabled
[DEBUG] 2017-05-24: 21:05:14 org.hibernate.internal.SessionFactoryImpl.<init>(SessionFactoryImpl.java:229) :  Building session factory
[DEBUG] 2017-05-24: 21:05:14 org.hibernate.internal.SessionFactoryImpl.<init>(SessionFactoryImpl.java:285) :  Session factory constructed with filter configurations : {}
[DEBUG] 2017-05-24: 21:05:14 org.hibernate.internal.SessionFactoryImpl.<init>(SessionFactoryImpl.java:286) :  Instantiating session factory with properties: {java.runtime.name=Java(TM) SE Runtime Environment, sun.boot.library.path=D:\Java\jdk1.8.0_11\jre\bin, java.vm.version=25.11-b03, java.vm.vendor=Oracle Corporation, maven.multiModuleProjectDirectory=D:\projects\workspace_mavens\ssh\ssh-usermanager_annotaion, java.vendor.url=http://java.oracle.com/, path.separator=;, guice.disable.misplaced.annotation.check=true, java.vm.name=Java HotSpot(TM) Client VM, file.encoding.pkg=sun.io, user.script=, user.country=CN, sun.java.launcher=SUN_STANDARD, sun.os.patch.level=Service Pack 1, java.vm.specification.name=Java Virtual Machine Specification, user.dir=D:\projects\workspace_mavens\ssh\ssh-usermanager_annotaion, java.runtime.version=1.8.0_11-b12, java.awt.graphicsenv=sun.awt.Win32GraphicsEnvironment, hibernate.current_session_context_class=org.springframework.orm.hibernate4.SpringSessionContext, java.endorsed.dirs=D:\Java\jdk1.8.0_11\jre\lib\endorsed, os.arch=x86, java.io.tmpdir=C:\Users\ADMINI~1\AppData\Local\Temp\, line.separator=
, java.vm.specification.vendor=Oracle Corporation, user.variant=, os.name=Windows 7, classworlds.conf=D:\projects\workspace_mavens\.metadata\.plugins\org.eclipse.m2e.launching\launches\m2conf6847136271574955004.tmp, sun.jnu.encoding=GBK, java.library.path=D:\Java\jdk1.8.0_11\bin;C:\Windows\Sun\Java\bin;C:\Windows\system32;C:\Windows;D:/Java/jre8/bin/client;D:/Java/jre8/bin;D:/Java/jre8/lib/i386;C:\Program Files\Common Files\NetSarang;d:\Program Files\ImageMagick-6.9.2-Q16;C:\Windows\system32;C:\Windows;C:\Windows\System32\Wbem;C:\Windows\System32\WindowsPowerShell\v1.0\;D:\Java\jdk1.8.0_11\bin;D:\Java\jdk1.8.0_11\jre\bin;D:\Program Files\TortoiseGit\bin;D:\Program Files\Android\Android Studio\gradle\gradle-2.14.1\bin;D:\android-sdk-windows\platform-tools;D:\mysql\mysql-5.7.16-win32\bin;D:\maven\apache-maven-3.3.9\bin;C:\Program Files\nodejs\;d:\Program Files\SSH Communications Security\SSH Secure Shell;C:\Users\Administrator\AppData\Roaming\npm;D:\Program Files\eclipse-jee-neon-1a-win32\eclipse;;., hibernate.connection.datasource=org.springframework.jdbc.datasource.DriverManagerDataSource@1c51db0, java.specification.name=Java Platform API Specification, java.class.version=52.0, sun.management.compiler=HotSpot Client Compiler, os.version=6.1, user.home=C:\Users\Administrator, user.timezone=Asia/Shanghai, java.awt.printerjob=sun.awt.windows.WPrinterJob, java.specification.version=1.8, file.encoding=UTF-8, hibernate.format_sql=true, user.name=Administrator, java.class.path=D:\maven\apache-maven-3.3.9\boot\plexus-classworlds-2.5.2.jar, hibernate.bytecode.use_reflection_optimizer=false, hibernate.show_sql=true, hibernate.classLoader.application=WebAppClassLoader=UserManager@ae7cf2, java.vm.specification.version=1.8, sun.arch.data.model=32, java.home=D:\Java\jdk1.8.0_11\jre, sun.java.command=org.codehaus.plexus.classworlds.launcher.Launcher -B package, hibernate.dialect=org.hibernate.dialect.MySQLDialect, java.specification.vendor=Oracle Corporation, user.language=zh, awt.toolkit=sun.awt.windows.WToolkit, java.vm.info=mixed mode, sharing, java.version=1.8.0_11, java.ext.dirs=D:\Java\jdk1.8.0_11\jre\lib\ext;C:\Windows\Sun\Java\lib\ext, sun.boot.class.path=D:\Java\jdk1.8.0_11\jre\lib\resources.jar;D:\Java\jdk1.8.0_11\jre\lib\rt.jar;D:\Java\jdk1.8.0_11\jre\lib\sunrsasign.jar;D:\Java\jdk1.8.0_11\jre\lib\jsse.jar;D:\Java\jdk1.8.0_11\jre\lib\jce.jar;D:\Java\jdk1.8.0_11\jre\lib\charsets.jar;D:\Java\jdk1.8.0_11\jre\lib\jfr.jar;D:\Java\jdk1.8.0_11\jre\classes, java.vendor=Oracle Corporation, maven.home=D:\maven\apache-maven-3.3.9, file.separator=\, java.vendor.url.bug=http://bugreport.sun.com/bugreport/, sun.cpu.endian=little, sun.io.unicode.encoding=UnicodeLittle, sun.desktop=windows, sun.cpu.isalist=pentium_pro+mmx pentium_pro pentium+mmx pentium i486 i386 i86}
[DEBUG] 2017-05-24: 21:05:14 org.hibernate.secure.spi.JaccIntegrator.doIntegration(JaccIntegrator.java:90) :  Skipping JACC integration as it was not enabled
[DEBUG] 2017-05-24: 21:05:14 org.hibernate.id.factory.internal.DefaultIdentifierGeneratorFactory.setDialect(DefaultIdentifierGeneratorFactory.java:107) :  Setting dialect [org.hibernate.dialect.MySQLDialect]
[DEBUG] 2017-05-24: 21:05:14 org.hibernate.persister.entity.AbstractEntityPersister.logStaticSQL(AbstractEntityPersister.java:3676) :  Static SQL for entity: com.ittx.usermanager.model.User
[DEBUG] 2017-05-24: 21:05:14 org.hibernate.persister.entity.AbstractEntityPersister.logStaticSQL(AbstractEntityPersister.java:3681) :   Version select: select id from user where id =?
[DEBUG] 2017-05-24: 21:05:14 org.hibernate.persister.entity.AbstractEntityPersister.logStaticSQL(AbstractEntityPersister.java:3684) :   Snapshot select: select user_.id, user_.name as name2_0_, user_.age as age3_0_, user_.sex as sex4_0_, user_.headuri as headuri5_0_ from user user_ where user_.id=?
[DEBUG] 2017-05-24: 21:05:14 org.hibernate.persister.entity.AbstractEntityPersister.logStaticSQL(AbstractEntityPersister.java:3687) :   Insert 0: insert into user (name, age, sex, headuri, id) values (?, ?, ?, ?, ?)
[DEBUG] 2017-05-24: 21:05:14 org.hibernate.persister.entity.AbstractEntityPersister.logStaticSQL(AbstractEntityPersister.java:3688) :   Update 0: update user set name=?, age=?, sex=?, headuri=? where id=?
[DEBUG] 2017-05-24: 21:05:14 org.hibernate.persister.entity.AbstractEntityPersister.logStaticSQL(AbstractEntityPersister.java:3689) :   Delete 0: delete from user where id=?
[DEBUG] 2017-05-24: 21:05:14 org.hibernate.persister.entity.AbstractEntityPersister.logStaticSQL(AbstractEntityPersister.java:3692) :   Identity insert: insert into user (name, age, sex, headuri) values (?, ?, ?, ?)
[DEBUG] 2017-05-24: 21:05:14 org.hibernate.loader.plan.build.internal.spaces.QuerySpacesImpl.registerQuerySpace(QuerySpacesImpl.java:192) :  Adding QuerySpace : uid = <gen:0> -> org.hibernate.loader.plan.build.internal.spaces.EntityQuerySpaceImpl@122cf0e]
[DEBUG] 2017-05-24: 21:05:14 org.hibernate.persister.walking.spi.MetamodelGraphWalker.visitAttributeDefinition(MetamodelGraphWalker.java:154) :  Visiting attribute path : name
[DEBUG] 2017-05-24: 21:05:14 org.hibernate.persister.walking.spi.MetamodelGraphWalker.visitAttributeDefinition(MetamodelGraphWalker.java:154) :  Visiting attribute path : age
[DEBUG] 2017-05-24: 21:05:14 org.hibernate.persister.walking.spi.MetamodelGraphWalker.visitAttributeDefinition(MetamodelGraphWalker.java:154) :  Visiting attribute path : sex
[DEBUG] 2017-05-24: 21:05:14 org.hibernate.persister.walking.spi.MetamodelGraphWalker.visitAttributeDefinition(MetamodelGraphWalker.java:154) :  Visiting attribute path : headerUri
[DEBUG] 2017-05-24: 21:05:14 org.hibernate.loader.plan.build.internal.FetchStyleLoadPlanBuildingAssociationVisitationStrategy.buildLoadPlan(FetchStyleLoadPlanBuildingAssociationVisitationStrategy.java:94) :  Building LoadPlan...
[DEBUG] 2017-05-24: 21:05:14 org.hibernate.loader.plan.exec.internal.LoadQueryJoinAndFetchProcessor.processQuerySpaceJoins(LoadQueryJoinAndFetchProcessor.java:112) :  processing queryspace <gen:0>
[DEBUG] 2017-05-24: 21:05:14 org.hibernate.loader.plan.build.spi.LoadPlanTreePrinter.logTree(LoadPlanTreePrinter.java:72) :  LoadPlan(entity=com.ittx.usermanager.model.User)
    - Returns
       - EntityReturnImpl(entity=com.ittx.usermanager.model.User, querySpaceUid=<gen:0>, path=com.ittx.usermanager.model.User)
    - QuerySpaces
       - EntityQuerySpaceImpl(uid=<gen:0>, entity=com.ittx.usermanager.model.User)
          - SQL table alias mapping - user0_
          - alias suffix - 0_
          - suffixed key columns - {id1_0_0_}

[DEBUG] 2017-05-24: 21:05:14 org.hibernate.loader.entity.plan.EntityLoader.<init>(EntityLoader.java:146) :  Static select for entity com.ittx.usermanager.model.User [NONE]: select user0_.id as id1_0_0_, user0_.name as name2_0_0_, user0_.age as age3_0_0_, user0_.sex as sex4_0_0_, user0_.headuri as headuri5_0_0_ from user user0_ where user0_.id=?
[DEBUG] 2017-05-24: 21:05:14 org.hibernate.loader.plan.build.internal.spaces.QuerySpacesImpl.registerQuerySpace(QuerySpacesImpl.java:192) :  Adding QuerySpace : uid = <gen:0> -> org.hibernate.loader.plan.build.internal.spaces.EntityQuerySpaceImpl@4257e3]
[DEBUG] 2017-05-24: 21:05:14 org.hibernate.persister.walking.spi.MetamodelGraphWalker.visitAttributeDefinition(MetamodelGraphWalker.java:154) :  Visiting attribute path : name
[DEBUG] 2017-05-24: 21:05:14 org.hibernate.persister.walking.spi.MetamodelGraphWalker.visitAttributeDefinition(MetamodelGraphWalker.java:154) :  Visiting attribute path : age
[DEBUG] 2017-05-24: 21:05:14 org.hibernate.persister.walking.spi.MetamodelGraphWalker.visitAttributeDefinition(MetamodelGraphWalker.java:154) :  Visiting attribute path : sex
[DEBUG] 2017-05-24: 21:05:14 org.hibernate.persister.walking.spi.MetamodelGraphWalker.visitAttributeDefinition(MetamodelGraphWalker.java:154) :  Visiting attribute path : headerUri
[DEBUG] 2017-05-24: 21:05:14 org.hibernate.loader.plan.build.internal.FetchStyleLoadPlanBuildingAssociationVisitationStrategy.buildLoadPlan(FetchStyleLoadPlanBuildingAssociationVisitationStrategy.java:94) :  Building LoadPlan...
[DEBUG] 2017-05-24: 21:05:14 org.hibernate.loader.plan.exec.internal.LoadQueryJoinAndFetchProcessor.processQuerySpaceJoins(LoadQueryJoinAndFetchProcessor.java:112) :  processing queryspace <gen:0>
[DEBUG] 2017-05-24: 21:05:14 org.hibernate.loader.plan.build.spi.LoadPlanTreePrinter.logTree(LoadPlanTreePrinter.java:72) :  LoadPlan(entity=com.ittx.usermanager.model.User)
    - Returns
       - EntityReturnImpl(entity=com.ittx.usermanager.model.User, querySpaceUid=<gen:0>, path=com.ittx.usermanager.model.User)
    - QuerySpaces
       - EntityQuerySpaceImpl(uid=<gen:0>, entity=com.ittx.usermanager.model.User)
          - SQL table alias mapping - user0_
          - alias suffix - 0_
          - suffixed key columns - {id1_0_0_}

[DEBUG] 2017-05-24: 21:05:14 org.hibernate.loader.entity.plan.EntityLoader.<init>(EntityLoader.java:146) :  Static select for entity com.ittx.usermanager.model.User [READ]: select user0_.id as id1_0_0_, user0_.name as name2_0_0_, user0_.age as age3_0_0_, user0_.sex as sex4_0_0_, user0_.headuri as headuri5_0_0_ from user user0_ where user0_.id=?
[DEBUG] 2017-05-24: 21:05:14 org.hibernate.loader.plan.build.internal.spaces.QuerySpacesImpl.registerQuerySpace(QuerySpacesImpl.java:192) :  Adding QuerySpace : uid = <gen:0> -> org.hibernate.loader.plan.build.internal.spaces.EntityQuerySpaceImpl@1508de]
[DEBUG] 2017-05-24: 21:05:14 org.hibernate.persister.walking.spi.MetamodelGraphWalker.visitAttributeDefinition(MetamodelGraphWalker.java:154) :  Visiting attribute path : name
[DEBUG] 2017-05-24: 21:05:14 org.hibernate.persister.walking.spi.MetamodelGraphWalker.visitAttributeDefinition(MetamodelGraphWalker.java:154) :  Visiting attribute path : age
[DEBUG] 2017-05-24: 21:05:14 org.hibernate.persister.walking.spi.MetamodelGraphWalker.visitAttributeDefinition(MetamodelGraphWalker.java:154) :  Visiting attribute path : sex
[DEBUG] 2017-05-24: 21:05:14 org.hibernate.persister.walking.spi.MetamodelGraphWalker.visitAttributeDefinition(MetamodelGraphWalker.java:154) :  Visiting attribute path : headerUri
[DEBUG] 2017-05-24: 21:05:14 org.hibernate.loader.plan.build.internal.FetchStyleLoadPlanBuildingAssociationVisitationStrategy.buildLoadPlan(FetchStyleLoadPlanBuildingAssociationVisitationStrategy.java:94) :  Building LoadPlan...
[DEBUG] 2017-05-24: 21:05:14 org.hibernate.loader.plan.exec.internal.LoadQueryJoinAndFetchProcessor.processQuerySpaceJoins(LoadQueryJoinAndFetchProcessor.java:112) :  processing queryspace <gen:0>
[DEBUG] 2017-05-24: 21:05:14 org.hibernate.loader.plan.build.spi.LoadPlanTreePrinter.logTree(LoadPlanTreePrinter.java:72) :  LoadPlan(entity=com.ittx.usermanager.model.User)
    - Returns
       - EntityReturnImpl(entity=com.ittx.usermanager.model.User, querySpaceUid=<gen:0>, path=com.ittx.usermanager.model.User)
    - QuerySpaces
       - EntityQuerySpaceImpl(uid=<gen:0>, entity=com.ittx.usermanager.model.User)
          - SQL table alias mapping - user0_
          - alias suffix - 0_
          - suffixed key columns - {id1_0_0_}

[DEBUG] 2017-05-24: 21:05:14 org.hibernate.loader.entity.plan.EntityLoader.<init>(EntityLoader.java:146) :  Static select for entity com.ittx.usermanager.model.User [UPGRADE]: select user0_.id as id1_0_0_, user0_.name as name2_0_0_, user0_.age as age3_0_0_, user0_.sex as sex4_0_0_, user0_.headuri as headuri5_0_0_ from user user0_ where user0_.id=? for update
[DEBUG] 2017-05-24: 21:05:14 org.hibernate.loader.plan.build.internal.spaces.QuerySpacesImpl.registerQuerySpace(QuerySpacesImpl.java:192) :  Adding QuerySpace : uid = <gen:0> -> org.hibernate.loader.plan.build.internal.spaces.EntityQuerySpaceImpl@dd3638]
[DEBUG] 2017-05-24: 21:05:14 org.hibernate.persister.walking.spi.MetamodelGraphWalker.visitAttributeDefinition(MetamodelGraphWalker.java:154) :  Visiting attribute path : name
[DEBUG] 2017-05-24: 21:05:14 org.hibernate.persister.walking.spi.MetamodelGraphWalker.visitAttributeDefinition(MetamodelGraphWalker.java:154) :  Visiting attribute path : age
[DEBUG] 2017-05-24: 21:05:14 org.hibernate.persister.walking.spi.MetamodelGraphWalker.visitAttributeDefinition(MetamodelGraphWalker.java:154) :  Visiting attribute path : sex
[DEBUG] 2017-05-24: 21:05:14 org.hibernate.persister.walking.spi.MetamodelGraphWalker.visitAttributeDefinition(MetamodelGraphWalker.java:154) :  Visiting attribute path : headerUri
[DEBUG] 2017-05-24: 21:05:14 org.hibernate.loader.plan.build.internal.FetchStyleLoadPlanBuildingAssociationVisitationStrategy.buildLoadPlan(FetchStyleLoadPlanBuildingAssociationVisitationStrategy.java:94) :  Building LoadPlan...
[DEBUG] 2017-05-24: 21:05:14 org.hibernate.loader.plan.exec.internal.LoadQueryJoinAndFetchProcessor.processQuerySpaceJoins(LoadQueryJoinAndFetchProcessor.java:112) :  processing queryspace <gen:0>
[DEBUG] 2017-05-24: 21:05:14 org.hibernate.loader.plan.build.spi.LoadPlanTreePrinter.logTree(LoadPlanTreePrinter.java:72) :  LoadPlan(entity=com.ittx.usermanager.model.User)
    - Returns
       - EntityReturnImpl(entity=com.ittx.usermanager.model.User, querySpaceUid=<gen:0>, path=com.ittx.usermanager.model.User)
    - QuerySpaces
       - EntityQuerySpaceImpl(uid=<gen:0>, entity=com.ittx.usermanager.model.User)
          - SQL table alias mapping - user0_
          - alias suffix - 0_
          - suffixed key columns - {id1_0_0_}

[DEBUG] 2017-05-24: 21:05:14 org.hibernate.loader.entity.plan.EntityLoader.<init>(EntityLoader.java:146) :  Static select for entity com.ittx.usermanager.model.User [UPGRADE_NOWAIT]: select user0_.id as id1_0_0_, user0_.name as name2_0_0_, user0_.age as age3_0_0_, user0_.sex as sex4_0_0_, user0_.headuri as headuri5_0_0_ from user user0_ where user0_.id=? for update
[DEBUG] 2017-05-24: 21:05:14 org.hibernate.loader.plan.build.internal.spaces.QuerySpacesImpl.registerQuerySpace(QuerySpacesImpl.java:192) :  Adding QuerySpace : uid = <gen:0> -> org.hibernate.loader.plan.build.internal.spaces.EntityQuerySpaceImpl@1c90b56]
[DEBUG] 2017-05-24: 21:05:14 org.hibernate.persister.walking.spi.MetamodelGraphWalker.visitAttributeDefinition(MetamodelGraphWalker.java:154) :  Visiting attribute path : name
[DEBUG] 2017-05-24: 21:05:14 org.hibernate.persister.walking.spi.MetamodelGraphWalker.visitAttributeDefinition(MetamodelGraphWalker.java:154) :  Visiting attribute path : age
[DEBUG] 2017-05-24: 21:05:14 org.hibernate.persister.walking.spi.MetamodelGraphWalker.visitAttributeDefinition(MetamodelGraphWalker.java:154) :  Visiting attribute path : sex
[DEBUG] 2017-05-24: 21:05:14 org.hibernate.persister.walking.spi.MetamodelGraphWalker.visitAttributeDefinition(MetamodelGraphWalker.java:154) :  Visiting attribute path : headerUri
[DEBUG] 2017-05-24: 21:05:14 org.hibernate.loader.plan.build.internal.FetchStyleLoadPlanBuildingAssociationVisitationStrategy.buildLoadPlan(FetchStyleLoadPlanBuildingAssociationVisitationStrategy.java:94) :  Building LoadPlan...
[DEBUG] 2017-05-24: 21:05:14 org.hibernate.loader.plan.exec.internal.LoadQueryJoinAndFetchProcessor.processQuerySpaceJoins(LoadQueryJoinAndFetchProcessor.java:112) :  processing queryspace <gen:0>
[DEBUG] 2017-05-24: 21:05:14 org.hibernate.loader.plan.build.spi.LoadPlanTreePrinter.logTree(LoadPlanTreePrinter.java:72) :  LoadPlan(entity=com.ittx.usermanager.model.User)
    - Returns
       - EntityReturnImpl(entity=com.ittx.usermanager.model.User, querySpaceUid=<gen:0>, path=com.ittx.usermanager.model.User)
    - QuerySpaces
       - EntityQuerySpaceImpl(uid=<gen:0>, entity=com.ittx.usermanager.model.User)
          - SQL table alias mapping - user0_
          - alias suffix - 0_
          - suffixed key columns - {id1_0_0_}

[DEBUG] 2017-05-24: 21:05:14 org.hibernate.loader.entity.plan.EntityLoader.<init>(EntityLoader.java:146) :  Static select for entity com.ittx.usermanager.model.User [UPGRADE_SKIPLOCKED]: select user0_.id as id1_0_0_, user0_.name as name2_0_0_, user0_.age as age3_0_0_, user0_.sex as sex4_0_0_, user0_.headuri as headuri5_0_0_ from user user0_ where user0_.id=? for update
[DEBUG] 2017-05-24: 21:05:14 org.hibernate.loader.plan.build.internal.spaces.QuerySpacesImpl.registerQuerySpace(QuerySpacesImpl.java:192) :  Adding QuerySpace : uid = <gen:0> -> org.hibernate.loader.plan.build.internal.spaces.EntityQuerySpaceImpl@6cd9e0]
[DEBUG] 2017-05-24: 21:05:14 org.hibernate.persister.walking.spi.MetamodelGraphWalker.visitAttributeDefinition(MetamodelGraphWalker.java:154) :  Visiting attribute path : name
[DEBUG] 2017-05-24: 21:05:14 org.hibernate.persister.walking.spi.MetamodelGraphWalker.visitAttributeDefinition(MetamodelGraphWalker.java:154) :  Visiting attribute path : age
[DEBUG] 2017-05-24: 21:05:14 org.hibernate.persister.walking.spi.MetamodelGraphWalker.visitAttributeDefinition(MetamodelGraphWalker.java:154) :  Visiting attribute path : sex
[DEBUG] 2017-05-24: 21:05:14 org.hibernate.persister.walking.spi.MetamodelGraphWalker.visitAttributeDefinition(MetamodelGraphWalker.java:154) :  Visiting attribute path : headerUri
[DEBUG] 2017-05-24: 21:05:14 org.hibernate.loader.plan.build.internal.FetchStyleLoadPlanBuildingAssociationVisitationStrategy.buildLoadPlan(FetchStyleLoadPlanBuildingAssociationVisitationStrategy.java:94) :  Building LoadPlan...
[DEBUG] 2017-05-24: 21:05:14 org.hibernate.loader.plan.exec.internal.LoadQueryJoinAndFetchProcessor.processQuerySpaceJoins(LoadQueryJoinAndFetchProcessor.java:112) :  processing queryspace <gen:0>
[DEBUG] 2017-05-24: 21:05:14 org.hibernate.loader.plan.build.spi.LoadPlanTreePrinter.logTree(LoadPlanTreePrinter.java:72) :  LoadPlan(entity=com.ittx.usermanager.model.User)
    - Returns
       - EntityReturnImpl(entity=com.ittx.usermanager.model.User, querySpaceUid=<gen:0>, path=com.ittx.usermanager.model.User)
    - QuerySpaces
       - EntityQuerySpaceImpl(uid=<gen:0>, entity=com.ittx.usermanager.model.User)
          - SQL table alias mapping - user0_
          - alias suffix - 0_
          - suffixed key columns - {id1_0_0_}

[DEBUG] 2017-05-24: 21:05:14 org.hibernate.loader.entity.plan.EntityLoader.<init>(EntityLoader.java:146) :  Static select for entity com.ittx.usermanager.model.User [FORCE]: select user0_.id as id1_0_0_, user0_.name as name2_0_0_, user0_.age as age3_0_0_, user0_.sex as sex4_0_0_, user0_.headuri as headuri5_0_0_ from user user0_ where user0_.id=? for update
[DEBUG] 2017-05-24: 21:05:14 org.hibernate.loader.plan.build.internal.spaces.QuerySpacesImpl.registerQuerySpace(QuerySpacesImpl.java:192) :  Adding QuerySpace : uid = <gen:0> -> org.hibernate.loader.plan.build.internal.spaces.EntityQuerySpaceImpl@17a13a7]
[DEBUG] 2017-05-24: 21:05:14 org.hibernate.persister.walking.spi.MetamodelGraphWalker.visitAttributeDefinition(MetamodelGraphWalker.java:154) :  Visiting attribute path : name
[DEBUG] 2017-05-24: 21:05:14 org.hibernate.persister.walking.spi.MetamodelGraphWalker.visitAttributeDefinition(MetamodelGraphWalker.java:154) :  Visiting attribute path : age
[DEBUG] 2017-05-24: 21:05:14 org.hibernate.persister.walking.spi.MetamodelGraphWalker.visitAttributeDefinition(MetamodelGraphWalker.java:154) :  Visiting attribute path : sex
[DEBUG] 2017-05-24: 21:05:14 org.hibernate.persister.walking.spi.MetamodelGraphWalker.visitAttributeDefinition(MetamodelGraphWalker.java:154) :  Visiting attribute path : headerUri
[DEBUG] 2017-05-24: 21:05:14 org.hibernate.loader.plan.build.internal.FetchStyleLoadPlanBuildingAssociationVisitationStrategy.buildLoadPlan(FetchStyleLoadPlanBuildingAssociationVisitationStrategy.java:94) :  Building LoadPlan...
[DEBUG] 2017-05-24: 21:05:14 org.hibernate.loader.plan.exec.internal.LoadQueryJoinAndFetchProcessor.processQuerySpaceJoins(LoadQueryJoinAndFetchProcessor.java:112) :  processing queryspace <gen:0>
[DEBUG] 2017-05-24: 21:05:14 org.hibernate.loader.plan.build.spi.LoadPlanTreePrinter.logTree(LoadPlanTreePrinter.java:72) :  LoadPlan(entity=com.ittx.usermanager.model.User)
    - Returns
       - EntityReturnImpl(entity=com.ittx.usermanager.model.User, querySpaceUid=<gen:0>, path=com.ittx.usermanager.model.User)
    - QuerySpaces
       - EntityQuerySpaceImpl(uid=<gen:0>, entity=com.ittx.usermanager.model.User)
          - SQL table alias mapping - user0_
          - alias suffix - 0_
          - suffixed key columns - {id1_0_0_}

[DEBUG] 2017-05-24: 21:05:14 org.hibernate.loader.entity.plan.EntityLoader.<init>(EntityLoader.java:146) :  Static select for entity com.ittx.usermanager.model.User [PESSIMISTIC_READ]: select user0_.id as id1_0_0_, user0_.name as name2_0_0_, user0_.age as age3_0_0_, user0_.sex as sex4_0_0_, user0_.headuri as headuri5_0_0_ from user user0_ where user0_.id=? lock in share mode
[DEBUG] 2017-05-24: 21:05:14 org.hibernate.loader.plan.build.internal.spaces.QuerySpacesImpl.registerQuerySpace(QuerySpacesImpl.java:192) :  Adding QuerySpace : uid = <gen:0> -> org.hibernate.loader.plan.build.internal.spaces.EntityQuerySpaceImpl@b37c02]
[DEBUG] 2017-05-24: 21:05:14 org.hibernate.persister.walking.spi.MetamodelGraphWalker.visitAttributeDefinition(MetamodelGraphWalker.java:154) :  Visiting attribute path : name
[DEBUG] 2017-05-24: 21:05:14 org.hibernate.persister.walking.spi.MetamodelGraphWalker.visitAttributeDefinition(MetamodelGraphWalker.java:154) :  Visiting attribute path : age
[DEBUG] 2017-05-24: 21:05:14 org.hibernate.persister.walking.spi.MetamodelGraphWalker.visitAttributeDefinition(MetamodelGraphWalker.java:154) :  Visiting attribute path : sex
[DEBUG] 2017-05-24: 21:05:14 org.hibernate.persister.walking.spi.MetamodelGraphWalker.visitAttributeDefinition(MetamodelGraphWalker.java:154) :  Visiting attribute path : headerUri
[DEBUG] 2017-05-24: 21:05:14 org.hibernate.loader.plan.build.internal.FetchStyleLoadPlanBuildingAssociationVisitationStrategy.buildLoadPlan(FetchStyleLoadPlanBuildingAssociationVisitationStrategy.java:94) :  Building LoadPlan...
[DEBUG] 2017-05-24: 21:05:14 org.hibernate.loader.plan.exec.internal.LoadQueryJoinAndFetchProcessor.processQuerySpaceJoins(LoadQueryJoinAndFetchProcessor.java:112) :  processing queryspace <gen:0>
[DEBUG] 2017-05-24: 21:05:14 org.hibernate.loader.plan.build.spi.LoadPlanTreePrinter.logTree(LoadPlanTreePrinter.java:72) :  LoadPlan(entity=com.ittx.usermanager.model.User)
    - Returns
       - EntityReturnImpl(entity=com.ittx.usermanager.model.User, querySpaceUid=<gen:0>, path=com.ittx.usermanager.model.User)
    - QuerySpaces
       - EntityQuerySpaceImpl(uid=<gen:0>, entity=com.ittx.usermanager.model.User)
          - SQL table alias mapping - user0_
          - alias suffix - 0_
          - suffixed key columns - {id1_0_0_}

[DEBUG] 2017-05-24: 21:05:14 org.hibernate.loader.entity.plan.EntityLoader.<init>(EntityLoader.java:146) :  Static select for entity com.ittx.usermanager.model.User [PESSIMISTIC_WRITE]: select user0_.id as id1_0_0_, user0_.name as name2_0_0_, user0_.age as age3_0_0_, user0_.sex as sex4_0_0_, user0_.headuri as headuri5_0_0_ from user user0_ where user0_.id=? for update
[DEBUG] 2017-05-24: 21:05:14 org.hibernate.loader.plan.build.internal.spaces.QuerySpacesImpl.registerQuerySpace(QuerySpacesImpl.java:192) :  Adding QuerySpace : uid = <gen:0> -> org.hibernate.loader.plan.build.internal.spaces.EntityQuerySpaceImpl@c8b723]
[DEBUG] 2017-05-24: 21:05:14 org.hibernate.persister.walking.spi.MetamodelGraphWalker.visitAttributeDefinition(MetamodelGraphWalker.java:154) :  Visiting attribute path : name
[DEBUG] 2017-05-24: 21:05:14 org.hibernate.persister.walking.spi.MetamodelGraphWalker.visitAttributeDefinition(MetamodelGraphWalker.java:154) :  Visiting attribute path : age
[DEBUG] 2017-05-24: 21:05:14 org.hibernate.persister.walking.spi.MetamodelGraphWalker.visitAttributeDefinition(MetamodelGraphWalker.java:154) :  Visiting attribute path : sex
[DEBUG] 2017-05-24: 21:05:14 org.hibernate.persister.walking.spi.MetamodelGraphWalker.visitAttributeDefinition(MetamodelGraphWalker.java:154) :  Visiting attribute path : headerUri
[DEBUG] 2017-05-24: 21:05:14 org.hibernate.loader.plan.build.internal.FetchStyleLoadPlanBuildingAssociationVisitationStrategy.buildLoadPlan(FetchStyleLoadPlanBuildingAssociationVisitationStrategy.java:94) :  Building LoadPlan...
[DEBUG] 2017-05-24: 21:05:14 org.hibernate.loader.plan.exec.internal.LoadQueryJoinAndFetchProcessor.processQuerySpaceJoins(LoadQueryJoinAndFetchProcessor.java:112) :  processing queryspace <gen:0>
[DEBUG] 2017-05-24: 21:05:14 org.hibernate.loader.plan.build.spi.LoadPlanTreePrinter.logTree(LoadPlanTreePrinter.java:72) :  LoadPlan(entity=com.ittx.usermanager.model.User)
    - Returns
       - EntityReturnImpl(entity=com.ittx.usermanager.model.User, querySpaceUid=<gen:0>, path=com.ittx.usermanager.model.User)
    - QuerySpaces
       - EntityQuerySpaceImpl(uid=<gen:0>, entity=com.ittx.usermanager.model.User)
          - SQL table alias mapping - user0_
          - alias suffix - 0_
          - suffixed key columns - {id1_0_0_}

[DEBUG] 2017-05-24: 21:05:14 org.hibernate.loader.entity.plan.EntityLoader.<init>(EntityLoader.java:146) :  Static select for entity com.ittx.usermanager.model.User [PESSIMISTIC_FORCE_INCREMENT]: select user0_.id as id1_0_0_, user0_.name as name2_0_0_, user0_.age as age3_0_0_, user0_.sex as sex4_0_0_, user0_.headuri as headuri5_0_0_ from user user0_ where user0_.id=? for update
[DEBUG] 2017-05-24: 21:05:14 org.hibernate.loader.plan.build.internal.spaces.QuerySpacesImpl.registerQuerySpace(QuerySpacesImpl.java:192) :  Adding QuerySpace : uid = <gen:0> -> org.hibernate.loader.plan.build.internal.spaces.EntityQuerySpaceImpl@1a98737]
[DEBUG] 2017-05-24: 21:05:14 org.hibernate.persister.walking.spi.MetamodelGraphWalker.visitAttributeDefinition(MetamodelGraphWalker.java:154) :  Visiting attribute path : name
[DEBUG] 2017-05-24: 21:05:14 org.hibernate.persister.walking.spi.MetamodelGraphWalker.visitAttributeDefinition(MetamodelGraphWalker.java:154) :  Visiting attribute path : age
[DEBUG] 2017-05-24: 21:05:14 org.hibernate.persister.walking.spi.MetamodelGraphWalker.visitAttributeDefinition(MetamodelGraphWalker.java:154) :  Visiting attribute path : sex
[DEBUG] 2017-05-24: 21:05:14 org.hibernate.persister.walking.spi.MetamodelGraphWalker.visitAttributeDefinition(MetamodelGraphWalker.java:154) :  Visiting attribute path : headerUri
[DEBUG] 2017-05-24: 21:05:14 org.hibernate.loader.plan.build.internal.FetchStyleLoadPlanBuildingAssociationVisitationStrategy.buildLoadPlan(FetchStyleLoadPlanBuildingAssociationVisitationStrategy.java:94) :  Building LoadPlan...
[DEBUG] 2017-05-24: 21:05:14 org.hibernate.loader.plan.exec.internal.LoadQueryJoinAndFetchProcessor.processQuerySpaceJoins(LoadQueryJoinAndFetchProcessor.java:112) :  processing queryspace <gen:0>
[DEBUG] 2017-05-24: 21:05:14 org.hibernate.loader.plan.build.spi.LoadPlanTreePrinter.logTree(LoadPlanTreePrinter.java:72) :  LoadPlan(entity=com.ittx.usermanager.model.User)
    - Returns
       - EntityReturnImpl(entity=com.ittx.usermanager.model.User, querySpaceUid=<gen:0>, path=com.ittx.usermanager.model.User)
    - QuerySpaces
       - EntityQuerySpaceImpl(uid=<gen:0>, entity=com.ittx.usermanager.model.User)
          - SQL table alias mapping - user0_
          - alias suffix - 0_
          - suffixed key columns - {id1_0_0_}

[DEBUG] 2017-05-24: 21:05:14 org.hibernate.loader.entity.plan.EntityLoader.<init>(EntityLoader.java:146) :  Static select for entity com.ittx.usermanager.model.User [OPTIMISTIC]: select user0_.id as id1_0_0_, user0_.name as name2_0_0_, user0_.age as age3_0_0_, user0_.sex as sex4_0_0_, user0_.headuri as headuri5_0_0_ from user user0_ where user0_.id=?
[DEBUG] 2017-05-24: 21:05:14 org.hibernate.loader.plan.build.internal.spaces.QuerySpacesImpl.registerQuerySpace(QuerySpacesImpl.java:192) :  Adding QuerySpace : uid = <gen:0> -> org.hibernate.loader.plan.build.internal.spaces.EntityQuerySpaceImpl@778c6f]
[DEBUG] 2017-05-24: 21:05:14 org.hibernate.persister.walking.spi.MetamodelGraphWalker.visitAttributeDefinition(MetamodelGraphWalker.java:154) :  Visiting attribute path : name
[DEBUG] 2017-05-24: 21:05:14 org.hibernate.persister.walking.spi.MetamodelGraphWalker.visitAttributeDefinition(MetamodelGraphWalker.java:154) :  Visiting attribute path : age
[DEBUG] 2017-05-24: 21:05:14 org.hibernate.persister.walking.spi.MetamodelGraphWalker.visitAttributeDefinition(MetamodelGraphWalker.java:154) :  Visiting attribute path : sex
[DEBUG] 2017-05-24: 21:05:14 org.hibernate.persister.walking.spi.MetamodelGraphWalker.visitAttributeDefinition(MetamodelGraphWalker.java:154) :  Visiting attribute path : headerUri
[DEBUG] 2017-05-24: 21:05:14 org.hibernate.loader.plan.build.internal.FetchStyleLoadPlanBuildingAssociationVisitationStrategy.buildLoadPlan(FetchStyleLoadPlanBuildingAssociationVisitationStrategy.java:94) :  Building LoadPlan...
[DEBUG] 2017-05-24: 21:05:14 org.hibernate.loader.plan.exec.internal.LoadQueryJoinAndFetchProcessor.processQuerySpaceJoins(LoadQueryJoinAndFetchProcessor.java:112) :  processing queryspace <gen:0>
[DEBUG] 2017-05-24: 21:05:14 org.hibernate.loader.plan.build.spi.LoadPlanTreePrinter.logTree(LoadPlanTreePrinter.java:72) :  LoadPlan(entity=com.ittx.usermanager.model.User)
    - Returns
       - EntityReturnImpl(entity=com.ittx.usermanager.model.User, querySpaceUid=<gen:0>, path=com.ittx.usermanager.model.User)
    - QuerySpaces
       - EntityQuerySpaceImpl(uid=<gen:0>, entity=com.ittx.usermanager.model.User)
          - SQL table alias mapping - user0_
          - alias suffix - 0_
          - suffixed key columns - {id1_0_0_}

[DEBUG] 2017-05-24: 21:05:14 org.hibernate.loader.entity.plan.EntityLoader.<init>(EntityLoader.java:146) :  Static select for entity com.ittx.usermanager.model.User [OPTIMISTIC_FORCE_INCREMENT]: select user0_.id as id1_0_0_, user0_.name as name2_0_0_, user0_.age as age3_0_0_, user0_.sex as sex4_0_0_, user0_.headuri as headuri5_0_0_ from user user0_ where user0_.id=?
[DEBUG] 2017-05-24: 21:05:14 org.hibernate.loader.entity.CascadeEntityLoader.<init>(CascadeEntityLoader.java:56) :  Static select for action ACTION_MERGE on entity com.ittx.usermanager.model.User: select user0_.id as id1_0_0_, user0_.name as name2_0_0_, user0_.age as age3_0_0_, user0_.sex as sex4_0_0_, user0_.headuri as headuri5_0_0_ from user user0_ where user0_.id=?
[DEBUG] 2017-05-24: 21:05:14 org.hibernate.loader.entity.CascadeEntityLoader.<init>(CascadeEntityLoader.java:56) :  Static select for action ACTION_REFRESH on entity com.ittx.usermanager.model.User: select user0_.id as id1_0_0_, user0_.name as name2_0_0_, user0_.age as age3_0_0_, user0_.sex as sex4_0_0_, user0_.headuri as headuri5_0_0_ from user user0_ where user0_.id=?
[DEBUG] 2017-05-24: 21:05:14 org.hibernate.internal.SessionFactoryRegistry.<init>(SessionFactoryRegistry.java:67) :  Initializing SessionFactoryRegistry : org.hibernate.internal.SessionFactoryRegistry@118662
[DEBUG] 2017-05-24: 21:05:14 org.hibernate.internal.SessionFactoryRegistry.addSessionFactory(SessionFactoryRegistry.java:89) :  Registering SessionFactory: b050629f-adda-405e-bc4a-630bdcdd8b8a (<unnamed>)
[DEBUG] 2017-05-24: 21:05:14 org.hibernate.internal.SessionFactoryRegistry.addSessionFactory(SessionFactoryRegistry.java:96) :  Not binding SessionFactory to JNDI, no JNDI name configured
[DEBUG] 2017-05-24: 21:05:14 org.hibernate.internal.SessionFactoryImpl.<init>(SessionFactoryImpl.java:505) :  Instantiated session factory
[DEBUG] 2017-05-24: 21:05:14 org.hibernate.internal.NamedQueryRepository.checkNamedQueries(NamedQueryRepository.java:155) :  Checking 0 named HQL queries
[DEBUG] 2017-05-24: 21:05:14 org.hibernate.internal.NamedQueryRepository.checkNamedQueries(NamedQueryRepository.java:171) :  Checking 0 named SQL queries
[DEBUG] 2017-05-24: 21:05:14 org.hibernate.stat.internal.StatisticsInitiator.initiateServiceInternal(StatisticsInitiator.java:110) :  Statistics initialized [enabled=false]
[DEBUG] 2017-05-24: 21:05:14 org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:251) :  Returning cached instance of singleton bean 'org.springframework.transaction.config.internalTransactionAdvisor'
[DEBUG] 2017-05-24: 21:05:14 org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:484) :  Finished creating instance of bean 'sessionFactory'
[DEBUG] 2017-05-24: 21:05:14 org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:251) :  Returning cached instance of singleton bean 'org.springframework.transaction.config.internalTransactionAdvisor'
[DEBUG] 2017-05-24: 21:05:14 org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.invokeInitMethods(AbstractAutowireCapableBeanFactory.java:1625) :  Invoking afterPropertiesSet() on bean with name 'userDao'
[DEBUG] 2017-05-24: 21:05:14 org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:251) :  Returning cached instance of singleton bean 'org.springframework.transaction.config.internalTransactionAdvisor'
[DEBUG] 2017-05-24: 21:05:14 org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:484) :  Finished creating instance of bean 'userDao'
[DEBUG] 2017-05-24: 21:05:14 org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor.registerDependentBeans(AutowiredAnnotationBeanPostProcessor.java:516) :  Autowiring by type from bean name 'userService' to bean named 'userDao'
[DEBUG] 2017-05-24: 21:05:14 org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:251) :  Returning cached instance of singleton bean 'org.springframework.transaction.config.internalTransactionAdvisor'
[DEBUG] 2017-05-24: 21:05:14 org.springframework.transaction.interceptor.AbstractFallbackTransactionAttributeSource.getTransactionAttribute(AbstractFallbackTransactionAttributeSource.java:108) :  Adding transactional method 'UserServiceImpl.getTotal' with attribute: PROPAGATION_REQUIRED,ISOLATION_DEFAULT; ''
[DEBUG] 2017-05-24: 21:05:14 org.springframework.aop.framework.autoproxy.AbstractAutoProxyCreator.buildAdvisors(AbstractAutoProxyCreator.java:528) :  Creating implicit proxy for bean 'userService' with 0 common interceptors and 1 specific interceptors
[DEBUG] 2017-05-24: 21:05:14 org.springframework.aop.framework.JdkDynamicAopProxy.getProxy(JdkDynamicAopProxy.java:118) :  Creating JDK dynamic proxy: target source is SingletonTargetSource for target object [com.ittx.usermanager.service.impl.UserServiceImpl@12bbebe]
[DEBUG] 2017-05-24: 21:05:14 org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:484) :  Finished creating instance of bean 'userService'
[DEBUG] 2017-05-24: 21:05:14 org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor.registerDependentBeans(AutowiredAnnotationBeanPostProcessor.java:516) :  Autowiring by type from bean name 'userAction' to bean named 'userService'
[DEBUG] 2017-05-24: 21:05:14 org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:251) :  Returning cached instance of singleton bean 'org.springframework.transaction.config.internalTransactionAdvisor'
[DEBUG] 2017-05-24: 21:05:14 org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:484) :  Finished creating instance of bean 'userAction'
[DEBUG] 2017-05-24: 21:05:14 org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:251) :  Returning cached instance of singleton bean 'userDao'
[DEBUG] 2017-05-24: 21:05:14 org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:251) :  Returning cached instance of singleton bean 'userService'
[DEBUG] 2017-05-24: 21:05:14 org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:251) :  Returning cached instance of singleton bean 'org.springframework.context.annotation.internalConfigurationAnnotationProcessor'
[DEBUG] 2017-05-24: 21:05:14 org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:251) :  Returning cached instance of singleton bean 'org.springframework.context.annotation.internalAutowiredAnnotationProcessor'
[DEBUG] 2017-05-24: 21:05:14 org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:251) :  Returning cached instance of singleton bean 'org.springframework.context.annotation.internalRequiredAnnotationProcessor'
[DEBUG] 2017-05-24: 21:05:14 org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:251) :  Returning cached instance of singleton bean 'org.springframework.context.annotation.internalCommonAnnotationProcessor'
[DEBUG] 2017-05-24: 21:05:14 org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:251) :  Returning cached instance of singleton bean 'org.springframework.context.annotation.internalPersistenceAnnotationProcessor'
[DEBUG] 2017-05-24: 21:05:14 org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:221) :  Creating shared instance of singleton bean 'org.springframework.context.event.internalEventListenerProcessor'
[DEBUG] 2017-05-24: 21:05:14 org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:448) :  Creating instance of bean 'org.springframework.context.event.internalEventListenerProcessor'
[DEBUG] 2017-05-24: 21:05:14 org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:529) :  Eagerly caching bean 'org.springframework.context.event.internalEventListenerProcessor' to allow for resolving potential circular references
[DEBUG] 2017-05-24: 21:05:14 org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:251) :  Returning cached instance of singleton bean 'org.springframework.transaction.config.internalTransactionAdvisor'
[DEBUG] 2017-05-24: 21:05:14 org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:484) :  Finished creating instance of bean 'org.springframework.context.event.internalEventListenerProcessor'
[DEBUG] 2017-05-24: 21:05:14 org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:221) :  Creating shared instance of singleton bean 'org.springframework.context.event.internalEventListenerFactory'
[DEBUG] 2017-05-24: 21:05:14 org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:448) :  Creating instance of bean 'org.springframework.context.event.internalEventListenerFactory'
[DEBUG] 2017-05-24: 21:05:14 org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:529) :  Eagerly caching bean 'org.springframework.context.event.internalEventListenerFactory' to allow for resolving potential circular references
[DEBUG] 2017-05-24: 21:05:14 org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:251) :  Returning cached instance of singleton bean 'org.springframework.transaction.config.internalTransactionAdvisor'
[DEBUG] 2017-05-24: 21:05:14 org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:484) :  Finished creating instance of bean 'org.springframework.context.event.internalEventListenerFactory'
[DEBUG] 2017-05-24: 21:05:14 org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:251) :  Returning cached instance of singleton bean 'org.springframework.context.support.PropertySourcesPlaceholderConfigurer#0'
[DEBUG] 2017-05-24: 21:05:14 org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:251) :  Returning cached instance of singleton bean 'dataSource'
[DEBUG] 2017-05-24: 21:05:14 org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:251) :  Returning cached instance of singleton bean 'sessionFactory'
[DEBUG] 2017-05-24: 21:05:14 org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:221) :  Creating shared instance of singleton bean 'transactionManager'
[DEBUG] 2017-05-24: 21:05:14 org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:448) :  Creating instance of bean 'transactionManager'
[DEBUG] 2017-05-24: 21:05:14 org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:529) :  Eagerly caching bean 'transactionManager' to allow for resolving potential circular references
[DEBUG] 2017-05-24: 21:05:14 org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:251) :  Returning cached instance of singleton bean 'sessionFactory'
[DEBUG] 2017-05-24: 21:05:14 org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.invokeInitMethods(AbstractAutowireCapableBeanFactory.java:1625) :  Invoking afterPropertiesSet() on bean with name 'transactionManager'
[INFO] 2017-05-24: 21:05:14 org.springframework.orm.hibernate4.HibernateTransactionManager.afterPropertiesSet(HibernateTransactionManager.java:360) :  Using DataSource [org.springframework.jdbc.datasource.DriverManagerDataSource@1c51db0] of Hibernate SessionFactory for HibernateTransactionManager
[DEBUG] 2017-05-24: 21:05:14 org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:251) :  Returning cached instance of singleton bean 'org.springframework.transaction.config.internalTransactionAdvisor'
[DEBUG] 2017-05-24: 21:05:14 org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:484) :  Finished creating instance of bean 'transactionManager'
[DEBUG] 2017-05-24: 21:05:14 org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:221) :  Creating shared instance of singleton bean 'org.springframework.transaction.config.internalTransactionalEventListenerFactory'
[DEBUG] 2017-05-24: 21:05:14 org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:448) :  Creating instance of bean 'org.springframework.transaction.config.internalTransactionalEventListenerFactory'
[DEBUG] 2017-05-24: 21:05:14 org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:529) :  Eagerly caching bean 'org.springframework.transaction.config.internalTransactionalEventListenerFactory' to allow for resolving potential circular references
[DEBUG] 2017-05-24: 21:05:14 org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:251) :  Returning cached instance of singleton bean 'org.springframework.transaction.config.internalTransactionAdvisor'
[DEBUG] 2017-05-24: 21:05:14 org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:484) :  Finished creating instance of bean 'org.springframework.transaction.config.internalTransactionalEventListenerFactory'
[DEBUG] 2017-05-24: 21:05:14 org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:251) :  Returning cached instance of singleton bean 'org.springframework.aop.config.internalAutoProxyCreator'
[DEBUG] 2017-05-24: 21:05:14 org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:251) :  Returning cached instance of singleton bean 'org.springframework.transaction.annotation.AnnotationTransactionAttributeSource#0'
[DEBUG] 2017-05-24: 21:05:14 org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:221) :  Creating shared instance of singleton bean 'org.springframework.transaction.interceptor.TransactionInterceptor#0'
[DEBUG] 2017-05-24: 21:05:14 org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:448) :  Creating instance of bean 'org.springframework.transaction.interceptor.TransactionInterceptor#0'
[DEBUG] 2017-05-24: 21:05:14 org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:529) :  Eagerly caching bean 'org.springframework.transaction.interceptor.TransactionInterceptor#0' to allow for resolving potential circular references
[DEBUG] 2017-05-24: 21:05:14 org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:251) :  Returning cached instance of singleton bean 'org.springframework.transaction.annotation.AnnotationTransactionAttributeSource#0'
[DEBUG] 2017-05-24: 21:05:14 org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.invokeInitMethods(AbstractAutowireCapableBeanFactory.java:1625) :  Invoking afterPropertiesSet() on bean with name 'org.springframework.transaction.interceptor.TransactionInterceptor#0'
[DEBUG] 2017-05-24: 21:05:14 org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:484) :  Finished creating instance of bean 'org.springframework.transaction.interceptor.TransactionInterceptor#0'
[DEBUG] 2017-05-24: 21:05:14 org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:251) :  Returning cached instance of singleton bean 'org.springframework.transaction.config.internalTransactionAdvisor'
[DEBUG] 2017-05-24: 21:05:14 org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:251) :  Returning cached instance of singleton bean 'org.springframework.context.annotation.ConfigurationClassPostProcessor.importAwareProcessor'
[DEBUG] 2017-05-24: 21:05:14 org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:251) :  Returning cached instance of singleton bean 'org.springframework.context.annotation.ConfigurationClassPostProcessor.enhancedConfigurationProcessor'
[DEBUG] 2017-05-24: 21:05:14 org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:251) :  Returning cached instance of singleton bean 'org.springframework.context.event.internalEventListenerFactory'
[DEBUG] 2017-05-24: 21:05:14 org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:251) :  Returning cached instance of singleton bean 'org.springframework.transaction.config.internalTransactionalEventListenerFactory'
[DEBUG] 2017-05-24: 21:05:14 org.springframework.context.support.AbstractApplicationContext.initLifecycleProcessor(AbstractApplicationContext.java:779) :  Unable to locate LifecycleProcessor with name 'lifecycleProcessor': using default [org.springframework.context.support.DefaultLifecycleProcessor@19063c7]
[DEBUG] 2017-05-24: 21:05:14 org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:251) :  Returning cached instance of singleton bean 'lifecycleProcessor'
[DEBUG] 2017-05-24: 21:05:14 org.springframework.jndi.JndiTemplate.lookup(JndiTemplate.java:150) :  Looking up JNDI object with name [java:comp/env/spring.liveBeansView.mbeanDomain]
[DEBUG] 2017-05-24: 21:05:14 org.springframework.jndi.JndiLocatorSupport.lookup(JndiLocatorSupport.java:101) :  Converted JNDI name [java:comp/env/spring.liveBeansView.mbeanDomain] not found - trying original name [spring.liveBeansView.mbeanDomain]. javax.naming.NameNotFoundException; remaining name 'spring.liveBeansView.mbeanDomain'
[DEBUG] 2017-05-24: 21:05:14 org.springframework.jndi.JndiTemplate.lookup(JndiTemplate.java:150) :  Looking up JNDI object with name [spring.liveBeansView.mbeanDomain]
[DEBUG] 2017-05-24: 21:05:14 org.springframework.jndi.JndiPropertySource.getProperty(JndiPropertySource.java:99) :  JNDI lookup for name [spring.liveBeansView.mbeanDomain] threw NamingException with message: null. Returning null.
[DEBUG] 2017-05-24: 21:05:14 org.springframework.core.env.PropertySourcesPropertyResolver.getProperty(PropertySourcesPropertyResolver.java:91) :  Could not find key 'spring.liveBeansView.mbeanDomain' in any property source
[DEBUG] 2017-05-24: 21:05:14 org.springframework.web.context.ContextLoader.initWebApplicationContext(ContextLoader.java:340) :  Published root WebApplicationContext as ServletContext attribute with name [org.springframework.web.context.WebApplicationContext.ROOT]
[INFO] 2017-05-24: 21:05:14 org.springframework.web.context.ContextLoader.initWebApplicationContext(ContextLoader.java:345) :  Root WebApplicationContext: initialization completed in 2774 ms
[INFO] 2017-05-24: 21:05:15 com.opensymphony.xwork2.util.logging.commons.CommonsLogger.info(CommonsLogger.java:49) :  Initializing Struts-Spring integration...
[INFO] 2017-05-24: 21:05:15 com.opensymphony.xwork2.util.logging.commons.CommonsLogger.info(CommonsLogger.java:49) :  ... initialized Struts-Spring integration successfully
[DEBUG] 2017-05-24: 21:05:15 org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:251) :  Returning cached instance of singleton bean 'org.springframework.transaction.config.internalTransactionAdvisor'
[DEBUG] 2017-05-24: 21:05:15 org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:251) :  Returning cached instance of singleton bean 'org.springframework.transaction.config.internalTransactionAdvisor'
[DEBUG] 2017-05-24: 21:05:15 org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:251) :  Returning cached instance of singleton bean 'org.springframework.transaction.config.internalTransactionAdvisor'
[DEBUG] 2017-05-24: 21:05:15 org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:251) :  Returning cached instance of singleton bean 'org.springframework.transaction.config.internalTransactionAdvisor'
[DEBUG] 2017-05-24: 21:05:15 org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:251) :  Returning cached instance of singleton bean 'org.springframework.transaction.config.internalTransactionAdvisor'
[DEBUG] 2017-05-24: 21:05:15 org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:251) :  Returning cached instance of singleton bean 'org.springframework.transaction.config.internalTransactionAdvisor'
[DEBUG] 2017-05-24: 21:05:15 org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:251) :  Returning cached instance of singleton bean 'org.springframework.transaction.config.internalTransactionAdvisor'
[DEBUG] 2017-05-24: 21:05:15 org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:251) :  Returning cached instance of singleton bean 'org.springframework.transaction.config.internalTransactionAdvisor'
[DEBUG] 2017-05-24: 21:05:15 org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:251) :  Returning cached instance of singleton bean 'org.springframework.transaction.config.internalTransactionAdvisor'
[DEBUG] 2017-05-24: 21:05:15 org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:251) :  Returning cached instance of singleton bean 'org.springframework.transaction.config.internalTransactionAdvisor'
[DEBUG] 2017-05-24: 21:05:15 org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:251) :  Returning cached instance of singleton bean 'org.springframework.transaction.config.internalTransactionAdvisor'
[DEBUG] 2017-05-24: 21:05:15 org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:251) :  Returning cached instance of singleton bean 'org.springframework.transaction.config.internalTransactionAdvisor'
[DEBUG] 2017-05-24: 21:05:15 org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:251) :  Returning cached instance of singleton bean 'org.springframework.transaction.config.internalTransactionAdvisor'
[DEBUG] 2017-05-24: 21:05:15 org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:251) :  Returning cached instance of singleton bean 'org.springframework.transaction.config.internalTransactionAdvisor'
[DEBUG] 2017-05-24: 21:05:15 org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:251) :  Returning cached instance of singleton bean 'org.springframework.transaction.config.internalTransactionAdvisor'
[DEBUG] 2017-05-24: 21:05:15 org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:251) :  Returning cached instance of singleton bean 'org.springframework.transaction.config.internalTransactionAdvisor'
[DEBUG] 2017-05-24: 21:05:15 org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:251) :  Returning cached instance of singleton bean 'org.springframework.transaction.config.internalTransactionAdvisor'
[DEBUG] 2017-05-24: 21:05:15 org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:251) :  Returning cached instance of singleton bean 'org.springframework.transaction.config.internalTransactionAdvisor'
[DEBUG] 2017-05-24: 21:05:15 org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:251) :  Returning cached instance of singleton bean 'org.springframework.transaction.config.internalTransactionAdvisor'
[DEBUG] 2017-05-24: 21:05:15 org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:251) :  Returning cached instance of singleton bean 'org.springframework.transaction.config.internalTransactionAdvisor'
[DEBUG] 2017-05-24: 21:05:15 org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:251) :  Returning cached instance of singleton bean 'org.springframework.transaction.config.internalTransactionAdvisor'
[DEBUG] 2017-05-24: 21:05:15 org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:251) :  Returning cached instance of singleton bean 'org.springframework.transaction.config.internalTransactionAdvisor'
[DEBUG] 2017-05-24: 21:05:15 org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:251) :  Returning cached instance of singleton bean 'org.springframework.transaction.config.internalTransactionAdvisor'
[DEBUG] 2017-05-24: 21:05:15 org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:251) :  Returning cached instance of singleton bean 'org.springframework.transaction.config.internalTransactionAdvisor'
[DEBUG] 2017-05-24: 21:05:15 org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:251) :  Returning cached instance of singleton bean 'org.springframework.transaction.config.internalTransactionAdvisor'
[DEBUG] 2017-05-24: 21:05:15 org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:251) :  Returning cached instance of singleton bean 'org.springframework.transaction.config.internalTransactionAdvisor'
[DEBUG] 2017-05-24: 21:05:15 org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:251) :  Returning cached instance of singleton bean 'org.springframework.transaction.config.internalTransactionAdvisor'
[DEBUG] 2017-05-24: 21:05:15 org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:251) :  Returning cached instance of singleton bean 'org.springframework.transaction.config.internalTransactionAdvisor'
[DEBUG] 2017-05-24: 21:05:15 org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:251) :  Returning cached instance of singleton bean 'org.springframework.transaction.config.internalTransactionAdvisor'
[DEBUG] 2017-05-24: 21:05:15 org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:251) :  Returning cached instance of singleton bean 'org.springframework.transaction.config.internalTransactionAdvisor'
[DEBUG] 2017-05-24: 21:05:15 org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:251) :  Returning cached instance of singleton bean 'org.springframework.transaction.config.internalTransactionAdvisor'
[DEBUG] 2017-05-24: 21:05:15 org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:251) :  Returning cached instance of singleton bean 'org.springframework.transaction.config.internalTransactionAdvisor'
[DEBUG] 2017-05-24: 21:05:15 org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:251) :  Returning cached instance of singleton bean 'org.springframework.transaction.config.internalTransactionAdvisor'
[DEBUG] 2017-05-24: 21:05:15 org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:251) :  Returning cached instance of singleton bean 'org.springframework.transaction.config.internalTransactionAdvisor'
[DEBUG] 2017-05-24: 21:05:15 org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:251) :  Returning cached instance of singleton bean 'org.springframework.transaction.config.internalTransactionAdvisor'
[DEBUG] 2017-05-24: 21:05:15 org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:251) :  Returning cached instance of singleton bean 'org.springframework.transaction.config.internalTransactionAdvisor'
[DEBUG] 2017-05-24: 21:05:15 org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:251) :  Returning cached instance of singleton bean 'org.springframework.transaction.config.internalTransactionAdvisor'
[DEBUG] 2017-05-24: 21:05:16 freemarker.log._Log4jLoggerFactory$Log4jLogger.debug(_Log4jLoggerFactory.java:45) :  Couldn't find template in cache for "org/apache/struts2/dispatcher/error.ftl"("zh_CN", UTF-8, parsed); will try to load it.
[DEBUG] 2017-05-24: 21:05:16 freemarker.log._Log4jLoggerFactory$Log4jLogger.debug(_Log4jLoggerFactory.java:45) :  TemplateLoader.findTemplateSource("org/apache/struts2/dispatcher/error.ftl"): Found
[DEBUG] 2017-05-24: 21:05:16 freemarker.log._Log4jLoggerFactory$Log4jLogger.debug(_Log4jLoggerFactory.java:45) :  Loading template for "org/apache/struts2/dispatcher/error.ftl"("zh_CN", UTF-8, parsed) from "jar:file:/D:/maven/repository/org/apache/struts/struts2-core/2.5.10/struts2-core-2.5.10.jar!/org/apache/struts2/dispatcher/error.ftl"
[DEBUG] 2017-05-24: 21:05:21 org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:251) :  Returning cached instance of singleton bean 'org.springframework.transaction.config.internalTransactionAdvisor'
[DEBUG] 2017-05-24: 21:05:21 org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:251) :  Returning cached instance of singleton bean 'servletContext'
[DEBUG] 2017-05-24: 21:05:21 org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.autowireByName(AbstractAutowireCapableBeanFactory.java:1253) :  Added autowiring by name from bean name 'com.ittx.usermanager.action.LoginAction' via property 'servletContext' to bean named 'servletContext'
[DEBUG] 2017-05-24: 21:05:21 com.ittx.usermanager.action.LoginAction.validate(LoginAction.java:39) :  validte >>>>
[DEBUG] 2017-05-24: 21:05:21 org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:251) :  Returning cached instance of singleton bean 'org.springframework.transaction.config.internalTransactionAdvisor'
[DEBUG] 2017-05-24: 21:05:31 org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:251) :  Returning cached instance of singleton bean 'servletContext'
[DEBUG] 2017-05-24: 21:05:31 org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.autowireByName(AbstractAutowireCapableBeanFactory.java:1253) :  Added autowiring by name from bean name 'com.ittx.usermanager.action.LoginAction' via property 'servletContext' to bean named 'servletContext'
[DEBUG] 2017-05-24: 21:05:31 com.ittx.usermanager.action.LoginAction.validate(LoginAction.java:39) :  validte >>>>
[DEBUG] 2017-05-24: 21:05:32 freemarker.log._Log4jLoggerFactory$Log4jLogger.debug(_Log4jLoggerFactory.java:45) :  Couldn't find template in cache for "template/xhtml/form.ftl"("zh_CN", UTF-8, parsed); will try to load it.
[DEBUG] 2017-05-24: 21:05:32 freemarker.log._Log4jLoggerFactory$Log4jLogger.debug(_Log4jLoggerFactory.java:45) :  TemplateLoader.findTemplateSource("template/xhtml/form.ftl"): Found
[DEBUG] 2017-05-24: 21:05:32 freemarker.log._Log4jLoggerFactory$Log4jLogger.debug(_Log4jLoggerFactory.java:45) :  Loading template for "template/xhtml/form.ftl"("zh_CN", UTF-8, parsed) from "jar:file:/D:/maven/repository/org/apache/struts/struts2-core/2.5.10/struts2-core-2.5.10.jar!/template/xhtml/form.ftl"
[DEBUG] 2017-05-24: 21:05:32 freemarker.log._Log4jLoggerFactory$Log4jLogger.debug(_Log4jLoggerFactory.java:45) :  Couldn't find template in cache for "template/~~~xhtml/form-validate.ftl"("zh_CN", UTF-8, parsed); will try to load it.
[DEBUG] 2017-05-24: 21:05:32 freemarker.log._Log4jLoggerFactory$Log4jLogger.debug(_Log4jLoggerFactory.java:45) :  TemplateLoader.findTemplateSource("template/~~~xhtml/form-validate.ftl"): Found
[DEBUG] 2017-05-24: 21:05:32 freemarker.log._Log4jLoggerFactory$Log4jLogger.debug(_Log4jLoggerFactory.java:45) :  Loading template for "template/~~~xhtml/form-validate.ftl"("zh_CN", UTF-8, parsed) from "jar:file:/D:/maven/repository/org/apache/struts/struts2-core/2.5.10/struts2-core-2.5.10.jar!/template/xhtml/form-validate.ftl"
[DEBUG] 2017-05-24: 21:05:32 freemarker.log._Log4jLoggerFactory$Log4jLogger.debug(_Log4jLoggerFactory.java:45) :  Key "validate" was not found on instance of java.util.LinkedHashMap. Introspection information for the class is: {getClass=public final native java.lang.Class java.lang.Object.getClass(), getOrDefault=public java.lang.Object java.util.LinkedHashMap.getOrDefault(java.lang.Object,java.lang.Object), computeIfAbsent=public java.lang.Object java.util.HashMap.computeIfAbsent(java.lang.Object,java.util.function.Function), values=public java.util.Collection java.util.LinkedHashMap.values(), replace=freemarker.ext.beans.OverloadedMethods@11d0265, java.lang.Object@3e55b2={public boolean java.util.HashMap.isEmpty()=[Ljava.lang.Class;@c5aa3a, public int java.util.AbstractMap.hashCode()=[Ljava.lang.Class;@74a947, public java.lang.Object java.util.HashMap.put(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@1615a91, public boolean java.util.AbstractMap.equals(java.lang.Object)=[Ljava.lang.Class;@a46ab2, public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object)=[Ljava.lang.Class;@1c389e6, public java.lang.String java.util.AbstractMap.toString()=[Ljava.lang.Class;@a23548, public boolean java.util.HashMap.containsKey(java.lang.Object)=[Ljava.lang.Class;@1be4a9f, public java.util.Set java.util.LinkedHashMap.keySet()=[Ljava.lang.Class;@44c60, public java.lang.Object java.util.HashMap.computeIfAbsent(java.lang.Object,java.util.function.Function)=[Ljava.lang.Class;@10f7dff, public java.lang.Object java.util.HashMap.clone()=[Ljava.lang.Class;@d214e3, public java.lang.Object java.util.LinkedHashMap.getOrDefault(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@1a74254, public java.util.Set java.util.LinkedHashMap.entrySet()=[Ljava.lang.Class;@1c4740c, public void java.util.LinkedHashMap.forEach(java.util.function.BiConsumer)=[Ljava.lang.Class;@1fe0c8e, public java.lang.Object java.util.HashMap.putIfAbsent(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@16f73de, public java.util.Collection java.util.LinkedHashMap.values()=[Ljava.lang.Class;@b3e45, public void java.util.LinkedHashMap.clear()=[Ljava.lang.Class;@a34e5c, public java.lang.Object java.util.HashMap.computeIfPresent(java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1fcb13a, public java.lang.Object java.util.HashMap.compute(java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1a7c258, public final native java.lang.Class java.lang.Object.getClass()=[Ljava.lang.Class;@7397f, public void java.util.HashMap.putAll(java.util.Map)=[Ljava.lang.Class;@59cd, public void java.util.LinkedHashMap.replaceAll(java.util.function.BiFunction)=[Ljava.lang.Class;@994816, public java.lang.Object java.util.HashMap.merge(java.lang.Object,java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1b1e75f, public int java.util.HashMap.size()=[Ljava.lang.Class;@bee157, public boolean java.util.LinkedHashMap.containsValue(java.lang.Object)=[Ljava.lang.Class;@5e0d7c}, replaceAll=public void java.util.LinkedHashMap.replaceAll(java.util.function.BiFunction), remove=freemarker.ext.beans.OverloadedMethods@8d3a99, containsValue=public boolean java.util.LinkedHashMap.containsValue(java.lang.Object), put=public java.lang.Object java.util.HashMap.put(java.lang.Object,java.lang.Object), empty=java.beans.PropertyDescriptor[name=empty; propertyType=boolean; readMethod=public boolean java.util.HashMap.isEmpty()], compute=public java.lang.Object java.util.HashMap.compute(java.lang.Object,java.util.function.BiFunction), hashCode=public int java.util.AbstractMap.hashCode(), putAll=public void java.util.HashMap.putAll(java.util.Map), get=public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object), merge=public java.lang.Object java.util.HashMap.merge(java.lang.Object,java.lang.Object,java.util.function.BiFunction), class=java.beans.PropertyDescriptor[name=class; propertyType=class java.lang.Class; readMethod=public final native java.lang.Class java.lang.Object.getClass()], keySet=public java.util.Set java.util.LinkedHashMap.keySet(), java.lang.Object@1c0f21d=freemarker.ext.beans.OverloadedMethods@d4b988, entrySet=public java.util.Set java.util.LinkedHashMap.entrySet(), java.lang.Object@15be27d=public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object), forEach=public void java.util.LinkedHashMap.forEach(java.util.function.BiConsumer), containsKey=public boolean java.util.HashMap.containsKey(java.lang.Object), isEmpty=public boolean java.util.HashMap.isEmpty(), clear=public void java.util.LinkedHashMap.clear(), computeIfPresent=public java.lang.Object java.util.HashMap.computeIfPresent(java.lang.Object,java.util.function.BiFunction), size=public int java.util.HashMap.size(), equals=public boolean java.util.AbstractMap.equals(java.lang.Object), clone=public java.lang.Object java.util.HashMap.clone(), toString=public java.lang.String java.util.AbstractMap.toString(), putIfAbsent=public java.lang.Object java.util.HashMap.putIfAbsent(java.lang.Object,java.lang.Object)}
[DEBUG] 2017-05-24: 21:05:32 freemarker.log._Log4jLoggerFactory$Log4jLogger.debug(_Log4jLoggerFactory.java:45) :  Couldn't find template in cache for "template/~~~xhtml/form-common.ftl"("zh_CN", UTF-8, parsed); will try to load it.
[DEBUG] 2017-05-24: 21:05:32 freemarker.log._Log4jLoggerFactory$Log4jLogger.debug(_Log4jLoggerFactory.java:45) :  TemplateLoader.findTemplateSource("template/~~~xhtml/form-common.ftl"): Found
[DEBUG] 2017-05-24: 21:05:32 freemarker.log._Log4jLoggerFactory$Log4jLogger.debug(_Log4jLoggerFactory.java:45) :  Loading template for "template/~~~xhtml/form-common.ftl"("zh_CN", UTF-8, parsed) from "jar:file:/D:/maven/repository/org/apache/struts/struts2-core/2.5.10/struts2-core-2.5.10.jar!/template/simple/form-common.ftl"
[DEBUG] 2017-05-24: 21:05:32 freemarker.log._Log4jLoggerFactory$Log4jLogger.debug(_Log4jLoggerFactory.java:45) :  Key "validate" was not found on instance of java.util.LinkedHashMap. Introspection information for the class is: {getClass=public final native java.lang.Class java.lang.Object.getClass(), getOrDefault=public java.lang.Object java.util.LinkedHashMap.getOrDefault(java.lang.Object,java.lang.Object), computeIfAbsent=public java.lang.Object java.util.HashMap.computeIfAbsent(java.lang.Object,java.util.function.Function), values=public java.util.Collection java.util.LinkedHashMap.values(), replace=freemarker.ext.beans.OverloadedMethods@11d0265, java.lang.Object@3e55b2={public boolean java.util.HashMap.isEmpty()=[Ljava.lang.Class;@c5aa3a, public int java.util.AbstractMap.hashCode()=[Ljava.lang.Class;@74a947, public java.lang.Object java.util.HashMap.put(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@1615a91, public boolean java.util.AbstractMap.equals(java.lang.Object)=[Ljava.lang.Class;@a46ab2, public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object)=[Ljava.lang.Class;@1c389e6, public java.lang.String java.util.AbstractMap.toString()=[Ljava.lang.Class;@a23548, public boolean java.util.HashMap.containsKey(java.lang.Object)=[Ljava.lang.Class;@1be4a9f, public java.util.Set java.util.LinkedHashMap.keySet()=[Ljava.lang.Class;@44c60, public java.lang.Object java.util.HashMap.computeIfAbsent(java.lang.Object,java.util.function.Function)=[Ljava.lang.Class;@10f7dff, public java.lang.Object java.util.HashMap.clone()=[Ljava.lang.Class;@d214e3, public java.lang.Object java.util.LinkedHashMap.getOrDefault(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@1a74254, public java.util.Set java.util.LinkedHashMap.entrySet()=[Ljava.lang.Class;@1c4740c, public void java.util.LinkedHashMap.forEach(java.util.function.BiConsumer)=[Ljava.lang.Class;@1fe0c8e, public java.lang.Object java.util.HashMap.putIfAbsent(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@16f73de, public java.util.Collection java.util.LinkedHashMap.values()=[Ljava.lang.Class;@b3e45, public void java.util.LinkedHashMap.clear()=[Ljava.lang.Class;@a34e5c, public java.lang.Object java.util.HashMap.computeIfPresent(java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1fcb13a, public java.lang.Object java.util.HashMap.compute(java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1a7c258, public final native java.lang.Class java.lang.Object.getClass()=[Ljava.lang.Class;@7397f, public void java.util.HashMap.putAll(java.util.Map)=[Ljava.lang.Class;@59cd, public void java.util.LinkedHashMap.replaceAll(java.util.function.BiFunction)=[Ljava.lang.Class;@994816, public java.lang.Object java.util.HashMap.merge(java.lang.Object,java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1b1e75f, public int java.util.HashMap.size()=[Ljava.lang.Class;@bee157, public boolean java.util.LinkedHashMap.containsValue(java.lang.Object)=[Ljava.lang.Class;@5e0d7c}, replaceAll=public void java.util.LinkedHashMap.replaceAll(java.util.function.BiFunction), remove=freemarker.ext.beans.OverloadedMethods@8d3a99, containsValue=public boolean java.util.LinkedHashMap.containsValue(java.lang.Object), put=public java.lang.Object java.util.HashMap.put(java.lang.Object,java.lang.Object), empty=java.beans.PropertyDescriptor[name=empty; propertyType=boolean; readMethod=public boolean java.util.HashMap.isEmpty()], compute=public java.lang.Object java.util.HashMap.compute(java.lang.Object,java.util.function.BiFunction), hashCode=public int java.util.AbstractMap.hashCode(), putAll=public void java.util.HashMap.putAll(java.util.Map), get=public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object), merge=public java.lang.Object java.util.HashMap.merge(java.lang.Object,java.lang.Object,java.util.function.BiFunction), class=java.beans.PropertyDescriptor[name=class; propertyType=class java.lang.Class; readMethod=public final native java.lang.Class java.lang.Object.getClass()], keySet=public java.util.Set java.util.LinkedHashMap.keySet(), java.lang.Object@1c0f21d=freemarker.ext.beans.OverloadedMethods@d4b988, entrySet=public java.util.Set java.util.LinkedHashMap.entrySet(), java.lang.Object@15be27d=public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object), forEach=public void java.util.LinkedHashMap.forEach(java.util.function.BiConsumer), containsKey=public boolean java.util.HashMap.containsKey(java.lang.Object), isEmpty=public boolean java.util.HashMap.isEmpty(), clear=public void java.util.LinkedHashMap.clear(), computeIfPresent=public java.lang.Object java.util.HashMap.computeIfPresent(java.lang.Object,java.util.function.BiFunction), size=public int java.util.HashMap.size(), equals=public boolean java.util.AbstractMap.equals(java.lang.Object), clone=public java.lang.Object java.util.HashMap.clone(), toString=public java.lang.String java.util.AbstractMap.toString(), putIfAbsent=public java.lang.Object java.util.HashMap.putIfAbsent(java.lang.Object,java.lang.Object)}
[DEBUG] 2017-05-24: 21:05:32 freemarker.log._Log4jLoggerFactory$Log4jLogger.debug(_Log4jLoggerFactory.java:45) :  Key "onsubmit" was not found on instance of java.util.LinkedHashMap. Introspection information for the class is: {getClass=public final native java.lang.Class java.lang.Object.getClass(), getOrDefault=public java.lang.Object java.util.LinkedHashMap.getOrDefault(java.lang.Object,java.lang.Object), computeIfAbsent=public java.lang.Object java.util.HashMap.computeIfAbsent(java.lang.Object,java.util.function.Function), values=public java.util.Collection java.util.LinkedHashMap.values(), replace=freemarker.ext.beans.OverloadedMethods@11d0265, java.lang.Object@3e55b2={public boolean java.util.HashMap.isEmpty()=[Ljava.lang.Class;@c5aa3a, public int java.util.AbstractMap.hashCode()=[Ljava.lang.Class;@74a947, public java.lang.Object java.util.HashMap.put(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@1615a91, public boolean java.util.AbstractMap.equals(java.lang.Object)=[Ljava.lang.Class;@a46ab2, public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object)=[Ljava.lang.Class;@1c389e6, public java.lang.String java.util.AbstractMap.toString()=[Ljava.lang.Class;@a23548, public boolean java.util.HashMap.containsKey(java.lang.Object)=[Ljava.lang.Class;@1be4a9f, public java.util.Set java.util.LinkedHashMap.keySet()=[Ljava.lang.Class;@44c60, public java.lang.Object java.util.HashMap.computeIfAbsent(java.lang.Object,java.util.function.Function)=[Ljava.lang.Class;@10f7dff, public java.lang.Object java.util.HashMap.clone()=[Ljava.lang.Class;@d214e3, public java.lang.Object java.util.LinkedHashMap.getOrDefault(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@1a74254, public java.util.Set java.util.LinkedHashMap.entrySet()=[Ljava.lang.Class;@1c4740c, public void java.util.LinkedHashMap.forEach(java.util.function.BiConsumer)=[Ljava.lang.Class;@1fe0c8e, public java.lang.Object java.util.HashMap.putIfAbsent(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@16f73de, public java.util.Collection java.util.LinkedHashMap.values()=[Ljava.lang.Class;@b3e45, public void java.util.LinkedHashMap.clear()=[Ljava.lang.Class;@a34e5c, public java.lang.Object java.util.HashMap.computeIfPresent(java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1fcb13a, public java.lang.Object java.util.HashMap.compute(java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1a7c258, public final native java.lang.Class java.lang.Object.getClass()=[Ljava.lang.Class;@7397f, public void java.util.HashMap.putAll(java.util.Map)=[Ljava.lang.Class;@59cd, public void java.util.LinkedHashMap.replaceAll(java.util.function.BiFunction)=[Ljava.lang.Class;@994816, public java.lang.Object java.util.HashMap.merge(java.lang.Object,java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1b1e75f, public int java.util.HashMap.size()=[Ljava.lang.Class;@bee157, public boolean java.util.LinkedHashMap.containsValue(java.lang.Object)=[Ljava.lang.Class;@5e0d7c}, replaceAll=public void java.util.LinkedHashMap.replaceAll(java.util.function.BiFunction), remove=freemarker.ext.beans.OverloadedMethods@8d3a99, containsValue=public boolean java.util.LinkedHashMap.containsValue(java.lang.Object), put=public java.lang.Object java.util.HashMap.put(java.lang.Object,java.lang.Object), empty=java.beans.PropertyDescriptor[name=empty; propertyType=boolean; readMethod=public boolean java.util.HashMap.isEmpty()], compute=public java.lang.Object java.util.HashMap.compute(java.lang.Object,java.util.function.BiFunction), hashCode=public int java.util.AbstractMap.hashCode(), putAll=public void java.util.HashMap.putAll(java.util.Map), get=public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object), merge=public java.lang.Object java.util.HashMap.merge(java.lang.Object,java.lang.Object,java.util.function.BiFunction), class=java.beans.PropertyDescriptor[name=class; propertyType=class java.lang.Class; readMethod=public final native java.lang.Class java.lang.Object.getClass()], keySet=public java.util.Set java.util.LinkedHashMap.keySet(), java.lang.Object@1c0f21d=freemarker.ext.beans.OverloadedMethods@d4b988, entrySet=public java.util.Set java.util.LinkedHashMap.entrySet(), java.lang.Object@15be27d=public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object), forEach=public void java.util.LinkedHashMap.forEach(java.util.function.BiConsumer), containsKey=public boolean java.util.HashMap.containsKey(java.lang.Object), isEmpty=public boolean java.util.HashMap.isEmpty(), clear=public void java.util.LinkedHashMap.clear(), computeIfPresent=public java.lang.Object java.util.HashMap.computeIfPresent(java.lang.Object,java.util.function.BiFunction), size=public int java.util.HashMap.size(), equals=public boolean java.util.AbstractMap.equals(java.lang.Object), clone=public java.lang.Object java.util.HashMap.clone(), toString=public java.lang.String java.util.AbstractMap.toString(), putIfAbsent=public java.lang.Object java.util.HashMap.putIfAbsent(java.lang.Object,java.lang.Object)}
[DEBUG] 2017-05-24: 21:05:32 freemarker.log._Log4jLoggerFactory$Log4jLogger.debug(_Log4jLoggerFactory.java:45) :  Key "onsubmit" was not found on instance of java.util.LinkedHashMap. Introspection information for the class is: {getClass=public final native java.lang.Class java.lang.Object.getClass(), getOrDefault=public java.lang.Object java.util.LinkedHashMap.getOrDefault(java.lang.Object,java.lang.Object), computeIfAbsent=public java.lang.Object java.util.HashMap.computeIfAbsent(java.lang.Object,java.util.function.Function), values=public java.util.Collection java.util.LinkedHashMap.values(), replace=freemarker.ext.beans.OverloadedMethods@11d0265, java.lang.Object@3e55b2={public boolean java.util.HashMap.isEmpty()=[Ljava.lang.Class;@c5aa3a, public int java.util.AbstractMap.hashCode()=[Ljava.lang.Class;@74a947, public java.lang.Object java.util.HashMap.put(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@1615a91, public boolean java.util.AbstractMap.equals(java.lang.Object)=[Ljava.lang.Class;@a46ab2, public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object)=[Ljava.lang.Class;@1c389e6, public java.lang.String java.util.AbstractMap.toString()=[Ljava.lang.Class;@a23548, public boolean java.util.HashMap.containsKey(java.lang.Object)=[Ljava.lang.Class;@1be4a9f, public java.util.Set java.util.LinkedHashMap.keySet()=[Ljava.lang.Class;@44c60, public java.lang.Object java.util.HashMap.computeIfAbsent(java.lang.Object,java.util.function.Function)=[Ljava.lang.Class;@10f7dff, public java.lang.Object java.util.HashMap.clone()=[Ljava.lang.Class;@d214e3, public java.lang.Object java.util.LinkedHashMap.getOrDefault(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@1a74254, public java.util.Set java.util.LinkedHashMap.entrySet()=[Ljava.lang.Class;@1c4740c, public void java.util.LinkedHashMap.forEach(java.util.function.BiConsumer)=[Ljava.lang.Class;@1fe0c8e, public java.lang.Object java.util.HashMap.putIfAbsent(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@16f73de, public java.util.Collection java.util.LinkedHashMap.values()=[Ljava.lang.Class;@b3e45, public void java.util.LinkedHashMap.clear()=[Ljava.lang.Class;@a34e5c, public java.lang.Object java.util.HashMap.computeIfPresent(java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1fcb13a, public java.lang.Object java.util.HashMap.compute(java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1a7c258, public final native java.lang.Class java.lang.Object.getClass()=[Ljava.lang.Class;@7397f, public void java.util.HashMap.putAll(java.util.Map)=[Ljava.lang.Class;@59cd, public void java.util.LinkedHashMap.replaceAll(java.util.function.BiFunction)=[Ljava.lang.Class;@994816, public java.lang.Object java.util.HashMap.merge(java.lang.Object,java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1b1e75f, public int java.util.HashMap.size()=[Ljava.lang.Class;@bee157, public boolean java.util.LinkedHashMap.containsValue(java.lang.Object)=[Ljava.lang.Class;@5e0d7c}, replaceAll=public void java.util.LinkedHashMap.replaceAll(java.util.function.BiFunction), remove=freemarker.ext.beans.OverloadedMethods@8d3a99, containsValue=public boolean java.util.LinkedHashMap.containsValue(java.lang.Object), put=public java.lang.Object java.util.HashMap.put(java.lang.Object,java.lang.Object), empty=java.beans.PropertyDescriptor[name=empty; propertyType=boolean; readMethod=public boolean java.util.HashMap.isEmpty()], compute=public java.lang.Object java.util.HashMap.compute(java.lang.Object,java.util.function.BiFunction), hashCode=public int java.util.AbstractMap.hashCode(), putAll=public void java.util.HashMap.putAll(java.util.Map), get=public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object), merge=public java.lang.Object java.util.HashMap.merge(java.lang.Object,java.lang.Object,java.util.function.BiFunction), class=java.beans.PropertyDescriptor[name=class; propertyType=class java.lang.Class; readMethod=public final native java.lang.Class java.lang.Object.getClass()], keySet=public java.util.Set java.util.LinkedHashMap.keySet(), java.lang.Object@1c0f21d=freemarker.ext.beans.OverloadedMethods@d4b988, entrySet=public java.util.Set java.util.LinkedHashMap.entrySet(), java.lang.Object@15be27d=public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object), forEach=public void java.util.LinkedHashMap.forEach(java.util.function.BiConsumer), containsKey=public boolean java.util.HashMap.containsKey(java.lang.Object), isEmpty=public boolean java.util.HashMap.isEmpty(), clear=public void java.util.LinkedHashMap.clear(), computeIfPresent=public java.lang.Object java.util.HashMap.computeIfPresent(java.lang.Object,java.util.function.BiFunction), size=public int java.util.HashMap.size(), equals=public boolean java.util.AbstractMap.equals(java.lang.Object), clone=public java.lang.Object java.util.HashMap.clone(), toString=public java.lang.String java.util.AbstractMap.toString(), putIfAbsent=public java.lang.Object java.util.HashMap.putIfAbsent(java.lang.Object,java.lang.Object)}
[DEBUG] 2017-05-24: 21:05:32 freemarker.log._Log4jLoggerFactory$Log4jLogger.debug(_Log4jLoggerFactory.java:45) :  Key "onreset" was not found on instance of java.util.LinkedHashMap. Introspection information for the class is: {getClass=public final native java.lang.Class java.lang.Object.getClass(), getOrDefault=public java.lang.Object java.util.LinkedHashMap.getOrDefault(java.lang.Object,java.lang.Object), computeIfAbsent=public java.lang.Object java.util.HashMap.computeIfAbsent(java.lang.Object,java.util.function.Function), values=public java.util.Collection java.util.LinkedHashMap.values(), replace=freemarker.ext.beans.OverloadedMethods@11d0265, java.lang.Object@3e55b2={public boolean java.util.HashMap.isEmpty()=[Ljava.lang.Class;@c5aa3a, public int java.util.AbstractMap.hashCode()=[Ljava.lang.Class;@74a947, public java.lang.Object java.util.HashMap.put(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@1615a91, public boolean java.util.AbstractMap.equals(java.lang.Object)=[Ljava.lang.Class;@a46ab2, public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object)=[Ljava.lang.Class;@1c389e6, public java.lang.String java.util.AbstractMap.toString()=[Ljava.lang.Class;@a23548, public boolean java.util.HashMap.containsKey(java.lang.Object)=[Ljava.lang.Class;@1be4a9f, public java.util.Set java.util.LinkedHashMap.keySet()=[Ljava.lang.Class;@44c60, public java.lang.Object java.util.HashMap.computeIfAbsent(java.lang.Object,java.util.function.Function)=[Ljava.lang.Class;@10f7dff, public java.lang.Object java.util.HashMap.clone()=[Ljava.lang.Class;@d214e3, public java.lang.Object java.util.LinkedHashMap.getOrDefault(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@1a74254, public java.util.Set java.util.LinkedHashMap.entrySet()=[Ljava.lang.Class;@1c4740c, public void java.util.LinkedHashMap.forEach(java.util.function.BiConsumer)=[Ljava.lang.Class;@1fe0c8e, public java.lang.Object java.util.HashMap.putIfAbsent(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@16f73de, public java.util.Collection java.util.LinkedHashMap.values()=[Ljava.lang.Class;@b3e45, public void java.util.LinkedHashMap.clear()=[Ljava.lang.Class;@a34e5c, public java.lang.Object java.util.HashMap.computeIfPresent(java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1fcb13a, public java.lang.Object java.util.HashMap.compute(java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1a7c258, public final native java.lang.Class java.lang.Object.getClass()=[Ljava.lang.Class;@7397f, public void java.util.HashMap.putAll(java.util.Map)=[Ljava.lang.Class;@59cd, public void java.util.LinkedHashMap.replaceAll(java.util.function.BiFunction)=[Ljava.lang.Class;@994816, public java.lang.Object java.util.HashMap.merge(java.lang.Object,java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1b1e75f, public int java.util.HashMap.size()=[Ljava.lang.Class;@bee157, public boolean java.util.LinkedHashMap.containsValue(java.lang.Object)=[Ljava.lang.Class;@5e0d7c}, replaceAll=public void java.util.LinkedHashMap.replaceAll(java.util.function.BiFunction), remove=freemarker.ext.beans.OverloadedMethods@8d3a99, containsValue=public boolean java.util.LinkedHashMap.containsValue(java.lang.Object), put=public java.lang.Object java.util.HashMap.put(java.lang.Object,java.lang.Object), empty=java.beans.PropertyDescriptor[name=empty; propertyType=boolean; readMethod=public boolean java.util.HashMap.isEmpty()], compute=public java.lang.Object java.util.HashMap.compute(java.lang.Object,java.util.function.BiFunction), hashCode=public int java.util.AbstractMap.hashCode(), putAll=public void java.util.HashMap.putAll(java.util.Map), get=public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object), merge=public java.lang.Object java.util.HashMap.merge(java.lang.Object,java.lang.Object,java.util.function.BiFunction), class=java.beans.PropertyDescriptor[name=class; propertyType=class java.lang.Class; readMethod=public final native java.lang.Class java.lang.Object.getClass()], keySet=public java.util.Set java.util.LinkedHashMap.keySet(), java.lang.Object@1c0f21d=freemarker.ext.beans.OverloadedMethods@d4b988, entrySet=public java.util.Set java.util.LinkedHashMap.entrySet(), java.lang.Object@15be27d=public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object), forEach=public void java.util.LinkedHashMap.forEach(java.util.function.BiConsumer), containsKey=public boolean java.util.HashMap.containsKey(java.lang.Object), isEmpty=public boolean java.util.HashMap.isEmpty(), clear=public void java.util.LinkedHashMap.clear(), computeIfPresent=public java.lang.Object java.util.HashMap.computeIfPresent(java.lang.Object,java.util.function.BiFunction), size=public int java.util.HashMap.size(), equals=public boolean java.util.AbstractMap.equals(java.lang.Object), clone=public java.lang.Object java.util.HashMap.clone(), toString=public java.lang.String java.util.AbstractMap.toString(), putIfAbsent=public java.lang.Object java.util.HashMap.putIfAbsent(java.lang.Object,java.lang.Object)}
[DEBUG] 2017-05-24: 21:05:32 freemarker.log._Log4jLoggerFactory$Log4jLogger.debug(_Log4jLoggerFactory.java:45) :  Key "target" was not found on instance of java.util.LinkedHashMap. Introspection information for the class is: {getClass=public final native java.lang.Class java.lang.Object.getClass(), getOrDefault=public java.lang.Object java.util.LinkedHashMap.getOrDefault(java.lang.Object,java.lang.Object), computeIfAbsent=public java.lang.Object java.util.HashMap.computeIfAbsent(java.lang.Object,java.util.function.Function), values=public java.util.Collection java.util.LinkedHashMap.values(), replace=freemarker.ext.beans.OverloadedMethods@11d0265, java.lang.Object@3e55b2={public boolean java.util.HashMap.isEmpty()=[Ljava.lang.Class;@c5aa3a, public int java.util.AbstractMap.hashCode()=[Ljava.lang.Class;@74a947, public java.lang.Object java.util.HashMap.put(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@1615a91, public boolean java.util.AbstractMap.equals(java.lang.Object)=[Ljava.lang.Class;@a46ab2, public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object)=[Ljava.lang.Class;@1c389e6, public java.lang.String java.util.AbstractMap.toString()=[Ljava.lang.Class;@a23548, public boolean java.util.HashMap.containsKey(java.lang.Object)=[Ljava.lang.Class;@1be4a9f, public java.util.Set java.util.LinkedHashMap.keySet()=[Ljava.lang.Class;@44c60, public java.lang.Object java.util.HashMap.computeIfAbsent(java.lang.Object,java.util.function.Function)=[Ljava.lang.Class;@10f7dff, public java.lang.Object java.util.HashMap.clone()=[Ljava.lang.Class;@d214e3, public java.lang.Object java.util.LinkedHashMap.getOrDefault(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@1a74254, public java.util.Set java.util.LinkedHashMap.entrySet()=[Ljava.lang.Class;@1c4740c, public void java.util.LinkedHashMap.forEach(java.util.function.BiConsumer)=[Ljava.lang.Class;@1fe0c8e, public java.lang.Object java.util.HashMap.putIfAbsent(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@16f73de, public java.util.Collection java.util.LinkedHashMap.values()=[Ljava.lang.Class;@b3e45, public void java.util.LinkedHashMap.clear()=[Ljava.lang.Class;@a34e5c, public java.lang.Object java.util.HashMap.computeIfPresent(java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1fcb13a, public java.lang.Object java.util.HashMap.compute(java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1a7c258, public final native java.lang.Class java.lang.Object.getClass()=[Ljava.lang.Class;@7397f, public void java.util.HashMap.putAll(java.util.Map)=[Ljava.lang.Class;@59cd, public void java.util.LinkedHashMap.replaceAll(java.util.function.BiFunction)=[Ljava.lang.Class;@994816, public java.lang.Object java.util.HashMap.merge(java.lang.Object,java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1b1e75f, public int java.util.HashMap.size()=[Ljava.lang.Class;@bee157, public boolean java.util.LinkedHashMap.containsValue(java.lang.Object)=[Ljava.lang.Class;@5e0d7c}, replaceAll=public void java.util.LinkedHashMap.replaceAll(java.util.function.BiFunction), remove=freemarker.ext.beans.OverloadedMethods@8d3a99, containsValue=public boolean java.util.LinkedHashMap.containsValue(java.lang.Object), put=public java.lang.Object java.util.HashMap.put(java.lang.Object,java.lang.Object), empty=java.beans.PropertyDescriptor[name=empty; propertyType=boolean; readMethod=public boolean java.util.HashMap.isEmpty()], compute=public java.lang.Object java.util.HashMap.compute(java.lang.Object,java.util.function.BiFunction), hashCode=public int java.util.AbstractMap.hashCode(), putAll=public void java.util.HashMap.putAll(java.util.Map), get=public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object), merge=public java.lang.Object java.util.HashMap.merge(java.lang.Object,java.lang.Object,java.util.function.BiFunction), class=java.beans.PropertyDescriptor[name=class; propertyType=class java.lang.Class; readMethod=public final native java.lang.Class java.lang.Object.getClass()], keySet=public java.util.Set java.util.LinkedHashMap.keySet(), java.lang.Object@1c0f21d=freemarker.ext.beans.OverloadedMethods@d4b988, entrySet=public java.util.Set java.util.LinkedHashMap.entrySet(), java.lang.Object@15be27d=public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object), forEach=public void java.util.LinkedHashMap.forEach(java.util.function.BiConsumer), containsKey=public boolean java.util.HashMap.containsKey(java.lang.Object), isEmpty=public boolean java.util.HashMap.isEmpty(), clear=public void java.util.LinkedHashMap.clear(), computeIfPresent=public java.lang.Object java.util.HashMap.computeIfPresent(java.lang.Object,java.util.function.BiFunction), size=public int java.util.HashMap.size(), equals=public boolean java.util.AbstractMap.equals(java.lang.Object), clone=public java.lang.Object java.util.HashMap.clone(), toString=public java.lang.String java.util.AbstractMap.toString(), putIfAbsent=public java.lang.Object java.util.HashMap.putIfAbsent(java.lang.Object,java.lang.Object)}
[DEBUG] 2017-05-24: 21:05:32 freemarker.log._Log4jLoggerFactory$Log4jLogger.debug(_Log4jLoggerFactory.java:45) :  Key "enctype" was not found on instance of java.util.LinkedHashMap. Introspection information for the class is: {getClass=public final native java.lang.Class java.lang.Object.getClass(), getOrDefault=public java.lang.Object java.util.LinkedHashMap.getOrDefault(java.lang.Object,java.lang.Object), computeIfAbsent=public java.lang.Object java.util.HashMap.computeIfAbsent(java.lang.Object,java.util.function.Function), values=public java.util.Collection java.util.LinkedHashMap.values(), replace=freemarker.ext.beans.OverloadedMethods@11d0265, java.lang.Object@3e55b2={public boolean java.util.HashMap.isEmpty()=[Ljava.lang.Class;@c5aa3a, public int java.util.AbstractMap.hashCode()=[Ljava.lang.Class;@74a947, public java.lang.Object java.util.HashMap.put(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@1615a91, public boolean java.util.AbstractMap.equals(java.lang.Object)=[Ljava.lang.Class;@a46ab2, public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object)=[Ljava.lang.Class;@1c389e6, public java.lang.String java.util.AbstractMap.toString()=[Ljava.lang.Class;@a23548, public boolean java.util.HashMap.containsKey(java.lang.Object)=[Ljava.lang.Class;@1be4a9f, public java.util.Set java.util.LinkedHashMap.keySet()=[Ljava.lang.Class;@44c60, public java.lang.Object java.util.HashMap.computeIfAbsent(java.lang.Object,java.util.function.Function)=[Ljava.lang.Class;@10f7dff, public java.lang.Object java.util.HashMap.clone()=[Ljava.lang.Class;@d214e3, public java.lang.Object java.util.LinkedHashMap.getOrDefault(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@1a74254, public java.util.Set java.util.LinkedHashMap.entrySet()=[Ljava.lang.Class;@1c4740c, public void java.util.LinkedHashMap.forEach(java.util.function.BiConsumer)=[Ljava.lang.Class;@1fe0c8e, public java.lang.Object java.util.HashMap.putIfAbsent(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@16f73de, public java.util.Collection java.util.LinkedHashMap.values()=[Ljava.lang.Class;@b3e45, public void java.util.LinkedHashMap.clear()=[Ljava.lang.Class;@a34e5c, public java.lang.Object java.util.HashMap.computeIfPresent(java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1fcb13a, public java.lang.Object java.util.HashMap.compute(java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1a7c258, public final native java.lang.Class java.lang.Object.getClass()=[Ljava.lang.Class;@7397f, public void java.util.HashMap.putAll(java.util.Map)=[Ljava.lang.Class;@59cd, public void java.util.LinkedHashMap.replaceAll(java.util.function.BiFunction)=[Ljava.lang.Class;@994816, public java.lang.Object java.util.HashMap.merge(java.lang.Object,java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1b1e75f, public int java.util.HashMap.size()=[Ljava.lang.Class;@bee157, public boolean java.util.LinkedHashMap.containsValue(java.lang.Object)=[Ljava.lang.Class;@5e0d7c}, replaceAll=public void java.util.LinkedHashMap.replaceAll(java.util.function.BiFunction), remove=freemarker.ext.beans.OverloadedMethods@8d3a99, containsValue=public boolean java.util.LinkedHashMap.containsValue(java.lang.Object), put=public java.lang.Object java.util.HashMap.put(java.lang.Object,java.lang.Object), empty=java.beans.PropertyDescriptor[name=empty; propertyType=boolean; readMethod=public boolean java.util.HashMap.isEmpty()], compute=public java.lang.Object java.util.HashMap.compute(java.lang.Object,java.util.function.BiFunction), hashCode=public int java.util.AbstractMap.hashCode(), putAll=public void java.util.HashMap.putAll(java.util.Map), get=public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object), merge=public java.lang.Object java.util.HashMap.merge(java.lang.Object,java.lang.Object,java.util.function.BiFunction), class=java.beans.PropertyDescriptor[name=class; propertyType=class java.lang.Class; readMethod=public final native java.lang.Class java.lang.Object.getClass()], keySet=public java.util.Set java.util.LinkedHashMap.keySet(), java.lang.Object@1c0f21d=freemarker.ext.beans.OverloadedMethods@d4b988, entrySet=public java.util.Set java.util.LinkedHashMap.entrySet(), java.lang.Object@15be27d=public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object), forEach=public void java.util.LinkedHashMap.forEach(java.util.function.BiConsumer), containsKey=public boolean java.util.HashMap.containsKey(java.lang.Object), isEmpty=public boolean java.util.HashMap.isEmpty(), clear=public void java.util.LinkedHashMap.clear(), computeIfPresent=public java.lang.Object java.util.HashMap.computeIfPresent(java.lang.Object,java.util.function.BiFunction), size=public int java.util.HashMap.size(), equals=public boolean java.util.AbstractMap.equals(java.lang.Object), clone=public java.lang.Object java.util.HashMap.clone(), toString=public java.lang.String java.util.AbstractMap.toString(), putIfAbsent=public java.lang.Object java.util.HashMap.putIfAbsent(java.lang.Object,java.lang.Object)}
[DEBUG] 2017-05-24: 21:05:32 freemarker.log._Log4jLoggerFactory$Log4jLogger.debug(_Log4jLoggerFactory.java:45) :  Key "cssClass" was not found on instance of java.util.LinkedHashMap. Introspection information for the class is: {getClass=public final native java.lang.Class java.lang.Object.getClass(), getOrDefault=public java.lang.Object java.util.LinkedHashMap.getOrDefault(java.lang.Object,java.lang.Object), computeIfAbsent=public java.lang.Object java.util.HashMap.computeIfAbsent(java.lang.Object,java.util.function.Function), values=public java.util.Collection java.util.LinkedHashMap.values(), replace=freemarker.ext.beans.OverloadedMethods@11d0265, java.lang.Object@3e55b2={public boolean java.util.HashMap.isEmpty()=[Ljava.lang.Class;@c5aa3a, public int java.util.AbstractMap.hashCode()=[Ljava.lang.Class;@74a947, public java.lang.Object java.util.HashMap.put(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@1615a91, public boolean java.util.AbstractMap.equals(java.lang.Object)=[Ljava.lang.Class;@a46ab2, public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object)=[Ljava.lang.Class;@1c389e6, public java.lang.String java.util.AbstractMap.toString()=[Ljava.lang.Class;@a23548, public boolean java.util.HashMap.containsKey(java.lang.Object)=[Ljava.lang.Class;@1be4a9f, public java.util.Set java.util.LinkedHashMap.keySet()=[Ljava.lang.Class;@44c60, public java.lang.Object java.util.HashMap.computeIfAbsent(java.lang.Object,java.util.function.Function)=[Ljava.lang.Class;@10f7dff, public java.lang.Object java.util.HashMap.clone()=[Ljava.lang.Class;@d214e3, public java.lang.Object java.util.LinkedHashMap.getOrDefault(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@1a74254, public java.util.Set java.util.LinkedHashMap.entrySet()=[Ljava.lang.Class;@1c4740c, public void java.util.LinkedHashMap.forEach(java.util.function.BiConsumer)=[Ljava.lang.Class;@1fe0c8e, public java.lang.Object java.util.HashMap.putIfAbsent(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@16f73de, public java.util.Collection java.util.LinkedHashMap.values()=[Ljava.lang.Class;@b3e45, public void java.util.LinkedHashMap.clear()=[Ljava.lang.Class;@a34e5c, public java.lang.Object java.util.HashMap.computeIfPresent(java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1fcb13a, public java.lang.Object java.util.HashMap.compute(java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1a7c258, public final native java.lang.Class java.lang.Object.getClass()=[Ljava.lang.Class;@7397f, public void java.util.HashMap.putAll(java.util.Map)=[Ljava.lang.Class;@59cd, public void java.util.LinkedHashMap.replaceAll(java.util.function.BiFunction)=[Ljava.lang.Class;@994816, public java.lang.Object java.util.HashMap.merge(java.lang.Object,java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1b1e75f, public int java.util.HashMap.size()=[Ljava.lang.Class;@bee157, public boolean java.util.LinkedHashMap.containsValue(java.lang.Object)=[Ljava.lang.Class;@5e0d7c}, replaceAll=public void java.util.LinkedHashMap.replaceAll(java.util.function.BiFunction), remove=freemarker.ext.beans.OverloadedMethods@8d3a99, containsValue=public boolean java.util.LinkedHashMap.containsValue(java.lang.Object), put=public java.lang.Object java.util.HashMap.put(java.lang.Object,java.lang.Object), empty=java.beans.PropertyDescriptor[name=empty; propertyType=boolean; readMethod=public boolean java.util.HashMap.isEmpty()], compute=public java.lang.Object java.util.HashMap.compute(java.lang.Object,java.util.function.BiFunction), hashCode=public int java.util.AbstractMap.hashCode(), putAll=public void java.util.HashMap.putAll(java.util.Map), get=public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object), merge=public java.lang.Object java.util.HashMap.merge(java.lang.Object,java.lang.Object,java.util.function.BiFunction), class=java.beans.PropertyDescriptor[name=class; propertyType=class java.lang.Class; readMethod=public final native java.lang.Class java.lang.Object.getClass()], keySet=public java.util.Set java.util.LinkedHashMap.keySet(), java.lang.Object@1c0f21d=freemarker.ext.beans.OverloadedMethods@d4b988, entrySet=public java.util.Set java.util.LinkedHashMap.entrySet(), java.lang.Object@15be27d=public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object), forEach=public void java.util.LinkedHashMap.forEach(java.util.function.BiConsumer), containsKey=public boolean java.util.HashMap.containsKey(java.lang.Object), isEmpty=public boolean java.util.HashMap.isEmpty(), clear=public void java.util.LinkedHashMap.clear(), computeIfPresent=public java.lang.Object java.util.HashMap.computeIfPresent(java.lang.Object,java.util.function.BiFunction), size=public int java.util.HashMap.size(), equals=public boolean java.util.AbstractMap.equals(java.lang.Object), clone=public java.lang.Object java.util.HashMap.clone(), toString=public java.lang.String java.util.AbstractMap.toString(), putIfAbsent=public java.lang.Object java.util.HashMap.putIfAbsent(java.lang.Object,java.lang.Object)}
[DEBUG] 2017-05-24: 21:05:32 freemarker.log._Log4jLoggerFactory$Log4jLogger.debug(_Log4jLoggerFactory.java:45) :  Key "cssStyle" was not found on instance of java.util.LinkedHashMap. Introspection information for the class is: {getClass=public final native java.lang.Class java.lang.Object.getClass(), getOrDefault=public java.lang.Object java.util.LinkedHashMap.getOrDefault(java.lang.Object,java.lang.Object), computeIfAbsent=public java.lang.Object java.util.HashMap.computeIfAbsent(java.lang.Object,java.util.function.Function), values=public java.util.Collection java.util.LinkedHashMap.values(), replace=freemarker.ext.beans.OverloadedMethods@11d0265, java.lang.Object@3e55b2={public boolean java.util.HashMap.isEmpty()=[Ljava.lang.Class;@c5aa3a, public int java.util.AbstractMap.hashCode()=[Ljava.lang.Class;@74a947, public java.lang.Object java.util.HashMap.put(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@1615a91, public boolean java.util.AbstractMap.equals(java.lang.Object)=[Ljava.lang.Class;@a46ab2, public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object)=[Ljava.lang.Class;@1c389e6, public java.lang.String java.util.AbstractMap.toString()=[Ljava.lang.Class;@a23548, public boolean java.util.HashMap.containsKey(java.lang.Object)=[Ljava.lang.Class;@1be4a9f, public java.util.Set java.util.LinkedHashMap.keySet()=[Ljava.lang.Class;@44c60, public java.lang.Object java.util.HashMap.computeIfAbsent(java.lang.Object,java.util.function.Function)=[Ljava.lang.Class;@10f7dff, public java.lang.Object java.util.HashMap.clone()=[Ljava.lang.Class;@d214e3, public java.lang.Object java.util.LinkedHashMap.getOrDefault(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@1a74254, public java.util.Set java.util.LinkedHashMap.entrySet()=[Ljava.lang.Class;@1c4740c, public void java.util.LinkedHashMap.forEach(java.util.function.BiConsumer)=[Ljava.lang.Class;@1fe0c8e, public java.lang.Object java.util.HashMap.putIfAbsent(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@16f73de, public java.util.Collection java.util.LinkedHashMap.values()=[Ljava.lang.Class;@b3e45, public void java.util.LinkedHashMap.clear()=[Ljava.lang.Class;@a34e5c, public java.lang.Object java.util.HashMap.computeIfPresent(java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1fcb13a, public java.lang.Object java.util.HashMap.compute(java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1a7c258, public final native java.lang.Class java.lang.Object.getClass()=[Ljava.lang.Class;@7397f, public void java.util.HashMap.putAll(java.util.Map)=[Ljava.lang.Class;@59cd, public void java.util.LinkedHashMap.replaceAll(java.util.function.BiFunction)=[Ljava.lang.Class;@994816, public java.lang.Object java.util.HashMap.merge(java.lang.Object,java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1b1e75f, public int java.util.HashMap.size()=[Ljava.lang.Class;@bee157, public boolean java.util.LinkedHashMap.containsValue(java.lang.Object)=[Ljava.lang.Class;@5e0d7c}, replaceAll=public void java.util.LinkedHashMap.replaceAll(java.util.function.BiFunction), remove=freemarker.ext.beans.OverloadedMethods@8d3a99, containsValue=public boolean java.util.LinkedHashMap.containsValue(java.lang.Object), put=public java.lang.Object java.util.HashMap.put(java.lang.Object,java.lang.Object), empty=java.beans.PropertyDescriptor[name=empty; propertyType=boolean; readMethod=public boolean java.util.HashMap.isEmpty()], compute=public java.lang.Object java.util.HashMap.compute(java.lang.Object,java.util.function.BiFunction), hashCode=public int java.util.AbstractMap.hashCode(), putAll=public void java.util.HashMap.putAll(java.util.Map), get=public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object), merge=public java.lang.Object java.util.HashMap.merge(java.lang.Object,java.lang.Object,java.util.function.BiFunction), class=java.beans.PropertyDescriptor[name=class; propertyType=class java.lang.Class; readMethod=public final native java.lang.Class java.lang.Object.getClass()], keySet=public java.util.Set java.util.LinkedHashMap.keySet(), java.lang.Object@1c0f21d=freemarker.ext.beans.OverloadedMethods@d4b988, entrySet=public java.util.Set java.util.LinkedHashMap.entrySet(), java.lang.Object@15be27d=public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object), forEach=public void java.util.LinkedHashMap.forEach(java.util.function.BiConsumer), containsKey=public boolean java.util.HashMap.containsKey(java.lang.Object), isEmpty=public boolean java.util.HashMap.isEmpty(), clear=public void java.util.LinkedHashMap.clear(), computeIfPresent=public java.lang.Object java.util.HashMap.computeIfPresent(java.lang.Object,java.util.function.BiFunction), size=public int java.util.HashMap.size(), equals=public boolean java.util.AbstractMap.equals(java.lang.Object), clone=public java.lang.Object java.util.HashMap.clone(), toString=public java.lang.String java.util.AbstractMap.toString(), putIfAbsent=public java.lang.Object java.util.HashMap.putIfAbsent(java.lang.Object,java.lang.Object)}
[DEBUG] 2017-05-24: 21:05:32 freemarker.log._Log4jLoggerFactory$Log4jLogger.debug(_Log4jLoggerFactory.java:45) :  Key "title" was not found on instance of java.util.LinkedHashMap. Introspection information for the class is: {getClass=public final native java.lang.Class java.lang.Object.getClass(), getOrDefault=public java.lang.Object java.util.LinkedHashMap.getOrDefault(java.lang.Object,java.lang.Object), computeIfAbsent=public java.lang.Object java.util.HashMap.computeIfAbsent(java.lang.Object,java.util.function.Function), values=public java.util.Collection java.util.LinkedHashMap.values(), replace=freemarker.ext.beans.OverloadedMethods@11d0265, java.lang.Object@3e55b2={public boolean java.util.HashMap.isEmpty()=[Ljava.lang.Class;@c5aa3a, public int java.util.AbstractMap.hashCode()=[Ljava.lang.Class;@74a947, public java.lang.Object java.util.HashMap.put(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@1615a91, public boolean java.util.AbstractMap.equals(java.lang.Object)=[Ljava.lang.Class;@a46ab2, public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object)=[Ljava.lang.Class;@1c389e6, public java.lang.String java.util.AbstractMap.toString()=[Ljava.lang.Class;@a23548, public boolean java.util.HashMap.containsKey(java.lang.Object)=[Ljava.lang.Class;@1be4a9f, public java.util.Set java.util.LinkedHashMap.keySet()=[Ljava.lang.Class;@44c60, public java.lang.Object java.util.HashMap.computeIfAbsent(java.lang.Object,java.util.function.Function)=[Ljava.lang.Class;@10f7dff, public java.lang.Object java.util.HashMap.clone()=[Ljava.lang.Class;@d214e3, public java.lang.Object java.util.LinkedHashMap.getOrDefault(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@1a74254, public java.util.Set java.util.LinkedHashMap.entrySet()=[Ljava.lang.Class;@1c4740c, public void java.util.LinkedHashMap.forEach(java.util.function.BiConsumer)=[Ljava.lang.Class;@1fe0c8e, public java.lang.Object java.util.HashMap.putIfAbsent(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@16f73de, public java.util.Collection java.util.LinkedHashMap.values()=[Ljava.lang.Class;@b3e45, public void java.util.LinkedHashMap.clear()=[Ljava.lang.Class;@a34e5c, public java.lang.Object java.util.HashMap.computeIfPresent(java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1fcb13a, public java.lang.Object java.util.HashMap.compute(java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1a7c258, public final native java.lang.Class java.lang.Object.getClass()=[Ljava.lang.Class;@7397f, public void java.util.HashMap.putAll(java.util.Map)=[Ljava.lang.Class;@59cd, public void java.util.LinkedHashMap.replaceAll(java.util.function.BiFunction)=[Ljava.lang.Class;@994816, public java.lang.Object java.util.HashMap.merge(java.lang.Object,java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1b1e75f, public int java.util.HashMap.size()=[Ljava.lang.Class;@bee157, public boolean java.util.LinkedHashMap.containsValue(java.lang.Object)=[Ljava.lang.Class;@5e0d7c}, replaceAll=public void java.util.LinkedHashMap.replaceAll(java.util.function.BiFunction), remove=freemarker.ext.beans.OverloadedMethods@8d3a99, containsValue=public boolean java.util.LinkedHashMap.containsValue(java.lang.Object), put=public java.lang.Object java.util.HashMap.put(java.lang.Object,java.lang.Object), empty=java.beans.PropertyDescriptor[name=empty; propertyType=boolean; readMethod=public boolean java.util.HashMap.isEmpty()], compute=public java.lang.Object java.util.HashMap.compute(java.lang.Object,java.util.function.BiFunction), hashCode=public int java.util.AbstractMap.hashCode(), putAll=public void java.util.HashMap.putAll(java.util.Map), get=public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object), merge=public java.lang.Object java.util.HashMap.merge(java.lang.Object,java.lang.Object,java.util.function.BiFunction), class=java.beans.PropertyDescriptor[name=class; propertyType=class java.lang.Class; readMethod=public final native java.lang.Class java.lang.Object.getClass()], keySet=public java.util.Set java.util.LinkedHashMap.keySet(), java.lang.Object@1c0f21d=freemarker.ext.beans.OverloadedMethods@d4b988, entrySet=public java.util.Set java.util.LinkedHashMap.entrySet(), java.lang.Object@15be27d=public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object), forEach=public void java.util.LinkedHashMap.forEach(java.util.function.BiConsumer), containsKey=public boolean java.util.HashMap.containsKey(java.lang.Object), isEmpty=public boolean java.util.HashMap.isEmpty(), clear=public void java.util.LinkedHashMap.clear(), computeIfPresent=public java.lang.Object java.util.HashMap.computeIfPresent(java.lang.Object,java.util.function.BiFunction), size=public int java.util.HashMap.size(), equals=public boolean java.util.AbstractMap.equals(java.lang.Object), clone=public java.lang.Object java.util.HashMap.clone(), toString=public java.lang.String java.util.AbstractMap.toString(), putIfAbsent=public java.lang.Object java.util.HashMap.putIfAbsent(java.lang.Object,java.lang.Object)}
[DEBUG] 2017-05-24: 21:05:32 freemarker.log._Log4jLoggerFactory$Log4jLogger.debug(_Log4jLoggerFactory.java:45) :  Key "acceptcharset" was not found on instance of java.util.LinkedHashMap. Introspection information for the class is: {getClass=public final native java.lang.Class java.lang.Object.getClass(), getOrDefault=public java.lang.Object java.util.LinkedHashMap.getOrDefault(java.lang.Object,java.lang.Object), computeIfAbsent=public java.lang.Object java.util.HashMap.computeIfAbsent(java.lang.Object,java.util.function.Function), values=public java.util.Collection java.util.LinkedHashMap.values(), replace=freemarker.ext.beans.OverloadedMethods@11d0265, java.lang.Object@3e55b2={public boolean java.util.HashMap.isEmpty()=[Ljava.lang.Class;@c5aa3a, public int java.util.AbstractMap.hashCode()=[Ljava.lang.Class;@74a947, public java.lang.Object java.util.HashMap.put(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@1615a91, public boolean java.util.AbstractMap.equals(java.lang.Object)=[Ljava.lang.Class;@a46ab2, public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object)=[Ljava.lang.Class;@1c389e6, public java.lang.String java.util.AbstractMap.toString()=[Ljava.lang.Class;@a23548, public boolean java.util.HashMap.containsKey(java.lang.Object)=[Ljava.lang.Class;@1be4a9f, public java.util.Set java.util.LinkedHashMap.keySet()=[Ljava.lang.Class;@44c60, public java.lang.Object java.util.HashMap.computeIfAbsent(java.lang.Object,java.util.function.Function)=[Ljava.lang.Class;@10f7dff, public java.lang.Object java.util.HashMap.clone()=[Ljava.lang.Class;@d214e3, public java.lang.Object java.util.LinkedHashMap.getOrDefault(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@1a74254, public java.util.Set java.util.LinkedHashMap.entrySet()=[Ljava.lang.Class;@1c4740c, public void java.util.LinkedHashMap.forEach(java.util.function.BiConsumer)=[Ljava.lang.Class;@1fe0c8e, public java.lang.Object java.util.HashMap.putIfAbsent(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@16f73de, public java.util.Collection java.util.LinkedHashMap.values()=[Ljava.lang.Class;@b3e45, public void java.util.LinkedHashMap.clear()=[Ljava.lang.Class;@a34e5c, public java.lang.Object java.util.HashMap.computeIfPresent(java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1fcb13a, public java.lang.Object java.util.HashMap.compute(java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1a7c258, public final native java.lang.Class java.lang.Object.getClass()=[Ljava.lang.Class;@7397f, public void java.util.HashMap.putAll(java.util.Map)=[Ljava.lang.Class;@59cd, public void java.util.LinkedHashMap.replaceAll(java.util.function.BiFunction)=[Ljava.lang.Class;@994816, public java.lang.Object java.util.HashMap.merge(java.lang.Object,java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1b1e75f, public int java.util.HashMap.size()=[Ljava.lang.Class;@bee157, public boolean java.util.LinkedHashMap.containsValue(java.lang.Object)=[Ljava.lang.Class;@5e0d7c}, replaceAll=public void java.util.LinkedHashMap.replaceAll(java.util.function.BiFunction), remove=freemarker.ext.beans.OverloadedMethods@8d3a99, containsValue=public boolean java.util.LinkedHashMap.containsValue(java.lang.Object), put=public java.lang.Object java.util.HashMap.put(java.lang.Object,java.lang.Object), empty=java.beans.PropertyDescriptor[name=empty; propertyType=boolean; readMethod=public boolean java.util.HashMap.isEmpty()], compute=public java.lang.Object java.util.HashMap.compute(java.lang.Object,java.util.function.BiFunction), hashCode=public int java.util.AbstractMap.hashCode(), putAll=public void java.util.HashMap.putAll(java.util.Map), get=public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object), merge=public java.lang.Object java.util.HashMap.merge(java.lang.Object,java.lang.Object,java.util.function.BiFunction), class=java.beans.PropertyDescriptor[name=class; propertyType=class java.lang.Class; readMethod=public final native java.lang.Class java.lang.Object.getClass()], keySet=public java.util.Set java.util.LinkedHashMap.keySet(), java.lang.Object@1c0f21d=freemarker.ext.beans.OverloadedMethods@d4b988, entrySet=public java.util.Set java.util.LinkedHashMap.entrySet(), java.lang.Object@15be27d=public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object), forEach=public void java.util.LinkedHashMap.forEach(java.util.function.BiConsumer), containsKey=public boolean java.util.HashMap.containsKey(java.lang.Object), isEmpty=public boolean java.util.HashMap.isEmpty(), clear=public void java.util.LinkedHashMap.clear(), computeIfPresent=public java.lang.Object java.util.HashMap.computeIfPresent(java.lang.Object,java.util.function.BiFunction), size=public int java.util.HashMap.size(), equals=public boolean java.util.AbstractMap.equals(java.lang.Object), clone=public java.lang.Object java.util.HashMap.clone(), toString=public java.lang.String java.util.AbstractMap.toString(), putIfAbsent=public java.lang.Object java.util.HashMap.putIfAbsent(java.lang.Object,java.lang.Object)}
[DEBUG] 2017-05-24: 21:05:32 freemarker.log._Log4jLoggerFactory$Log4jLogger.debug(_Log4jLoggerFactory.java:45) :  Couldn't find template in cache for "template/~~~xhtml/dynamic-attributes.ftl"("zh_CN", UTF-8, parsed); will try to load it.
[DEBUG] 2017-05-24: 21:05:32 freemarker.log._Log4jLoggerFactory$Log4jLogger.debug(_Log4jLoggerFactory.java:45) :  TemplateLoader.findTemplateSource("template/~~~xhtml/dynamic-attributes.ftl"): Found
[DEBUG] 2017-05-24: 21:05:32 freemarker.log._Log4jLoggerFactory$Log4jLogger.debug(_Log4jLoggerFactory.java:45) :  Loading template for "template/~~~xhtml/dynamic-attributes.ftl"("zh_CN", UTF-8, parsed) from "jar:file:/D:/maven/repository/org/apache/struts/struts2-core/2.5.10/struts2-core-2.5.10.jar!/template/simple/dynamic-attributes.ftl"
[DEBUG] 2017-05-24: 21:05:32 freemarker.log._Log4jLoggerFactory$Log4jLogger.debug(_Log4jLoggerFactory.java:45) :  Key "validate" was not found on instance of java.util.LinkedHashMap. Introspection information for the class is: {getClass=public final native java.lang.Class java.lang.Object.getClass(), getOrDefault=public java.lang.Object java.util.LinkedHashMap.getOrDefault(java.lang.Object,java.lang.Object), computeIfAbsent=public java.lang.Object java.util.HashMap.computeIfAbsent(java.lang.Object,java.util.function.Function), values=public java.util.Collection java.util.LinkedHashMap.values(), replace=freemarker.ext.beans.OverloadedMethods@11d0265, java.lang.Object@3e55b2={public boolean java.util.HashMap.isEmpty()=[Ljava.lang.Class;@c5aa3a, public int java.util.AbstractMap.hashCode()=[Ljava.lang.Class;@74a947, public java.lang.Object java.util.HashMap.put(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@1615a91, public boolean java.util.AbstractMap.equals(java.lang.Object)=[Ljava.lang.Class;@a46ab2, public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object)=[Ljava.lang.Class;@1c389e6, public java.lang.String java.util.AbstractMap.toString()=[Ljava.lang.Class;@a23548, public boolean java.util.HashMap.containsKey(java.lang.Object)=[Ljava.lang.Class;@1be4a9f, public java.util.Set java.util.LinkedHashMap.keySet()=[Ljava.lang.Class;@44c60, public java.lang.Object java.util.HashMap.computeIfAbsent(java.lang.Object,java.util.function.Function)=[Ljava.lang.Class;@10f7dff, public java.lang.Object java.util.HashMap.clone()=[Ljava.lang.Class;@d214e3, public java.lang.Object java.util.LinkedHashMap.getOrDefault(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@1a74254, public java.util.Set java.util.LinkedHashMap.entrySet()=[Ljava.lang.Class;@1c4740c, public void java.util.LinkedHashMap.forEach(java.util.function.BiConsumer)=[Ljava.lang.Class;@1fe0c8e, public java.lang.Object java.util.HashMap.putIfAbsent(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@16f73de, public java.util.Collection java.util.LinkedHashMap.values()=[Ljava.lang.Class;@b3e45, public void java.util.LinkedHashMap.clear()=[Ljava.lang.Class;@a34e5c, public java.lang.Object java.util.HashMap.computeIfPresent(java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1fcb13a, public java.lang.Object java.util.HashMap.compute(java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1a7c258, public final native java.lang.Class java.lang.Object.getClass()=[Ljava.lang.Class;@7397f, public void java.util.HashMap.putAll(java.util.Map)=[Ljava.lang.Class;@59cd, public void java.util.LinkedHashMap.replaceAll(java.util.function.BiFunction)=[Ljava.lang.Class;@994816, public java.lang.Object java.util.HashMap.merge(java.lang.Object,java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1b1e75f, public int java.util.HashMap.size()=[Ljava.lang.Class;@bee157, public boolean java.util.LinkedHashMap.containsValue(java.lang.Object)=[Ljava.lang.Class;@5e0d7c}, replaceAll=public void java.util.LinkedHashMap.replaceAll(java.util.function.BiFunction), remove=freemarker.ext.beans.OverloadedMethods@8d3a99, containsValue=public boolean java.util.LinkedHashMap.containsValue(java.lang.Object), put=public java.lang.Object java.util.HashMap.put(java.lang.Object,java.lang.Object), empty=java.beans.PropertyDescriptor[name=empty; propertyType=boolean; readMethod=public boolean java.util.HashMap.isEmpty()], compute=public java.lang.Object java.util.HashMap.compute(java.lang.Object,java.util.function.BiFunction), hashCode=public int java.util.AbstractMap.hashCode(), putAll=public void java.util.HashMap.putAll(java.util.Map), get=public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object), merge=public java.lang.Object java.util.HashMap.merge(java.lang.Object,java.lang.Object,java.util.function.BiFunction), class=java.beans.PropertyDescriptor[name=class; propertyType=class java.lang.Class; readMethod=public final native java.lang.Class java.lang.Object.getClass()], keySet=public java.util.Set java.util.LinkedHashMap.keySet(), java.lang.Object@1c0f21d=freemarker.ext.beans.OverloadedMethods@d4b988, entrySet=public java.util.Set java.util.LinkedHashMap.entrySet(), java.lang.Object@15be27d=public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object), forEach=public void java.util.LinkedHashMap.forEach(java.util.function.BiConsumer), containsKey=public boolean java.util.HashMap.containsKey(java.lang.Object), isEmpty=public boolean java.util.HashMap.isEmpty(), clear=public void java.util.LinkedHashMap.clear(), computeIfPresent=public java.lang.Object java.util.HashMap.computeIfPresent(java.lang.Object,java.util.function.BiFunction), size=public int java.util.HashMap.size(), equals=public boolean java.util.AbstractMap.equals(java.lang.Object), clone=public java.lang.Object java.util.HashMap.clone(), toString=public java.lang.String java.util.AbstractMap.toString(), putIfAbsent=public java.lang.Object java.util.HashMap.putIfAbsent(java.lang.Object,java.lang.Object)}
[DEBUG] 2017-05-24: 21:05:32 freemarker.log._Log4jLoggerFactory$Log4jLogger.debug(_Log4jLoggerFactory.java:45) :  Key "onreset" was not found on instance of java.util.LinkedHashMap. Introspection information for the class is: {getClass=public final native java.lang.Class java.lang.Object.getClass(), getOrDefault=public java.lang.Object java.util.LinkedHashMap.getOrDefault(java.lang.Object,java.lang.Object), computeIfAbsent=public java.lang.Object java.util.HashMap.computeIfAbsent(java.lang.Object,java.util.function.Function), values=public java.util.Collection java.util.LinkedHashMap.values(), replace=freemarker.ext.beans.OverloadedMethods@11d0265, java.lang.Object@3e55b2={public boolean java.util.HashMap.isEmpty()=[Ljava.lang.Class;@c5aa3a, public int java.util.AbstractMap.hashCode()=[Ljava.lang.Class;@74a947, public java.lang.Object java.util.HashMap.put(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@1615a91, public boolean java.util.AbstractMap.equals(java.lang.Object)=[Ljava.lang.Class;@a46ab2, public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object)=[Ljava.lang.Class;@1c389e6, public java.lang.String java.util.AbstractMap.toString()=[Ljava.lang.Class;@a23548, public boolean java.util.HashMap.containsKey(java.lang.Object)=[Ljava.lang.Class;@1be4a9f, public java.util.Set java.util.LinkedHashMap.keySet()=[Ljava.lang.Class;@44c60, public java.lang.Object java.util.HashMap.computeIfAbsent(java.lang.Object,java.util.function.Function)=[Ljava.lang.Class;@10f7dff, public java.lang.Object java.util.HashMap.clone()=[Ljava.lang.Class;@d214e3, public java.lang.Object java.util.LinkedHashMap.getOrDefault(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@1a74254, public java.util.Set java.util.LinkedHashMap.entrySet()=[Ljava.lang.Class;@1c4740c, public void java.util.LinkedHashMap.forEach(java.util.function.BiConsumer)=[Ljava.lang.Class;@1fe0c8e, public java.lang.Object java.util.HashMap.putIfAbsent(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@16f73de, public java.util.Collection java.util.LinkedHashMap.values()=[Ljava.lang.Class;@b3e45, public void java.util.LinkedHashMap.clear()=[Ljava.lang.Class;@a34e5c, public java.lang.Object java.util.HashMap.computeIfPresent(java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1fcb13a, public java.lang.Object java.util.HashMap.compute(java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1a7c258, public final native java.lang.Class java.lang.Object.getClass()=[Ljava.lang.Class;@7397f, public void java.util.HashMap.putAll(java.util.Map)=[Ljava.lang.Class;@59cd, public void java.util.LinkedHashMap.replaceAll(java.util.function.BiFunction)=[Ljava.lang.Class;@994816, public java.lang.Object java.util.HashMap.merge(java.lang.Object,java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1b1e75f, public int java.util.HashMap.size()=[Ljava.lang.Class;@bee157, public boolean java.util.LinkedHashMap.containsValue(java.lang.Object)=[Ljava.lang.Class;@5e0d7c}, replaceAll=public void java.util.LinkedHashMap.replaceAll(java.util.function.BiFunction), remove=freemarker.ext.beans.OverloadedMethods@8d3a99, containsValue=public boolean java.util.LinkedHashMap.containsValue(java.lang.Object), put=public java.lang.Object java.util.HashMap.put(java.lang.Object,java.lang.Object), empty=java.beans.PropertyDescriptor[name=empty; propertyType=boolean; readMethod=public boolean java.util.HashMap.isEmpty()], compute=public java.lang.Object java.util.HashMap.compute(java.lang.Object,java.util.function.BiFunction), hashCode=public int java.util.AbstractMap.hashCode(), putAll=public void java.util.HashMap.putAll(java.util.Map), get=public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object), merge=public java.lang.Object java.util.HashMap.merge(java.lang.Object,java.lang.Object,java.util.function.BiFunction), class=java.beans.PropertyDescriptor[name=class; propertyType=class java.lang.Class; readMethod=public final native java.lang.Class java.lang.Object.getClass()], keySet=public java.util.Set java.util.LinkedHashMap.keySet(), java.lang.Object@1c0f21d=freemarker.ext.beans.OverloadedMethods@d4b988, entrySet=public java.util.Set java.util.LinkedHashMap.entrySet(), java.lang.Object@15be27d=public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object), forEach=public void java.util.LinkedHashMap.forEach(java.util.function.BiConsumer), containsKey=public boolean java.util.HashMap.containsKey(java.lang.Object), isEmpty=public boolean java.util.HashMap.isEmpty(), clear=public void java.util.LinkedHashMap.clear(), computeIfPresent=public java.lang.Object java.util.HashMap.computeIfPresent(java.lang.Object,java.util.function.BiFunction), size=public int java.util.HashMap.size(), equals=public boolean java.util.AbstractMap.equals(java.lang.Object), clone=public java.lang.Object java.util.HashMap.clone(), toString=public java.lang.String java.util.AbstractMap.toString(), putIfAbsent=public java.lang.Object java.util.HashMap.putIfAbsent(java.lang.Object,java.lang.Object)}
[DEBUG] 2017-05-24: 21:05:32 freemarker.log._Log4jLoggerFactory$Log4jLogger.debug(_Log4jLoggerFactory.java:45) :  Couldn't find template in cache for "template/~~~xhtml/control.ftl"("zh_CN", UTF-8, parsed); will try to load it.
[DEBUG] 2017-05-24: 21:05:32 freemarker.log._Log4jLoggerFactory$Log4jLogger.debug(_Log4jLoggerFactory.java:45) :  TemplateLoader.findTemplateSource("template/~~~xhtml/control.ftl"): Found
[DEBUG] 2017-05-24: 21:05:32 freemarker.log._Log4jLoggerFactory$Log4jLogger.debug(_Log4jLoggerFactory.java:45) :  Loading template for "template/~~~xhtml/control.ftl"("zh_CN", UTF-8, parsed) from "jar:file:/D:/maven/repository/org/apache/struts/struts2-core/2.5.10/struts2-core-2.5.10.jar!/template/xhtml/control.ftl"
[DEBUG] 2017-05-24: 21:05:32 freemarker.log._Log4jLoggerFactory$Log4jLogger.debug(_Log4jLoggerFactory.java:45) :  Key "cssClass" was not found on instance of java.util.LinkedHashMap. Introspection information for the class is: {getClass=public final native java.lang.Class java.lang.Object.getClass(), getOrDefault=public java.lang.Object java.util.LinkedHashMap.getOrDefault(java.lang.Object,java.lang.Object), computeIfAbsent=public java.lang.Object java.util.HashMap.computeIfAbsent(java.lang.Object,java.util.function.Function), values=public java.util.Collection java.util.LinkedHashMap.values(), replace=freemarker.ext.beans.OverloadedMethods@11d0265, java.lang.Object@3e55b2={public boolean java.util.HashMap.isEmpty()=[Ljava.lang.Class;@c5aa3a, public int java.util.AbstractMap.hashCode()=[Ljava.lang.Class;@74a947, public java.lang.Object java.util.HashMap.put(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@1615a91, public boolean java.util.AbstractMap.equals(java.lang.Object)=[Ljava.lang.Class;@a46ab2, public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object)=[Ljava.lang.Class;@1c389e6, public java.lang.String java.util.AbstractMap.toString()=[Ljava.lang.Class;@a23548, public boolean java.util.HashMap.containsKey(java.lang.Object)=[Ljava.lang.Class;@1be4a9f, public java.util.Set java.util.LinkedHashMap.keySet()=[Ljava.lang.Class;@44c60, public java.lang.Object java.util.HashMap.computeIfAbsent(java.lang.Object,java.util.function.Function)=[Ljava.lang.Class;@10f7dff, public java.lang.Object java.util.HashMap.clone()=[Ljava.lang.Class;@d214e3, public java.lang.Object java.util.LinkedHashMap.getOrDefault(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@1a74254, public java.util.Set java.util.LinkedHashMap.entrySet()=[Ljava.lang.Class;@1c4740c, public void java.util.LinkedHashMap.forEach(java.util.function.BiConsumer)=[Ljava.lang.Class;@1fe0c8e, public java.lang.Object java.util.HashMap.putIfAbsent(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@16f73de, public java.util.Collection java.util.LinkedHashMap.values()=[Ljava.lang.Class;@b3e45, public void java.util.LinkedHashMap.clear()=[Ljava.lang.Class;@a34e5c, public java.lang.Object java.util.HashMap.computeIfPresent(java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1fcb13a, public java.lang.Object java.util.HashMap.compute(java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1a7c258, public final native java.lang.Class java.lang.Object.getClass()=[Ljava.lang.Class;@7397f, public void java.util.HashMap.putAll(java.util.Map)=[Ljava.lang.Class;@59cd, public void java.util.LinkedHashMap.replaceAll(java.util.function.BiFunction)=[Ljava.lang.Class;@994816, public java.lang.Object java.util.HashMap.merge(java.lang.Object,java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1b1e75f, public int java.util.HashMap.size()=[Ljava.lang.Class;@bee157, public boolean java.util.LinkedHashMap.containsValue(java.lang.Object)=[Ljava.lang.Class;@5e0d7c}, replaceAll=public void java.util.LinkedHashMap.replaceAll(java.util.function.BiFunction), remove=freemarker.ext.beans.OverloadedMethods@8d3a99, containsValue=public boolean java.util.LinkedHashMap.containsValue(java.lang.Object), put=public java.lang.Object java.util.HashMap.put(java.lang.Object,java.lang.Object), empty=java.beans.PropertyDescriptor[name=empty; propertyType=boolean; readMethod=public boolean java.util.HashMap.isEmpty()], compute=public java.lang.Object java.util.HashMap.compute(java.lang.Object,java.util.function.BiFunction), hashCode=public int java.util.AbstractMap.hashCode(), putAll=public void java.util.HashMap.putAll(java.util.Map), get=public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object), merge=public java.lang.Object java.util.HashMap.merge(java.lang.Object,java.lang.Object,java.util.function.BiFunction), class=java.beans.PropertyDescriptor[name=class; propertyType=class java.lang.Class; readMethod=public final native java.lang.Class java.lang.Object.getClass()], keySet=public java.util.Set java.util.LinkedHashMap.keySet(), java.lang.Object@1c0f21d=freemarker.ext.beans.OverloadedMethods@d4b988, entrySet=public java.util.Set java.util.LinkedHashMap.entrySet(), java.lang.Object@15be27d=public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object), forEach=public void java.util.LinkedHashMap.forEach(java.util.function.BiConsumer), containsKey=public boolean java.util.HashMap.containsKey(java.lang.Object), isEmpty=public boolean java.util.HashMap.isEmpty(), clear=public void java.util.LinkedHashMap.clear(), computeIfPresent=public java.lang.Object java.util.HashMap.computeIfPresent(java.lang.Object,java.util.function.BiFunction), size=public int java.util.HashMap.size(), equals=public boolean java.util.AbstractMap.equals(java.lang.Object), clone=public java.lang.Object java.util.HashMap.clone(), toString=public java.lang.String java.util.AbstractMap.toString(), putIfAbsent=public java.lang.Object java.util.HashMap.putIfAbsent(java.lang.Object,java.lang.Object)}
[DEBUG] 2017-05-24: 21:05:32 freemarker.log._Log4jLoggerFactory$Log4jLogger.debug(_Log4jLoggerFactory.java:45) :  Key "cssStyle" was not found on instance of java.util.LinkedHashMap. Introspection information for the class is: {getClass=public final native java.lang.Class java.lang.Object.getClass(), getOrDefault=public java.lang.Object java.util.LinkedHashMap.getOrDefault(java.lang.Object,java.lang.Object), computeIfAbsent=public java.lang.Object java.util.HashMap.computeIfAbsent(java.lang.Object,java.util.function.Function), values=public java.util.Collection java.util.LinkedHashMap.values(), replace=freemarker.ext.beans.OverloadedMethods@11d0265, java.lang.Object@3e55b2={public boolean java.util.HashMap.isEmpty()=[Ljava.lang.Class;@c5aa3a, public int java.util.AbstractMap.hashCode()=[Ljava.lang.Class;@74a947, public java.lang.Object java.util.HashMap.put(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@1615a91, public boolean java.util.AbstractMap.equals(java.lang.Object)=[Ljava.lang.Class;@a46ab2, public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object)=[Ljava.lang.Class;@1c389e6, public java.lang.String java.util.AbstractMap.toString()=[Ljava.lang.Class;@a23548, public boolean java.util.HashMap.containsKey(java.lang.Object)=[Ljava.lang.Class;@1be4a9f, public java.util.Set java.util.LinkedHashMap.keySet()=[Ljava.lang.Class;@44c60, public java.lang.Object java.util.HashMap.computeIfAbsent(java.lang.Object,java.util.function.Function)=[Ljava.lang.Class;@10f7dff, public java.lang.Object java.util.HashMap.clone()=[Ljava.lang.Class;@d214e3, public java.lang.Object java.util.LinkedHashMap.getOrDefault(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@1a74254, public java.util.Set java.util.LinkedHashMap.entrySet()=[Ljava.lang.Class;@1c4740c, public void java.util.LinkedHashMap.forEach(java.util.function.BiConsumer)=[Ljava.lang.Class;@1fe0c8e, public java.lang.Object java.util.HashMap.putIfAbsent(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@16f73de, public java.util.Collection java.util.LinkedHashMap.values()=[Ljava.lang.Class;@b3e45, public void java.util.LinkedHashMap.clear()=[Ljava.lang.Class;@a34e5c, public java.lang.Object java.util.HashMap.computeIfPresent(java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1fcb13a, public java.lang.Object java.util.HashMap.compute(java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1a7c258, public final native java.lang.Class java.lang.Object.getClass()=[Ljava.lang.Class;@7397f, public void java.util.HashMap.putAll(java.util.Map)=[Ljava.lang.Class;@59cd, public void java.util.LinkedHashMap.replaceAll(java.util.function.BiFunction)=[Ljava.lang.Class;@994816, public java.lang.Object java.util.HashMap.merge(java.lang.Object,java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1b1e75f, public int java.util.HashMap.size()=[Ljava.lang.Class;@bee157, public boolean java.util.LinkedHashMap.containsValue(java.lang.Object)=[Ljava.lang.Class;@5e0d7c}, replaceAll=public void java.util.LinkedHashMap.replaceAll(java.util.function.BiFunction), remove=freemarker.ext.beans.OverloadedMethods@8d3a99, containsValue=public boolean java.util.LinkedHashMap.containsValue(java.lang.Object), put=public java.lang.Object java.util.HashMap.put(java.lang.Object,java.lang.Object), empty=java.beans.PropertyDescriptor[name=empty; propertyType=boolean; readMethod=public boolean java.util.HashMap.isEmpty()], compute=public java.lang.Object java.util.HashMap.compute(java.lang.Object,java.util.function.BiFunction), hashCode=public int java.util.AbstractMap.hashCode(), putAll=public void java.util.HashMap.putAll(java.util.Map), get=public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object), merge=public java.lang.Object java.util.HashMap.merge(java.lang.Object,java.lang.Object,java.util.function.BiFunction), class=java.beans.PropertyDescriptor[name=class; propertyType=class java.lang.Class; readMethod=public final native java.lang.Class java.lang.Object.getClass()], keySet=public java.util.Set java.util.LinkedHashMap.keySet(), java.lang.Object@1c0f21d=freemarker.ext.beans.OverloadedMethods@d4b988, entrySet=public java.util.Set java.util.LinkedHashMap.entrySet(), java.lang.Object@15be27d=public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object), forEach=public void java.util.LinkedHashMap.forEach(java.util.function.BiConsumer), containsKey=public boolean java.util.HashMap.containsKey(java.lang.Object), isEmpty=public boolean java.util.HashMap.isEmpty(), clear=public void java.util.LinkedHashMap.clear(), computeIfPresent=public java.lang.Object java.util.HashMap.computeIfPresent(java.lang.Object,java.util.function.BiFunction), size=public int java.util.HashMap.size(), equals=public boolean java.util.AbstractMap.equals(java.lang.Object), clone=public java.lang.Object java.util.HashMap.clone(), toString=public java.lang.String java.util.AbstractMap.toString(), putIfAbsent=public java.lang.Object java.util.HashMap.putIfAbsent(java.lang.Object,java.lang.Object)}
[DEBUG] 2017-05-24: 21:05:32 freemarker.log._Log4jLoggerFactory$Log4jLogger.debug(_Log4jLoggerFactory.java:45) :  Couldn't find template in cache for "template/xhtml/hidden.ftl"("zh_CN", UTF-8, parsed); will try to load it.
[DEBUG] 2017-05-24: 21:05:32 freemarker.log._Log4jLoggerFactory$Log4jLogger.debug(_Log4jLoggerFactory.java:45) :  TemplateLoader.findTemplateSource("template/xhtml/hidden.ftl"): Found
[DEBUG] 2017-05-24: 21:05:32 freemarker.log._Log4jLoggerFactory$Log4jLogger.debug(_Log4jLoggerFactory.java:45) :  Loading template for "template/xhtml/hidden.ftl"("zh_CN", UTF-8, parsed) from "jar:file:/D:/maven/repository/org/apache/struts/struts2-core/2.5.10/struts2-core-2.5.10.jar!/template/xhtml/hidden.ftl"
[DEBUG] 2017-05-24: 21:05:32 freemarker.log._Log4jLoggerFactory$Log4jLogger.debug(_Log4jLoggerFactory.java:45) :  Couldn't find template in cache for "template/simple/hidden.ftl"("zh_CN", UTF-8, parsed); will try to load it.
[DEBUG] 2017-05-24: 21:05:32 freemarker.log._Log4jLoggerFactory$Log4jLogger.debug(_Log4jLoggerFactory.java:45) :  TemplateLoader.findTemplateSource("template/simple/hidden.ftl"): Found
[DEBUG] 2017-05-24: 21:05:32 freemarker.log._Log4jLoggerFactory$Log4jLogger.debug(_Log4jLoggerFactory.java:45) :  Loading template for "template/simple/hidden.ftl"("zh_CN", UTF-8, parsed) from "jar:file:/D:/maven/repository/org/apache/struts/struts2-core/2.5.10/struts2-core-2.5.10.jar!/template/simple/hidden.ftl"
[DEBUG] 2017-05-24: 21:05:32 freemarker.log._Log4jLoggerFactory$Log4jLogger.debug(_Log4jLoggerFactory.java:45) :  Key "cssClass" was not found on instance of java.util.LinkedHashMap. Introspection information for the class is: {getClass=public final native java.lang.Class java.lang.Object.getClass(), getOrDefault=public java.lang.Object java.util.LinkedHashMap.getOrDefault(java.lang.Object,java.lang.Object), computeIfAbsent=public java.lang.Object java.util.HashMap.computeIfAbsent(java.lang.Object,java.util.function.Function), values=public java.util.Collection java.util.LinkedHashMap.values(), replace=freemarker.ext.beans.OverloadedMethods@11d0265, java.lang.Object@3e55b2={public boolean java.util.HashMap.isEmpty()=[Ljava.lang.Class;@c5aa3a, public int java.util.AbstractMap.hashCode()=[Ljava.lang.Class;@74a947, public java.lang.Object java.util.HashMap.put(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@1615a91, public boolean java.util.AbstractMap.equals(java.lang.Object)=[Ljava.lang.Class;@a46ab2, public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object)=[Ljava.lang.Class;@1c389e6, public java.lang.String java.util.AbstractMap.toString()=[Ljava.lang.Class;@a23548, public boolean java.util.HashMap.containsKey(java.lang.Object)=[Ljava.lang.Class;@1be4a9f, public java.util.Set java.util.LinkedHashMap.keySet()=[Ljava.lang.Class;@44c60, public java.lang.Object java.util.HashMap.computeIfAbsent(java.lang.Object,java.util.function.Function)=[Ljava.lang.Class;@10f7dff, public java.lang.Object java.util.HashMap.clone()=[Ljava.lang.Class;@d214e3, public java.lang.Object java.util.LinkedHashMap.getOrDefault(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@1a74254, public java.util.Set java.util.LinkedHashMap.entrySet()=[Ljava.lang.Class;@1c4740c, public void java.util.LinkedHashMap.forEach(java.util.function.BiConsumer)=[Ljava.lang.Class;@1fe0c8e, public java.lang.Object java.util.HashMap.putIfAbsent(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@16f73de, public java.util.Collection java.util.LinkedHashMap.values()=[Ljava.lang.Class;@b3e45, public void java.util.LinkedHashMap.clear()=[Ljava.lang.Class;@a34e5c, public java.lang.Object java.util.HashMap.computeIfPresent(java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1fcb13a, public java.lang.Object java.util.HashMap.compute(java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1a7c258, public final native java.lang.Class java.lang.Object.getClass()=[Ljava.lang.Class;@7397f, public void java.util.HashMap.putAll(java.util.Map)=[Ljava.lang.Class;@59cd, public void java.util.LinkedHashMap.replaceAll(java.util.function.BiFunction)=[Ljava.lang.Class;@994816, public java.lang.Object java.util.HashMap.merge(java.lang.Object,java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1b1e75f, public int java.util.HashMap.size()=[Ljava.lang.Class;@bee157, public boolean java.util.LinkedHashMap.containsValue(java.lang.Object)=[Ljava.lang.Class;@5e0d7c}, replaceAll=public void java.util.LinkedHashMap.replaceAll(java.util.function.BiFunction), remove=freemarker.ext.beans.OverloadedMethods@8d3a99, containsValue=public boolean java.util.LinkedHashMap.containsValue(java.lang.Object), put=public java.lang.Object java.util.HashMap.put(java.lang.Object,java.lang.Object), empty=java.beans.PropertyDescriptor[name=empty; propertyType=boolean; readMethod=public boolean java.util.HashMap.isEmpty()], compute=public java.lang.Object java.util.HashMap.compute(java.lang.Object,java.util.function.BiFunction), hashCode=public int java.util.AbstractMap.hashCode(), putAll=public void java.util.HashMap.putAll(java.util.Map), get=public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object), merge=public java.lang.Object java.util.HashMap.merge(java.lang.Object,java.lang.Object,java.util.function.BiFunction), class=java.beans.PropertyDescriptor[name=class; propertyType=class java.lang.Class; readMethod=public final native java.lang.Class java.lang.Object.getClass()], keySet=public java.util.Set java.util.LinkedHashMap.keySet(), java.lang.Object@1c0f21d=freemarker.ext.beans.OverloadedMethods@d4b988, entrySet=public java.util.Set java.util.LinkedHashMap.entrySet(), java.lang.Object@15be27d=public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object), forEach=public void java.util.LinkedHashMap.forEach(java.util.function.BiConsumer), containsKey=public boolean java.util.HashMap.containsKey(java.lang.Object), isEmpty=public boolean java.util.HashMap.isEmpty(), clear=public void java.util.LinkedHashMap.clear(), computeIfPresent=public java.lang.Object java.util.HashMap.computeIfPresent(java.lang.Object,java.util.function.BiFunction), size=public int java.util.HashMap.size(), equals=public boolean java.util.AbstractMap.equals(java.lang.Object), clone=public java.lang.Object java.util.HashMap.clone(), toString=public java.lang.String java.util.AbstractMap.toString(), putIfAbsent=public java.lang.Object java.util.HashMap.putIfAbsent(java.lang.Object,java.lang.Object)}
[DEBUG] 2017-05-24: 21:05:32 freemarker.log._Log4jLoggerFactory$Log4jLogger.debug(_Log4jLoggerFactory.java:45) :  Key "cssStyle" was not found on instance of java.util.LinkedHashMap. Introspection information for the class is: {getClass=public final native java.lang.Class java.lang.Object.getClass(), getOrDefault=public java.lang.Object java.util.LinkedHashMap.getOrDefault(java.lang.Object,java.lang.Object), computeIfAbsent=public java.lang.Object java.util.HashMap.computeIfAbsent(java.lang.Object,java.util.function.Function), values=public java.util.Collection java.util.LinkedHashMap.values(), replace=freemarker.ext.beans.OverloadedMethods@11d0265, java.lang.Object@3e55b2={public boolean java.util.HashMap.isEmpty()=[Ljava.lang.Class;@c5aa3a, public int java.util.AbstractMap.hashCode()=[Ljava.lang.Class;@74a947, public java.lang.Object java.util.HashMap.put(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@1615a91, public boolean java.util.AbstractMap.equals(java.lang.Object)=[Ljava.lang.Class;@a46ab2, public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object)=[Ljava.lang.Class;@1c389e6, public java.lang.String java.util.AbstractMap.toString()=[Ljava.lang.Class;@a23548, public boolean java.util.HashMap.containsKey(java.lang.Object)=[Ljava.lang.Class;@1be4a9f, public java.util.Set java.util.LinkedHashMap.keySet()=[Ljava.lang.Class;@44c60, public java.lang.Object java.util.HashMap.computeIfAbsent(java.lang.Object,java.util.function.Function)=[Ljava.lang.Class;@10f7dff, public java.lang.Object java.util.HashMap.clone()=[Ljava.lang.Class;@d214e3, public java.lang.Object java.util.LinkedHashMap.getOrDefault(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@1a74254, public java.util.Set java.util.LinkedHashMap.entrySet()=[Ljava.lang.Class;@1c4740c, public void java.util.LinkedHashMap.forEach(java.util.function.BiConsumer)=[Ljava.lang.Class;@1fe0c8e, public java.lang.Object java.util.HashMap.putIfAbsent(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@16f73de, public java.util.Collection java.util.LinkedHashMap.values()=[Ljava.lang.Class;@b3e45, public void java.util.LinkedHashMap.clear()=[Ljava.lang.Class;@a34e5c, public java.lang.Object java.util.HashMap.computeIfPresent(java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1fcb13a, public java.lang.Object java.util.HashMap.compute(java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1a7c258, public final native java.lang.Class java.lang.Object.getClass()=[Ljava.lang.Class;@7397f, public void java.util.HashMap.putAll(java.util.Map)=[Ljava.lang.Class;@59cd, public void java.util.LinkedHashMap.replaceAll(java.util.function.BiFunction)=[Ljava.lang.Class;@994816, public java.lang.Object java.util.HashMap.merge(java.lang.Object,java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1b1e75f, public int java.util.HashMap.size()=[Ljava.lang.Class;@bee157, public boolean java.util.LinkedHashMap.containsValue(java.lang.Object)=[Ljava.lang.Class;@5e0d7c}, replaceAll=public void java.util.LinkedHashMap.replaceAll(java.util.function.BiFunction), remove=freemarker.ext.beans.OverloadedMethods@8d3a99, containsValue=public boolean java.util.LinkedHashMap.containsValue(java.lang.Object), put=public java.lang.Object java.util.HashMap.put(java.lang.Object,java.lang.Object), empty=java.beans.PropertyDescriptor[name=empty; propertyType=boolean; readMethod=public boolean java.util.HashMap.isEmpty()], compute=public java.lang.Object java.util.HashMap.compute(java.lang.Object,java.util.function.BiFunction), hashCode=public int java.util.AbstractMap.hashCode(), putAll=public void java.util.HashMap.putAll(java.util.Map), get=public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object), merge=public java.lang.Object java.util.HashMap.merge(java.lang.Object,java.lang.Object,java.util.function.BiFunction), class=java.beans.PropertyDescriptor[name=class; propertyType=class java.lang.Class; readMethod=public final native java.lang.Class java.lang.Object.getClass()], keySet=public java.util.Set java.util.LinkedHashMap.keySet(), java.lang.Object@1c0f21d=freemarker.ext.beans.OverloadedMethods@d4b988, entrySet=public java.util.Set java.util.LinkedHashMap.entrySet(), java.lang.Object@15be27d=public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object), forEach=public void java.util.LinkedHashMap.forEach(java.util.function.BiConsumer), containsKey=public boolean java.util.HashMap.containsKey(java.lang.Object), isEmpty=public boolean java.util.HashMap.isEmpty(), clear=public void java.util.LinkedHashMap.clear(), computeIfPresent=public java.lang.Object java.util.HashMap.computeIfPresent(java.lang.Object,java.util.function.BiFunction), size=public int java.util.HashMap.size(), equals=public boolean java.util.AbstractMap.equals(java.lang.Object), clone=public java.lang.Object java.util.HashMap.clone(), toString=public java.lang.String java.util.AbstractMap.toString(), putIfAbsent=public java.lang.Object java.util.HashMap.putIfAbsent(java.lang.Object,java.lang.Object)}
[DEBUG] 2017-05-24: 21:05:32 freemarker.log._Log4jLoggerFactory$Log4jLogger.debug(_Log4jLoggerFactory.java:45) :  Key "disabled" was not found on instance of java.util.LinkedHashMap. Introspection information for the class is: {getClass=public final native java.lang.Class java.lang.Object.getClass(), getOrDefault=public java.lang.Object java.util.LinkedHashMap.getOrDefault(java.lang.Object,java.lang.Object), computeIfAbsent=public java.lang.Object java.util.HashMap.computeIfAbsent(java.lang.Object,java.util.function.Function), values=public java.util.Collection java.util.LinkedHashMap.values(), replace=freemarker.ext.beans.OverloadedMethods@11d0265, java.lang.Object@3e55b2={public boolean java.util.HashMap.isEmpty()=[Ljava.lang.Class;@c5aa3a, public int java.util.AbstractMap.hashCode()=[Ljava.lang.Class;@74a947, public java.lang.Object java.util.HashMap.put(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@1615a91, public boolean java.util.AbstractMap.equals(java.lang.Object)=[Ljava.lang.Class;@a46ab2, public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object)=[Ljava.lang.Class;@1c389e6, public java.lang.String java.util.AbstractMap.toString()=[Ljava.lang.Class;@a23548, public boolean java.util.HashMap.containsKey(java.lang.Object)=[Ljava.lang.Class;@1be4a9f, public java.util.Set java.util.LinkedHashMap.keySet()=[Ljava.lang.Class;@44c60, public java.lang.Object java.util.HashMap.computeIfAbsent(java.lang.Object,java.util.function.Function)=[Ljava.lang.Class;@10f7dff, public java.lang.Object java.util.HashMap.clone()=[Ljava.lang.Class;@d214e3, public java.lang.Object java.util.LinkedHashMap.getOrDefault(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@1a74254, public java.util.Set java.util.LinkedHashMap.entrySet()=[Ljava.lang.Class;@1c4740c, public void java.util.LinkedHashMap.forEach(java.util.function.BiConsumer)=[Ljava.lang.Class;@1fe0c8e, public java.lang.Object java.util.HashMap.putIfAbsent(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@16f73de, public java.util.Collection java.util.LinkedHashMap.values()=[Ljava.lang.Class;@b3e45, public void java.util.LinkedHashMap.clear()=[Ljava.lang.Class;@a34e5c, public java.lang.Object java.util.HashMap.computeIfPresent(java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1fcb13a, public java.lang.Object java.util.HashMap.compute(java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1a7c258, public final native java.lang.Class java.lang.Object.getClass()=[Ljava.lang.Class;@7397f, public void java.util.HashMap.putAll(java.util.Map)=[Ljava.lang.Class;@59cd, public void java.util.LinkedHashMap.replaceAll(java.util.function.BiFunction)=[Ljava.lang.Class;@994816, public java.lang.Object java.util.HashMap.merge(java.lang.Object,java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1b1e75f, public int java.util.HashMap.size()=[Ljava.lang.Class;@bee157, public boolean java.util.LinkedHashMap.containsValue(java.lang.Object)=[Ljava.lang.Class;@5e0d7c}, replaceAll=public void java.util.LinkedHashMap.replaceAll(java.util.function.BiFunction), remove=freemarker.ext.beans.OverloadedMethods@8d3a99, containsValue=public boolean java.util.LinkedHashMap.containsValue(java.lang.Object), put=public java.lang.Object java.util.HashMap.put(java.lang.Object,java.lang.Object), empty=java.beans.PropertyDescriptor[name=empty; propertyType=boolean; readMethod=public boolean java.util.HashMap.isEmpty()], compute=public java.lang.Object java.util.HashMap.compute(java.lang.Object,java.util.function.BiFunction), hashCode=public int java.util.AbstractMap.hashCode(), putAll=public void java.util.HashMap.putAll(java.util.Map), get=public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object), merge=public java.lang.Object java.util.HashMap.merge(java.lang.Object,java.lang.Object,java.util.function.BiFunction), class=java.beans.PropertyDescriptor[name=class; propertyType=class java.lang.Class; readMethod=public final native java.lang.Class java.lang.Object.getClass()], keySet=public java.util.Set java.util.LinkedHashMap.keySet(), java.lang.Object@1c0f21d=freemarker.ext.beans.OverloadedMethods@d4b988, entrySet=public java.util.Set java.util.LinkedHashMap.entrySet(), java.lang.Object@15be27d=public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object), forEach=public void java.util.LinkedHashMap.forEach(java.util.function.BiConsumer), containsKey=public boolean java.util.HashMap.containsKey(java.lang.Object), isEmpty=public boolean java.util.HashMap.isEmpty(), clear=public void java.util.LinkedHashMap.clear(), computeIfPresent=public java.lang.Object java.util.HashMap.computeIfPresent(java.lang.Object,java.util.function.BiFunction), size=public int java.util.HashMap.size(), equals=public boolean java.util.AbstractMap.equals(java.lang.Object), clone=public java.lang.Object java.util.HashMap.clone(), toString=public java.lang.String java.util.AbstractMap.toString(), putIfAbsent=public java.lang.Object java.util.HashMap.putIfAbsent(java.lang.Object,java.lang.Object)}
[DEBUG] 2017-05-24: 21:05:32 freemarker.log._Log4jLoggerFactory$Log4jLogger.debug(_Log4jLoggerFactory.java:45) :  TemplateLoader.findTemplateSource("template/~~~xhtml/dynamic-attributes.ftl"): Found
[DEBUG] 2017-05-24: 21:05:32 freemarker.log._Log4jLoggerFactory$Log4jLogger.debug(_Log4jLoggerFactory.java:45) :  "template/~~~xhtml/dynamic-attributes.ftl"("zh_CN", UTF-8, parsed): using cached since jar:file:/D:/maven/repository/org/apache/struts/struts2-core/2.5.10/struts2-core-2.5.10.jar!/template/simple/dynamic-attributes.ftl hasn't changed.
[DEBUG] 2017-05-24: 21:05:32 freemarker.log._Log4jLoggerFactory$Log4jLogger.debug(_Log4jLoggerFactory.java:45) :  TemplateLoader.findTemplateSource("template/xhtml/hidden.ftl"): Found
[DEBUG] 2017-05-24: 21:05:32 freemarker.log._Log4jLoggerFactory$Log4jLogger.debug(_Log4jLoggerFactory.java:45) :  "template/xhtml/hidden.ftl"("zh_CN", UTF-8, parsed): using cached since jar:file:/D:/maven/repository/org/apache/struts/struts2-core/2.5.10/struts2-core-2.5.10.jar!/template/xhtml/hidden.ftl hasn't changed.
[DEBUG] 2017-05-24: 21:05:32 freemarker.log._Log4jLoggerFactory$Log4jLogger.debug(_Log4jLoggerFactory.java:45) :  TemplateLoader.findTemplateSource("template/simple/hidden.ftl"): Found
[DEBUG] 2017-05-24: 21:05:32 freemarker.log._Log4jLoggerFactory$Log4jLogger.debug(_Log4jLoggerFactory.java:45) :  "template/simple/hidden.ftl"("zh_CN", UTF-8, parsed): using cached since jar:file:/D:/maven/repository/org/apache/struts/struts2-core/2.5.10/struts2-core-2.5.10.jar!/template/simple/hidden.ftl hasn't changed.
[DEBUG] 2017-05-24: 21:05:32 freemarker.log._Log4jLoggerFactory$Log4jLogger.debug(_Log4jLoggerFactory.java:45) :  Key "cssClass" was not found on instance of java.util.LinkedHashMap. Introspection information for the class is: {getClass=public final native java.lang.Class java.lang.Object.getClass(), getOrDefault=public java.lang.Object java.util.LinkedHashMap.getOrDefault(java.lang.Object,java.lang.Object), computeIfAbsent=public java.lang.Object java.util.HashMap.computeIfAbsent(java.lang.Object,java.util.function.Function), values=public java.util.Collection java.util.LinkedHashMap.values(), replace=freemarker.ext.beans.OverloadedMethods@11d0265, java.lang.Object@3e55b2={public boolean java.util.HashMap.isEmpty()=[Ljava.lang.Class;@c5aa3a, public int java.util.AbstractMap.hashCode()=[Ljava.lang.Class;@74a947, public java.lang.Object java.util.HashMap.put(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@1615a91, public boolean java.util.AbstractMap.equals(java.lang.Object)=[Ljava.lang.Class;@a46ab2, public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object)=[Ljava.lang.Class;@1c389e6, public java.lang.String java.util.AbstractMap.toString()=[Ljava.lang.Class;@a23548, public boolean java.util.HashMap.containsKey(java.lang.Object)=[Ljava.lang.Class;@1be4a9f, public java.util.Set java.util.LinkedHashMap.keySet()=[Ljava.lang.Class;@44c60, public java.lang.Object java.util.HashMap.computeIfAbsent(java.lang.Object,java.util.function.Function)=[Ljava.lang.Class;@10f7dff, public java.lang.Object java.util.HashMap.clone()=[Ljava.lang.Class;@d214e3, public java.lang.Object java.util.LinkedHashMap.getOrDefault(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@1a74254, public java.util.Set java.util.LinkedHashMap.entrySet()=[Ljava.lang.Class;@1c4740c, public void java.util.LinkedHashMap.forEach(java.util.function.BiConsumer)=[Ljava.lang.Class;@1fe0c8e, public java.lang.Object java.util.HashMap.putIfAbsent(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@16f73de, public java.util.Collection java.util.LinkedHashMap.values()=[Ljava.lang.Class;@b3e45, public void java.util.LinkedHashMap.clear()=[Ljava.lang.Class;@a34e5c, public java.lang.Object java.util.HashMap.computeIfPresent(java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1fcb13a, public java.lang.Object java.util.HashMap.compute(java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1a7c258, public final native java.lang.Class java.lang.Object.getClass()=[Ljava.lang.Class;@7397f, public void java.util.HashMap.putAll(java.util.Map)=[Ljava.lang.Class;@59cd, public void java.util.LinkedHashMap.replaceAll(java.util.function.BiFunction)=[Ljava.lang.Class;@994816, public java.lang.Object java.util.HashMap.merge(java.lang.Object,java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1b1e75f, public int java.util.HashMap.size()=[Ljava.lang.Class;@bee157, public boolean java.util.LinkedHashMap.containsValue(java.lang.Object)=[Ljava.lang.Class;@5e0d7c}, replaceAll=public void java.util.LinkedHashMap.replaceAll(java.util.function.BiFunction), remove=freemarker.ext.beans.OverloadedMethods@8d3a99, containsValue=public boolean java.util.LinkedHashMap.containsValue(java.lang.Object), put=public java.lang.Object java.util.HashMap.put(java.lang.Object,java.lang.Object), empty=java.beans.PropertyDescriptor[name=empty; propertyType=boolean; readMethod=public boolean java.util.HashMap.isEmpty()], compute=public java.lang.Object java.util.HashMap.compute(java.lang.Object,java.util.function.BiFunction), hashCode=public int java.util.AbstractMap.hashCode(), putAll=public void java.util.HashMap.putAll(java.util.Map), get=public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object), merge=public java.lang.Object java.util.HashMap.merge(java.lang.Object,java.lang.Object,java.util.function.BiFunction), class=java.beans.PropertyDescriptor[name=class; propertyType=class java.lang.Class; readMethod=public final native java.lang.Class java.lang.Object.getClass()], keySet=public java.util.Set java.util.LinkedHashMap.keySet(), java.lang.Object@1c0f21d=freemarker.ext.beans.OverloadedMethods@d4b988, entrySet=public java.util.Set java.util.LinkedHashMap.entrySet(), java.lang.Object@15be27d=public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object), forEach=public void java.util.LinkedHashMap.forEach(java.util.function.BiConsumer), containsKey=public boolean java.util.HashMap.containsKey(java.lang.Object), isEmpty=public boolean java.util.HashMap.isEmpty(), clear=public void java.util.LinkedHashMap.clear(), computeIfPresent=public java.lang.Object java.util.HashMap.computeIfPresent(java.lang.Object,java.util.function.BiFunction), size=public int java.util.HashMap.size(), equals=public boolean java.util.AbstractMap.equals(java.lang.Object), clone=public java.lang.Object java.util.HashMap.clone(), toString=public java.lang.String java.util.AbstractMap.toString(), putIfAbsent=public java.lang.Object java.util.HashMap.putIfAbsent(java.lang.Object,java.lang.Object)}
[DEBUG] 2017-05-24: 21:05:32 freemarker.log._Log4jLoggerFactory$Log4jLogger.debug(_Log4jLoggerFactory.java:45) :  Key "cssStyle" was not found on instance of java.util.LinkedHashMap. Introspection information for the class is: {getClass=public final native java.lang.Class java.lang.Object.getClass(), getOrDefault=public java.lang.Object java.util.LinkedHashMap.getOrDefault(java.lang.Object,java.lang.Object), computeIfAbsent=public java.lang.Object java.util.HashMap.computeIfAbsent(java.lang.Object,java.util.function.Function), values=public java.util.Collection java.util.LinkedHashMap.values(), replace=freemarker.ext.beans.OverloadedMethods@11d0265, java.lang.Object@3e55b2={public boolean java.util.HashMap.isEmpty()=[Ljava.lang.Class;@c5aa3a, public int java.util.AbstractMap.hashCode()=[Ljava.lang.Class;@74a947, public java.lang.Object java.util.HashMap.put(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@1615a91, public boolean java.util.AbstractMap.equals(java.lang.Object)=[Ljava.lang.Class;@a46ab2, public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object)=[Ljava.lang.Class;@1c389e6, public java.lang.String java.util.AbstractMap.toString()=[Ljava.lang.Class;@a23548, public boolean java.util.HashMap.containsKey(java.lang.Object)=[Ljava.lang.Class;@1be4a9f, public java.util.Set java.util.LinkedHashMap.keySet()=[Ljava.lang.Class;@44c60, public java.lang.Object java.util.HashMap.computeIfAbsent(java.lang.Object,java.util.function.Function)=[Ljava.lang.Class;@10f7dff, public java.lang.Object java.util.HashMap.clone()=[Ljava.lang.Class;@d214e3, public java.lang.Object java.util.LinkedHashMap.getOrDefault(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@1a74254, public java.util.Set java.util.LinkedHashMap.entrySet()=[Ljava.lang.Class;@1c4740c, public void java.util.LinkedHashMap.forEach(java.util.function.BiConsumer)=[Ljava.lang.Class;@1fe0c8e, public java.lang.Object java.util.HashMap.putIfAbsent(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@16f73de, public java.util.Collection java.util.LinkedHashMap.values()=[Ljava.lang.Class;@b3e45, public void java.util.LinkedHashMap.clear()=[Ljava.lang.Class;@a34e5c, public java.lang.Object java.util.HashMap.computeIfPresent(java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1fcb13a, public java.lang.Object java.util.HashMap.compute(java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1a7c258, public final native java.lang.Class java.lang.Object.getClass()=[Ljava.lang.Class;@7397f, public void java.util.HashMap.putAll(java.util.Map)=[Ljava.lang.Class;@59cd, public void java.util.LinkedHashMap.replaceAll(java.util.function.BiFunction)=[Ljava.lang.Class;@994816, public java.lang.Object java.util.HashMap.merge(java.lang.Object,java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1b1e75f, public int java.util.HashMap.size()=[Ljava.lang.Class;@bee157, public boolean java.util.LinkedHashMap.containsValue(java.lang.Object)=[Ljava.lang.Class;@5e0d7c}, replaceAll=public void java.util.LinkedHashMap.replaceAll(java.util.function.BiFunction), remove=freemarker.ext.beans.OverloadedMethods@8d3a99, containsValue=public boolean java.util.LinkedHashMap.containsValue(java.lang.Object), put=public java.lang.Object java.util.HashMap.put(java.lang.Object,java.lang.Object), empty=java.beans.PropertyDescriptor[name=empty; propertyType=boolean; readMethod=public boolean java.util.HashMap.isEmpty()], compute=public java.lang.Object java.util.HashMap.compute(java.lang.Object,java.util.function.BiFunction), hashCode=public int java.util.AbstractMap.hashCode(), putAll=public void java.util.HashMap.putAll(java.util.Map), get=public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object), merge=public java.lang.Object java.util.HashMap.merge(java.lang.Object,java.lang.Object,java.util.function.BiFunction), class=java.beans.PropertyDescriptor[name=class; propertyType=class java.lang.Class; readMethod=public final native java.lang.Class java.lang.Object.getClass()], keySet=public java.util.Set java.util.LinkedHashMap.keySet(), java.lang.Object@1c0f21d=freemarker.ext.beans.OverloadedMethods@d4b988, entrySet=public java.util.Set java.util.LinkedHashMap.entrySet(), java.lang.Object@15be27d=public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object), forEach=public void java.util.LinkedHashMap.forEach(java.util.function.BiConsumer), containsKey=public boolean java.util.HashMap.containsKey(java.lang.Object), isEmpty=public boolean java.util.HashMap.isEmpty(), clear=public void java.util.LinkedHashMap.clear(), computeIfPresent=public java.lang.Object java.util.HashMap.computeIfPresent(java.lang.Object,java.util.function.BiFunction), size=public int java.util.HashMap.size(), equals=public boolean java.util.AbstractMap.equals(java.lang.Object), clone=public java.lang.Object java.util.HashMap.clone(), toString=public java.lang.String java.util.AbstractMap.toString(), putIfAbsent=public java.lang.Object java.util.HashMap.putIfAbsent(java.lang.Object,java.lang.Object)}
[DEBUG] 2017-05-24: 21:05:32 freemarker.log._Log4jLoggerFactory$Log4jLogger.debug(_Log4jLoggerFactory.java:45) :  Key "disabled" was not found on instance of java.util.LinkedHashMap. Introspection information for the class is: {getClass=public final native java.lang.Class java.lang.Object.getClass(), getOrDefault=public java.lang.Object java.util.LinkedHashMap.getOrDefault(java.lang.Object,java.lang.Object), computeIfAbsent=public java.lang.Object java.util.HashMap.computeIfAbsent(java.lang.Object,java.util.function.Function), values=public java.util.Collection java.util.LinkedHashMap.values(), replace=freemarker.ext.beans.OverloadedMethods@11d0265, java.lang.Object@3e55b2={public boolean java.util.HashMap.isEmpty()=[Ljava.lang.Class;@c5aa3a, public int java.util.AbstractMap.hashCode()=[Ljava.lang.Class;@74a947, public java.lang.Object java.util.HashMap.put(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@1615a91, public boolean java.util.AbstractMap.equals(java.lang.Object)=[Ljava.lang.Class;@a46ab2, public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object)=[Ljava.lang.Class;@1c389e6, public java.lang.String java.util.AbstractMap.toString()=[Ljava.lang.Class;@a23548, public boolean java.util.HashMap.containsKey(java.lang.Object)=[Ljava.lang.Class;@1be4a9f, public java.util.Set java.util.LinkedHashMap.keySet()=[Ljava.lang.Class;@44c60, public java.lang.Object java.util.HashMap.computeIfAbsent(java.lang.Object,java.util.function.Function)=[Ljava.lang.Class;@10f7dff, public java.lang.Object java.util.HashMap.clone()=[Ljava.lang.Class;@d214e3, public java.lang.Object java.util.LinkedHashMap.getOrDefault(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@1a74254, public java.util.Set java.util.LinkedHashMap.entrySet()=[Ljava.lang.Class;@1c4740c, public void java.util.LinkedHashMap.forEach(java.util.function.BiConsumer)=[Ljava.lang.Class;@1fe0c8e, public java.lang.Object java.util.HashMap.putIfAbsent(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@16f73de, public java.util.Collection java.util.LinkedHashMap.values()=[Ljava.lang.Class;@b3e45, public void java.util.LinkedHashMap.clear()=[Ljava.lang.Class;@a34e5c, public java.lang.Object java.util.HashMap.computeIfPresent(java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1fcb13a, public java.lang.Object java.util.HashMap.compute(java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1a7c258, public final native java.lang.Class java.lang.Object.getClass()=[Ljava.lang.Class;@7397f, public void java.util.HashMap.putAll(java.util.Map)=[Ljava.lang.Class;@59cd, public void java.util.LinkedHashMap.replaceAll(java.util.function.BiFunction)=[Ljava.lang.Class;@994816, public java.lang.Object java.util.HashMap.merge(java.lang.Object,java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1b1e75f, public int java.util.HashMap.size()=[Ljava.lang.Class;@bee157, public boolean java.util.LinkedHashMap.containsValue(java.lang.Object)=[Ljava.lang.Class;@5e0d7c}, replaceAll=public void java.util.LinkedHashMap.replaceAll(java.util.function.BiFunction), remove=freemarker.ext.beans.OverloadedMethods@8d3a99, containsValue=public boolean java.util.LinkedHashMap.containsValue(java.lang.Object), put=public java.lang.Object java.util.HashMap.put(java.lang.Object,java.lang.Object), empty=java.beans.PropertyDescriptor[name=empty; propertyType=boolean; readMethod=public boolean java.util.HashMap.isEmpty()], compute=public java.lang.Object java.util.HashMap.compute(java.lang.Object,java.util.function.BiFunction), hashCode=public int java.util.AbstractMap.hashCode(), putAll=public void java.util.HashMap.putAll(java.util.Map), get=public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object), merge=public java.lang.Object java.util.HashMap.merge(java.lang.Object,java.lang.Object,java.util.function.BiFunction), class=java.beans.PropertyDescriptor[name=class; propertyType=class java.lang.Class; readMethod=public final native java.lang.Class java.lang.Object.getClass()], keySet=public java.util.Set java.util.LinkedHashMap.keySet(), java.lang.Object@1c0f21d=freemarker.ext.beans.OverloadedMethods@d4b988, entrySet=public java.util.Set java.util.LinkedHashMap.entrySet(), java.lang.Object@15be27d=public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object), forEach=public void java.util.LinkedHashMap.forEach(java.util.function.BiConsumer), containsKey=public boolean java.util.HashMap.containsKey(java.lang.Object), isEmpty=public boolean java.util.HashMap.isEmpty(), clear=public void java.util.LinkedHashMap.clear(), computeIfPresent=public java.lang.Object java.util.HashMap.computeIfPresent(java.lang.Object,java.util.function.BiFunction), size=public int java.util.HashMap.size(), equals=public boolean java.util.AbstractMap.equals(java.lang.Object), clone=public java.lang.Object java.util.HashMap.clone(), toString=public java.lang.String java.util.AbstractMap.toString(), putIfAbsent=public java.lang.Object java.util.HashMap.putIfAbsent(java.lang.Object,java.lang.Object)}
[DEBUG] 2017-05-24: 21:05:32 freemarker.log._Log4jLoggerFactory$Log4jLogger.debug(_Log4jLoggerFactory.java:45) :  TemplateLoader.findTemplateSource("template/~~~xhtml/dynamic-attributes.ftl"): Found
[DEBUG] 2017-05-24: 21:05:32 freemarker.log._Log4jLoggerFactory$Log4jLogger.debug(_Log4jLoggerFactory.java:45) :  "template/~~~xhtml/dynamic-attributes.ftl"("zh_CN", UTF-8, parsed): using cached since jar:file:/D:/maven/repository/org/apache/struts/struts2-core/2.5.10/struts2-core-2.5.10.jar!/template/simple/dynamic-attributes.ftl hasn't changed.
[DEBUG] 2017-05-24: 21:05:32 freemarker.log._Log4jLoggerFactory$Log4jLogger.debug(_Log4jLoggerFactory.java:45) :  Couldn't find template in cache for "template/xhtml/text.ftl"("zh_CN", UTF-8, parsed); will try to load it.
[DEBUG] 2017-05-24: 21:05:32 freemarker.log._Log4jLoggerFactory$Log4jLogger.debug(_Log4jLoggerFactory.java:45) :  TemplateLoader.findTemplateSource("template/xhtml/text.ftl"): Found
[DEBUG] 2017-05-24: 21:05:32 freemarker.log._Log4jLoggerFactory$Log4jLogger.debug(_Log4jLoggerFactory.java:45) :  Loading template for "template/xhtml/text.ftl"("zh_CN", UTF-8, parsed) from "jar:file:/D:/maven/repository/org/apache/struts/struts2-core/2.5.10/struts2-core-2.5.10.jar!/template/xhtml/text.ftl"
[DEBUG] 2017-05-24: 21:05:32 freemarker.log._Log4jLoggerFactory$Log4jLogger.debug(_Log4jLoggerFactory.java:45) :  Couldn't find template in cache for "template/~~~xhtml/controlheader.ftl"("zh_CN", UTF-8, parsed); will try to load it.
[DEBUG] 2017-05-24: 21:05:32 freemarker.log._Log4jLoggerFactory$Log4jLogger.debug(_Log4jLoggerFactory.java:45) :  TemplateLoader.findTemplateSource("template/~~~xhtml/controlheader.ftl"): Found
[DEBUG] 2017-05-24: 21:05:32 freemarker.log._Log4jLoggerFactory$Log4jLogger.debug(_Log4jLoggerFactory.java:45) :  Loading template for "template/~~~xhtml/controlheader.ftl"("zh_CN", UTF-8, parsed) from "jar:file:/D:/maven/repository/org/apache/struts/struts2-core/2.5.10/struts2-core-2.5.10.jar!/template/xhtml/controlheader.ftl"
[DEBUG] 2017-05-24: 21:05:32 freemarker.log._Log4jLoggerFactory$Log4jLogger.debug(_Log4jLoggerFactory.java:45) :  Couldn't find template in cache for "template/~~~xhtml/controlheader-core.ftl"("zh_CN", UTF-8, parsed); will try to load it.
[DEBUG] 2017-05-24: 21:05:32 freemarker.log._Log4jLoggerFactory$Log4jLogger.debug(_Log4jLoggerFactory.java:45) :  TemplateLoader.findTemplateSource("template/~~~xhtml/controlheader-core.ftl"): Found
[DEBUG] 2017-05-24: 21:05:32 freemarker.log._Log4jLoggerFactory$Log4jLogger.debug(_Log4jLoggerFactory.java:45) :  Loading template for "template/~~~xhtml/controlheader-core.ftl"("zh_CN", UTF-8, parsed) from "jar:file:/D:/maven/repository/org/apache/struts/struts2-core/2.5.10/struts2-core-2.5.10.jar!/template/xhtml/controlheader-core.ftl"
[DEBUG] 2017-05-24: 21:05:32 freemarker.log._Log4jLoggerFactory$Log4jLogger.debug(_Log4jLoggerFactory.java:45) :  Key "errorposition" was not found on instance of java.util.LinkedHashMap. Introspection information for the class is: {getClass=public final native java.lang.Class java.lang.Object.getClass(), getOrDefault=public java.lang.Object java.util.LinkedHashMap.getOrDefault(java.lang.Object,java.lang.Object), computeIfAbsent=public java.lang.Object java.util.HashMap.computeIfAbsent(java.lang.Object,java.util.function.Function), values=public java.util.Collection java.util.LinkedHashMap.values(), replace=freemarker.ext.beans.OverloadedMethods@11d0265, java.lang.Object@3e55b2={public boolean java.util.HashMap.isEmpty()=[Ljava.lang.Class;@c5aa3a, public int java.util.AbstractMap.hashCode()=[Ljava.lang.Class;@74a947, public java.lang.Object java.util.HashMap.put(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@1615a91, public boolean java.util.AbstractMap.equals(java.lang.Object)=[Ljava.lang.Class;@a46ab2, public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object)=[Ljava.lang.Class;@1c389e6, public java.lang.String java.util.AbstractMap.toString()=[Ljava.lang.Class;@a23548, public boolean java.util.HashMap.containsKey(java.lang.Object)=[Ljava.lang.Class;@1be4a9f, public java.util.Set java.util.LinkedHashMap.keySet()=[Ljava.lang.Class;@44c60, public java.lang.Object java.util.HashMap.computeIfAbsent(java.lang.Object,java.util.function.Function)=[Ljava.lang.Class;@10f7dff, public java.lang.Object java.util.HashMap.clone()=[Ljava.lang.Class;@d214e3, public java.lang.Object java.util.LinkedHashMap.getOrDefault(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@1a74254, public java.util.Set java.util.LinkedHashMap.entrySet()=[Ljava.lang.Class;@1c4740c, public void java.util.LinkedHashMap.forEach(java.util.function.BiConsumer)=[Ljava.lang.Class;@1fe0c8e, public java.lang.Object java.util.HashMap.putIfAbsent(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@16f73de, public java.util.Collection java.util.LinkedHashMap.values()=[Ljava.lang.Class;@b3e45, public void java.util.LinkedHashMap.clear()=[Ljava.lang.Class;@a34e5c, public java.lang.Object java.util.HashMap.computeIfPresent(java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1fcb13a, public java.lang.Object java.util.HashMap.compute(java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1a7c258, public final native java.lang.Class java.lang.Object.getClass()=[Ljava.lang.Class;@7397f, public void java.util.HashMap.putAll(java.util.Map)=[Ljava.lang.Class;@59cd, public void java.util.LinkedHashMap.replaceAll(java.util.function.BiFunction)=[Ljava.lang.Class;@994816, public java.lang.Object java.util.HashMap.merge(java.lang.Object,java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1b1e75f, public int java.util.HashMap.size()=[Ljava.lang.Class;@bee157, public boolean java.util.LinkedHashMap.containsValue(java.lang.Object)=[Ljava.lang.Class;@5e0d7c}, replaceAll=public void java.util.LinkedHashMap.replaceAll(java.util.function.BiFunction), remove=freemarker.ext.beans.OverloadedMethods@8d3a99, containsValue=public boolean java.util.LinkedHashMap.containsValue(java.lang.Object), put=public java.lang.Object java.util.HashMap.put(java.lang.Object,java.lang.Object), empty=java.beans.PropertyDescriptor[name=empty; propertyType=boolean; readMethod=public boolean java.util.HashMap.isEmpty()], compute=public java.lang.Object java.util.HashMap.compute(java.lang.Object,java.util.function.BiFunction), hashCode=public int java.util.AbstractMap.hashCode(), putAll=public void java.util.HashMap.putAll(java.util.Map), get=public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object), merge=public java.lang.Object java.util.HashMap.merge(java.lang.Object,java.lang.Object,java.util.function.BiFunction), class=java.beans.PropertyDescriptor[name=class; propertyType=class java.lang.Class; readMethod=public final native java.lang.Class java.lang.Object.getClass()], keySet=public java.util.Set java.util.LinkedHashMap.keySet(), java.lang.Object@1c0f21d=freemarker.ext.beans.OverloadedMethods@d4b988, entrySet=public java.util.Set java.util.LinkedHashMap.entrySet(), java.lang.Object@15be27d=public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object), forEach=public void java.util.LinkedHashMap.forEach(java.util.function.BiConsumer), containsKey=public boolean java.util.HashMap.containsKey(java.lang.Object), isEmpty=public boolean java.util.HashMap.isEmpty(), clear=public void java.util.LinkedHashMap.clear(), computeIfPresent=public java.lang.Object java.util.HashMap.computeIfPresent(java.lang.Object,java.util.function.BiFunction), size=public int java.util.HashMap.size(), equals=public boolean java.util.AbstractMap.equals(java.lang.Object), clone=public java.lang.Object java.util.HashMap.clone(), toString=public java.lang.String java.util.AbstractMap.toString(), putIfAbsent=public java.lang.Object java.util.HashMap.putIfAbsent(java.lang.Object,java.lang.Object)}
[DEBUG] 2017-05-24: 21:05:32 freemarker.log._Log4jLoggerFactory$Log4jLogger.debug(_Log4jLoggerFactory.java:45) :  Key "labelposition" was not found on instance of java.util.LinkedHashMap. Introspection information for the class is: {getClass=public final native java.lang.Class java.lang.Object.getClass(), getOrDefault=public java.lang.Object java.util.LinkedHashMap.getOrDefault(java.lang.Object,java.lang.Object), computeIfAbsent=public java.lang.Object java.util.HashMap.computeIfAbsent(java.lang.Object,java.util.function.Function), values=public java.util.Collection java.util.LinkedHashMap.values(), replace=freemarker.ext.beans.OverloadedMethods@11d0265, java.lang.Object@3e55b2={public boolean java.util.HashMap.isEmpty()=[Ljava.lang.Class;@c5aa3a, public int java.util.AbstractMap.hashCode()=[Ljava.lang.Class;@74a947, public java.lang.Object java.util.HashMap.put(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@1615a91, public boolean java.util.AbstractMap.equals(java.lang.Object)=[Ljava.lang.Class;@a46ab2, public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object)=[Ljava.lang.Class;@1c389e6, public java.lang.String java.util.AbstractMap.toString()=[Ljava.lang.Class;@a23548, public boolean java.util.HashMap.containsKey(java.lang.Object)=[Ljava.lang.Class;@1be4a9f, public java.util.Set java.util.LinkedHashMap.keySet()=[Ljava.lang.Class;@44c60, public java.lang.Object java.util.HashMap.computeIfAbsent(java.lang.Object,java.util.function.Function)=[Ljava.lang.Class;@10f7dff, public java.lang.Object java.util.HashMap.clone()=[Ljava.lang.Class;@d214e3, public java.lang.Object java.util.LinkedHashMap.getOrDefault(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@1a74254, public java.util.Set java.util.LinkedHashMap.entrySet()=[Ljava.lang.Class;@1c4740c, public void java.util.LinkedHashMap.forEach(java.util.function.BiConsumer)=[Ljava.lang.Class;@1fe0c8e, public java.lang.Object java.util.HashMap.putIfAbsent(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@16f73de, public java.util.Collection java.util.LinkedHashMap.values()=[Ljava.lang.Class;@b3e45, public void java.util.LinkedHashMap.clear()=[Ljava.lang.Class;@a34e5c, public java.lang.Object java.util.HashMap.computeIfPresent(java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1fcb13a, public java.lang.Object java.util.HashMap.compute(java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1a7c258, public final native java.lang.Class java.lang.Object.getClass()=[Ljava.lang.Class;@7397f, public void java.util.HashMap.putAll(java.util.Map)=[Ljava.lang.Class;@59cd, public void java.util.LinkedHashMap.replaceAll(java.util.function.BiFunction)=[Ljava.lang.Class;@994816, public java.lang.Object java.util.HashMap.merge(java.lang.Object,java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1b1e75f, public int java.util.HashMap.size()=[Ljava.lang.Class;@bee157, public boolean java.util.LinkedHashMap.containsValue(java.lang.Object)=[Ljava.lang.Class;@5e0d7c}, replaceAll=public void java.util.LinkedHashMap.replaceAll(java.util.function.BiFunction), remove=freemarker.ext.beans.OverloadedMethods@8d3a99, containsValue=public boolean java.util.LinkedHashMap.containsValue(java.lang.Object), put=public java.lang.Object java.util.HashMap.put(java.lang.Object,java.lang.Object), empty=java.beans.PropertyDescriptor[name=empty; propertyType=boolean; readMethod=public boolean java.util.HashMap.isEmpty()], compute=public java.lang.Object java.util.HashMap.compute(java.lang.Object,java.util.function.BiFunction), hashCode=public int java.util.AbstractMap.hashCode(), putAll=public void java.util.HashMap.putAll(java.util.Map), get=public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object), merge=public java.lang.Object java.util.HashMap.merge(java.lang.Object,java.lang.Object,java.util.function.BiFunction), class=java.beans.PropertyDescriptor[name=class; propertyType=class java.lang.Class; readMethod=public final native java.lang.Class java.lang.Object.getClass()], keySet=public java.util.Set java.util.LinkedHashMap.keySet(), java.lang.Object@1c0f21d=freemarker.ext.beans.OverloadedMethods@d4b988, entrySet=public java.util.Set java.util.LinkedHashMap.entrySet(), java.lang.Object@15be27d=public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object), forEach=public void java.util.LinkedHashMap.forEach(java.util.function.BiConsumer), containsKey=public boolean java.util.HashMap.containsKey(java.lang.Object), isEmpty=public boolean java.util.HashMap.isEmpty(), clear=public void java.util.LinkedHashMap.clear(), computeIfPresent=public java.lang.Object java.util.HashMap.computeIfPresent(java.lang.Object,java.util.function.BiFunction), size=public int java.util.HashMap.size(), equals=public boolean java.util.AbstractMap.equals(java.lang.Object), clone=public java.lang.Object java.util.HashMap.clone(), toString=public java.lang.String java.util.AbstractMap.toString(), putIfAbsent=public java.lang.Object java.util.HashMap.putIfAbsent(java.lang.Object,java.lang.Object)}
[DEBUG] 2017-05-24: 21:05:32 freemarker.log._Log4jLoggerFactory$Log4jLogger.debug(_Log4jLoggerFactory.java:45) :  Key "labelposition" was not found on instance of java.util.LinkedHashMap. Introspection information for the class is: {getClass=public final native java.lang.Class java.lang.Object.getClass(), getOrDefault=public java.lang.Object java.util.LinkedHashMap.getOrDefault(java.lang.Object,java.lang.Object), computeIfAbsent=public java.lang.Object java.util.HashMap.computeIfAbsent(java.lang.Object,java.util.function.Function), values=public java.util.Collection java.util.LinkedHashMap.values(), replace=freemarker.ext.beans.OverloadedMethods@11d0265, java.lang.Object@3e55b2={public boolean java.util.HashMap.isEmpty()=[Ljava.lang.Class;@c5aa3a, public int java.util.AbstractMap.hashCode()=[Ljava.lang.Class;@74a947, public java.lang.Object java.util.HashMap.put(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@1615a91, public boolean java.util.AbstractMap.equals(java.lang.Object)=[Ljava.lang.Class;@a46ab2, public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object)=[Ljava.lang.Class;@1c389e6, public java.lang.String java.util.AbstractMap.toString()=[Ljava.lang.Class;@a23548, public boolean java.util.HashMap.containsKey(java.lang.Object)=[Ljava.lang.Class;@1be4a9f, public java.util.Set java.util.LinkedHashMap.keySet()=[Ljava.lang.Class;@44c60, public java.lang.Object java.util.HashMap.computeIfAbsent(java.lang.Object,java.util.function.Function)=[Ljava.lang.Class;@10f7dff, public java.lang.Object java.util.HashMap.clone()=[Ljava.lang.Class;@d214e3, public java.lang.Object java.util.LinkedHashMap.getOrDefault(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@1a74254, public java.util.Set java.util.LinkedHashMap.entrySet()=[Ljava.lang.Class;@1c4740c, public void java.util.LinkedHashMap.forEach(java.util.function.BiConsumer)=[Ljava.lang.Class;@1fe0c8e, public java.lang.Object java.util.HashMap.putIfAbsent(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@16f73de, public java.util.Collection java.util.LinkedHashMap.values()=[Ljava.lang.Class;@b3e45, public void java.util.LinkedHashMap.clear()=[Ljava.lang.Class;@a34e5c, public java.lang.Object java.util.HashMap.computeIfPresent(java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1fcb13a, public java.lang.Object java.util.HashMap.compute(java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1a7c258, public final native java.lang.Class java.lang.Object.getClass()=[Ljava.lang.Class;@7397f, public void java.util.HashMap.putAll(java.util.Map)=[Ljava.lang.Class;@59cd, public void java.util.LinkedHashMap.replaceAll(java.util.function.BiFunction)=[Ljava.lang.Class;@994816, public java.lang.Object java.util.HashMap.merge(java.lang.Object,java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1b1e75f, public int java.util.HashMap.size()=[Ljava.lang.Class;@bee157, public boolean java.util.LinkedHashMap.containsValue(java.lang.Object)=[Ljava.lang.Class;@5e0d7c}, replaceAll=public void java.util.LinkedHashMap.replaceAll(java.util.function.BiFunction), remove=freemarker.ext.beans.OverloadedMethods@8d3a99, containsValue=public boolean java.util.LinkedHashMap.containsValue(java.lang.Object), put=public java.lang.Object java.util.HashMap.put(java.lang.Object,java.lang.Object), empty=java.beans.PropertyDescriptor[name=empty; propertyType=boolean; readMethod=public boolean java.util.HashMap.isEmpty()], compute=public java.lang.Object java.util.HashMap.compute(java.lang.Object,java.util.function.BiFunction), hashCode=public int java.util.AbstractMap.hashCode(), putAll=public void java.util.HashMap.putAll(java.util.Map), get=public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object), merge=public java.lang.Object java.util.HashMap.merge(java.lang.Object,java.lang.Object,java.util.function.BiFunction), class=java.beans.PropertyDescriptor[name=class; propertyType=class java.lang.Class; readMethod=public final native java.lang.Class java.lang.Object.getClass()], keySet=public java.util.Set java.util.LinkedHashMap.keySet(), java.lang.Object@1c0f21d=freemarker.ext.beans.OverloadedMethods@d4b988, entrySet=public java.util.Set java.util.LinkedHashMap.entrySet(), java.lang.Object@15be27d=public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object), forEach=public void java.util.LinkedHashMap.forEach(java.util.function.BiConsumer), containsKey=public boolean java.util.HashMap.containsKey(java.lang.Object), isEmpty=public boolean java.util.HashMap.isEmpty(), clear=public void java.util.LinkedHashMap.clear(), computeIfPresent=public java.lang.Object java.util.HashMap.computeIfPresent(java.lang.Object,java.util.function.BiFunction), size=public int java.util.HashMap.size(), equals=public boolean java.util.AbstractMap.equals(java.lang.Object), clone=public java.lang.Object java.util.HashMap.clone(), toString=public java.lang.String java.util.AbstractMap.toString(), putIfAbsent=public java.lang.Object java.util.HashMap.putIfAbsent(java.lang.Object,java.lang.Object)}
[DEBUG] 2017-05-24: 21:05:32 freemarker.log._Log4jLoggerFactory$Log4jLogger.debug(_Log4jLoggerFactory.java:45) :  Key "labelposition" was not found on instance of java.util.LinkedHashMap. Introspection information for the class is: {getClass=public final native java.lang.Class java.lang.Object.getClass(), getOrDefault=public java.lang.Object java.util.LinkedHashMap.getOrDefault(java.lang.Object,java.lang.Object), computeIfAbsent=public java.lang.Object java.util.HashMap.computeIfAbsent(java.lang.Object,java.util.function.Function), values=public java.util.Collection java.util.LinkedHashMap.values(), replace=freemarker.ext.beans.OverloadedMethods@11d0265, java.lang.Object@3e55b2={public boolean java.util.HashMap.isEmpty()=[Ljava.lang.Class;@c5aa3a, public int java.util.AbstractMap.hashCode()=[Ljava.lang.Class;@74a947, public java.lang.Object java.util.HashMap.put(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@1615a91, public boolean java.util.AbstractMap.equals(java.lang.Object)=[Ljava.lang.Class;@a46ab2, public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object)=[Ljava.lang.Class;@1c389e6, public java.lang.String java.util.AbstractMap.toString()=[Ljava.lang.Class;@a23548, public boolean java.util.HashMap.containsKey(java.lang.Object)=[Ljava.lang.Class;@1be4a9f, public java.util.Set java.util.LinkedHashMap.keySet()=[Ljava.lang.Class;@44c60, public java.lang.Object java.util.HashMap.computeIfAbsent(java.lang.Object,java.util.function.Function)=[Ljava.lang.Class;@10f7dff, public java.lang.Object java.util.HashMap.clone()=[Ljava.lang.Class;@d214e3, public java.lang.Object java.util.LinkedHashMap.getOrDefault(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@1a74254, public java.util.Set java.util.LinkedHashMap.entrySet()=[Ljava.lang.Class;@1c4740c, public void java.util.LinkedHashMap.forEach(java.util.function.BiConsumer)=[Ljava.lang.Class;@1fe0c8e, public java.lang.Object java.util.HashMap.putIfAbsent(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@16f73de, public java.util.Collection java.util.LinkedHashMap.values()=[Ljava.lang.Class;@b3e45, public void java.util.LinkedHashMap.clear()=[Ljava.lang.Class;@a34e5c, public java.lang.Object java.util.HashMap.computeIfPresent(java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1fcb13a, public java.lang.Object java.util.HashMap.compute(java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1a7c258, public final native java.lang.Class java.lang.Object.getClass()=[Ljava.lang.Class;@7397f, public void java.util.HashMap.putAll(java.util.Map)=[Ljava.lang.Class;@59cd, public void java.util.LinkedHashMap.replaceAll(java.util.function.BiFunction)=[Ljava.lang.Class;@994816, public java.lang.Object java.util.HashMap.merge(java.lang.Object,java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1b1e75f, public int java.util.HashMap.size()=[Ljava.lang.Class;@bee157, public boolean java.util.LinkedHashMap.containsValue(java.lang.Object)=[Ljava.lang.Class;@5e0d7c}, replaceAll=public void java.util.LinkedHashMap.replaceAll(java.util.function.BiFunction), remove=freemarker.ext.beans.OverloadedMethods@8d3a99, containsValue=public boolean java.util.LinkedHashMap.containsValue(java.lang.Object), put=public java.lang.Object java.util.HashMap.put(java.lang.Object,java.lang.Object), empty=java.beans.PropertyDescriptor[name=empty; propertyType=boolean; readMethod=public boolean java.util.HashMap.isEmpty()], compute=public java.lang.Object java.util.HashMap.compute(java.lang.Object,java.util.function.BiFunction), hashCode=public int java.util.AbstractMap.hashCode(), putAll=public void java.util.HashMap.putAll(java.util.Map), get=public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object), merge=public java.lang.Object java.util.HashMap.merge(java.lang.Object,java.lang.Object,java.util.function.BiFunction), class=java.beans.PropertyDescriptor[name=class; propertyType=class java.lang.Class; readMethod=public final native java.lang.Class java.lang.Object.getClass()], keySet=public java.util.Set java.util.LinkedHashMap.keySet(), java.lang.Object@1c0f21d=freemarker.ext.beans.OverloadedMethods@d4b988, entrySet=public java.util.Set java.util.LinkedHashMap.entrySet(), java.lang.Object@15be27d=public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object), forEach=public void java.util.LinkedHashMap.forEach(java.util.function.BiConsumer), containsKey=public boolean java.util.HashMap.containsKey(java.lang.Object), isEmpty=public boolean java.util.HashMap.isEmpty(), clear=public void java.util.LinkedHashMap.clear(), computeIfPresent=public java.lang.Object java.util.HashMap.computeIfPresent(java.lang.Object,java.util.function.BiFunction), size=public int java.util.HashMap.size(), equals=public boolean java.util.AbstractMap.equals(java.lang.Object), clone=public java.lang.Object java.util.HashMap.clone(), toString=public java.lang.String java.util.AbstractMap.toString(), putIfAbsent=public java.lang.Object java.util.HashMap.putIfAbsent(java.lang.Object,java.lang.Object)}
[DEBUG] 2017-05-24: 21:05:32 freemarker.log._Log4jLoggerFactory$Log4jLogger.debug(_Log4jLoggerFactory.java:45) :  Key "required" was not found on instance of java.util.LinkedHashMap. Introspection information for the class is: {getClass=public final native java.lang.Class java.lang.Object.getClass(), getOrDefault=public java.lang.Object java.util.LinkedHashMap.getOrDefault(java.lang.Object,java.lang.Object), computeIfAbsent=public java.lang.Object java.util.HashMap.computeIfAbsent(java.lang.Object,java.util.function.Function), values=public java.util.Collection java.util.LinkedHashMap.values(), replace=freemarker.ext.beans.OverloadedMethods@11d0265, java.lang.Object@3e55b2={public boolean java.util.HashMap.isEmpty()=[Ljava.lang.Class;@c5aa3a, public int java.util.AbstractMap.hashCode()=[Ljava.lang.Class;@74a947, public java.lang.Object java.util.HashMap.put(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@1615a91, public boolean java.util.AbstractMap.equals(java.lang.Object)=[Ljava.lang.Class;@a46ab2, public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object)=[Ljava.lang.Class;@1c389e6, public java.lang.String java.util.AbstractMap.toString()=[Ljava.lang.Class;@a23548, public boolean java.util.HashMap.containsKey(java.lang.Object)=[Ljava.lang.Class;@1be4a9f, public java.util.Set java.util.LinkedHashMap.keySet()=[Ljava.lang.Class;@44c60, public java.lang.Object java.util.HashMap.computeIfAbsent(java.lang.Object,java.util.function.Function)=[Ljava.lang.Class;@10f7dff, public java.lang.Object java.util.HashMap.clone()=[Ljava.lang.Class;@d214e3, public java.lang.Object java.util.LinkedHashMap.getOrDefault(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@1a74254, public java.util.Set java.util.LinkedHashMap.entrySet()=[Ljava.lang.Class;@1c4740c, public void java.util.LinkedHashMap.forEach(java.util.function.BiConsumer)=[Ljava.lang.Class;@1fe0c8e, public java.lang.Object java.util.HashMap.putIfAbsent(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@16f73de, public java.util.Collection java.util.LinkedHashMap.values()=[Ljava.lang.Class;@b3e45, public void java.util.LinkedHashMap.clear()=[Ljava.lang.Class;@a34e5c, public java.lang.Object java.util.HashMap.computeIfPresent(java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1fcb13a, public java.lang.Object java.util.HashMap.compute(java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1a7c258, public final native java.lang.Class java.lang.Object.getClass()=[Ljava.lang.Class;@7397f, public void java.util.HashMap.putAll(java.util.Map)=[Ljava.lang.Class;@59cd, public void java.util.LinkedHashMap.replaceAll(java.util.function.BiFunction)=[Ljava.lang.Class;@994816, public java.lang.Object java.util.HashMap.merge(java.lang.Object,java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1b1e75f, public int java.util.HashMap.size()=[Ljava.lang.Class;@bee157, public boolean java.util.LinkedHashMap.containsValue(java.lang.Object)=[Ljava.lang.Class;@5e0d7c}, replaceAll=public void java.util.LinkedHashMap.replaceAll(java.util.function.BiFunction), remove=freemarker.ext.beans.OverloadedMethods@8d3a99, containsValue=public boolean java.util.LinkedHashMap.containsValue(java.lang.Object), put=public java.lang.Object java.util.HashMap.put(java.lang.Object,java.lang.Object), empty=java.beans.PropertyDescriptor[name=empty; propertyType=boolean; readMethod=public boolean java.util.HashMap.isEmpty()], compute=public java.lang.Object java.util.HashMap.compute(java.lang.Object,java.util.function.BiFunction), hashCode=public int java.util.AbstractMap.hashCode(), putAll=public void java.util.HashMap.putAll(java.util.Map), get=public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object), merge=public java.lang.Object java.util.HashMap.merge(java.lang.Object,java.lang.Object,java.util.function.BiFunction), class=java.beans.PropertyDescriptor[name=class; propertyType=class java.lang.Class; readMethod=public final native java.lang.Class java.lang.Object.getClass()], keySet=public java.util.Set java.util.LinkedHashMap.keySet(), java.lang.Object@1c0f21d=freemarker.ext.beans.OverloadedMethods@d4b988, entrySet=public java.util.Set java.util.LinkedHashMap.entrySet(), java.lang.Object@15be27d=public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object), forEach=public void java.util.LinkedHashMap.forEach(java.util.function.BiConsumer), containsKey=public boolean java.util.HashMap.containsKey(java.lang.Object), isEmpty=public boolean java.util.HashMap.isEmpty(), clear=public void java.util.LinkedHashMap.clear(), computeIfPresent=public java.lang.Object java.util.HashMap.computeIfPresent(java.lang.Object,java.util.function.BiFunction), size=public int java.util.HashMap.size(), equals=public boolean java.util.AbstractMap.equals(java.lang.Object), clone=public java.lang.Object java.util.HashMap.clone(), toString=public java.lang.String java.util.AbstractMap.toString(), putIfAbsent=public java.lang.Object java.util.HashMap.putIfAbsent(java.lang.Object,java.lang.Object)}
[DEBUG] 2017-05-24: 21:05:32 freemarker.log._Log4jLoggerFactory$Log4jLogger.debug(_Log4jLoggerFactory.java:45) :  Key "required" was not found on instance of java.util.LinkedHashMap. Introspection information for the class is: {getClass=public final native java.lang.Class java.lang.Object.getClass(), getOrDefault=public java.lang.Object java.util.LinkedHashMap.getOrDefault(java.lang.Object,java.lang.Object), computeIfAbsent=public java.lang.Object java.util.HashMap.computeIfAbsent(java.lang.Object,java.util.function.Function), values=public java.util.Collection java.util.LinkedHashMap.values(), replace=freemarker.ext.beans.OverloadedMethods@11d0265, java.lang.Object@3e55b2={public boolean java.util.HashMap.isEmpty()=[Ljava.lang.Class;@c5aa3a, public int java.util.AbstractMap.hashCode()=[Ljava.lang.Class;@74a947, public java.lang.Object java.util.HashMap.put(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@1615a91, public boolean java.util.AbstractMap.equals(java.lang.Object)=[Ljava.lang.Class;@a46ab2, public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object)=[Ljava.lang.Class;@1c389e6, public java.lang.String java.util.AbstractMap.toString()=[Ljava.lang.Class;@a23548, public boolean java.util.HashMap.containsKey(java.lang.Object)=[Ljava.lang.Class;@1be4a9f, public java.util.Set java.util.LinkedHashMap.keySet()=[Ljava.lang.Class;@44c60, public java.lang.Object java.util.HashMap.computeIfAbsent(java.lang.Object,java.util.function.Function)=[Ljava.lang.Class;@10f7dff, public java.lang.Object java.util.HashMap.clone()=[Ljava.lang.Class;@d214e3, public java.lang.Object java.util.LinkedHashMap.getOrDefault(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@1a74254, public java.util.Set java.util.LinkedHashMap.entrySet()=[Ljava.lang.Class;@1c4740c, public void java.util.LinkedHashMap.forEach(java.util.function.BiConsumer)=[Ljava.lang.Class;@1fe0c8e, public java.lang.Object java.util.HashMap.putIfAbsent(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@16f73de, public java.util.Collection java.util.LinkedHashMap.values()=[Ljava.lang.Class;@b3e45, public void java.util.LinkedHashMap.clear()=[Ljava.lang.Class;@a34e5c, public java.lang.Object java.util.HashMap.computeIfPresent(java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1fcb13a, public java.lang.Object java.util.HashMap.compute(java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1a7c258, public final native java.lang.Class java.lang.Object.getClass()=[Ljava.lang.Class;@7397f, public void java.util.HashMap.putAll(java.util.Map)=[Ljava.lang.Class;@59cd, public void java.util.LinkedHashMap.replaceAll(java.util.function.BiFunction)=[Ljava.lang.Class;@994816, public java.lang.Object java.util.HashMap.merge(java.lang.Object,java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1b1e75f, public int java.util.HashMap.size()=[Ljava.lang.Class;@bee157, public boolean java.util.LinkedHashMap.containsValue(java.lang.Object)=[Ljava.lang.Class;@5e0d7c}, replaceAll=public void java.util.LinkedHashMap.replaceAll(java.util.function.BiFunction), remove=freemarker.ext.beans.OverloadedMethods@8d3a99, containsValue=public boolean java.util.LinkedHashMap.containsValue(java.lang.Object), put=public java.lang.Object java.util.HashMap.put(java.lang.Object,java.lang.Object), empty=java.beans.PropertyDescriptor[name=empty; propertyType=boolean; readMethod=public boolean java.util.HashMap.isEmpty()], compute=public java.lang.Object java.util.HashMap.compute(java.lang.Object,java.util.function.BiFunction), hashCode=public int java.util.AbstractMap.hashCode(), putAll=public void java.util.HashMap.putAll(java.util.Map), get=public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object), merge=public java.lang.Object java.util.HashMap.merge(java.lang.Object,java.lang.Object,java.util.function.BiFunction), class=java.beans.PropertyDescriptor[name=class; propertyType=class java.lang.Class; readMethod=public final native java.lang.Class java.lang.Object.getClass()], keySet=public java.util.Set java.util.LinkedHashMap.keySet(), java.lang.Object@1c0f21d=freemarker.ext.beans.OverloadedMethods@d4b988, entrySet=public java.util.Set java.util.LinkedHashMap.entrySet(), java.lang.Object@15be27d=public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object), forEach=public void java.util.LinkedHashMap.forEach(java.util.function.BiConsumer), containsKey=public boolean java.util.HashMap.containsKey(java.lang.Object), isEmpty=public boolean java.util.HashMap.isEmpty(), clear=public void java.util.LinkedHashMap.clear(), computeIfPresent=public java.lang.Object java.util.HashMap.computeIfPresent(java.lang.Object,java.util.function.BiFunction), size=public int java.util.HashMap.size(), equals=public boolean java.util.AbstractMap.equals(java.lang.Object), clone=public java.lang.Object java.util.HashMap.clone(), toString=public java.lang.String java.util.AbstractMap.toString(), putIfAbsent=public java.lang.Object java.util.HashMap.putIfAbsent(java.lang.Object,java.lang.Object)}
[DEBUG] 2017-05-24: 21:05:32 freemarker.log._Log4jLoggerFactory$Log4jLogger.debug(_Log4jLoggerFactory.java:45) :  Key "labelseparator" was not found on instance of java.util.LinkedHashMap. Introspection information for the class is: {getClass=public final native java.lang.Class java.lang.Object.getClass(), getOrDefault=public java.lang.Object java.util.LinkedHashMap.getOrDefault(java.lang.Object,java.lang.Object), computeIfAbsent=public java.lang.Object java.util.HashMap.computeIfAbsent(java.lang.Object,java.util.function.Function), values=public java.util.Collection java.util.LinkedHashMap.values(), replace=freemarker.ext.beans.OverloadedMethods@11d0265, java.lang.Object@3e55b2={public boolean java.util.HashMap.isEmpty()=[Ljava.lang.Class;@c5aa3a, public int java.util.AbstractMap.hashCode()=[Ljava.lang.Class;@74a947, public java.lang.Object java.util.HashMap.put(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@1615a91, public boolean java.util.AbstractMap.equals(java.lang.Object)=[Ljava.lang.Class;@a46ab2, public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object)=[Ljava.lang.Class;@1c389e6, public java.lang.String java.util.AbstractMap.toString()=[Ljava.lang.Class;@a23548, public boolean java.util.HashMap.containsKey(java.lang.Object)=[Ljava.lang.Class;@1be4a9f, public java.util.Set java.util.LinkedHashMap.keySet()=[Ljava.lang.Class;@44c60, public java.lang.Object java.util.HashMap.computeIfAbsent(java.lang.Object,java.util.function.Function)=[Ljava.lang.Class;@10f7dff, public java.lang.Object java.util.HashMap.clone()=[Ljava.lang.Class;@d214e3, public java.lang.Object java.util.LinkedHashMap.getOrDefault(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@1a74254, public java.util.Set java.util.LinkedHashMap.entrySet()=[Ljava.lang.Class;@1c4740c, public void java.util.LinkedHashMap.forEach(java.util.function.BiConsumer)=[Ljava.lang.Class;@1fe0c8e, public java.lang.Object java.util.HashMap.putIfAbsent(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@16f73de, public java.util.Collection java.util.LinkedHashMap.values()=[Ljava.lang.Class;@b3e45, public void java.util.LinkedHashMap.clear()=[Ljava.lang.Class;@a34e5c, public java.lang.Object java.util.HashMap.computeIfPresent(java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1fcb13a, public java.lang.Object java.util.HashMap.compute(java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1a7c258, public final native java.lang.Class java.lang.Object.getClass()=[Ljava.lang.Class;@7397f, public void java.util.HashMap.putAll(java.util.Map)=[Ljava.lang.Class;@59cd, public void java.util.LinkedHashMap.replaceAll(java.util.function.BiFunction)=[Ljava.lang.Class;@994816, public java.lang.Object java.util.HashMap.merge(java.lang.Object,java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1b1e75f, public int java.util.HashMap.size()=[Ljava.lang.Class;@bee157, public boolean java.util.LinkedHashMap.containsValue(java.lang.Object)=[Ljava.lang.Class;@5e0d7c}, replaceAll=public void java.util.LinkedHashMap.replaceAll(java.util.function.BiFunction), remove=freemarker.ext.beans.OverloadedMethods@8d3a99, containsValue=public boolean java.util.LinkedHashMap.containsValue(java.lang.Object), put=public java.lang.Object java.util.HashMap.put(java.lang.Object,java.lang.Object), empty=java.beans.PropertyDescriptor[name=empty; propertyType=boolean; readMethod=public boolean java.util.HashMap.isEmpty()], compute=public java.lang.Object java.util.HashMap.compute(java.lang.Object,java.util.function.BiFunction), hashCode=public int java.util.AbstractMap.hashCode(), putAll=public void java.util.HashMap.putAll(java.util.Map), get=public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object), merge=public java.lang.Object java.util.HashMap.merge(java.lang.Object,java.lang.Object,java.util.function.BiFunction), class=java.beans.PropertyDescriptor[name=class; propertyType=class java.lang.Class; readMethod=public final native java.lang.Class java.lang.Object.getClass()], keySet=public java.util.Set java.util.LinkedHashMap.keySet(), java.lang.Object@1c0f21d=freemarker.ext.beans.OverloadedMethods@d4b988, entrySet=public java.util.Set java.util.LinkedHashMap.entrySet(), java.lang.Object@15be27d=public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object), forEach=public void java.util.LinkedHashMap.forEach(java.util.function.BiConsumer), containsKey=public boolean java.util.HashMap.containsKey(java.lang.Object), isEmpty=public boolean java.util.HashMap.isEmpty(), clear=public void java.util.LinkedHashMap.clear(), computeIfPresent=public java.lang.Object java.util.HashMap.computeIfPresent(java.lang.Object,java.util.function.BiFunction), size=public int java.util.HashMap.size(), equals=public boolean java.util.AbstractMap.equals(java.lang.Object), clone=public java.lang.Object java.util.HashMap.clone(), toString=public java.lang.String java.util.AbstractMap.toString(), putIfAbsent=public java.lang.Object java.util.HashMap.putIfAbsent(java.lang.Object,java.lang.Object)}
[DEBUG] 2017-05-24: 21:05:32 freemarker.log._Log4jLoggerFactory$Log4jLogger.debug(_Log4jLoggerFactory.java:45) :  Couldn't find template in cache for "template/~~~xhtml/tooltip.ftl"("zh_CN", UTF-8, parsed); will try to load it.
[DEBUG] 2017-05-24: 21:05:32 freemarker.log._Log4jLoggerFactory$Log4jLogger.debug(_Log4jLoggerFactory.java:45) :  TemplateLoader.findTemplateSource("template/~~~xhtml/tooltip.ftl"): Found
[DEBUG] 2017-05-24: 21:05:32 freemarker.log._Log4jLoggerFactory$Log4jLogger.debug(_Log4jLoggerFactory.java:45) :  Loading template for "template/~~~xhtml/tooltip.ftl"("zh_CN", UTF-8, parsed) from "jar:file:/D:/maven/repository/org/apache/struts/struts2-core/2.5.10/struts2-core-2.5.10.jar!/template/xhtml/tooltip.ftl"
[DEBUG] 2017-05-24: 21:05:32 freemarker.log._Log4jLoggerFactory$Log4jLogger.debug(_Log4jLoggerFactory.java:45) :  Key "tooltip" was not found on instance of java.util.LinkedHashMap. Introspection information for the class is: {getClass=public final native java.lang.Class java.lang.Object.getClass(), getOrDefault=public java.lang.Object java.util.LinkedHashMap.getOrDefault(java.lang.Object,java.lang.Object), computeIfAbsent=public java.lang.Object java.util.HashMap.computeIfAbsent(java.lang.Object,java.util.function.Function), values=public java.util.Collection java.util.LinkedHashMap.values(), replace=freemarker.ext.beans.OverloadedMethods@11d0265, java.lang.Object@3e55b2={public boolean java.util.HashMap.isEmpty()=[Ljava.lang.Class;@c5aa3a, public int java.util.AbstractMap.hashCode()=[Ljava.lang.Class;@74a947, public java.lang.Object java.util.HashMap.put(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@1615a91, public boolean java.util.AbstractMap.equals(java.lang.Object)=[Ljava.lang.Class;@a46ab2, public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object)=[Ljava.lang.Class;@1c389e6, public java.lang.String java.util.AbstractMap.toString()=[Ljava.lang.Class;@a23548, public boolean java.util.HashMap.containsKey(java.lang.Object)=[Ljava.lang.Class;@1be4a9f, public java.util.Set java.util.LinkedHashMap.keySet()=[Ljava.lang.Class;@44c60, public java.lang.Object java.util.HashMap.computeIfAbsent(java.lang.Object,java.util.function.Function)=[Ljava.lang.Class;@10f7dff, public java.lang.Object java.util.HashMap.clone()=[Ljava.lang.Class;@d214e3, public java.lang.Object java.util.LinkedHashMap.getOrDefault(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@1a74254, public java.util.Set java.util.LinkedHashMap.entrySet()=[Ljava.lang.Class;@1c4740c, public void java.util.LinkedHashMap.forEach(java.util.function.BiConsumer)=[Ljava.lang.Class;@1fe0c8e, public java.lang.Object java.util.HashMap.putIfAbsent(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@16f73de, public java.util.Collection java.util.LinkedHashMap.values()=[Ljava.lang.Class;@b3e45, public void java.util.LinkedHashMap.clear()=[Ljava.lang.Class;@a34e5c, public java.lang.Object java.util.HashMap.computeIfPresent(java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1fcb13a, public java.lang.Object java.util.HashMap.compute(java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1a7c258, public final native java.lang.Class java.lang.Object.getClass()=[Ljava.lang.Class;@7397f, public void java.util.HashMap.putAll(java.util.Map)=[Ljava.lang.Class;@59cd, public void java.util.LinkedHashMap.replaceAll(java.util.function.BiFunction)=[Ljava.lang.Class;@994816, public java.lang.Object java.util.HashMap.merge(java.lang.Object,java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1b1e75f, public int java.util.HashMap.size()=[Ljava.lang.Class;@bee157, public boolean java.util.LinkedHashMap.containsValue(java.lang.Object)=[Ljava.lang.Class;@5e0d7c}, replaceAll=public void java.util.LinkedHashMap.replaceAll(java.util.function.BiFunction), remove=freemarker.ext.beans.OverloadedMethods@8d3a99, containsValue=public boolean java.util.LinkedHashMap.containsValue(java.lang.Object), put=public java.lang.Object java.util.HashMap.put(java.lang.Object,java.lang.Object), empty=java.beans.PropertyDescriptor[name=empty; propertyType=boolean; readMethod=public boolean java.util.HashMap.isEmpty()], compute=public java.lang.Object java.util.HashMap.compute(java.lang.Object,java.util.function.BiFunction), hashCode=public int java.util.AbstractMap.hashCode(), putAll=public void java.util.HashMap.putAll(java.util.Map), get=public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object), merge=public java.lang.Object java.util.HashMap.merge(java.lang.Object,java.lang.Object,java.util.function.BiFunction), class=java.beans.PropertyDescriptor[name=class; propertyType=class java.lang.Class; readMethod=public final native java.lang.Class java.lang.Object.getClass()], keySet=public java.util.Set java.util.LinkedHashMap.keySet(), java.lang.Object@1c0f21d=freemarker.ext.beans.OverloadedMethods@d4b988, entrySet=public java.util.Set java.util.LinkedHashMap.entrySet(), java.lang.Object@15be27d=public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object), forEach=public void java.util.LinkedHashMap.forEach(java.util.function.BiConsumer), containsKey=public boolean java.util.HashMap.containsKey(java.lang.Object), isEmpty=public boolean java.util.HashMap.isEmpty(), clear=public void java.util.LinkedHashMap.clear(), computeIfPresent=public java.lang.Object java.util.HashMap.computeIfPresent(java.lang.Object,java.util.function.BiFunction), size=public int java.util.HashMap.size(), equals=public boolean java.util.AbstractMap.equals(java.lang.Object), clone=public java.lang.Object java.util.HashMap.clone(), toString=public java.lang.String java.util.AbstractMap.toString(), putIfAbsent=public java.lang.Object java.util.HashMap.putIfAbsent(java.lang.Object,java.lang.Object)}
[DEBUG] 2017-05-24: 21:05:32 freemarker.log._Log4jLoggerFactory$Log4jLogger.debug(_Log4jLoggerFactory.java:45) :  Key "align" was not found on instance of java.util.LinkedHashMap. Introspection information for the class is: {getClass=public final native java.lang.Class java.lang.Object.getClass(), getOrDefault=public java.lang.Object java.util.LinkedHashMap.getOrDefault(java.lang.Object,java.lang.Object), computeIfAbsent=public java.lang.Object java.util.HashMap.computeIfAbsent(java.lang.Object,java.util.function.Function), values=public java.util.Collection java.util.LinkedHashMap.values(), replace=freemarker.ext.beans.OverloadedMethods@11d0265, java.lang.Object@3e55b2={public boolean java.util.HashMap.isEmpty()=[Ljava.lang.Class;@c5aa3a, public int java.util.AbstractMap.hashCode()=[Ljava.lang.Class;@74a947, public java.lang.Object java.util.HashMap.put(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@1615a91, public boolean java.util.AbstractMap.equals(java.lang.Object)=[Ljava.lang.Class;@a46ab2, public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object)=[Ljava.lang.Class;@1c389e6, public java.lang.String java.util.AbstractMap.toString()=[Ljava.lang.Class;@a23548, public boolean java.util.HashMap.containsKey(java.lang.Object)=[Ljava.lang.Class;@1be4a9f, public java.util.Set java.util.LinkedHashMap.keySet()=[Ljava.lang.Class;@44c60, public java.lang.Object java.util.HashMap.computeIfAbsent(java.lang.Object,java.util.function.Function)=[Ljava.lang.Class;@10f7dff, public java.lang.Object java.util.HashMap.clone()=[Ljava.lang.Class;@d214e3, public java.lang.Object java.util.LinkedHashMap.getOrDefault(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@1a74254, public java.util.Set java.util.LinkedHashMap.entrySet()=[Ljava.lang.Class;@1c4740c, public void java.util.LinkedHashMap.forEach(java.util.function.BiConsumer)=[Ljava.lang.Class;@1fe0c8e, public java.lang.Object java.util.HashMap.putIfAbsent(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@16f73de, public java.util.Collection java.util.LinkedHashMap.values()=[Ljava.lang.Class;@b3e45, public void java.util.LinkedHashMap.clear()=[Ljava.lang.Class;@a34e5c, public java.lang.Object java.util.HashMap.computeIfPresent(java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1fcb13a, public java.lang.Object java.util.HashMap.compute(java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1a7c258, public final native java.lang.Class java.lang.Object.getClass()=[Ljava.lang.Class;@7397f, public void java.util.HashMap.putAll(java.util.Map)=[Ljava.lang.Class;@59cd, public void java.util.LinkedHashMap.replaceAll(java.util.function.BiFunction)=[Ljava.lang.Class;@994816, public java.lang.Object java.util.HashMap.merge(java.lang.Object,java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1b1e75f, public int java.util.HashMap.size()=[Ljava.lang.Class;@bee157, public boolean java.util.LinkedHashMap.containsValue(java.lang.Object)=[Ljava.lang.Class;@5e0d7c}, replaceAll=public void java.util.LinkedHashMap.replaceAll(java.util.function.BiFunction), remove=freemarker.ext.beans.OverloadedMethods@8d3a99, containsValue=public boolean java.util.LinkedHashMap.containsValue(java.lang.Object), put=public java.lang.Object java.util.HashMap.put(java.lang.Object,java.lang.Object), empty=java.beans.PropertyDescriptor[name=empty; propertyType=boolean; readMethod=public boolean java.util.HashMap.isEmpty()], compute=public java.lang.Object java.util.HashMap.compute(java.lang.Object,java.util.function.BiFunction), hashCode=public int java.util.AbstractMap.hashCode(), putAll=public void java.util.HashMap.putAll(java.util.Map), get=public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object), merge=public java.lang.Object java.util.HashMap.merge(java.lang.Object,java.lang.Object,java.util.function.BiFunction), class=java.beans.PropertyDescriptor[name=class; propertyType=class java.lang.Class; readMethod=public final native java.lang.Class java.lang.Object.getClass()], keySet=public java.util.Set java.util.LinkedHashMap.keySet(), java.lang.Object@1c0f21d=freemarker.ext.beans.OverloadedMethods@d4b988, entrySet=public java.util.Set java.util.LinkedHashMap.entrySet(), java.lang.Object@15be27d=public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object), forEach=public void java.util.LinkedHashMap.forEach(java.util.function.BiConsumer), containsKey=public boolean java.util.HashMap.containsKey(java.lang.Object), isEmpty=public boolean java.util.HashMap.isEmpty(), clear=public void java.util.LinkedHashMap.clear(), computeIfPresent=public java.lang.Object java.util.HashMap.computeIfPresent(java.lang.Object,java.util.function.BiFunction), size=public int java.util.HashMap.size(), equals=public boolean java.util.AbstractMap.equals(java.lang.Object), clone=public java.lang.Object java.util.HashMap.clone(), toString=public java.lang.String java.util.AbstractMap.toString(), putIfAbsent=public java.lang.Object java.util.HashMap.putIfAbsent(java.lang.Object,java.lang.Object)}
[DEBUG] 2017-05-24: 21:05:32 freemarker.log._Log4jLoggerFactory$Log4jLogger.debug(_Log4jLoggerFactory.java:45) :  Couldn't find template in cache for "template/simple/text.ftl"("zh_CN", UTF-8, parsed); will try to load it.
[DEBUG] 2017-05-24: 21:05:32 freemarker.log._Log4jLoggerFactory$Log4jLogger.debug(_Log4jLoggerFactory.java:45) :  TemplateLoader.findTemplateSource("template/simple/text.ftl"): Found
[DEBUG] 2017-05-24: 21:05:32 freemarker.log._Log4jLoggerFactory$Log4jLogger.debug(_Log4jLoggerFactory.java:45) :  Loading template for "template/simple/text.ftl"("zh_CN", UTF-8, parsed) from "jar:file:/D:/maven/repository/org/apache/struts/struts2-core/2.5.10/struts2-core-2.5.10.jar!/template/simple/text.ftl"
[DEBUG] 2017-05-24: 21:05:32 freemarker.log._Log4jLoggerFactory$Log4jLogger.debug(_Log4jLoggerFactory.java:45) :  Key "type" was not found on instance of java.util.LinkedHashMap. Introspection information for the class is: {getClass=public final native java.lang.Class java.lang.Object.getClass(), getOrDefault=public java.lang.Object java.util.LinkedHashMap.getOrDefault(java.lang.Object,java.lang.Object), computeIfAbsent=public java.lang.Object java.util.HashMap.computeIfAbsent(java.lang.Object,java.util.function.Function), values=public java.util.Collection java.util.LinkedHashMap.values(), replace=freemarker.ext.beans.OverloadedMethods@11d0265, java.lang.Object@3e55b2={public boolean java.util.HashMap.isEmpty()=[Ljava.lang.Class;@c5aa3a, public int java.util.AbstractMap.hashCode()=[Ljava.lang.Class;@74a947, public java.lang.Object java.util.HashMap.put(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@1615a91, public boolean java.util.AbstractMap.equals(java.lang.Object)=[Ljava.lang.Class;@a46ab2, public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object)=[Ljava.lang.Class;@1c389e6, public java.lang.String java.util.AbstractMap.toString()=[Ljava.lang.Class;@a23548, public boolean java.util.HashMap.containsKey(java.lang.Object)=[Ljava.lang.Class;@1be4a9f, public java.util.Set java.util.LinkedHashMap.keySet()=[Ljava.lang.Class;@44c60, public java.lang.Object java.util.HashMap.computeIfAbsent(java.lang.Object,java.util.function.Function)=[Ljava.lang.Class;@10f7dff, public java.lang.Object java.util.HashMap.clone()=[Ljava.lang.Class;@d214e3, public java.lang.Object java.util.LinkedHashMap.getOrDefault(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@1a74254, public java.util.Set java.util.LinkedHashMap.entrySet()=[Ljava.lang.Class;@1c4740c, public void java.util.LinkedHashMap.forEach(java.util.function.BiConsumer)=[Ljava.lang.Class;@1fe0c8e, public java.lang.Object java.util.HashMap.putIfAbsent(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@16f73de, public java.util.Collection java.util.LinkedHashMap.values()=[Ljava.lang.Class;@b3e45, public void java.util.LinkedHashMap.clear()=[Ljava.lang.Class;@a34e5c, public java.lang.Object java.util.HashMap.computeIfPresent(java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1fcb13a, public java.lang.Object java.util.HashMap.compute(java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1a7c258, public final native java.lang.Class java.lang.Object.getClass()=[Ljava.lang.Class;@7397f, public void java.util.HashMap.putAll(java.util.Map)=[Ljava.lang.Class;@59cd, public void java.util.LinkedHashMap.replaceAll(java.util.function.BiFunction)=[Ljava.lang.Class;@994816, public java.lang.Object java.util.HashMap.merge(java.lang.Object,java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1b1e75f, public int java.util.HashMap.size()=[Ljava.lang.Class;@bee157, public boolean java.util.LinkedHashMap.containsValue(java.lang.Object)=[Ljava.lang.Class;@5e0d7c}, replaceAll=public void java.util.LinkedHashMap.replaceAll(java.util.function.BiFunction), remove=freemarker.ext.beans.OverloadedMethods@8d3a99, containsValue=public boolean java.util.LinkedHashMap.containsValue(java.lang.Object), put=public java.lang.Object java.util.HashMap.put(java.lang.Object,java.lang.Object), empty=java.beans.PropertyDescriptor[name=empty; propertyType=boolean; readMethod=public boolean java.util.HashMap.isEmpty()], compute=public java.lang.Object java.util.HashMap.compute(java.lang.Object,java.util.function.BiFunction), hashCode=public int java.util.AbstractMap.hashCode(), putAll=public void java.util.HashMap.putAll(java.util.Map), get=public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object), merge=public java.lang.Object java.util.HashMap.merge(java.lang.Object,java.lang.Object,java.util.function.BiFunction), class=java.beans.PropertyDescriptor[name=class; propertyType=class java.lang.Class; readMethod=public final native java.lang.Class java.lang.Object.getClass()], keySet=public java.util.Set java.util.LinkedHashMap.keySet(), java.lang.Object@1c0f21d=freemarker.ext.beans.OverloadedMethods@d4b988, entrySet=public java.util.Set java.util.LinkedHashMap.entrySet(), java.lang.Object@15be27d=public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object), forEach=public void java.util.LinkedHashMap.forEach(java.util.function.BiConsumer), containsKey=public boolean java.util.HashMap.containsKey(java.lang.Object), isEmpty=public boolean java.util.HashMap.isEmpty(), clear=public void java.util.LinkedHashMap.clear(), computeIfPresent=public java.lang.Object java.util.HashMap.computeIfPresent(java.lang.Object,java.util.function.BiFunction), size=public int java.util.HashMap.size(), equals=public boolean java.util.AbstractMap.equals(java.lang.Object), clone=public java.lang.Object java.util.HashMap.clone(), toString=public java.lang.String java.util.AbstractMap.toString(), putIfAbsent=public java.lang.Object java.util.HashMap.putIfAbsent(java.lang.Object,java.lang.Object)}
[DEBUG] 2017-05-24: 21:05:32 freemarker.log._Log4jLoggerFactory$Log4jLogger.debug(_Log4jLoggerFactory.java:45) :  Key "maxlength" was not found on instance of java.util.LinkedHashMap. Introspection information for the class is: {getClass=public final native java.lang.Class java.lang.Object.getClass(), getOrDefault=public java.lang.Object java.util.LinkedHashMap.getOrDefault(java.lang.Object,java.lang.Object), computeIfAbsent=public java.lang.Object java.util.HashMap.computeIfAbsent(java.lang.Object,java.util.function.Function), values=public java.util.Collection java.util.LinkedHashMap.values(), replace=freemarker.ext.beans.OverloadedMethods@11d0265, java.lang.Object@3e55b2={public boolean java.util.HashMap.isEmpty()=[Ljava.lang.Class;@c5aa3a, public int java.util.AbstractMap.hashCode()=[Ljava.lang.Class;@74a947, public java.lang.Object java.util.HashMap.put(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@1615a91, public boolean java.util.AbstractMap.equals(java.lang.Object)=[Ljava.lang.Class;@a46ab2, public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object)=[Ljava.lang.Class;@1c389e6, public java.lang.String java.util.AbstractMap.toString()=[Ljava.lang.Class;@a23548, public boolean java.util.HashMap.containsKey(java.lang.Object)=[Ljava.lang.Class;@1be4a9f, public java.util.Set java.util.LinkedHashMap.keySet()=[Ljava.lang.Class;@44c60, public java.lang.Object java.util.HashMap.computeIfAbsent(java.lang.Object,java.util.function.Function)=[Ljava.lang.Class;@10f7dff, public java.lang.Object java.util.HashMap.clone()=[Ljava.lang.Class;@d214e3, public java.lang.Object java.util.LinkedHashMap.getOrDefault(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@1a74254, public java.util.Set java.util.LinkedHashMap.entrySet()=[Ljava.lang.Class;@1c4740c, public void java.util.LinkedHashMap.forEach(java.util.function.BiConsumer)=[Ljava.lang.Class;@1fe0c8e, public java.lang.Object java.util.HashMap.putIfAbsent(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@16f73de, public java.util.Collection java.util.LinkedHashMap.values()=[Ljava.lang.Class;@b3e45, public void java.util.LinkedHashMap.clear()=[Ljava.lang.Class;@a34e5c, public java.lang.Object java.util.HashMap.computeIfPresent(java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1fcb13a, public java.lang.Object java.util.HashMap.compute(java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1a7c258, public final native java.lang.Class java.lang.Object.getClass()=[Ljava.lang.Class;@7397f, public void java.util.HashMap.putAll(java.util.Map)=[Ljava.lang.Class;@59cd, public void java.util.LinkedHashMap.replaceAll(java.util.function.BiFunction)=[Ljava.lang.Class;@994816, public java.lang.Object java.util.HashMap.merge(java.lang.Object,java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1b1e75f, public int java.util.HashMap.size()=[Ljava.lang.Class;@bee157, public boolean java.util.LinkedHashMap.containsValue(java.lang.Object)=[Ljava.lang.Class;@5e0d7c}, replaceAll=public void java.util.LinkedHashMap.replaceAll(java.util.function.BiFunction), remove=freemarker.ext.beans.OverloadedMethods@8d3a99, containsValue=public boolean java.util.LinkedHashMap.containsValue(java.lang.Object), put=public java.lang.Object java.util.HashMap.put(java.lang.Object,java.lang.Object), empty=java.beans.PropertyDescriptor[name=empty; propertyType=boolean; readMethod=public boolean java.util.HashMap.isEmpty()], compute=public java.lang.Object java.util.HashMap.compute(java.lang.Object,java.util.function.BiFunction), hashCode=public int java.util.AbstractMap.hashCode(), putAll=public void java.util.HashMap.putAll(java.util.Map), get=public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object), merge=public java.lang.Object java.util.HashMap.merge(java.lang.Object,java.lang.Object,java.util.function.BiFunction), class=java.beans.PropertyDescriptor[name=class; propertyType=class java.lang.Class; readMethod=public final native java.lang.Class java.lang.Object.getClass()], keySet=public java.util.Set java.util.LinkedHashMap.keySet(), java.lang.Object@1c0f21d=freemarker.ext.beans.OverloadedMethods@d4b988, entrySet=public java.util.Set java.util.LinkedHashMap.entrySet(), java.lang.Object@15be27d=public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object), forEach=public void java.util.LinkedHashMap.forEach(java.util.function.BiConsumer), containsKey=public boolean java.util.HashMap.containsKey(java.lang.Object), isEmpty=public boolean java.util.HashMap.isEmpty(), clear=public void java.util.LinkedHashMap.clear(), computeIfPresent=public java.lang.Object java.util.HashMap.computeIfPresent(java.lang.Object,java.util.function.BiFunction), size=public int java.util.HashMap.size(), equals=public boolean java.util.AbstractMap.equals(java.lang.Object), clone=public java.lang.Object java.util.HashMap.clone(), toString=public java.lang.String java.util.AbstractMap.toString(), putIfAbsent=public java.lang.Object java.util.HashMap.putIfAbsent(java.lang.Object,java.lang.Object)}
[DEBUG] 2017-05-24: 21:05:32 freemarker.log._Log4jLoggerFactory$Log4jLogger.debug(_Log4jLoggerFactory.java:45) :  Key "disabled" was not found on instance of java.util.LinkedHashMap. Introspection information for the class is: {getClass=public final native java.lang.Class java.lang.Object.getClass(), getOrDefault=public java.lang.Object java.util.LinkedHashMap.getOrDefault(java.lang.Object,java.lang.Object), computeIfAbsent=public java.lang.Object java.util.HashMap.computeIfAbsent(java.lang.Object,java.util.function.Function), values=public java.util.Collection java.util.LinkedHashMap.values(), replace=freemarker.ext.beans.OverloadedMethods@11d0265, java.lang.Object@3e55b2={public boolean java.util.HashMap.isEmpty()=[Ljava.lang.Class;@c5aa3a, public int java.util.AbstractMap.hashCode()=[Ljava.lang.Class;@74a947, public java.lang.Object java.util.HashMap.put(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@1615a91, public boolean java.util.AbstractMap.equals(java.lang.Object)=[Ljava.lang.Class;@a46ab2, public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object)=[Ljava.lang.Class;@1c389e6, public java.lang.String java.util.AbstractMap.toString()=[Ljava.lang.Class;@a23548, public boolean java.util.HashMap.containsKey(java.lang.Object)=[Ljava.lang.Class;@1be4a9f, public java.util.Set java.util.LinkedHashMap.keySet()=[Ljava.lang.Class;@44c60, public java.lang.Object java.util.HashMap.computeIfAbsent(java.lang.Object,java.util.function.Function)=[Ljava.lang.Class;@10f7dff, public java.lang.Object java.util.HashMap.clone()=[Ljava.lang.Class;@d214e3, public java.lang.Object java.util.LinkedHashMap.getOrDefault(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@1a74254, public java.util.Set java.util.LinkedHashMap.entrySet()=[Ljava.lang.Class;@1c4740c, public void java.util.LinkedHashMap.forEach(java.util.function.BiConsumer)=[Ljava.lang.Class;@1fe0c8e, public java.lang.Object java.util.HashMap.putIfAbsent(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@16f73de, public java.util.Collection java.util.LinkedHashMap.values()=[Ljava.lang.Class;@b3e45, public void java.util.LinkedHashMap.clear()=[Ljava.lang.Class;@a34e5c, public java.lang.Object java.util.HashMap.computeIfPresent(java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1fcb13a, public java.lang.Object java.util.HashMap.compute(java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1a7c258, public final native java.lang.Class java.lang.Object.getClass()=[Ljava.lang.Class;@7397f, public void java.util.HashMap.putAll(java.util.Map)=[Ljava.lang.Class;@59cd, public void java.util.LinkedHashMap.replaceAll(java.util.function.BiFunction)=[Ljava.lang.Class;@994816, public java.lang.Object java.util.HashMap.merge(java.lang.Object,java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1b1e75f, public int java.util.HashMap.size()=[Ljava.lang.Class;@bee157, public boolean java.util.LinkedHashMap.containsValue(java.lang.Object)=[Ljava.lang.Class;@5e0d7c}, replaceAll=public void java.util.LinkedHashMap.replaceAll(java.util.function.BiFunction), remove=freemarker.ext.beans.OverloadedMethods@8d3a99, containsValue=public boolean java.util.LinkedHashMap.containsValue(java.lang.Object), put=public java.lang.Object java.util.HashMap.put(java.lang.Object,java.lang.Object), empty=java.beans.PropertyDescriptor[name=empty; propertyType=boolean; readMethod=public boolean java.util.HashMap.isEmpty()], compute=public java.lang.Object java.util.HashMap.compute(java.lang.Object,java.util.function.BiFunction), hashCode=public int java.util.AbstractMap.hashCode(), putAll=public void java.util.HashMap.putAll(java.util.Map), get=public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object), merge=public java.lang.Object java.util.HashMap.merge(java.lang.Object,java.lang.Object,java.util.function.BiFunction), class=java.beans.PropertyDescriptor[name=class; propertyType=class java.lang.Class; readMethod=public final native java.lang.Class java.lang.Object.getClass()], keySet=public java.util.Set java.util.LinkedHashMap.keySet(), java.lang.Object@1c0f21d=freemarker.ext.beans.OverloadedMethods@d4b988, entrySet=public java.util.Set java.util.LinkedHashMap.entrySet(), java.lang.Object@15be27d=public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object), forEach=public void java.util.LinkedHashMap.forEach(java.util.function.BiConsumer), containsKey=public boolean java.util.HashMap.containsKey(java.lang.Object), isEmpty=public boolean java.util.HashMap.isEmpty(), clear=public void java.util.LinkedHashMap.clear(), computeIfPresent=public java.lang.Object java.util.HashMap.computeIfPresent(java.lang.Object,java.util.function.BiFunction), size=public int java.util.HashMap.size(), equals=public boolean java.util.AbstractMap.equals(java.lang.Object), clone=public java.lang.Object java.util.HashMap.clone(), toString=public java.lang.String java.util.AbstractMap.toString(), putIfAbsent=public java.lang.Object java.util.HashMap.putIfAbsent(java.lang.Object,java.lang.Object)}
[DEBUG] 2017-05-24: 21:05:32 freemarker.log._Log4jLoggerFactory$Log4jLogger.debug(_Log4jLoggerFactory.java:45) :  Key "readonly" was not found on instance of java.util.LinkedHashMap. Introspection information for the class is: {getClass=public final native java.lang.Class java.lang.Object.getClass(), getOrDefault=public java.lang.Object java.util.LinkedHashMap.getOrDefault(java.lang.Object,java.lang.Object), computeIfAbsent=public java.lang.Object java.util.HashMap.computeIfAbsent(java.lang.Object,java.util.function.Function), values=public java.util.Collection java.util.LinkedHashMap.values(), replace=freemarker.ext.beans.OverloadedMethods@11d0265, java.lang.Object@3e55b2={public boolean java.util.HashMap.isEmpty()=[Ljava.lang.Class;@c5aa3a, public int java.util.AbstractMap.hashCode()=[Ljava.lang.Class;@74a947, public java.lang.Object java.util.HashMap.put(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@1615a91, public boolean java.util.AbstractMap.equals(java.lang.Object)=[Ljava.lang.Class;@a46ab2, public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object)=[Ljava.lang.Class;@1c389e6, public java.lang.String java.util.AbstractMap.toString()=[Ljava.lang.Class;@a23548, public boolean java.util.HashMap.containsKey(java.lang.Object)=[Ljava.lang.Class;@1be4a9f, public java.util.Set java.util.LinkedHashMap.keySet()=[Ljava.lang.Class;@44c60, public java.lang.Object java.util.HashMap.computeIfAbsent(java.lang.Object,java.util.function.Function)=[Ljava.lang.Class;@10f7dff, public java.lang.Object java.util.HashMap.clone()=[Ljava.lang.Class;@d214e3, public java.lang.Object java.util.LinkedHashMap.getOrDefault(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@1a74254, public java.util.Set java.util.LinkedHashMap.entrySet()=[Ljava.lang.Class;@1c4740c, public void java.util.LinkedHashMap.forEach(java.util.function.BiConsumer)=[Ljava.lang.Class;@1fe0c8e, public java.lang.Object java.util.HashMap.putIfAbsent(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@16f73de, public java.util.Collection java.util.LinkedHashMap.values()=[Ljava.lang.Class;@b3e45, public void java.util.LinkedHashMap.clear()=[Ljava.lang.Class;@a34e5c, public java.lang.Object java.util.HashMap.computeIfPresent(java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1fcb13a, public java.lang.Object java.util.HashMap.compute(java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1a7c258, public final native java.lang.Class java.lang.Object.getClass()=[Ljava.lang.Class;@7397f, public void java.util.HashMap.putAll(java.util.Map)=[Ljava.lang.Class;@59cd, public void java.util.LinkedHashMap.replaceAll(java.util.function.BiFunction)=[Ljava.lang.Class;@994816, public java.lang.Object java.util.HashMap.merge(java.lang.Object,java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1b1e75f, public int java.util.HashMap.size()=[Ljava.lang.Class;@bee157, public boolean java.util.LinkedHashMap.containsValue(java.lang.Object)=[Ljava.lang.Class;@5e0d7c}, replaceAll=public void java.util.LinkedHashMap.replaceAll(java.util.function.BiFunction), remove=freemarker.ext.beans.OverloadedMethods@8d3a99, containsValue=public boolean java.util.LinkedHashMap.containsValue(java.lang.Object), put=public java.lang.Object java.util.HashMap.put(java.lang.Object,java.lang.Object), empty=java.beans.PropertyDescriptor[name=empty; propertyType=boolean; readMethod=public boolean java.util.HashMap.isEmpty()], compute=public java.lang.Object java.util.HashMap.compute(java.lang.Object,java.util.function.BiFunction), hashCode=public int java.util.AbstractMap.hashCode(), putAll=public void java.util.HashMap.putAll(java.util.Map), get=public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object), merge=public java.lang.Object java.util.HashMap.merge(java.lang.Object,java.lang.Object,java.util.function.BiFunction), class=java.beans.PropertyDescriptor[name=class; propertyType=class java.lang.Class; readMethod=public final native java.lang.Class java.lang.Object.getClass()], keySet=public java.util.Set java.util.LinkedHashMap.keySet(), java.lang.Object@1c0f21d=freemarker.ext.beans.OverloadedMethods@d4b988, entrySet=public java.util.Set java.util.LinkedHashMap.entrySet(), java.lang.Object@15be27d=public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object), forEach=public void java.util.LinkedHashMap.forEach(java.util.function.BiConsumer), containsKey=public boolean java.util.HashMap.containsKey(java.lang.Object), isEmpty=public boolean java.util.HashMap.isEmpty(), clear=public void java.util.LinkedHashMap.clear(), computeIfPresent=public java.lang.Object java.util.HashMap.computeIfPresent(java.lang.Object,java.util.function.BiFunction), size=public int java.util.HashMap.size(), equals=public boolean java.util.AbstractMap.equals(java.lang.Object), clone=public java.lang.Object java.util.HashMap.clone(), toString=public java.lang.String java.util.AbstractMap.toString(), putIfAbsent=public java.lang.Object java.util.HashMap.putIfAbsent(java.lang.Object,java.lang.Object)}
[DEBUG] 2017-05-24: 21:05:32 freemarker.log._Log4jLoggerFactory$Log4jLogger.debug(_Log4jLoggerFactory.java:45) :  Key "tabindex" was not found on instance of java.util.LinkedHashMap. Introspection information for the class is: {getClass=public final native java.lang.Class java.lang.Object.getClass(), getOrDefault=public java.lang.Object java.util.LinkedHashMap.getOrDefault(java.lang.Object,java.lang.Object), computeIfAbsent=public java.lang.Object java.util.HashMap.computeIfAbsent(java.lang.Object,java.util.function.Function), values=public java.util.Collection java.util.LinkedHashMap.values(), replace=freemarker.ext.beans.OverloadedMethods@11d0265, java.lang.Object@3e55b2={public boolean java.util.HashMap.isEmpty()=[Ljava.lang.Class;@c5aa3a, public int java.util.AbstractMap.hashCode()=[Ljava.lang.Class;@74a947, public java.lang.Object java.util.HashMap.put(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@1615a91, public boolean java.util.AbstractMap.equals(java.lang.Object)=[Ljava.lang.Class;@a46ab2, public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object)=[Ljava.lang.Class;@1c389e6, public java.lang.String java.util.AbstractMap.toString()=[Ljava.lang.Class;@a23548, public boolean java.util.HashMap.containsKey(java.lang.Object)=[Ljava.lang.Class;@1be4a9f, public java.util.Set java.util.LinkedHashMap.keySet()=[Ljava.lang.Class;@44c60, public java.lang.Object java.util.HashMap.computeIfAbsent(java.lang.Object,java.util.function.Function)=[Ljava.lang.Class;@10f7dff, public java.lang.Object java.util.HashMap.clone()=[Ljava.lang.Class;@d214e3, public java.lang.Object java.util.LinkedHashMap.getOrDefault(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@1a74254, public java.util.Set java.util.LinkedHashMap.entrySet()=[Ljava.lang.Class;@1c4740c, public void java.util.LinkedHashMap.forEach(java.util.function.BiConsumer)=[Ljava.lang.Class;@1fe0c8e, public java.lang.Object java.util.HashMap.putIfAbsent(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@16f73de, public java.util.Collection java.util.LinkedHashMap.values()=[Ljava.lang.Class;@b3e45, public void java.util.LinkedHashMap.clear()=[Ljava.lang.Class;@a34e5c, public java.lang.Object java.util.HashMap.computeIfPresent(java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1fcb13a, public java.lang.Object java.util.HashMap.compute(java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1a7c258, public final native java.lang.Class java.lang.Object.getClass()=[Ljava.lang.Class;@7397f, public void java.util.HashMap.putAll(java.util.Map)=[Ljava.lang.Class;@59cd, public void java.util.LinkedHashMap.replaceAll(java.util.function.BiFunction)=[Ljava.lang.Class;@994816, public java.lang.Object java.util.HashMap.merge(java.lang.Object,java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1b1e75f, public int java.util.HashMap.size()=[Ljava.lang.Class;@bee157, public boolean java.util.LinkedHashMap.containsValue(java.lang.Object)=[Ljava.lang.Class;@5e0d7c}, replaceAll=public void java.util.LinkedHashMap.replaceAll(java.util.function.BiFunction), remove=freemarker.ext.beans.OverloadedMethods@8d3a99, containsValue=public boolean java.util.LinkedHashMap.containsValue(java.lang.Object), put=public java.lang.Object java.util.HashMap.put(java.lang.Object,java.lang.Object), empty=java.beans.PropertyDescriptor[name=empty; propertyType=boolean; readMethod=public boolean java.util.HashMap.isEmpty()], compute=public java.lang.Object java.util.HashMap.compute(java.lang.Object,java.util.function.BiFunction), hashCode=public int java.util.AbstractMap.hashCode(), putAll=public void java.util.HashMap.putAll(java.util.Map), get=public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object), merge=public java.lang.Object java.util.HashMap.merge(java.lang.Object,java.lang.Object,java.util.function.BiFunction), class=java.beans.PropertyDescriptor[name=class; propertyType=class java.lang.Class; readMethod=public final native java.lang.Class java.lang.Object.getClass()], keySet=public java.util.Set java.util.LinkedHashMap.keySet(), java.lang.Object@1c0f21d=freemarker.ext.beans.OverloadedMethods@d4b988, entrySet=public java.util.Set java.util.LinkedHashMap.entrySet(), java.lang.Object@15be27d=public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object), forEach=public void java.util.LinkedHashMap.forEach(java.util.function.BiConsumer), containsKey=public boolean java.util.HashMap.containsKey(java.lang.Object), isEmpty=public boolean java.util.HashMap.isEmpty(), clear=public void java.util.LinkedHashMap.clear(), computeIfPresent=public java.lang.Object java.util.HashMap.computeIfPresent(java.lang.Object,java.util.function.BiFunction), size=public int java.util.HashMap.size(), equals=public boolean java.util.AbstractMap.equals(java.lang.Object), clone=public java.lang.Object java.util.HashMap.clone(), toString=public java.lang.String java.util.AbstractMap.toString(), putIfAbsent=public java.lang.Object java.util.HashMap.putIfAbsent(java.lang.Object,java.lang.Object)}
[DEBUG] 2017-05-24: 21:05:32 freemarker.log._Log4jLoggerFactory$Log4jLogger.debug(_Log4jLoggerFactory.java:45) :  Couldn't find template in cache for "template/~~~xhtml/css.ftl"("zh_CN", UTF-8, parsed); will try to load it.
[DEBUG] 2017-05-24: 21:05:32 freemarker.log._Log4jLoggerFactory$Log4jLogger.debug(_Log4jLoggerFactory.java:45) :  TemplateLoader.findTemplateSource("template/~~~xhtml/css.ftl"): Found
[DEBUG] 2017-05-24: 21:05:32 freemarker.log._Log4jLoggerFactory$Log4jLogger.debug(_Log4jLoggerFactory.java:45) :  Loading template for "template/~~~xhtml/css.ftl"("zh_CN", UTF-8, parsed) from "jar:file:/D:/maven/repository/org/apache/struts/struts2-core/2.5.10/struts2-core-2.5.10.jar!/template/simple/css.ftl"
[DEBUG] 2017-05-24: 21:05:32 freemarker.log._Log4jLoggerFactory$Log4jLogger.debug(_Log4jLoggerFactory.java:45) :  Key "cssClass" was not found on instance of java.util.LinkedHashMap. Introspection information for the class is: {getClass=public final native java.lang.Class java.lang.Object.getClass(), getOrDefault=public java.lang.Object java.util.LinkedHashMap.getOrDefault(java.lang.Object,java.lang.Object), computeIfAbsent=public java.lang.Object java.util.HashMap.computeIfAbsent(java.lang.Object,java.util.function.Function), values=public java.util.Collection java.util.LinkedHashMap.values(), replace=freemarker.ext.beans.OverloadedMethods@11d0265, java.lang.Object@3e55b2={public boolean java.util.HashMap.isEmpty()=[Ljava.lang.Class;@c5aa3a, public int java.util.AbstractMap.hashCode()=[Ljava.lang.Class;@74a947, public java.lang.Object java.util.HashMap.put(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@1615a91, public boolean java.util.AbstractMap.equals(java.lang.Object)=[Ljava.lang.Class;@a46ab2, public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object)=[Ljava.lang.Class;@1c389e6, public java.lang.String java.util.AbstractMap.toString()=[Ljava.lang.Class;@a23548, public boolean java.util.HashMap.containsKey(java.lang.Object)=[Ljava.lang.Class;@1be4a9f, public java.util.Set java.util.LinkedHashMap.keySet()=[Ljava.lang.Class;@44c60, public java.lang.Object java.util.HashMap.computeIfAbsent(java.lang.Object,java.util.function.Function)=[Ljava.lang.Class;@10f7dff, public java.lang.Object java.util.HashMap.clone()=[Ljava.lang.Class;@d214e3, public java.lang.Object java.util.LinkedHashMap.getOrDefault(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@1a74254, public java.util.Set java.util.LinkedHashMap.entrySet()=[Ljava.lang.Class;@1c4740c, public void java.util.LinkedHashMap.forEach(java.util.function.BiConsumer)=[Ljava.lang.Class;@1fe0c8e, public java.lang.Object java.util.HashMap.putIfAbsent(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@16f73de, public java.util.Collection java.util.LinkedHashMap.values()=[Ljava.lang.Class;@b3e45, public void java.util.LinkedHashMap.clear()=[Ljava.lang.Class;@a34e5c, public java.lang.Object java.util.HashMap.computeIfPresent(java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1fcb13a, public java.lang.Object java.util.HashMap.compute(java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1a7c258, public final native java.lang.Class java.lang.Object.getClass()=[Ljava.lang.Class;@7397f, public void java.util.HashMap.putAll(java.util.Map)=[Ljava.lang.Class;@59cd, public void java.util.LinkedHashMap.replaceAll(java.util.function.BiFunction)=[Ljava.lang.Class;@994816, public java.lang.Object java.util.HashMap.merge(java.lang.Object,java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1b1e75f, public int java.util.HashMap.size()=[Ljava.lang.Class;@bee157, public boolean java.util.LinkedHashMap.containsValue(java.lang.Object)=[Ljava.lang.Class;@5e0d7c}, replaceAll=public void java.util.LinkedHashMap.replaceAll(java.util.function.BiFunction), remove=freemarker.ext.beans.OverloadedMethods@8d3a99, containsValue=public boolean java.util.LinkedHashMap.containsValue(java.lang.Object), put=public java.lang.Object java.util.HashMap.put(java.lang.Object,java.lang.Object), empty=java.beans.PropertyDescriptor[name=empty; propertyType=boolean; readMethod=public boolean java.util.HashMap.isEmpty()], compute=public java.lang.Object java.util.HashMap.compute(java.lang.Object,java.util.function.BiFunction), hashCode=public int java.util.AbstractMap.hashCode(), putAll=public void java.util.HashMap.putAll(java.util.Map), get=public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object), merge=public java.lang.Object java.util.HashMap.merge(java.lang.Object,java.lang.Object,java.util.function.BiFunction), class=java.beans.PropertyDescriptor[name=class; propertyType=class java.lang.Class; readMethod=public final native java.lang.Class java.lang.Object.getClass()], keySet=public java.util.Set java.util.LinkedHashMap.keySet(), java.lang.Object@1c0f21d=freemarker.ext.beans.OverloadedMethods@d4b988, entrySet=public java.util.Set java.util.LinkedHashMap.entrySet(), java.lang.Object@15be27d=public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object), forEach=public void java.util.LinkedHashMap.forEach(java.util.function.BiConsumer), containsKey=public boolean java.util.HashMap.containsKey(java.lang.Object), isEmpty=public boolean java.util.HashMap.isEmpty(), clear=public void java.util.LinkedHashMap.clear(), computeIfPresent=public java.lang.Object java.util.HashMap.computeIfPresent(java.lang.Object,java.util.function.BiFunction), size=public int java.util.HashMap.size(), equals=public boolean java.util.AbstractMap.equals(java.lang.Object), clone=public java.lang.Object java.util.HashMap.clone(), toString=public java.lang.String java.util.AbstractMap.toString(), putIfAbsent=public java.lang.Object java.util.HashMap.putIfAbsent(java.lang.Object,java.lang.Object)}
[DEBUG] 2017-05-24: 21:05:32 freemarker.log._Log4jLoggerFactory$Log4jLogger.debug(_Log4jLoggerFactory.java:45) :  Key "cssClass" was not found on instance of java.util.LinkedHashMap. Introspection information for the class is: {getClass=public final native java.lang.Class java.lang.Object.getClass(), getOrDefault=public java.lang.Object java.util.LinkedHashMap.getOrDefault(java.lang.Object,java.lang.Object), computeIfAbsent=public java.lang.Object java.util.HashMap.computeIfAbsent(java.lang.Object,java.util.function.Function), values=public java.util.Collection java.util.LinkedHashMap.values(), replace=freemarker.ext.beans.OverloadedMethods@11d0265, java.lang.Object@3e55b2={public boolean java.util.HashMap.isEmpty()=[Ljava.lang.Class;@c5aa3a, public int java.util.AbstractMap.hashCode()=[Ljava.lang.Class;@74a947, public java.lang.Object java.util.HashMap.put(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@1615a91, public boolean java.util.AbstractMap.equals(java.lang.Object)=[Ljava.lang.Class;@a46ab2, public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object)=[Ljava.lang.Class;@1c389e6, public java.lang.String java.util.AbstractMap.toString()=[Ljava.lang.Class;@a23548, public boolean java.util.HashMap.containsKey(java.lang.Object)=[Ljava.lang.Class;@1be4a9f, public java.util.Set java.util.LinkedHashMap.keySet()=[Ljava.lang.Class;@44c60, public java.lang.Object java.util.HashMap.computeIfAbsent(java.lang.Object,java.util.function.Function)=[Ljava.lang.Class;@10f7dff, public java.lang.Object java.util.HashMap.clone()=[Ljava.lang.Class;@d214e3, public java.lang.Object java.util.LinkedHashMap.getOrDefault(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@1a74254, public java.util.Set java.util.LinkedHashMap.entrySet()=[Ljava.lang.Class;@1c4740c, public void java.util.LinkedHashMap.forEach(java.util.function.BiConsumer)=[Ljava.lang.Class;@1fe0c8e, public java.lang.Object java.util.HashMap.putIfAbsent(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@16f73de, public java.util.Collection java.util.LinkedHashMap.values()=[Ljava.lang.Class;@b3e45, public void java.util.LinkedHashMap.clear()=[Ljava.lang.Class;@a34e5c, public java.lang.Object java.util.HashMap.computeIfPresent(java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1fcb13a, public java.lang.Object java.util.HashMap.compute(java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1a7c258, public final native java.lang.Class java.lang.Object.getClass()=[Ljava.lang.Class;@7397f, public void java.util.HashMap.putAll(java.util.Map)=[Ljava.lang.Class;@59cd, public void java.util.LinkedHashMap.replaceAll(java.util.function.BiFunction)=[Ljava.lang.Class;@994816, public java.lang.Object java.util.HashMap.merge(java.lang.Object,java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1b1e75f, public int java.util.HashMap.size()=[Ljava.lang.Class;@bee157, public boolean java.util.LinkedHashMap.containsValue(java.lang.Object)=[Ljava.lang.Class;@5e0d7c}, replaceAll=public void java.util.LinkedHashMap.replaceAll(java.util.function.BiFunction), remove=freemarker.ext.beans.OverloadedMethods@8d3a99, containsValue=public boolean java.util.LinkedHashMap.containsValue(java.lang.Object), put=public java.lang.Object java.util.HashMap.put(java.lang.Object,java.lang.Object), empty=java.beans.PropertyDescriptor[name=empty; propertyType=boolean; readMethod=public boolean java.util.HashMap.isEmpty()], compute=public java.lang.Object java.util.HashMap.compute(java.lang.Object,java.util.function.BiFunction), hashCode=public int java.util.AbstractMap.hashCode(), putAll=public void java.util.HashMap.putAll(java.util.Map), get=public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object), merge=public java.lang.Object java.util.HashMap.merge(java.lang.Object,java.lang.Object,java.util.function.BiFunction), class=java.beans.PropertyDescriptor[name=class; propertyType=class java.lang.Class; readMethod=public final native java.lang.Class java.lang.Object.getClass()], keySet=public java.util.Set java.util.LinkedHashMap.keySet(), java.lang.Object@1c0f21d=freemarker.ext.beans.OverloadedMethods@d4b988, entrySet=public java.util.Set java.util.LinkedHashMap.entrySet(), java.lang.Object@15be27d=public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object), forEach=public void java.util.LinkedHashMap.forEach(java.util.function.BiConsumer), containsKey=public boolean java.util.HashMap.containsKey(java.lang.Object), isEmpty=public boolean java.util.HashMap.isEmpty(), clear=public void java.util.LinkedHashMap.clear(), computeIfPresent=public java.lang.Object java.util.HashMap.computeIfPresent(java.lang.Object,java.util.function.BiFunction), size=public int java.util.HashMap.size(), equals=public boolean java.util.AbstractMap.equals(java.lang.Object), clone=public java.lang.Object java.util.HashMap.clone(), toString=public java.lang.String java.util.AbstractMap.toString(), putIfAbsent=public java.lang.Object java.util.HashMap.putIfAbsent(java.lang.Object,java.lang.Object)}
[DEBUG] 2017-05-24: 21:05:32 freemarker.log._Log4jLoggerFactory$Log4jLogger.debug(_Log4jLoggerFactory.java:45) :  Key "cssClass" was not found on instance of java.util.LinkedHashMap. Introspection information for the class is: {getClass=public final native java.lang.Class java.lang.Object.getClass(), getOrDefault=public java.lang.Object java.util.LinkedHashMap.getOrDefault(java.lang.Object,java.lang.Object), computeIfAbsent=public java.lang.Object java.util.HashMap.computeIfAbsent(java.lang.Object,java.util.function.Function), values=public java.util.Collection java.util.LinkedHashMap.values(), replace=freemarker.ext.beans.OverloadedMethods@11d0265, java.lang.Object@3e55b2={public boolean java.util.HashMap.isEmpty()=[Ljava.lang.Class;@c5aa3a, public int java.util.AbstractMap.hashCode()=[Ljava.lang.Class;@74a947, public java.lang.Object java.util.HashMap.put(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@1615a91, public boolean java.util.AbstractMap.equals(java.lang.Object)=[Ljava.lang.Class;@a46ab2, public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object)=[Ljava.lang.Class;@1c389e6, public java.lang.String java.util.AbstractMap.toString()=[Ljava.lang.Class;@a23548, public boolean java.util.HashMap.containsKey(java.lang.Object)=[Ljava.lang.Class;@1be4a9f, public java.util.Set java.util.LinkedHashMap.keySet()=[Ljava.lang.Class;@44c60, public java.lang.Object java.util.HashMap.computeIfAbsent(java.lang.Object,java.util.function.Function)=[Ljava.lang.Class;@10f7dff, public java.lang.Object java.util.HashMap.clone()=[Ljava.lang.Class;@d214e3, public java.lang.Object java.util.LinkedHashMap.getOrDefault(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@1a74254, public java.util.Set java.util.LinkedHashMap.entrySet()=[Ljava.lang.Class;@1c4740c, public void java.util.LinkedHashMap.forEach(java.util.function.BiConsumer)=[Ljava.lang.Class;@1fe0c8e, public java.lang.Object java.util.HashMap.putIfAbsent(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@16f73de, public java.util.Collection java.util.LinkedHashMap.values()=[Ljava.lang.Class;@b3e45, public void java.util.LinkedHashMap.clear()=[Ljava.lang.Class;@a34e5c, public java.lang.Object java.util.HashMap.computeIfPresent(java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1fcb13a, public java.lang.Object java.util.HashMap.compute(java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1a7c258, public final native java.lang.Class java.lang.Object.getClass()=[Ljava.lang.Class;@7397f, public void java.util.HashMap.putAll(java.util.Map)=[Ljava.lang.Class;@59cd, public void java.util.LinkedHashMap.replaceAll(java.util.function.BiFunction)=[Ljava.lang.Class;@994816, public java.lang.Object java.util.HashMap.merge(java.lang.Object,java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1b1e75f, public int java.util.HashMap.size()=[Ljava.lang.Class;@bee157, public boolean java.util.LinkedHashMap.containsValue(java.lang.Object)=[Ljava.lang.Class;@5e0d7c}, replaceAll=public void java.util.LinkedHashMap.replaceAll(java.util.function.BiFunction), remove=freemarker.ext.beans.OverloadedMethods@8d3a99, containsValue=public boolean java.util.LinkedHashMap.containsValue(java.lang.Object), put=public java.lang.Object java.util.HashMap.put(java.lang.Object,java.lang.Object), empty=java.beans.PropertyDescriptor[name=empty; propertyType=boolean; readMethod=public boolean java.util.HashMap.isEmpty()], compute=public java.lang.Object java.util.HashMap.compute(java.lang.Object,java.util.function.BiFunction), hashCode=public int java.util.AbstractMap.hashCode(), putAll=public void java.util.HashMap.putAll(java.util.Map), get=public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object), merge=public java.lang.Object java.util.HashMap.merge(java.lang.Object,java.lang.Object,java.util.function.BiFunction), class=java.beans.PropertyDescriptor[name=class; propertyType=class java.lang.Class; readMethod=public final native java.lang.Class java.lang.Object.getClass()], keySet=public java.util.Set java.util.LinkedHashMap.keySet(), java.lang.Object@1c0f21d=freemarker.ext.beans.OverloadedMethods@d4b988, entrySet=public java.util.Set java.util.LinkedHashMap.entrySet(), java.lang.Object@15be27d=public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object), forEach=public void java.util.LinkedHashMap.forEach(java.util.function.BiConsumer), containsKey=public boolean java.util.HashMap.containsKey(java.lang.Object), isEmpty=public boolean java.util.HashMap.isEmpty(), clear=public void java.util.LinkedHashMap.clear(), computeIfPresent=public java.lang.Object java.util.HashMap.computeIfPresent(java.lang.Object,java.util.function.BiFunction), size=public int java.util.HashMap.size(), equals=public boolean java.util.AbstractMap.equals(java.lang.Object), clone=public java.lang.Object java.util.HashMap.clone(), toString=public java.lang.String java.util.AbstractMap.toString(), putIfAbsent=public java.lang.Object java.util.HashMap.putIfAbsent(java.lang.Object,java.lang.Object)}
[DEBUG] 2017-05-24: 21:05:32 freemarker.log._Log4jLoggerFactory$Log4jLogger.debug(_Log4jLoggerFactory.java:45) :  Key "cssStyle" was not found on instance of java.util.LinkedHashMap. Introspection information for the class is: {getClass=public final native java.lang.Class java.lang.Object.getClass(), getOrDefault=public java.lang.Object java.util.LinkedHashMap.getOrDefault(java.lang.Object,java.lang.Object), computeIfAbsent=public java.lang.Object java.util.HashMap.computeIfAbsent(java.lang.Object,java.util.function.Function), values=public java.util.Collection java.util.LinkedHashMap.values(), replace=freemarker.ext.beans.OverloadedMethods@11d0265, java.lang.Object@3e55b2={public boolean java.util.HashMap.isEmpty()=[Ljava.lang.Class;@c5aa3a, public int java.util.AbstractMap.hashCode()=[Ljava.lang.Class;@74a947, public java.lang.Object java.util.HashMap.put(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@1615a91, public boolean java.util.AbstractMap.equals(java.lang.Object)=[Ljava.lang.Class;@a46ab2, public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object)=[Ljava.lang.Class;@1c389e6, public java.lang.String java.util.AbstractMap.toString()=[Ljava.lang.Class;@a23548, public boolean java.util.HashMap.containsKey(java.lang.Object)=[Ljava.lang.Class;@1be4a9f, public java.util.Set java.util.LinkedHashMap.keySet()=[Ljava.lang.Class;@44c60, public java.lang.Object java.util.HashMap.computeIfAbsent(java.lang.Object,java.util.function.Function)=[Ljava.lang.Class;@10f7dff, public java.lang.Object java.util.HashMap.clone()=[Ljava.lang.Class;@d214e3, public java.lang.Object java.util.LinkedHashMap.getOrDefault(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@1a74254, public java.util.Set java.util.LinkedHashMap.entrySet()=[Ljava.lang.Class;@1c4740c, public void java.util.LinkedHashMap.forEach(java.util.function.BiConsumer)=[Ljava.lang.Class;@1fe0c8e, public java.lang.Object java.util.HashMap.putIfAbsent(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@16f73de, public java.util.Collection java.util.LinkedHashMap.values()=[Ljava.lang.Class;@b3e45, public void java.util.LinkedHashMap.clear()=[Ljava.lang.Class;@a34e5c, public java.lang.Object java.util.HashMap.computeIfPresent(java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1fcb13a, public java.lang.Object java.util.HashMap.compute(java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1a7c258, public final native java.lang.Class java.lang.Object.getClass()=[Ljava.lang.Class;@7397f, public void java.util.HashMap.putAll(java.util.Map)=[Ljava.lang.Class;@59cd, public void java.util.LinkedHashMap.replaceAll(java.util.function.BiFunction)=[Ljava.lang.Class;@994816, public java.lang.Object java.util.HashMap.merge(java.lang.Object,java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1b1e75f, public int java.util.HashMap.size()=[Ljava.lang.Class;@bee157, public boolean java.util.LinkedHashMap.containsValue(java.lang.Object)=[Ljava.lang.Class;@5e0d7c}, replaceAll=public void java.util.LinkedHashMap.replaceAll(java.util.function.BiFunction), remove=freemarker.ext.beans.OverloadedMethods@8d3a99, containsValue=public boolean java.util.LinkedHashMap.containsValue(java.lang.Object), put=public java.lang.Object java.util.HashMap.put(java.lang.Object,java.lang.Object), empty=java.beans.PropertyDescriptor[name=empty; propertyType=boolean; readMethod=public boolean java.util.HashMap.isEmpty()], compute=public java.lang.Object java.util.HashMap.compute(java.lang.Object,java.util.function.BiFunction), hashCode=public int java.util.AbstractMap.hashCode(), putAll=public void java.util.HashMap.putAll(java.util.Map), get=public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object), merge=public java.lang.Object java.util.HashMap.merge(java.lang.Object,java.lang.Object,java.util.function.BiFunction), class=java.beans.PropertyDescriptor[name=class; propertyType=class java.lang.Class; readMethod=public final native java.lang.Class java.lang.Object.getClass()], keySet=public java.util.Set java.util.LinkedHashMap.keySet(), java.lang.Object@1c0f21d=freemarker.ext.beans.OverloadedMethods@d4b988, entrySet=public java.util.Set java.util.LinkedHashMap.entrySet(), java.lang.Object@15be27d=public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object), forEach=public void java.util.LinkedHashMap.forEach(java.util.function.BiConsumer), containsKey=public boolean java.util.HashMap.containsKey(java.lang.Object), isEmpty=public boolean java.util.HashMap.isEmpty(), clear=public void java.util.LinkedHashMap.clear(), computeIfPresent=public java.lang.Object java.util.HashMap.computeIfPresent(java.lang.Object,java.util.function.BiFunction), size=public int java.util.HashMap.size(), equals=public boolean java.util.AbstractMap.equals(java.lang.Object), clone=public java.lang.Object java.util.HashMap.clone(), toString=public java.lang.String java.util.AbstractMap.toString(), putIfAbsent=public java.lang.Object java.util.HashMap.putIfAbsent(java.lang.Object,java.lang.Object)}
[DEBUG] 2017-05-24: 21:05:32 freemarker.log._Log4jLoggerFactory$Log4jLogger.debug(_Log4jLoggerFactory.java:45) :  Key "title" was not found on instance of java.util.LinkedHashMap. Introspection information for the class is: {getClass=public final native java.lang.Class java.lang.Object.getClass(), getOrDefault=public java.lang.Object java.util.LinkedHashMap.getOrDefault(java.lang.Object,java.lang.Object), computeIfAbsent=public java.lang.Object java.util.HashMap.computeIfAbsent(java.lang.Object,java.util.function.Function), values=public java.util.Collection java.util.LinkedHashMap.values(), replace=freemarker.ext.beans.OverloadedMethods@11d0265, java.lang.Object@3e55b2={public boolean java.util.HashMap.isEmpty()=[Ljava.lang.Class;@c5aa3a, public int java.util.AbstractMap.hashCode()=[Ljava.lang.Class;@74a947, public java.lang.Object java.util.HashMap.put(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@1615a91, public boolean java.util.AbstractMap.equals(java.lang.Object)=[Ljava.lang.Class;@a46ab2, public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object)=[Ljava.lang.Class;@1c389e6, public java.lang.String java.util.AbstractMap.toString()=[Ljava.lang.Class;@a23548, public boolean java.util.HashMap.containsKey(java.lang.Object)=[Ljava.lang.Class;@1be4a9f, public java.util.Set java.util.LinkedHashMap.keySet()=[Ljava.lang.Class;@44c60, public java.lang.Object java.util.HashMap.computeIfAbsent(java.lang.Object,java.util.function.Function)=[Ljava.lang.Class;@10f7dff, public java.lang.Object java.util.HashMap.clone()=[Ljava.lang.Class;@d214e3, public java.lang.Object java.util.LinkedHashMap.getOrDefault(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@1a74254, public java.util.Set java.util.LinkedHashMap.entrySet()=[Ljava.lang.Class;@1c4740c, public void java.util.LinkedHashMap.forEach(java.util.function.BiConsumer)=[Ljava.lang.Class;@1fe0c8e, public java.lang.Object java.util.HashMap.putIfAbsent(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@16f73de, public java.util.Collection java.util.LinkedHashMap.values()=[Ljava.lang.Class;@b3e45, public void java.util.LinkedHashMap.clear()=[Ljava.lang.Class;@a34e5c, public java.lang.Object java.util.HashMap.computeIfPresent(java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1fcb13a, public java.lang.Object java.util.HashMap.compute(java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1a7c258, public final native java.lang.Class java.lang.Object.getClass()=[Ljava.lang.Class;@7397f, public void java.util.HashMap.putAll(java.util.Map)=[Ljava.lang.Class;@59cd, public void java.util.LinkedHashMap.replaceAll(java.util.function.BiFunction)=[Ljava.lang.Class;@994816, public java.lang.Object java.util.HashMap.merge(java.lang.Object,java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1b1e75f, public int java.util.HashMap.size()=[Ljava.lang.Class;@bee157, public boolean java.util.LinkedHashMap.containsValue(java.lang.Object)=[Ljava.lang.Class;@5e0d7c}, replaceAll=public void java.util.LinkedHashMap.replaceAll(java.util.function.BiFunction), remove=freemarker.ext.beans.OverloadedMethods@8d3a99, containsValue=public boolean java.util.LinkedHashMap.containsValue(java.lang.Object), put=public java.lang.Object java.util.HashMap.put(java.lang.Object,java.lang.Object), empty=java.beans.PropertyDescriptor[name=empty; propertyType=boolean; readMethod=public boolean java.util.HashMap.isEmpty()], compute=public java.lang.Object java.util.HashMap.compute(java.lang.Object,java.util.function.BiFunction), hashCode=public int java.util.AbstractMap.hashCode(), putAll=public void java.util.HashMap.putAll(java.util.Map), get=public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object), merge=public java.lang.Object java.util.HashMap.merge(java.lang.Object,java.lang.Object,java.util.function.BiFunction), class=java.beans.PropertyDescriptor[name=class; propertyType=class java.lang.Class; readMethod=public final native java.lang.Class java.lang.Object.getClass()], keySet=public java.util.Set java.util.LinkedHashMap.keySet(), java.lang.Object@1c0f21d=freemarker.ext.beans.OverloadedMethods@d4b988, entrySet=public java.util.Set java.util.LinkedHashMap.entrySet(), java.lang.Object@15be27d=public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object), forEach=public void java.util.LinkedHashMap.forEach(java.util.function.BiConsumer), containsKey=public boolean java.util.HashMap.containsKey(java.lang.Object), isEmpty=public boolean java.util.HashMap.isEmpty(), clear=public void java.util.LinkedHashMap.clear(), computeIfPresent=public java.lang.Object java.util.HashMap.computeIfPresent(java.lang.Object,java.util.function.BiFunction), size=public int java.util.HashMap.size(), equals=public boolean java.util.AbstractMap.equals(java.lang.Object), clone=public java.lang.Object java.util.HashMap.clone(), toString=public java.lang.String java.util.AbstractMap.toString(), putIfAbsent=public java.lang.Object java.util.HashMap.putIfAbsent(java.lang.Object,java.lang.Object)}
[DEBUG] 2017-05-24: 21:05:32 freemarker.log._Log4jLoggerFactory$Log4jLogger.debug(_Log4jLoggerFactory.java:45) :  Couldn't find template in cache for "template/~~~xhtml/scripting-events.ftl"("zh_CN", UTF-8, parsed); will try to load it.
[DEBUG] 2017-05-24: 21:05:32 freemarker.log._Log4jLoggerFactory$Log4jLogger.debug(_Log4jLoggerFactory.java:45) :  TemplateLoader.findTemplateSource("template/~~~xhtml/scripting-events.ftl"): Found
[DEBUG] 2017-05-24: 21:05:32 freemarker.log._Log4jLoggerFactory$Log4jLogger.debug(_Log4jLoggerFactory.java:45) :  Loading template for "template/~~~xhtml/scripting-events.ftl"("zh_CN", UTF-8, parsed) from "jar:file:/D:/maven/repository/org/apache/struts/struts2-core/2.5.10/struts2-core-2.5.10.jar!/template/simple/scripting-events.ftl"
[DEBUG] 2017-05-24: 21:05:32 freemarker.log._Log4jLoggerFactory$Log4jLogger.debug(_Log4jLoggerFactory.java:45) :  Key "onclick" was not found on instance of java.util.LinkedHashMap. Introspection information for the class is: {getClass=public final native java.lang.Class java.lang.Object.getClass(), getOrDefault=public java.lang.Object java.util.LinkedHashMap.getOrDefault(java.lang.Object,java.lang.Object), computeIfAbsent=public java.lang.Object java.util.HashMap.computeIfAbsent(java.lang.Object,java.util.function.Function), values=public java.util.Collection java.util.LinkedHashMap.values(), replace=freemarker.ext.beans.OverloadedMethods@11d0265, java.lang.Object@3e55b2={public boolean java.util.HashMap.isEmpty()=[Ljava.lang.Class;@c5aa3a, public int java.util.AbstractMap.hashCode()=[Ljava.lang.Class;@74a947, public java.lang.Object java.util.HashMap.put(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@1615a91, public boolean java.util.AbstractMap.equals(java.lang.Object)=[Ljava.lang.Class;@a46ab2, public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object)=[Ljava.lang.Class;@1c389e6, public java.lang.String java.util.AbstractMap.toString()=[Ljava.lang.Class;@a23548, public boolean java.util.HashMap.containsKey(java.lang.Object)=[Ljava.lang.Class;@1be4a9f, public java.util.Set java.util.LinkedHashMap.keySet()=[Ljava.lang.Class;@44c60, public java.lang.Object java.util.HashMap.computeIfAbsent(java.lang.Object,java.util.function.Function)=[Ljava.lang.Class;@10f7dff, public java.lang.Object java.util.HashMap.clone()=[Ljava.lang.Class;@d214e3, public java.lang.Object java.util.LinkedHashMap.getOrDefault(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@1a74254, public java.util.Set java.util.LinkedHashMap.entrySet()=[Ljava.lang.Class;@1c4740c, public void java.util.LinkedHashMap.forEach(java.util.function.BiConsumer)=[Ljava.lang.Class;@1fe0c8e, public java.lang.Object java.util.HashMap.putIfAbsent(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@16f73de, public java.util.Collection java.util.LinkedHashMap.values()=[Ljava.lang.Class;@b3e45, public void java.util.LinkedHashMap.clear()=[Ljava.lang.Class;@a34e5c, public java.lang.Object java.util.HashMap.computeIfPresent(java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1fcb13a, public java.lang.Object java.util.HashMap.compute(java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1a7c258, public final native java.lang.Class java.lang.Object.getClass()=[Ljava.lang.Class;@7397f, public void java.util.HashMap.putAll(java.util.Map)=[Ljava.lang.Class;@59cd, public void java.util.LinkedHashMap.replaceAll(java.util.function.BiFunction)=[Ljava.lang.Class;@994816, public java.lang.Object java.util.HashMap.merge(java.lang.Object,java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1b1e75f, public int java.util.HashMap.size()=[Ljava.lang.Class;@bee157, public boolean java.util.LinkedHashMap.containsValue(java.lang.Object)=[Ljava.lang.Class;@5e0d7c}, replaceAll=public void java.util.LinkedHashMap.replaceAll(java.util.function.BiFunction), remove=freemarker.ext.beans.OverloadedMethods@8d3a99, containsValue=public boolean java.util.LinkedHashMap.containsValue(java.lang.Object), put=public java.lang.Object java.util.HashMap.put(java.lang.Object,java.lang.Object), empty=java.beans.PropertyDescriptor[name=empty; propertyType=boolean; readMethod=public boolean java.util.HashMap.isEmpty()], compute=public java.lang.Object java.util.HashMap.compute(java.lang.Object,java.util.function.BiFunction), hashCode=public int java.util.AbstractMap.hashCode(), putAll=public void java.util.HashMap.putAll(java.util.Map), get=public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object), merge=public java.lang.Object java.util.HashMap.merge(java.lang.Object,java.lang.Object,java.util.function.BiFunction), class=java.beans.PropertyDescriptor[name=class; propertyType=class java.lang.Class; readMethod=public final native java.lang.Class java.lang.Object.getClass()], keySet=public java.util.Set java.util.LinkedHashMap.keySet(), java.lang.Object@1c0f21d=freemarker.ext.beans.OverloadedMethods@d4b988, entrySet=public java.util.Set java.util.LinkedHashMap.entrySet(), java.lang.Object@15be27d=public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object), forEach=public void java.util.LinkedHashMap.forEach(java.util.function.BiConsumer), containsKey=public boolean java.util.HashMap.containsKey(java.lang.Object), isEmpty=public boolean java.util.HashMap.isEmpty(), clear=public void java.util.LinkedHashMap.clear(), computeIfPresent=public java.lang.Object java.util.HashMap.computeIfPresent(java.lang.Object,java.util.function.BiFunction), size=public int java.util.HashMap.size(), equals=public boolean java.util.AbstractMap.equals(java.lang.Object), clone=public java.lang.Object java.util.HashMap.clone(), toString=public java.lang.String java.util.AbstractMap.toString(), putIfAbsent=public java.lang.Object java.util.HashMap.putIfAbsent(java.lang.Object,java.lang.Object)}
[DEBUG] 2017-05-24: 21:05:32 freemarker.log._Log4jLoggerFactory$Log4jLogger.debug(_Log4jLoggerFactory.java:45) :  Key "ondblclick" was not found on instance of java.util.LinkedHashMap. Introspection information for the class is: {getClass=public final native java.lang.Class java.lang.Object.getClass(), getOrDefault=public java.lang.Object java.util.LinkedHashMap.getOrDefault(java.lang.Object,java.lang.Object), computeIfAbsent=public java.lang.Object java.util.HashMap.computeIfAbsent(java.lang.Object,java.util.function.Function), values=public java.util.Collection java.util.LinkedHashMap.values(), replace=freemarker.ext.beans.OverloadedMethods@11d0265, java.lang.Object@3e55b2={public boolean java.util.HashMap.isEmpty()=[Ljava.lang.Class;@c5aa3a, public int java.util.AbstractMap.hashCode()=[Ljava.lang.Class;@74a947, public java.lang.Object java.util.HashMap.put(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@1615a91, public boolean java.util.AbstractMap.equals(java.lang.Object)=[Ljava.lang.Class;@a46ab2, public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object)=[Ljava.lang.Class;@1c389e6, public java.lang.String java.util.AbstractMap.toString()=[Ljava.lang.Class;@a23548, public boolean java.util.HashMap.containsKey(java.lang.Object)=[Ljava.lang.Class;@1be4a9f, public java.util.Set java.util.LinkedHashMap.keySet()=[Ljava.lang.Class;@44c60, public java.lang.Object java.util.HashMap.computeIfAbsent(java.lang.Object,java.util.function.Function)=[Ljava.lang.Class;@10f7dff, public java.lang.Object java.util.HashMap.clone()=[Ljava.lang.Class;@d214e3, public java.lang.Object java.util.LinkedHashMap.getOrDefault(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@1a74254, public java.util.Set java.util.LinkedHashMap.entrySet()=[Ljava.lang.Class;@1c4740c, public void java.util.LinkedHashMap.forEach(java.util.function.BiConsumer)=[Ljava.lang.Class;@1fe0c8e, public java.lang.Object java.util.HashMap.putIfAbsent(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@16f73de, public java.util.Collection java.util.LinkedHashMap.values()=[Ljava.lang.Class;@b3e45, public void java.util.LinkedHashMap.clear()=[Ljava.lang.Class;@a34e5c, public java.lang.Object java.util.HashMap.computeIfPresent(java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1fcb13a, public java.lang.Object java.util.HashMap.compute(java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1a7c258, public final native java.lang.Class java.lang.Object.getClass()=[Ljava.lang.Class;@7397f, public void java.util.HashMap.putAll(java.util.Map)=[Ljava.lang.Class;@59cd, public void java.util.LinkedHashMap.replaceAll(java.util.function.BiFunction)=[Ljava.lang.Class;@994816, public java.lang.Object java.util.HashMap.merge(java.lang.Object,java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1b1e75f, public int java.util.HashMap.size()=[Ljava.lang.Class;@bee157, public boolean java.util.LinkedHashMap.containsValue(java.lang.Object)=[Ljava.lang.Class;@5e0d7c}, replaceAll=public void java.util.LinkedHashMap.replaceAll(java.util.function.BiFunction), remove=freemarker.ext.beans.OverloadedMethods@8d3a99, containsValue=public boolean java.util.LinkedHashMap.containsValue(java.lang.Object), put=public java.lang.Object java.util.HashMap.put(java.lang.Object,java.lang.Object), empty=java.beans.PropertyDescriptor[name=empty; propertyType=boolean; readMethod=public boolean java.util.HashMap.isEmpty()], compute=public java.lang.Object java.util.HashMap.compute(java.lang.Object,java.util.function.BiFunction), hashCode=public int java.util.AbstractMap.hashCode(), putAll=public void java.util.HashMap.putAll(java.util.Map), get=public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object), merge=public java.lang.Object java.util.HashMap.merge(java.lang.Object,java.lang.Object,java.util.function.BiFunction), class=java.beans.PropertyDescriptor[name=class; propertyType=class java.lang.Class; readMethod=public final native java.lang.Class java.lang.Object.getClass()], keySet=public java.util.Set java.util.LinkedHashMap.keySet(), java.lang.Object@1c0f21d=freemarker.ext.beans.OverloadedMethods@d4b988, entrySet=public java.util.Set java.util.LinkedHashMap.entrySet(), java.lang.Object@15be27d=public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object), forEach=public void java.util.LinkedHashMap.forEach(java.util.function.BiConsumer), containsKey=public boolean java.util.HashMap.containsKey(java.lang.Object), isEmpty=public boolean java.util.HashMap.isEmpty(), clear=public void java.util.LinkedHashMap.clear(), computeIfPresent=public java.lang.Object java.util.HashMap.computeIfPresent(java.lang.Object,java.util.function.BiFunction), size=public int java.util.HashMap.size(), equals=public boolean java.util.AbstractMap.equals(java.lang.Object), clone=public java.lang.Object java.util.HashMap.clone(), toString=public java.lang.String java.util.AbstractMap.toString(), putIfAbsent=public java.lang.Object java.util.HashMap.putIfAbsent(java.lang.Object,java.lang.Object)}
[DEBUG] 2017-05-24: 21:05:32 freemarker.log._Log4jLoggerFactory$Log4jLogger.debug(_Log4jLoggerFactory.java:45) :  Key "onmousedown" was not found on instance of java.util.LinkedHashMap. Introspection information for the class is: {getClass=public final native java.lang.Class java.lang.Object.getClass(), getOrDefault=public java.lang.Object java.util.LinkedHashMap.getOrDefault(java.lang.Object,java.lang.Object), computeIfAbsent=public java.lang.Object java.util.HashMap.computeIfAbsent(java.lang.Object,java.util.function.Function), values=public java.util.Collection java.util.LinkedHashMap.values(), replace=freemarker.ext.beans.OverloadedMethods@11d0265, java.lang.Object@3e55b2={public boolean java.util.HashMap.isEmpty()=[Ljava.lang.Class;@c5aa3a, public int java.util.AbstractMap.hashCode()=[Ljava.lang.Class;@74a947, public java.lang.Object java.util.HashMap.put(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@1615a91, public boolean java.util.AbstractMap.equals(java.lang.Object)=[Ljava.lang.Class;@a46ab2, public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object)=[Ljava.lang.Class;@1c389e6, public java.lang.String java.util.AbstractMap.toString()=[Ljava.lang.Class;@a23548, public boolean java.util.HashMap.containsKey(java.lang.Object)=[Ljava.lang.Class;@1be4a9f, public java.util.Set java.util.LinkedHashMap.keySet()=[Ljava.lang.Class;@44c60, public java.lang.Object java.util.HashMap.computeIfAbsent(java.lang.Object,java.util.function.Function)=[Ljava.lang.Class;@10f7dff, public java.lang.Object java.util.HashMap.clone()=[Ljava.lang.Class;@d214e3, public java.lang.Object java.util.LinkedHashMap.getOrDefault(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@1a74254, public java.util.Set java.util.LinkedHashMap.entrySet()=[Ljava.lang.Class;@1c4740c, public void java.util.LinkedHashMap.forEach(java.util.function.BiConsumer)=[Ljava.lang.Class;@1fe0c8e, public java.lang.Object java.util.HashMap.putIfAbsent(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@16f73de, public java.util.Collection java.util.LinkedHashMap.values()=[Ljava.lang.Class;@b3e45, public void java.util.LinkedHashMap.clear()=[Ljava.lang.Class;@a34e5c, public java.lang.Object java.util.HashMap.computeIfPresent(java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1fcb13a, public java.lang.Object java.util.HashMap.compute(java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1a7c258, public final native java.lang.Class java.lang.Object.getClass()=[Ljava.lang.Class;@7397f, public void java.util.HashMap.putAll(java.util.Map)=[Ljava.lang.Class;@59cd, public void java.util.LinkedHashMap.replaceAll(java.util.function.BiFunction)=[Ljava.lang.Class;@994816, public java.lang.Object java.util.HashMap.merge(java.lang.Object,java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1b1e75f, public int java.util.HashMap.size()=[Ljava.lang.Class;@bee157, public boolean java.util.LinkedHashMap.containsValue(java.lang.Object)=[Ljava.lang.Class;@5e0d7c}, replaceAll=public void java.util.LinkedHashMap.replaceAll(java.util.function.BiFunction), remove=freemarker.ext.beans.OverloadedMethods@8d3a99, containsValue=public boolean java.util.LinkedHashMap.containsValue(java.lang.Object), put=public java.lang.Object java.util.HashMap.put(java.lang.Object,java.lang.Object), empty=java.beans.PropertyDescriptor[name=empty; propertyType=boolean; readMethod=public boolean java.util.HashMap.isEmpty()], compute=public java.lang.Object java.util.HashMap.compute(java.lang.Object,java.util.function.BiFunction), hashCode=public int java.util.AbstractMap.hashCode(), putAll=public void java.util.HashMap.putAll(java.util.Map), get=public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object), merge=public java.lang.Object java.util.HashMap.merge(java.lang.Object,java.lang.Object,java.util.function.BiFunction), class=java.beans.PropertyDescriptor[name=class; propertyType=class java.lang.Class; readMethod=public final native java.lang.Class java.lang.Object.getClass()], keySet=public java.util.Set java.util.LinkedHashMap.keySet(), java.lang.Object@1c0f21d=freemarker.ext.beans.OverloadedMethods@d4b988, entrySet=public java.util.Set java.util.LinkedHashMap.entrySet(), java.lang.Object@15be27d=public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object), forEach=public void java.util.LinkedHashMap.forEach(java.util.function.BiConsumer), containsKey=public boolean java.util.HashMap.containsKey(java.lang.Object), isEmpty=public boolean java.util.HashMap.isEmpty(), clear=public void java.util.LinkedHashMap.clear(), computeIfPresent=public java.lang.Object java.util.HashMap.computeIfPresent(java.lang.Object,java.util.function.BiFunction), size=public int java.util.HashMap.size(), equals=public boolean java.util.AbstractMap.equals(java.lang.Object), clone=public java.lang.Object java.util.HashMap.clone(), toString=public java.lang.String java.util.AbstractMap.toString(), putIfAbsent=public java.lang.Object java.util.HashMap.putIfAbsent(java.lang.Object,java.lang.Object)}
[DEBUG] 2017-05-24: 21:05:32 freemarker.log._Log4jLoggerFactory$Log4jLogger.debug(_Log4jLoggerFactory.java:45) :  Key "onmouseup" was not found on instance of java.util.LinkedHashMap. Introspection information for the class is: {getClass=public final native java.lang.Class java.lang.Object.getClass(), getOrDefault=public java.lang.Object java.util.LinkedHashMap.getOrDefault(java.lang.Object,java.lang.Object), computeIfAbsent=public java.lang.Object java.util.HashMap.computeIfAbsent(java.lang.Object,java.util.function.Function), values=public java.util.Collection java.util.LinkedHashMap.values(), replace=freemarker.ext.beans.OverloadedMethods@11d0265, java.lang.Object@3e55b2={public boolean java.util.HashMap.isEmpty()=[Ljava.lang.Class;@c5aa3a, public int java.util.AbstractMap.hashCode()=[Ljava.lang.Class;@74a947, public java.lang.Object java.util.HashMap.put(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@1615a91, public boolean java.util.AbstractMap.equals(java.lang.Object)=[Ljava.lang.Class;@a46ab2, public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object)=[Ljava.lang.Class;@1c389e6, public java.lang.String java.util.AbstractMap.toString()=[Ljava.lang.Class;@a23548, public boolean java.util.HashMap.containsKey(java.lang.Object)=[Ljava.lang.Class;@1be4a9f, public java.util.Set java.util.LinkedHashMap.keySet()=[Ljava.lang.Class;@44c60, public java.lang.Object java.util.HashMap.computeIfAbsent(java.lang.Object,java.util.function.Function)=[Ljava.lang.Class;@10f7dff, public java.lang.Object java.util.HashMap.clone()=[Ljava.lang.Class;@d214e3, public java.lang.Object java.util.LinkedHashMap.getOrDefault(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@1a74254, public java.util.Set java.util.LinkedHashMap.entrySet()=[Ljava.lang.Class;@1c4740c, public void java.util.LinkedHashMap.forEach(java.util.function.BiConsumer)=[Ljava.lang.Class;@1fe0c8e, public java.lang.Object java.util.HashMap.putIfAbsent(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@16f73de, public java.util.Collection java.util.LinkedHashMap.values()=[Ljava.lang.Class;@b3e45, public void java.util.LinkedHashMap.clear()=[Ljava.lang.Class;@a34e5c, public java.lang.Object java.util.HashMap.computeIfPresent(java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1fcb13a, public java.lang.Object java.util.HashMap.compute(java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1a7c258, public final native java.lang.Class java.lang.Object.getClass()=[Ljava.lang.Class;@7397f, public void java.util.HashMap.putAll(java.util.Map)=[Ljava.lang.Class;@59cd, public void java.util.LinkedHashMap.replaceAll(java.util.function.BiFunction)=[Ljava.lang.Class;@994816, public java.lang.Object java.util.HashMap.merge(java.lang.Object,java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1b1e75f, public int java.util.HashMap.size()=[Ljava.lang.Class;@bee157, public boolean java.util.LinkedHashMap.containsValue(java.lang.Object)=[Ljava.lang.Class;@5e0d7c}, replaceAll=public void java.util.LinkedHashMap.replaceAll(java.util.function.BiFunction), remove=freemarker.ext.beans.OverloadedMethods@8d3a99, containsValue=public boolean java.util.LinkedHashMap.containsValue(java.lang.Object), put=public java.lang.Object java.util.HashMap.put(java.lang.Object,java.lang.Object), empty=java.beans.PropertyDescriptor[name=empty; propertyType=boolean; readMethod=public boolean java.util.HashMap.isEmpty()], compute=public java.lang.Object java.util.HashMap.compute(java.lang.Object,java.util.function.BiFunction), hashCode=public int java.util.AbstractMap.hashCode(), putAll=public void java.util.HashMap.putAll(java.util.Map), get=public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object), merge=public java.lang.Object java.util.HashMap.merge(java.lang.Object,java.lang.Object,java.util.function.BiFunction), class=java.beans.PropertyDescriptor[name=class; propertyType=class java.lang.Class; readMethod=public final native java.lang.Class java.lang.Object.getClass()], keySet=public java.util.Set java.util.LinkedHashMap.keySet(), java.lang.Object@1c0f21d=freemarker.ext.beans.OverloadedMethods@d4b988, entrySet=public java.util.Set java.util.LinkedHashMap.entrySet(), java.lang.Object@15be27d=public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object), forEach=public void java.util.LinkedHashMap.forEach(java.util.function.BiConsumer), containsKey=public boolean java.util.HashMap.containsKey(java.lang.Object), isEmpty=public boolean java.util.HashMap.isEmpty(), clear=public void java.util.LinkedHashMap.clear(), computeIfPresent=public java.lang.Object java.util.HashMap.computeIfPresent(java.lang.Object,java.util.function.BiFunction), size=public int java.util.HashMap.size(), equals=public boolean java.util.AbstractMap.equals(java.lang.Object), clone=public java.lang.Object java.util.HashMap.clone(), toString=public java.lang.String java.util.AbstractMap.toString(), putIfAbsent=public java.lang.Object java.util.HashMap.putIfAbsent(java.lang.Object,java.lang.Object)}
[DEBUG] 2017-05-24: 21:05:32 freemarker.log._Log4jLoggerFactory$Log4jLogger.debug(_Log4jLoggerFactory.java:45) :  Key "onmouseover" was not found on instance of java.util.LinkedHashMap. Introspection information for the class is: {getClass=public final native java.lang.Class java.lang.Object.getClass(), getOrDefault=public java.lang.Object java.util.LinkedHashMap.getOrDefault(java.lang.Object,java.lang.Object), computeIfAbsent=public java.lang.Object java.util.HashMap.computeIfAbsent(java.lang.Object,java.util.function.Function), values=public java.util.Collection java.util.LinkedHashMap.values(), replace=freemarker.ext.beans.OverloadedMethods@11d0265, java.lang.Object@3e55b2={public boolean java.util.HashMap.isEmpty()=[Ljava.lang.Class;@c5aa3a, public int java.util.AbstractMap.hashCode()=[Ljava.lang.Class;@74a947, public java.lang.Object java.util.HashMap.put(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@1615a91, public boolean java.util.AbstractMap.equals(java.lang.Object)=[Ljava.lang.Class;@a46ab2, public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object)=[Ljava.lang.Class;@1c389e6, public java.lang.String java.util.AbstractMap.toString()=[Ljava.lang.Class;@a23548, public boolean java.util.HashMap.containsKey(java.lang.Object)=[Ljava.lang.Class;@1be4a9f, public java.util.Set java.util.LinkedHashMap.keySet()=[Ljava.lang.Class;@44c60, public java.lang.Object java.util.HashMap.computeIfAbsent(java.lang.Object,java.util.function.Function)=[Ljava.lang.Class;@10f7dff, public java.lang.Object java.util.HashMap.clone()=[Ljava.lang.Class;@d214e3, public java.lang.Object java.util.LinkedHashMap.getOrDefault(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@1a74254, public java.util.Set java.util.LinkedHashMap.entrySet()=[Ljava.lang.Class;@1c4740c, public void java.util.LinkedHashMap.forEach(java.util.function.BiConsumer)=[Ljava.lang.Class;@1fe0c8e, public java.lang.Object java.util.HashMap.putIfAbsent(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@16f73de, public java.util.Collection java.util.LinkedHashMap.values()=[Ljava.lang.Class;@b3e45, public void java.util.LinkedHashMap.clear()=[Ljava.lang.Class;@a34e5c, public java.lang.Object java.util.HashMap.computeIfPresent(java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1fcb13a, public java.lang.Object java.util.HashMap.compute(java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1a7c258, public final native java.lang.Class java.lang.Object.getClass()=[Ljava.lang.Class;@7397f, public void java.util.HashMap.putAll(java.util.Map)=[Ljava.lang.Class;@59cd, public void java.util.LinkedHashMap.replaceAll(java.util.function.BiFunction)=[Ljava.lang.Class;@994816, public java.lang.Object java.util.HashMap.merge(java.lang.Object,java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1b1e75f, public int java.util.HashMap.size()=[Ljava.lang.Class;@bee157, public boolean java.util.LinkedHashMap.containsValue(java.lang.Object)=[Ljava.lang.Class;@5e0d7c}, replaceAll=public void java.util.LinkedHashMap.replaceAll(java.util.function.BiFunction), remove=freemarker.ext.beans.OverloadedMethods@8d3a99, containsValue=public boolean java.util.LinkedHashMap.containsValue(java.lang.Object), put=public java.lang.Object java.util.HashMap.put(java.lang.Object,java.lang.Object), empty=java.beans.PropertyDescriptor[name=empty; propertyType=boolean; readMethod=public boolean java.util.HashMap.isEmpty()], compute=public java.lang.Object java.util.HashMap.compute(java.lang.Object,java.util.function.BiFunction), hashCode=public int java.util.AbstractMap.hashCode(), putAll=public void java.util.HashMap.putAll(java.util.Map), get=public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object), merge=public java.lang.Object java.util.HashMap.merge(java.lang.Object,java.lang.Object,java.util.function.BiFunction), class=java.beans.PropertyDescriptor[name=class; propertyType=class java.lang.Class; readMethod=public final native java.lang.Class java.lang.Object.getClass()], keySet=public java.util.Set java.util.LinkedHashMap.keySet(), java.lang.Object@1c0f21d=freemarker.ext.beans.OverloadedMethods@d4b988, entrySet=public java.util.Set java.util.LinkedHashMap.entrySet(), java.lang.Object@15be27d=public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object), forEach=public void java.util.LinkedHashMap.forEach(java.util.function.BiConsumer), containsKey=public boolean java.util.HashMap.containsKey(java.lang.Object), isEmpty=public boolean java.util.HashMap.isEmpty(), clear=public void java.util.LinkedHashMap.clear(), computeIfPresent=public java.lang.Object java.util.HashMap.computeIfPresent(java.lang.Object,java.util.function.BiFunction), size=public int java.util.HashMap.size(), equals=public boolean java.util.AbstractMap.equals(java.lang.Object), clone=public java.lang.Object java.util.HashMap.clone(), toString=public java.lang.String java.util.AbstractMap.toString(), putIfAbsent=public java.lang.Object java.util.HashMap.putIfAbsent(java.lang.Object,java.lang.Object)}
[DEBUG] 2017-05-24: 21:05:32 freemarker.log._Log4jLoggerFactory$Log4jLogger.debug(_Log4jLoggerFactory.java:45) :  Key "onmousemove" was not found on instance of java.util.LinkedHashMap. Introspection information for the class is: {getClass=public final native java.lang.Class java.lang.Object.getClass(), getOrDefault=public java.lang.Object java.util.LinkedHashMap.getOrDefault(java.lang.Object,java.lang.Object), computeIfAbsent=public java.lang.Object java.util.HashMap.computeIfAbsent(java.lang.Object,java.util.function.Function), values=public java.util.Collection java.util.LinkedHashMap.values(), replace=freemarker.ext.beans.OverloadedMethods@11d0265, java.lang.Object@3e55b2={public boolean java.util.HashMap.isEmpty()=[Ljava.lang.Class;@c5aa3a, public int java.util.AbstractMap.hashCode()=[Ljava.lang.Class;@74a947, public java.lang.Object java.util.HashMap.put(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@1615a91, public boolean java.util.AbstractMap.equals(java.lang.Object)=[Ljava.lang.Class;@a46ab2, public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object)=[Ljava.lang.Class;@1c389e6, public java.lang.String java.util.AbstractMap.toString()=[Ljava.lang.Class;@a23548, public boolean java.util.HashMap.containsKey(java.lang.Object)=[Ljava.lang.Class;@1be4a9f, public java.util.Set java.util.LinkedHashMap.keySet()=[Ljava.lang.Class;@44c60, public java.lang.Object java.util.HashMap.computeIfAbsent(java.lang.Object,java.util.function.Function)=[Ljava.lang.Class;@10f7dff, public java.lang.Object java.util.HashMap.clone()=[Ljava.lang.Class;@d214e3, public java.lang.Object java.util.LinkedHashMap.getOrDefault(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@1a74254, public java.util.Set java.util.LinkedHashMap.entrySet()=[Ljava.lang.Class;@1c4740c, public void java.util.LinkedHashMap.forEach(java.util.function.BiConsumer)=[Ljava.lang.Class;@1fe0c8e, public java.lang.Object java.util.HashMap.putIfAbsent(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@16f73de, public java.util.Collection java.util.LinkedHashMap.values()=[Ljava.lang.Class;@b3e45, public void java.util.LinkedHashMap.clear()=[Ljava.lang.Class;@a34e5c, public java.lang.Object java.util.HashMap.computeIfPresent(java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1fcb13a, public java.lang.Object java.util.HashMap.compute(java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1a7c258, public final native java.lang.Class java.lang.Object.getClass()=[Ljava.lang.Class;@7397f, public void java.util.HashMap.putAll(java.util.Map)=[Ljava.lang.Class;@59cd, public void java.util.LinkedHashMap.replaceAll(java.util.function.BiFunction)=[Ljava.lang.Class;@994816, public java.lang.Object java.util.HashMap.merge(java.lang.Object,java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1b1e75f, public int java.util.HashMap.size()=[Ljava.lang.Class;@bee157, public boolean java.util.LinkedHashMap.containsValue(java.lang.Object)=[Ljava.lang.Class;@5e0d7c}, replaceAll=public void java.util.LinkedHashMap.replaceAll(java.util.function.BiFunction), remove=freemarker.ext.beans.OverloadedMethods@8d3a99, containsValue=public boolean java.util.LinkedHashMap.containsValue(java.lang.Object), put=public java.lang.Object java.util.HashMap.put(java.lang.Object,java.lang.Object), empty=java.beans.PropertyDescriptor[name=empty; propertyType=boolean; readMethod=public boolean java.util.HashMap.isEmpty()], compute=public java.lang.Object java.util.HashMap.compute(java.lang.Object,java.util.function.BiFunction), hashCode=public int java.util.AbstractMap.hashCode(), putAll=public void java.util.HashMap.putAll(java.util.Map), get=public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object), merge=public java.lang.Object java.util.HashMap.merge(java.lang.Object,java.lang.Object,java.util.function.BiFunction), class=java.beans.PropertyDescriptor[name=class; propertyType=class java.lang.Class; readMethod=public final native java.lang.Class java.lang.Object.getClass()], keySet=public java.util.Set java.util.LinkedHashMap.keySet(), java.lang.Object@1c0f21d=freemarker.ext.beans.OverloadedMethods@d4b988, entrySet=public java.util.Set java.util.LinkedHashMap.entrySet(), java.lang.Object@15be27d=public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object), forEach=public void java.util.LinkedHashMap.forEach(java.util.function.BiConsumer), containsKey=public boolean java.util.HashMap.containsKey(java.lang.Object), isEmpty=public boolean java.util.HashMap.isEmpty(), clear=public void java.util.LinkedHashMap.clear(), computeIfPresent=public java.lang.Object java.util.HashMap.computeIfPresent(java.lang.Object,java.util.function.BiFunction), size=public int java.util.HashMap.size(), equals=public boolean java.util.AbstractMap.equals(java.lang.Object), clone=public java.lang.Object java.util.HashMap.clone(), toString=public java.lang.String java.util.AbstractMap.toString(), putIfAbsent=public java.lang.Object java.util.HashMap.putIfAbsent(java.lang.Object,java.lang.Object)}
[DEBUG] 2017-05-24: 21:05:32 freemarker.log._Log4jLoggerFactory$Log4jLogger.debug(_Log4jLoggerFactory.java:45) :  Key "onmouseout" was not found on instance of java.util.LinkedHashMap. Introspection information for the class is: {getClass=public final native java.lang.Class java.lang.Object.getClass(), getOrDefault=public java.lang.Object java.util.LinkedHashMap.getOrDefault(java.lang.Object,java.lang.Object), computeIfAbsent=public java.lang.Object java.util.HashMap.computeIfAbsent(java.lang.Object,java.util.function.Function), values=public java.util.Collection java.util.LinkedHashMap.values(), replace=freemarker.ext.beans.OverloadedMethods@11d0265, java.lang.Object@3e55b2={public boolean java.util.HashMap.isEmpty()=[Ljava.lang.Class;@c5aa3a, public int java.util.AbstractMap.hashCode()=[Ljava.lang.Class;@74a947, public java.lang.Object java.util.HashMap.put(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@1615a91, public boolean java.util.AbstractMap.equals(java.lang.Object)=[Ljava.lang.Class;@a46ab2, public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object)=[Ljava.lang.Class;@1c389e6, public java.lang.String java.util.AbstractMap.toString()=[Ljava.lang.Class;@a23548, public boolean java.util.HashMap.containsKey(java.lang.Object)=[Ljava.lang.Class;@1be4a9f, public java.util.Set java.util.LinkedHashMap.keySet()=[Ljava.lang.Class;@44c60, public java.lang.Object java.util.HashMap.computeIfAbsent(java.lang.Object,java.util.function.Function)=[Ljava.lang.Class;@10f7dff, public java.lang.Object java.util.HashMap.clone()=[Ljava.lang.Class;@d214e3, public java.lang.Object java.util.LinkedHashMap.getOrDefault(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@1a74254, public java.util.Set java.util.LinkedHashMap.entrySet()=[Ljava.lang.Class;@1c4740c, public void java.util.LinkedHashMap.forEach(java.util.function.BiConsumer)=[Ljava.lang.Class;@1fe0c8e, public java.lang.Object java.util.HashMap.putIfAbsent(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@16f73de, public java.util.Collection java.util.LinkedHashMap.values()=[Ljava.lang.Class;@b3e45, public void java.util.LinkedHashMap.clear()=[Ljava.lang.Class;@a34e5c, public java.lang.Object java.util.HashMap.computeIfPresent(java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1fcb13a, public java.lang.Object java.util.HashMap.compute(java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1a7c258, public final native java.lang.Class java.lang.Object.getClass()=[Ljava.lang.Class;@7397f, public void java.util.HashMap.putAll(java.util.Map)=[Ljava.lang.Class;@59cd, public void java.util.LinkedHashMap.replaceAll(java.util.function.BiFunction)=[Ljava.lang.Class;@994816, public java.lang.Object java.util.HashMap.merge(java.lang.Object,java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1b1e75f, public int java.util.HashMap.size()=[Ljava.lang.Class;@bee157, public boolean java.util.LinkedHashMap.containsValue(java.lang.Object)=[Ljava.lang.Class;@5e0d7c}, replaceAll=public void java.util.LinkedHashMap.replaceAll(java.util.function.BiFunction), remove=freemarker.ext.beans.OverloadedMethods@8d3a99, containsValue=public boolean java.util.LinkedHashMap.containsValue(java.lang.Object), put=public java.lang.Object java.util.HashMap.put(java.lang.Object,java.lang.Object), empty=java.beans.PropertyDescriptor[name=empty; propertyType=boolean; readMethod=public boolean java.util.HashMap.isEmpty()], compute=public java.lang.Object java.util.HashMap.compute(java.lang.Object,java.util.function.BiFunction), hashCode=public int java.util.AbstractMap.hashCode(), putAll=public void java.util.HashMap.putAll(java.util.Map), get=public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object), merge=public java.lang.Object java.util.HashMap.merge(java.lang.Object,java.lang.Object,java.util.function.BiFunction), class=java.beans.PropertyDescriptor[name=class; propertyType=class java.lang.Class; readMethod=public final native java.lang.Class java.lang.Object.getClass()], keySet=public java.util.Set java.util.LinkedHashMap.keySet(), java.lang.Object@1c0f21d=freemarker.ext.beans.OverloadedMethods@d4b988, entrySet=public java.util.Set java.util.LinkedHashMap.entrySet(), java.lang.Object@15be27d=public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object), forEach=public void java.util.LinkedHashMap.forEach(java.util.function.BiConsumer), containsKey=public boolean java.util.HashMap.containsKey(java.lang.Object), isEmpty=public boolean java.util.HashMap.isEmpty(), clear=public void java.util.LinkedHashMap.clear(), computeIfPresent=public java.lang.Object java.util.HashMap.computeIfPresent(java.lang.Object,java.util.function.BiFunction), size=public int java.util.HashMap.size(), equals=public boolean java.util.AbstractMap.equals(java.lang.Object), clone=public java.lang.Object java.util.HashMap.clone(), toString=public java.lang.String java.util.AbstractMap.toString(), putIfAbsent=public java.lang.Object java.util.HashMap.putIfAbsent(java.lang.Object,java.lang.Object)}
[DEBUG] 2017-05-24: 21:05:32 freemarker.log._Log4jLoggerFactory$Log4jLogger.debug(_Log4jLoggerFactory.java:45) :  Key "onfocus" was not found on instance of java.util.LinkedHashMap. Introspection information for the class is: {getClass=public final native java.lang.Class java.lang.Object.getClass(), getOrDefault=public java.lang.Object java.util.LinkedHashMap.getOrDefault(java.lang.Object,java.lang.Object), computeIfAbsent=public java.lang.Object java.util.HashMap.computeIfAbsent(java.lang.Object,java.util.function.Function), values=public java.util.Collection java.util.LinkedHashMap.values(), replace=freemarker.ext.beans.OverloadedMethods@11d0265, java.lang.Object@3e55b2={public boolean java.util.HashMap.isEmpty()=[Ljava.lang.Class;@c5aa3a, public int java.util.AbstractMap.hashCode()=[Ljava.lang.Class;@74a947, public java.lang.Object java.util.HashMap.put(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@1615a91, public boolean java.util.AbstractMap.equals(java.lang.Object)=[Ljava.lang.Class;@a46ab2, public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object)=[Ljava.lang.Class;@1c389e6, public java.lang.String java.util.AbstractMap.toString()=[Ljava.lang.Class;@a23548, public boolean java.util.HashMap.containsKey(java.lang.Object)=[Ljava.lang.Class;@1be4a9f, public java.util.Set java.util.LinkedHashMap.keySet()=[Ljava.lang.Class;@44c60, public java.lang.Object java.util.HashMap.computeIfAbsent(java.lang.Object,java.util.function.Function)=[Ljava.lang.Class;@10f7dff, public java.lang.Object java.util.HashMap.clone()=[Ljava.lang.Class;@d214e3, public java.lang.Object java.util.LinkedHashMap.getOrDefault(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@1a74254, public java.util.Set java.util.LinkedHashMap.entrySet()=[Ljava.lang.Class;@1c4740c, public void java.util.LinkedHashMap.forEach(java.util.function.BiConsumer)=[Ljava.lang.Class;@1fe0c8e, public java.lang.Object java.util.HashMap.putIfAbsent(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@16f73de, public java.util.Collection java.util.LinkedHashMap.values()=[Ljava.lang.Class;@b3e45, public void java.util.LinkedHashMap.clear()=[Ljava.lang.Class;@a34e5c, public java.lang.Object java.util.HashMap.computeIfPresent(java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1fcb13a, public java.lang.Object java.util.HashMap.compute(java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1a7c258, public final native java.lang.Class java.lang.Object.getClass()=[Ljava.lang.Class;@7397f, public void java.util.HashMap.putAll(java.util.Map)=[Ljava.lang.Class;@59cd, public void java.util.LinkedHashMap.replaceAll(java.util.function.BiFunction)=[Ljava.lang.Class;@994816, public java.lang.Object java.util.HashMap.merge(java.lang.Object,java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1b1e75f, public int java.util.HashMap.size()=[Ljava.lang.Class;@bee157, public boolean java.util.LinkedHashMap.containsValue(java.lang.Object)=[Ljava.lang.Class;@5e0d7c}, replaceAll=public void java.util.LinkedHashMap.replaceAll(java.util.function.BiFunction), remove=freemarker.ext.beans.OverloadedMethods@8d3a99, containsValue=public boolean java.util.LinkedHashMap.containsValue(java.lang.Object), put=public java.lang.Object java.util.HashMap.put(java.lang.Object,java.lang.Object), empty=java.beans.PropertyDescriptor[name=empty; propertyType=boolean; readMethod=public boolean java.util.HashMap.isEmpty()], compute=public java.lang.Object java.util.HashMap.compute(java.lang.Object,java.util.function.BiFunction), hashCode=public int java.util.AbstractMap.hashCode(), putAll=public void java.util.HashMap.putAll(java.util.Map), get=public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object), merge=public java.lang.Object java.util.HashMap.merge(java.lang.Object,java.lang.Object,java.util.function.BiFunction), class=java.beans.PropertyDescriptor[name=class; propertyType=class java.lang.Class; readMethod=public final native java.lang.Class java.lang.Object.getClass()], keySet=public java.util.Set java.util.LinkedHashMap.keySet(), java.lang.Object@1c0f21d=freemarker.ext.beans.OverloadedMethods@d4b988, entrySet=public java.util.Set java.util.LinkedHashMap.entrySet(), java.lang.Object@15be27d=public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object), forEach=public void java.util.LinkedHashMap.forEach(java.util.function.BiConsumer), containsKey=public boolean java.util.HashMap.containsKey(java.lang.Object), isEmpty=public boolean java.util.HashMap.isEmpty(), clear=public void java.util.LinkedHashMap.clear(), computeIfPresent=public java.lang.Object java.util.HashMap.computeIfPresent(java.lang.Object,java.util.function.BiFunction), size=public int java.util.HashMap.size(), equals=public boolean java.util.AbstractMap.equals(java.lang.Object), clone=public java.lang.Object java.util.HashMap.clone(), toString=public java.lang.String java.util.AbstractMap.toString(), putIfAbsent=public java.lang.Object java.util.HashMap.putIfAbsent(java.lang.Object,java.lang.Object)}
[DEBUG] 2017-05-24: 21:05:32 freemarker.log._Log4jLoggerFactory$Log4jLogger.debug(_Log4jLoggerFactory.java:45) :  Key "onblur" was not found on instance of java.util.LinkedHashMap. Introspection information for the class is: {getClass=public final native java.lang.Class java.lang.Object.getClass(), getOrDefault=public java.lang.Object java.util.LinkedHashMap.getOrDefault(java.lang.Object,java.lang.Object), computeIfAbsent=public java.lang.Object java.util.HashMap.computeIfAbsent(java.lang.Object,java.util.function.Function), values=public java.util.Collection java.util.LinkedHashMap.values(), replace=freemarker.ext.beans.OverloadedMethods@11d0265, java.lang.Object@3e55b2={public boolean java.util.HashMap.isEmpty()=[Ljava.lang.Class;@c5aa3a, public int java.util.AbstractMap.hashCode()=[Ljava.lang.Class;@74a947, public java.lang.Object java.util.HashMap.put(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@1615a91, public boolean java.util.AbstractMap.equals(java.lang.Object)=[Ljava.lang.Class;@a46ab2, public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object)=[Ljava.lang.Class;@1c389e6, public java.lang.String java.util.AbstractMap.toString()=[Ljava.lang.Class;@a23548, public boolean java.util.HashMap.containsKey(java.lang.Object)=[Ljava.lang.Class;@1be4a9f, public java.util.Set java.util.LinkedHashMap.keySet()=[Ljava.lang.Class;@44c60, public java.lang.Object java.util.HashMap.computeIfAbsent(java.lang.Object,java.util.function.Function)=[Ljava.lang.Class;@10f7dff, public java.lang.Object java.util.HashMap.clone()=[Ljava.lang.Class;@d214e3, public java.lang.Object java.util.LinkedHashMap.getOrDefault(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@1a74254, public java.util.Set java.util.LinkedHashMap.entrySet()=[Ljava.lang.Class;@1c4740c, public void java.util.LinkedHashMap.forEach(java.util.function.BiConsumer)=[Ljava.lang.Class;@1fe0c8e, public java.lang.Object java.util.HashMap.putIfAbsent(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@16f73de, public java.util.Collection java.util.LinkedHashMap.values()=[Ljava.lang.Class;@b3e45, public void java.util.LinkedHashMap.clear()=[Ljava.lang.Class;@a34e5c, public java.lang.Object java.util.HashMap.computeIfPresent(java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1fcb13a, public java.lang.Object java.util.HashMap.compute(java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1a7c258, public final native java.lang.Class java.lang.Object.getClass()=[Ljava.lang.Class;@7397f, public void java.util.HashMap.putAll(java.util.Map)=[Ljava.lang.Class;@59cd, public void java.util.LinkedHashMap.replaceAll(java.util.function.BiFunction)=[Ljava.lang.Class;@994816, public java.lang.Object java.util.HashMap.merge(java.lang.Object,java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1b1e75f, public int java.util.HashMap.size()=[Ljava.lang.Class;@bee157, public boolean java.util.LinkedHashMap.containsValue(java.lang.Object)=[Ljava.lang.Class;@5e0d7c}, replaceAll=public void java.util.LinkedHashMap.replaceAll(java.util.function.BiFunction), remove=freemarker.ext.beans.OverloadedMethods@8d3a99, containsValue=public boolean java.util.LinkedHashMap.containsValue(java.lang.Object), put=public java.lang.Object java.util.HashMap.put(java.lang.Object,java.lang.Object), empty=java.beans.PropertyDescriptor[name=empty; propertyType=boolean; readMethod=public boolean java.util.HashMap.isEmpty()], compute=public java.lang.Object java.util.HashMap.compute(java.lang.Object,java.util.function.BiFunction), hashCode=public int java.util.AbstractMap.hashCode(), putAll=public void java.util.HashMap.putAll(java.util.Map), get=public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object), merge=public java.lang.Object java.util.HashMap.merge(java.lang.Object,java.lang.Object,java.util.function.BiFunction), class=java.beans.PropertyDescriptor[name=class; propertyType=class java.lang.Class; readMethod=public final native java.lang.Class java.lang.Object.getClass()], keySet=public java.util.Set java.util.LinkedHashMap.keySet(), java.lang.Object@1c0f21d=freemarker.ext.beans.OverloadedMethods@d4b988, entrySet=public java.util.Set java.util.LinkedHashMap.entrySet(), java.lang.Object@15be27d=public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object), forEach=public void java.util.LinkedHashMap.forEach(java.util.function.BiConsumer), containsKey=public boolean java.util.HashMap.containsKey(java.lang.Object), isEmpty=public boolean java.util.HashMap.isEmpty(), clear=public void java.util.LinkedHashMap.clear(), computeIfPresent=public java.lang.Object java.util.HashMap.computeIfPresent(java.lang.Object,java.util.function.BiFunction), size=public int java.util.HashMap.size(), equals=public boolean java.util.AbstractMap.equals(java.lang.Object), clone=public java.lang.Object java.util.HashMap.clone(), toString=public java.lang.String java.util.AbstractMap.toString(), putIfAbsent=public java.lang.Object java.util.HashMap.putIfAbsent(java.lang.Object,java.lang.Object)}
[DEBUG] 2017-05-24: 21:05:32 freemarker.log._Log4jLoggerFactory$Log4jLogger.debug(_Log4jLoggerFactory.java:45) :  Key "onkeypress" was not found on instance of java.util.LinkedHashMap. Introspection information for the class is: {getClass=public final native java.lang.Class java.lang.Object.getClass(), getOrDefault=public java.lang.Object java.util.LinkedHashMap.getOrDefault(java.lang.Object,java.lang.Object), computeIfAbsent=public java.lang.Object java.util.HashMap.computeIfAbsent(java.lang.Object,java.util.function.Function), values=public java.util.Collection java.util.LinkedHashMap.values(), replace=freemarker.ext.beans.OverloadedMethods@11d0265, java.lang.Object@3e55b2={public boolean java.util.HashMap.isEmpty()=[Ljava.lang.Class;@c5aa3a, public int java.util.AbstractMap.hashCode()=[Ljava.lang.Class;@74a947, public java.lang.Object java.util.HashMap.put(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@1615a91, public boolean java.util.AbstractMap.equals(java.lang.Object)=[Ljava.lang.Class;@a46ab2, public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object)=[Ljava.lang.Class;@1c389e6, public java.lang.String java.util.AbstractMap.toString()=[Ljava.lang.Class;@a23548, public boolean java.util.HashMap.containsKey(java.lang.Object)=[Ljava.lang.Class;@1be4a9f, public java.util.Set java.util.LinkedHashMap.keySet()=[Ljava.lang.Class;@44c60, public java.lang.Object java.util.HashMap.computeIfAbsent(java.lang.Object,java.util.function.Function)=[Ljava.lang.Class;@10f7dff, public java.lang.Object java.util.HashMap.clone()=[Ljava.lang.Class;@d214e3, public java.lang.Object java.util.LinkedHashMap.getOrDefault(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@1a74254, public java.util.Set java.util.LinkedHashMap.entrySet()=[Ljava.lang.Class;@1c4740c, public void java.util.LinkedHashMap.forEach(java.util.function.BiConsumer)=[Ljava.lang.Class;@1fe0c8e, public java.lang.Object java.util.HashMap.putIfAbsent(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@16f73de, public java.util.Collection java.util.LinkedHashMap.values()=[Ljava.lang.Class;@b3e45, public void java.util.LinkedHashMap.clear()=[Ljava.lang.Class;@a34e5c, public java.lang.Object java.util.HashMap.computeIfPresent(java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1fcb13a, public java.lang.Object java.util.HashMap.compute(java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1a7c258, public final native java.lang.Class java.lang.Object.getClass()=[Ljava.lang.Class;@7397f, public void java.util.HashMap.putAll(java.util.Map)=[Ljava.lang.Class;@59cd, public void java.util.LinkedHashMap.replaceAll(java.util.function.BiFunction)=[Ljava.lang.Class;@994816, public java.lang.Object java.util.HashMap.merge(java.lang.Object,java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1b1e75f, public int java.util.HashMap.size()=[Ljava.lang.Class;@bee157, public boolean java.util.LinkedHashMap.containsValue(java.lang.Object)=[Ljava.lang.Class;@5e0d7c}, replaceAll=public void java.util.LinkedHashMap.replaceAll(java.util.function.BiFunction), remove=freemarker.ext.beans.OverloadedMethods@8d3a99, containsValue=public boolean java.util.LinkedHashMap.containsValue(java.lang.Object), put=public java.lang.Object java.util.HashMap.put(java.lang.Object,java.lang.Object), empty=java.beans.PropertyDescriptor[name=empty; propertyType=boolean; readMethod=public boolean java.util.HashMap.isEmpty()], compute=public java.lang.Object java.util.HashMap.compute(java.lang.Object,java.util.function.BiFunction), hashCode=public int java.util.AbstractMap.hashCode(), putAll=public void java.util.HashMap.putAll(java.util.Map), get=public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object), merge=public java.lang.Object java.util.HashMap.merge(java.lang.Object,java.lang.Object,java.util.function.BiFunction), class=java.beans.PropertyDescriptor[name=class; propertyType=class java.lang.Class; readMethod=public final native java.lang.Class java.lang.Object.getClass()], keySet=public java.util.Set java.util.LinkedHashMap.keySet(), java.lang.Object@1c0f21d=freemarker.ext.beans.OverloadedMethods@d4b988, entrySet=public java.util.Set java.util.LinkedHashMap.entrySet(), java.lang.Object@15be27d=public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object), forEach=public void java.util.LinkedHashMap.forEach(java.util.function.BiConsumer), containsKey=public boolean java.util.HashMap.containsKey(java.lang.Object), isEmpty=public boolean java.util.HashMap.isEmpty(), clear=public void java.util.LinkedHashMap.clear(), computeIfPresent=public java.lang.Object java.util.HashMap.computeIfPresent(java.lang.Object,java.util.function.BiFunction), size=public int java.util.HashMap.size(), equals=public boolean java.util.AbstractMap.equals(java.lang.Object), clone=public java.lang.Object java.util.HashMap.clone(), toString=public java.lang.String java.util.AbstractMap.toString(), putIfAbsent=public java.lang.Object java.util.HashMap.putIfAbsent(java.lang.Object,java.lang.Object)}
[DEBUG] 2017-05-24: 21:05:32 freemarker.log._Log4jLoggerFactory$Log4jLogger.debug(_Log4jLoggerFactory.java:45) :  Key "onkeydown" was not found on instance of java.util.LinkedHashMap. Introspection information for the class is: {getClass=public final native java.lang.Class java.lang.Object.getClass(), getOrDefault=public java.lang.Object java.util.LinkedHashMap.getOrDefault(java.lang.Object,java.lang.Object), computeIfAbsent=public java.lang.Object java.util.HashMap.computeIfAbsent(java.lang.Object,java.util.function.Function), values=public java.util.Collection java.util.LinkedHashMap.values(), replace=freemarker.ext.beans.OverloadedMethods@11d0265, java.lang.Object@3e55b2={public boolean java.util.HashMap.isEmpty()=[Ljava.lang.Class;@c5aa3a, public int java.util.AbstractMap.hashCode()=[Ljava.lang.Class;@74a947, public java.lang.Object java.util.HashMap.put(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@1615a91, public boolean java.util.AbstractMap.equals(java.lang.Object)=[Ljava.lang.Class;@a46ab2, public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object)=[Ljava.lang.Class;@1c389e6, public java.lang.String java.util.AbstractMap.toString()=[Ljava.lang.Class;@a23548, public boolean java.util.HashMap.containsKey(java.lang.Object)=[Ljava.lang.Class;@1be4a9f, public java.util.Set java.util.LinkedHashMap.keySet()=[Ljava.lang.Class;@44c60, public java.lang.Object java.util.HashMap.computeIfAbsent(java.lang.Object,java.util.function.Function)=[Ljava.lang.Class;@10f7dff, public java.lang.Object java.util.HashMap.clone()=[Ljava.lang.Class;@d214e3, public java.lang.Object java.util.LinkedHashMap.getOrDefault(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@1a74254, public java.util.Set java.util.LinkedHashMap.entrySet()=[Ljava.lang.Class;@1c4740c, public void java.util.LinkedHashMap.forEach(java.util.function.BiConsumer)=[Ljava.lang.Class;@1fe0c8e, public java.lang.Object java.util.HashMap.putIfAbsent(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@16f73de, public java.util.Collection java.util.LinkedHashMap.values()=[Ljava.lang.Class;@b3e45, public void java.util.LinkedHashMap.clear()=[Ljava.lang.Class;@a34e5c, public java.lang.Object java.util.HashMap.computeIfPresent(java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1fcb13a, public java.lang.Object java.util.HashMap.compute(java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1a7c258, public final native java.lang.Class java.lang.Object.getClass()=[Ljava.lang.Class;@7397f, public void java.util.HashMap.putAll(java.util.Map)=[Ljava.lang.Class;@59cd, public void java.util.LinkedHashMap.replaceAll(java.util.function.BiFunction)=[Ljava.lang.Class;@994816, public java.lang.Object java.util.HashMap.merge(java.lang.Object,java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1b1e75f, public int java.util.HashMap.size()=[Ljava.lang.Class;@bee157, public boolean java.util.LinkedHashMap.containsValue(java.lang.Object)=[Ljava.lang.Class;@5e0d7c}, replaceAll=public void java.util.LinkedHashMap.replaceAll(java.util.function.BiFunction), remove=freemarker.ext.beans.OverloadedMethods@8d3a99, containsValue=public boolean java.util.LinkedHashMap.containsValue(java.lang.Object), put=public java.lang.Object java.util.HashMap.put(java.lang.Object,java.lang.Object), empty=java.beans.PropertyDescriptor[name=empty; propertyType=boolean; readMethod=public boolean java.util.HashMap.isEmpty()], compute=public java.lang.Object java.util.HashMap.compute(java.lang.Object,java.util.function.BiFunction), hashCode=public int java.util.AbstractMap.hashCode(), putAll=public void java.util.HashMap.putAll(java.util.Map), get=public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object), merge=public java.lang.Object java.util.HashMap.merge(java.lang.Object,java.lang.Object,java.util.function.BiFunction), class=java.beans.PropertyDescriptor[name=class; propertyType=class java.lang.Class; readMethod=public final native java.lang.Class java.lang.Object.getClass()], keySet=public java.util.Set java.util.LinkedHashMap.keySet(), java.lang.Object@1c0f21d=freemarker.ext.beans.OverloadedMethods@d4b988, entrySet=public java.util.Set java.util.LinkedHashMap.entrySet(), java.lang.Object@15be27d=public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object), forEach=public void java.util.LinkedHashMap.forEach(java.util.function.BiConsumer), containsKey=public boolean java.util.HashMap.containsKey(java.lang.Object), isEmpty=public boolean java.util.HashMap.isEmpty(), clear=public void java.util.LinkedHashMap.clear(), computeIfPresent=public java.lang.Object java.util.HashMap.computeIfPresent(java.lang.Object,java.util.function.BiFunction), size=public int java.util.HashMap.size(), equals=public boolean java.util.AbstractMap.equals(java.lang.Object), clone=public java.lang.Object java.util.HashMap.clone(), toString=public java.lang.String java.util.AbstractMap.toString(), putIfAbsent=public java.lang.Object java.util.HashMap.putIfAbsent(java.lang.Object,java.lang.Object)}
[DEBUG] 2017-05-24: 21:05:32 freemarker.log._Log4jLoggerFactory$Log4jLogger.debug(_Log4jLoggerFactory.java:45) :  Key "onkeyup" was not found on instance of java.util.LinkedHashMap. Introspection information for the class is: {getClass=public final native java.lang.Class java.lang.Object.getClass(), getOrDefault=public java.lang.Object java.util.LinkedHashMap.getOrDefault(java.lang.Object,java.lang.Object), computeIfAbsent=public java.lang.Object java.util.HashMap.computeIfAbsent(java.lang.Object,java.util.function.Function), values=public java.util.Collection java.util.LinkedHashMap.values(), replace=freemarker.ext.beans.OverloadedMethods@11d0265, java.lang.Object@3e55b2={public boolean java.util.HashMap.isEmpty()=[Ljava.lang.Class;@c5aa3a, public int java.util.AbstractMap.hashCode()=[Ljava.lang.Class;@74a947, public java.lang.Object java.util.HashMap.put(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@1615a91, public boolean java.util.AbstractMap.equals(java.lang.Object)=[Ljava.lang.Class;@a46ab2, public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object)=[Ljava.lang.Class;@1c389e6, public java.lang.String java.util.AbstractMap.toString()=[Ljava.lang.Class;@a23548, public boolean java.util.HashMap.containsKey(java.lang.Object)=[Ljava.lang.Class;@1be4a9f, public java.util.Set java.util.LinkedHashMap.keySet()=[Ljava.lang.Class;@44c60, public java.lang.Object java.util.HashMap.computeIfAbsent(java.lang.Object,java.util.function.Function)=[Ljava.lang.Class;@10f7dff, public java.lang.Object java.util.HashMap.clone()=[Ljava.lang.Class;@d214e3, public java.lang.Object java.util.LinkedHashMap.getOrDefault(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@1a74254, public java.util.Set java.util.LinkedHashMap.entrySet()=[Ljava.lang.Class;@1c4740c, public void java.util.LinkedHashMap.forEach(java.util.function.BiConsumer)=[Ljava.lang.Class;@1fe0c8e, public java.lang.Object java.util.HashMap.putIfAbsent(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@16f73de, public java.util.Collection java.util.LinkedHashMap.values()=[Ljava.lang.Class;@b3e45, public void java.util.LinkedHashMap.clear()=[Ljava.lang.Class;@a34e5c, public java.lang.Object java.util.HashMap.computeIfPresent(java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1fcb13a, public java.lang.Object java.util.HashMap.compute(java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1a7c258, public final native java.lang.Class java.lang.Object.getClass()=[Ljava.lang.Class;@7397f, public void java.util.HashMap.putAll(java.util.Map)=[Ljava.lang.Class;@59cd, public void java.util.LinkedHashMap.replaceAll(java.util.function.BiFunction)=[Ljava.lang.Class;@994816, public java.lang.Object java.util.HashMap.merge(java.lang.Object,java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1b1e75f, public int java.util.HashMap.size()=[Ljava.lang.Class;@bee157, public boolean java.util.LinkedHashMap.containsValue(java.lang.Object)=[Ljava.lang.Class;@5e0d7c}, replaceAll=public void java.util.LinkedHashMap.replaceAll(java.util.function.BiFunction), remove=freemarker.ext.beans.OverloadedMethods@8d3a99, containsValue=public boolean java.util.LinkedHashMap.containsValue(java.lang.Object), put=public java.lang.Object java.util.HashMap.put(java.lang.Object,java.lang.Object), empty=java.beans.PropertyDescriptor[name=empty; propertyType=boolean; readMethod=public boolean java.util.HashMap.isEmpty()], compute=public java.lang.Object java.util.HashMap.compute(java.lang.Object,java.util.function.BiFunction), hashCode=public int java.util.AbstractMap.hashCode(), putAll=public void java.util.HashMap.putAll(java.util.Map), get=public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object), merge=public java.lang.Object java.util.HashMap.merge(java.lang.Object,java.lang.Object,java.util.function.BiFunction), class=java.beans.PropertyDescriptor[name=class; propertyType=class java.lang.Class; readMethod=public final native java.lang.Class java.lang.Object.getClass()], keySet=public java.util.Set java.util.LinkedHashMap.keySet(), java.lang.Object@1c0f21d=freemarker.ext.beans.OverloadedMethods@d4b988, entrySet=public java.util.Set java.util.LinkedHashMap.entrySet(), java.lang.Object@15be27d=public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object), forEach=public void java.util.LinkedHashMap.forEach(java.util.function.BiConsumer), containsKey=public boolean java.util.HashMap.containsKey(java.lang.Object), isEmpty=public boolean java.util.HashMap.isEmpty(), clear=public void java.util.LinkedHashMap.clear(), computeIfPresent=public java.lang.Object java.util.HashMap.computeIfPresent(java.lang.Object,java.util.function.BiFunction), size=public int java.util.HashMap.size(), equals=public boolean java.util.AbstractMap.equals(java.lang.Object), clone=public java.lang.Object java.util.HashMap.clone(), toString=public java.lang.String java.util.AbstractMap.toString(), putIfAbsent=public java.lang.Object java.util.HashMap.putIfAbsent(java.lang.Object,java.lang.Object)}
[DEBUG] 2017-05-24: 21:05:32 freemarker.log._Log4jLoggerFactory$Log4jLogger.debug(_Log4jLoggerFactory.java:45) :  Key "onselect" was not found on instance of java.util.LinkedHashMap. Introspection information for the class is: {getClass=public final native java.lang.Class java.lang.Object.getClass(), getOrDefault=public java.lang.Object java.util.LinkedHashMap.getOrDefault(java.lang.Object,java.lang.Object), computeIfAbsent=public java.lang.Object java.util.HashMap.computeIfAbsent(java.lang.Object,java.util.function.Function), values=public java.util.Collection java.util.LinkedHashMap.values(), replace=freemarker.ext.beans.OverloadedMethods@11d0265, java.lang.Object@3e55b2={public boolean java.util.HashMap.isEmpty()=[Ljava.lang.Class;@c5aa3a, public int java.util.AbstractMap.hashCode()=[Ljava.lang.Class;@74a947, public java.lang.Object java.util.HashMap.put(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@1615a91, public boolean java.util.AbstractMap.equals(java.lang.Object)=[Ljava.lang.Class;@a46ab2, public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object)=[Ljava.lang.Class;@1c389e6, public java.lang.String java.util.AbstractMap.toString()=[Ljava.lang.Class;@a23548, public boolean java.util.HashMap.containsKey(java.lang.Object)=[Ljava.lang.Class;@1be4a9f, public java.util.Set java.util.LinkedHashMap.keySet()=[Ljava.lang.Class;@44c60, public java.lang.Object java.util.HashMap.computeIfAbsent(java.lang.Object,java.util.function.Function)=[Ljava.lang.Class;@10f7dff, public java.lang.Object java.util.HashMap.clone()=[Ljava.lang.Class;@d214e3, public java.lang.Object java.util.LinkedHashMap.getOrDefault(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@1a74254, public java.util.Set java.util.LinkedHashMap.entrySet()=[Ljava.lang.Class;@1c4740c, public void java.util.LinkedHashMap.forEach(java.util.function.BiConsumer)=[Ljava.lang.Class;@1fe0c8e, public java.lang.Object java.util.HashMap.putIfAbsent(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@16f73de, public java.util.Collection java.util.LinkedHashMap.values()=[Ljava.lang.Class;@b3e45, public void java.util.LinkedHashMap.clear()=[Ljava.lang.Class;@a34e5c, public java.lang.Object java.util.HashMap.computeIfPresent(java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1fcb13a, public java.lang.Object java.util.HashMap.compute(java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1a7c258, public final native java.lang.Class java.lang.Object.getClass()=[Ljava.lang.Class;@7397f, public void java.util.HashMap.putAll(java.util.Map)=[Ljava.lang.Class;@59cd, public void java.util.LinkedHashMap.replaceAll(java.util.function.BiFunction)=[Ljava.lang.Class;@994816, public java.lang.Object java.util.HashMap.merge(java.lang.Object,java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1b1e75f, public int java.util.HashMap.size()=[Ljava.lang.Class;@bee157, public boolean java.util.LinkedHashMap.containsValue(java.lang.Object)=[Ljava.lang.Class;@5e0d7c}, replaceAll=public void java.util.LinkedHashMap.replaceAll(java.util.function.BiFunction), remove=freemarker.ext.beans.OverloadedMethods@8d3a99, containsValue=public boolean java.util.LinkedHashMap.containsValue(java.lang.Object), put=public java.lang.Object java.util.HashMap.put(java.lang.Object,java.lang.Object), empty=java.beans.PropertyDescriptor[name=empty; propertyType=boolean; readMethod=public boolean java.util.HashMap.isEmpty()], compute=public java.lang.Object java.util.HashMap.compute(java.lang.Object,java.util.function.BiFunction), hashCode=public int java.util.AbstractMap.hashCode(), putAll=public void java.util.HashMap.putAll(java.util.Map), get=public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object), merge=public java.lang.Object java.util.HashMap.merge(java.lang.Object,java.lang.Object,java.util.function.BiFunction), class=java.beans.PropertyDescriptor[name=class; propertyType=class java.lang.Class; readMethod=public final native java.lang.Class java.lang.Object.getClass()], keySet=public java.util.Set java.util.LinkedHashMap.keySet(), java.lang.Object@1c0f21d=freemarker.ext.beans.OverloadedMethods@d4b988, entrySet=public java.util.Set java.util.LinkedHashMap.entrySet(), java.lang.Object@15be27d=public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object), forEach=public void java.util.LinkedHashMap.forEach(java.util.function.BiConsumer), containsKey=public boolean java.util.HashMap.containsKey(java.lang.Object), isEmpty=public boolean java.util.HashMap.isEmpty(), clear=public void java.util.LinkedHashMap.clear(), computeIfPresent=public java.lang.Object java.util.HashMap.computeIfPresent(java.lang.Object,java.util.function.BiFunction), size=public int java.util.HashMap.size(), equals=public boolean java.util.AbstractMap.equals(java.lang.Object), clone=public java.lang.Object java.util.HashMap.clone(), toString=public java.lang.String java.util.AbstractMap.toString(), putIfAbsent=public java.lang.Object java.util.HashMap.putIfAbsent(java.lang.Object,java.lang.Object)}
[DEBUG] 2017-05-24: 21:05:32 freemarker.log._Log4jLoggerFactory$Log4jLogger.debug(_Log4jLoggerFactory.java:45) :  Key "onchange" was not found on instance of java.util.LinkedHashMap. Introspection information for the class is: {getClass=public final native java.lang.Class java.lang.Object.getClass(), getOrDefault=public java.lang.Object java.util.LinkedHashMap.getOrDefault(java.lang.Object,java.lang.Object), computeIfAbsent=public java.lang.Object java.util.HashMap.computeIfAbsent(java.lang.Object,java.util.function.Function), values=public java.util.Collection java.util.LinkedHashMap.values(), replace=freemarker.ext.beans.OverloadedMethods@11d0265, java.lang.Object@3e55b2={public boolean java.util.HashMap.isEmpty()=[Ljava.lang.Class;@c5aa3a, public int java.util.AbstractMap.hashCode()=[Ljava.lang.Class;@74a947, public java.lang.Object java.util.HashMap.put(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@1615a91, public boolean java.util.AbstractMap.equals(java.lang.Object)=[Ljava.lang.Class;@a46ab2, public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object)=[Ljava.lang.Class;@1c389e6, public java.lang.String java.util.AbstractMap.toString()=[Ljava.lang.Class;@a23548, public boolean java.util.HashMap.containsKey(java.lang.Object)=[Ljava.lang.Class;@1be4a9f, public java.util.Set java.util.LinkedHashMap.keySet()=[Ljava.lang.Class;@44c60, public java.lang.Object java.util.HashMap.computeIfAbsent(java.lang.Object,java.util.function.Function)=[Ljava.lang.Class;@10f7dff, public java.lang.Object java.util.HashMap.clone()=[Ljava.lang.Class;@d214e3, public java.lang.Object java.util.LinkedHashMap.getOrDefault(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@1a74254, public java.util.Set java.util.LinkedHashMap.entrySet()=[Ljava.lang.Class;@1c4740c, public void java.util.LinkedHashMap.forEach(java.util.function.BiConsumer)=[Ljava.lang.Class;@1fe0c8e, public java.lang.Object java.util.HashMap.putIfAbsent(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@16f73de, public java.util.Collection java.util.LinkedHashMap.values()=[Ljava.lang.Class;@b3e45, public void java.util.LinkedHashMap.clear()=[Ljava.lang.Class;@a34e5c, public java.lang.Object java.util.HashMap.computeIfPresent(java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1fcb13a, public java.lang.Object java.util.HashMap.compute(java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1a7c258, public final native java.lang.Class java.lang.Object.getClass()=[Ljava.lang.Class;@7397f, public void java.util.HashMap.putAll(java.util.Map)=[Ljava.lang.Class;@59cd, public void java.util.LinkedHashMap.replaceAll(java.util.function.BiFunction)=[Ljava.lang.Class;@994816, public java.lang.Object java.util.HashMap.merge(java.lang.Object,java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1b1e75f, public int java.util.HashMap.size()=[Ljava.lang.Class;@bee157, public boolean java.util.LinkedHashMap.containsValue(java.lang.Object)=[Ljava.lang.Class;@5e0d7c}, replaceAll=public void java.util.LinkedHashMap.replaceAll(java.util.function.BiFunction), remove=freemarker.ext.beans.OverloadedMethods@8d3a99, containsValue=public boolean java.util.LinkedHashMap.containsValue(java.lang.Object), put=public java.lang.Object java.util.HashMap.put(java.lang.Object,java.lang.Object), empty=java.beans.PropertyDescriptor[name=empty; propertyType=boolean; readMethod=public boolean java.util.HashMap.isEmpty()], compute=public java.lang.Object java.util.HashMap.compute(java.lang.Object,java.util.function.BiFunction), hashCode=public int java.util.AbstractMap.hashCode(), putAll=public void java.util.HashMap.putAll(java.util.Map), get=public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object), merge=public java.lang.Object java.util.HashMap.merge(java.lang.Object,java.lang.Object,java.util.function.BiFunction), class=java.beans.PropertyDescriptor[name=class; propertyType=class java.lang.Class; readMethod=public final native java.lang.Class java.lang.Object.getClass()], keySet=public java.util.Set java.util.LinkedHashMap.keySet(), java.lang.Object@1c0f21d=freemarker.ext.beans.OverloadedMethods@d4b988, entrySet=public java.util.Set java.util.LinkedHashMap.entrySet(), java.lang.Object@15be27d=public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object), forEach=public void java.util.LinkedHashMap.forEach(java.util.function.BiConsumer), containsKey=public boolean java.util.HashMap.containsKey(java.lang.Object), isEmpty=public boolean java.util.HashMap.isEmpty(), clear=public void java.util.LinkedHashMap.clear(), computeIfPresent=public java.lang.Object java.util.HashMap.computeIfPresent(java.lang.Object,java.util.function.BiFunction), size=public int java.util.HashMap.size(), equals=public boolean java.util.AbstractMap.equals(java.lang.Object), clone=public java.lang.Object java.util.HashMap.clone(), toString=public java.lang.String java.util.AbstractMap.toString(), putIfAbsent=public java.lang.Object java.util.HashMap.putIfAbsent(java.lang.Object,java.lang.Object)}
[DEBUG] 2017-05-24: 21:05:32 freemarker.log._Log4jLoggerFactory$Log4jLogger.debug(_Log4jLoggerFactory.java:45) :  Couldn't find template in cache for "template/~~~xhtml/common-attributes.ftl"("zh_CN", UTF-8, parsed); will try to load it.
[DEBUG] 2017-05-24: 21:05:32 freemarker.log._Log4jLoggerFactory$Log4jLogger.debug(_Log4jLoggerFactory.java:45) :  TemplateLoader.findTemplateSource("template/~~~xhtml/common-attributes.ftl"): Found
[DEBUG] 2017-05-24: 21:05:32 freemarker.log._Log4jLoggerFactory$Log4jLogger.debug(_Log4jLoggerFactory.java:45) :  Loading template for "template/~~~xhtml/common-attributes.ftl"("zh_CN", UTF-8, parsed) from "jar:file:/D:/maven/repository/org/apache/struts/struts2-core/2.5.10/struts2-core-2.5.10.jar!/template/simple/common-attributes.ftl"
[DEBUG] 2017-05-24: 21:05:32 freemarker.log._Log4jLoggerFactory$Log4jLogger.debug(_Log4jLoggerFactory.java:45) :  Key "accesskey" was not found on instance of java.util.LinkedHashMap. Introspection information for the class is: {getClass=public final native java.lang.Class java.lang.Object.getClass(), getOrDefault=public java.lang.Object java.util.LinkedHashMap.getOrDefault(java.lang.Object,java.lang.Object), computeIfAbsent=public java.lang.Object java.util.HashMap.computeIfAbsent(java.lang.Object,java.util.function.Function), values=public java.util.Collection java.util.LinkedHashMap.values(), replace=freemarker.ext.beans.OverloadedMethods@11d0265, java.lang.Object@3e55b2={public boolean java.util.HashMap.isEmpty()=[Ljava.lang.Class;@c5aa3a, public int java.util.AbstractMap.hashCode()=[Ljava.lang.Class;@74a947, public java.lang.Object java.util.HashMap.put(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@1615a91, public boolean java.util.AbstractMap.equals(java.lang.Object)=[Ljava.lang.Class;@a46ab2, public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object)=[Ljava.lang.Class;@1c389e6, public java.lang.String java.util.AbstractMap.toString()=[Ljava.lang.Class;@a23548, public boolean java.util.HashMap.containsKey(java.lang.Object)=[Ljava.lang.Class;@1be4a9f, public java.util.Set java.util.LinkedHashMap.keySet()=[Ljava.lang.Class;@44c60, public java.lang.Object java.util.HashMap.computeIfAbsent(java.lang.Object,java.util.function.Function)=[Ljava.lang.Class;@10f7dff, public java.lang.Object java.util.HashMap.clone()=[Ljava.lang.Class;@d214e3, public java.lang.Object java.util.LinkedHashMap.getOrDefault(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@1a74254, public java.util.Set java.util.LinkedHashMap.entrySet()=[Ljava.lang.Class;@1c4740c, public void java.util.LinkedHashMap.forEach(java.util.function.BiConsumer)=[Ljava.lang.Class;@1fe0c8e, public java.lang.Object java.util.HashMap.putIfAbsent(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@16f73de, public java.util.Collection java.util.LinkedHashMap.values()=[Ljava.lang.Class;@b3e45, public void java.util.LinkedHashMap.clear()=[Ljava.lang.Class;@a34e5c, public java.lang.Object java.util.HashMap.computeIfPresent(java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1fcb13a, public java.lang.Object java.util.HashMap.compute(java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1a7c258, public final native java.lang.Class java.lang.Object.getClass()=[Ljava.lang.Class;@7397f, public void java.util.HashMap.putAll(java.util.Map)=[Ljava.lang.Class;@59cd, public void java.util.LinkedHashMap.replaceAll(java.util.function.BiFunction)=[Ljava.lang.Class;@994816, public java.lang.Object java.util.HashMap.merge(java.lang.Object,java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1b1e75f, public int java.util.HashMap.size()=[Ljava.lang.Class;@bee157, public boolean java.util.LinkedHashMap.containsValue(java.lang.Object)=[Ljava.lang.Class;@5e0d7c}, replaceAll=public void java.util.LinkedHashMap.replaceAll(java.util.function.BiFunction), remove=freemarker.ext.beans.OverloadedMethods@8d3a99, containsValue=public boolean java.util.LinkedHashMap.containsValue(java.lang.Object), put=public java.lang.Object java.util.HashMap.put(java.lang.Object,java.lang.Object), empty=java.beans.PropertyDescriptor[name=empty; propertyType=boolean; readMethod=public boolean java.util.HashMap.isEmpty()], compute=public java.lang.Object java.util.HashMap.compute(java.lang.Object,java.util.function.BiFunction), hashCode=public int java.util.AbstractMap.hashCode(), putAll=public void java.util.HashMap.putAll(java.util.Map), get=public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object), merge=public java.lang.Object java.util.HashMap.merge(java.lang.Object,java.lang.Object,java.util.function.BiFunction), class=java.beans.PropertyDescriptor[name=class; propertyType=class java.lang.Class; readMethod=public final native java.lang.Class java.lang.Object.getClass()], keySet=public java.util.Set java.util.LinkedHashMap.keySet(), java.lang.Object@1c0f21d=freemarker.ext.beans.OverloadedMethods@d4b988, entrySet=public java.util.Set java.util.LinkedHashMap.entrySet(), java.lang.Object@15be27d=public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object), forEach=public void java.util.LinkedHashMap.forEach(java.util.function.BiConsumer), containsKey=public boolean java.util.HashMap.containsKey(java.lang.Object), isEmpty=public boolean java.util.HashMap.isEmpty(), clear=public void java.util.LinkedHashMap.clear(), computeIfPresent=public java.lang.Object java.util.HashMap.computeIfPresent(java.lang.Object,java.util.function.BiFunction), size=public int java.util.HashMap.size(), equals=public boolean java.util.AbstractMap.equals(java.lang.Object), clone=public java.lang.Object java.util.HashMap.clone(), toString=public java.lang.String java.util.AbstractMap.toString(), putIfAbsent=public java.lang.Object java.util.HashMap.putIfAbsent(java.lang.Object,java.lang.Object)}
[DEBUG] 2017-05-24: 21:05:32 freemarker.log._Log4jLoggerFactory$Log4jLogger.debug(_Log4jLoggerFactory.java:45) :  TemplateLoader.findTemplateSource("template/~~~xhtml/dynamic-attributes.ftl"): Found
[DEBUG] 2017-05-24: 21:05:32 freemarker.log._Log4jLoggerFactory$Log4jLogger.debug(_Log4jLoggerFactory.java:45) :  "template/~~~xhtml/dynamic-attributes.ftl"("zh_CN", UTF-8, parsed): using cached since jar:file:/D:/maven/repository/org/apache/struts/struts2-core/2.5.10/struts2-core-2.5.10.jar!/template/simple/dynamic-attributes.ftl hasn't changed.
[DEBUG] 2017-05-24: 21:05:32 freemarker.log._Log4jLoggerFactory$Log4jLogger.debug(_Log4jLoggerFactory.java:45) :  Couldn't find template in cache for "template/~~~xhtml/controlfooter.ftl"("zh_CN", UTF-8, parsed); will try to load it.
[DEBUG] 2017-05-24: 21:05:32 freemarker.log._Log4jLoggerFactory$Log4jLogger.debug(_Log4jLoggerFactory.java:45) :  TemplateLoader.findTemplateSource("template/~~~xhtml/controlfooter.ftl"): Found
[DEBUG] 2017-05-24: 21:05:32 freemarker.log._Log4jLoggerFactory$Log4jLogger.debug(_Log4jLoggerFactory.java:45) :  Loading template for "template/~~~xhtml/controlfooter.ftl"("zh_CN", UTF-8, parsed) from "jar:file:/D:/maven/repository/org/apache/struts/struts2-core/2.5.10/struts2-core-2.5.10.jar!/template/xhtml/controlfooter.ftl"
[DEBUG] 2017-05-24: 21:05:32 freemarker.log._Log4jLoggerFactory$Log4jLogger.debug(_Log4jLoggerFactory.java:45) :  Key "after" was not found on instance of java.util.LinkedHashMap. Introspection information for the class is: {getClass=public final native java.lang.Class java.lang.Object.getClass(), getOrDefault=public java.lang.Object java.util.LinkedHashMap.getOrDefault(java.lang.Object,java.lang.Object), computeIfAbsent=public java.lang.Object java.util.HashMap.computeIfAbsent(java.lang.Object,java.util.function.Function), values=public java.util.Collection java.util.LinkedHashMap.values(), replace=freemarker.ext.beans.OverloadedMethods@11d0265, java.lang.Object@3e55b2={public boolean java.util.HashMap.isEmpty()=[Ljava.lang.Class;@c5aa3a, public int java.util.AbstractMap.hashCode()=[Ljava.lang.Class;@74a947, public java.lang.Object java.util.HashMap.put(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@1615a91, public boolean java.util.AbstractMap.equals(java.lang.Object)=[Ljava.lang.Class;@a46ab2, public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object)=[Ljava.lang.Class;@1c389e6, public java.lang.String java.util.AbstractMap.toString()=[Ljava.lang.Class;@a23548, public boolean java.util.HashMap.containsKey(java.lang.Object)=[Ljava.lang.Class;@1be4a9f, public java.util.Set java.util.LinkedHashMap.keySet()=[Ljava.lang.Class;@44c60, public java.lang.Object java.util.HashMap.computeIfAbsent(java.lang.Object,java.util.function.Function)=[Ljava.lang.Class;@10f7dff, public java.lang.Object java.util.HashMap.clone()=[Ljava.lang.Class;@d214e3, public java.lang.Object java.util.LinkedHashMap.getOrDefault(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@1a74254, public java.util.Set java.util.LinkedHashMap.entrySet()=[Ljava.lang.Class;@1c4740c, public void java.util.LinkedHashMap.forEach(java.util.function.BiConsumer)=[Ljava.lang.Class;@1fe0c8e, public java.lang.Object java.util.HashMap.putIfAbsent(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@16f73de, public java.util.Collection java.util.LinkedHashMap.values()=[Ljava.lang.Class;@b3e45, public void java.util.LinkedHashMap.clear()=[Ljava.lang.Class;@a34e5c, public java.lang.Object java.util.HashMap.computeIfPresent(java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1fcb13a, public java.lang.Object java.util.HashMap.compute(java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1a7c258, public final native java.lang.Class java.lang.Object.getClass()=[Ljava.lang.Class;@7397f, public void java.util.HashMap.putAll(java.util.Map)=[Ljava.lang.Class;@59cd, public void java.util.LinkedHashMap.replaceAll(java.util.function.BiFunction)=[Ljava.lang.Class;@994816, public java.lang.Object java.util.HashMap.merge(java.lang.Object,java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1b1e75f, public int java.util.HashMap.size()=[Ljava.lang.Class;@bee157, public boolean java.util.LinkedHashMap.containsValue(java.lang.Object)=[Ljava.lang.Class;@5e0d7c}, replaceAll=public void java.util.LinkedHashMap.replaceAll(java.util.function.BiFunction), remove=freemarker.ext.beans.OverloadedMethods@8d3a99, containsValue=public boolean java.util.LinkedHashMap.containsValue(java.lang.Object), put=public java.lang.Object java.util.HashMap.put(java.lang.Object,java.lang.Object), empty=java.beans.PropertyDescriptor[name=empty; propertyType=boolean; readMethod=public boolean java.util.HashMap.isEmpty()], compute=public java.lang.Object java.util.HashMap.compute(java.lang.Object,java.util.function.BiFunction), hashCode=public int java.util.AbstractMap.hashCode(), putAll=public void java.util.HashMap.putAll(java.util.Map), get=public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object), merge=public java.lang.Object java.util.HashMap.merge(java.lang.Object,java.lang.Object,java.util.function.BiFunction), class=java.beans.PropertyDescriptor[name=class; propertyType=class java.lang.Class; readMethod=public final native java.lang.Class java.lang.Object.getClass()], keySet=public java.util.Set java.util.LinkedHashMap.keySet(), java.lang.Object@1c0f21d=freemarker.ext.beans.OverloadedMethods@d4b988, entrySet=public java.util.Set java.util.LinkedHashMap.entrySet(), java.lang.Object@15be27d=public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object), forEach=public void java.util.LinkedHashMap.forEach(java.util.function.BiConsumer), containsKey=public boolean java.util.HashMap.containsKey(java.lang.Object), isEmpty=public boolean java.util.HashMap.isEmpty(), clear=public void java.util.LinkedHashMap.clear(), computeIfPresent=public java.lang.Object java.util.HashMap.computeIfPresent(java.lang.Object,java.util.function.BiFunction), size=public int java.util.HashMap.size(), equals=public boolean java.util.AbstractMap.equals(java.lang.Object), clone=public java.lang.Object java.util.HashMap.clone(), toString=public java.lang.String java.util.AbstractMap.toString(), putIfAbsent=public java.lang.Object java.util.HashMap.putIfAbsent(java.lang.Object,java.lang.Object)}
[DEBUG] 2017-05-24: 21:05:32 freemarker.log._Log4jLoggerFactory$Log4jLogger.debug(_Log4jLoggerFactory.java:45) :  Key "errorposition" was not found on instance of java.util.LinkedHashMap. Introspection information for the class is: {getClass=public final native java.lang.Class java.lang.Object.getClass(), getOrDefault=public java.lang.Object java.util.LinkedHashMap.getOrDefault(java.lang.Object,java.lang.Object), computeIfAbsent=public java.lang.Object java.util.HashMap.computeIfAbsent(java.lang.Object,java.util.function.Function), values=public java.util.Collection java.util.LinkedHashMap.values(), replace=freemarker.ext.beans.OverloadedMethods@11d0265, java.lang.Object@3e55b2={public boolean java.util.HashMap.isEmpty()=[Ljava.lang.Class;@c5aa3a, public int java.util.AbstractMap.hashCode()=[Ljava.lang.Class;@74a947, public java.lang.Object java.util.HashMap.put(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@1615a91, public boolean java.util.AbstractMap.equals(java.lang.Object)=[Ljava.lang.Class;@a46ab2, public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object)=[Ljava.lang.Class;@1c389e6, public java.lang.String java.util.AbstractMap.toString()=[Ljava.lang.Class;@a23548, public boolean java.util.HashMap.containsKey(java.lang.Object)=[Ljava.lang.Class;@1be4a9f, public java.util.Set java.util.LinkedHashMap.keySet()=[Ljava.lang.Class;@44c60, public java.lang.Object java.util.HashMap.computeIfAbsent(java.lang.Object,java.util.function.Function)=[Ljava.lang.Class;@10f7dff, public java.lang.Object java.util.HashMap.clone()=[Ljava.lang.Class;@d214e3, public java.lang.Object java.util.LinkedHashMap.getOrDefault(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@1a74254, public java.util.Set java.util.LinkedHashMap.entrySet()=[Ljava.lang.Class;@1c4740c, public void java.util.LinkedHashMap.forEach(java.util.function.BiConsumer)=[Ljava.lang.Class;@1fe0c8e, public java.lang.Object java.util.HashMap.putIfAbsent(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@16f73de, public java.util.Collection java.util.LinkedHashMap.values()=[Ljava.lang.Class;@b3e45, public void java.util.LinkedHashMap.clear()=[Ljava.lang.Class;@a34e5c, public java.lang.Object java.util.HashMap.computeIfPresent(java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1fcb13a, public java.lang.Object java.util.HashMap.compute(java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1a7c258, public final native java.lang.Class java.lang.Object.getClass()=[Ljava.lang.Class;@7397f, public void java.util.HashMap.putAll(java.util.Map)=[Ljava.lang.Class;@59cd, public void java.util.LinkedHashMap.replaceAll(java.util.function.BiFunction)=[Ljava.lang.Class;@994816, public java.lang.Object java.util.HashMap.merge(java.lang.Object,java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1b1e75f, public int java.util.HashMap.size()=[Ljava.lang.Class;@bee157, public boolean java.util.LinkedHashMap.containsValue(java.lang.Object)=[Ljava.lang.Class;@5e0d7c}, replaceAll=public void java.util.LinkedHashMap.replaceAll(java.util.function.BiFunction), remove=freemarker.ext.beans.OverloadedMethods@8d3a99, containsValue=public boolean java.util.LinkedHashMap.containsValue(java.lang.Object), put=public java.lang.Object java.util.HashMap.put(java.lang.Object,java.lang.Object), empty=java.beans.PropertyDescriptor[name=empty; propertyType=boolean; readMethod=public boolean java.util.HashMap.isEmpty()], compute=public java.lang.Object java.util.HashMap.compute(java.lang.Object,java.util.function.BiFunction), hashCode=public int java.util.AbstractMap.hashCode(), putAll=public void java.util.HashMap.putAll(java.util.Map), get=public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object), merge=public java.lang.Object java.util.HashMap.merge(java.lang.Object,java.lang.Object,java.util.function.BiFunction), class=java.beans.PropertyDescriptor[name=class; propertyType=class java.lang.Class; readMethod=public final native java.lang.Class java.lang.Object.getClass()], keySet=public java.util.Set java.util.LinkedHashMap.keySet(), java.lang.Object@1c0f21d=freemarker.ext.beans.OverloadedMethods@d4b988, entrySet=public java.util.Set java.util.LinkedHashMap.entrySet(), java.lang.Object@15be27d=public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object), forEach=public void java.util.LinkedHashMap.forEach(java.util.function.BiConsumer), containsKey=public boolean java.util.HashMap.containsKey(java.lang.Object), isEmpty=public boolean java.util.HashMap.isEmpty(), clear=public void java.util.LinkedHashMap.clear(), computeIfPresent=public java.lang.Object java.util.HashMap.computeIfPresent(java.lang.Object,java.util.function.BiFunction), size=public int java.util.HashMap.size(), equals=public boolean java.util.AbstractMap.equals(java.lang.Object), clone=public java.lang.Object java.util.HashMap.clone(), toString=public java.lang.String java.util.AbstractMap.toString(), putIfAbsent=public java.lang.Object java.util.HashMap.putIfAbsent(java.lang.Object,java.lang.Object)}
[DEBUG] 2017-05-24: 21:05:32 freemarker.log._Log4jLoggerFactory$Log4jLogger.debug(_Log4jLoggerFactory.java:45) :  TemplateLoader.findTemplateSource("template/xhtml/text.ftl"): Found
[DEBUG] 2017-05-24: 21:05:32 freemarker.log._Log4jLoggerFactory$Log4jLogger.debug(_Log4jLoggerFactory.java:45) :  "template/xhtml/text.ftl"("zh_CN", UTF-8, parsed): using cached since jar:file:/D:/maven/repository/org/apache/struts/struts2-core/2.5.10/struts2-core-2.5.10.jar!/template/xhtml/text.ftl hasn't changed.
[DEBUG] 2017-05-24: 21:05:32 freemarker.log._Log4jLoggerFactory$Log4jLogger.debug(_Log4jLoggerFactory.java:45) :  TemplateLoader.findTemplateSource("template/~~~xhtml/controlheader.ftl"): Found
[DEBUG] 2017-05-24: 21:05:32 freemarker.log._Log4jLoggerFactory$Log4jLogger.debug(_Log4jLoggerFactory.java:45) :  "template/~~~xhtml/controlheader.ftl"("zh_CN", UTF-8, parsed): using cached since jar:file:/D:/maven/repository/org/apache/struts/struts2-core/2.5.10/struts2-core-2.5.10.jar!/template/xhtml/controlheader.ftl hasn't changed.
[DEBUG] 2017-05-24: 21:05:32 freemarker.log._Log4jLoggerFactory$Log4jLogger.debug(_Log4jLoggerFactory.java:45) :  TemplateLoader.findTemplateSource("template/~~~xhtml/controlheader-core.ftl"): Found
[DEBUG] 2017-05-24: 21:05:32 freemarker.log._Log4jLoggerFactory$Log4jLogger.debug(_Log4jLoggerFactory.java:45) :  "template/~~~xhtml/controlheader-core.ftl"("zh_CN", UTF-8, parsed): using cached since jar:file:/D:/maven/repository/org/apache/struts/struts2-core/2.5.10/struts2-core-2.5.10.jar!/template/xhtml/controlheader-core.ftl hasn't changed.
[DEBUG] 2017-05-24: 21:05:32 freemarker.log._Log4jLoggerFactory$Log4jLogger.debug(_Log4jLoggerFactory.java:45) :  Key "errorposition" was not found on instance of java.util.LinkedHashMap. Introspection information for the class is: {getClass=public final native java.lang.Class java.lang.Object.getClass(), getOrDefault=public java.lang.Object java.util.LinkedHashMap.getOrDefault(java.lang.Object,java.lang.Object), computeIfAbsent=public java.lang.Object java.util.HashMap.computeIfAbsent(java.lang.Object,java.util.function.Function), values=public java.util.Collection java.util.LinkedHashMap.values(), replace=freemarker.ext.beans.OverloadedMethods@11d0265, java.lang.Object@3e55b2={public boolean java.util.HashMap.isEmpty()=[Ljava.lang.Class;@c5aa3a, public int java.util.AbstractMap.hashCode()=[Ljava.lang.Class;@74a947, public java.lang.Object java.util.HashMap.put(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@1615a91, public boolean java.util.AbstractMap.equals(java.lang.Object)=[Ljava.lang.Class;@a46ab2, public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object)=[Ljava.lang.Class;@1c389e6, public java.lang.String java.util.AbstractMap.toString()=[Ljava.lang.Class;@a23548, public boolean java.util.HashMap.containsKey(java.lang.Object)=[Ljava.lang.Class;@1be4a9f, public java.util.Set java.util.LinkedHashMap.keySet()=[Ljava.lang.Class;@44c60, public java.lang.Object java.util.HashMap.computeIfAbsent(java.lang.Object,java.util.function.Function)=[Ljava.lang.Class;@10f7dff, public java.lang.Object java.util.HashMap.clone()=[Ljava.lang.Class;@d214e3, public java.lang.Object java.util.LinkedHashMap.getOrDefault(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@1a74254, public java.util.Set java.util.LinkedHashMap.entrySet()=[Ljava.lang.Class;@1c4740c, public void java.util.LinkedHashMap.forEach(java.util.function.BiConsumer)=[Ljava.lang.Class;@1fe0c8e, public java.lang.Object java.util.HashMap.putIfAbsent(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@16f73de, public java.util.Collection java.util.LinkedHashMap.values()=[Ljava.lang.Class;@b3e45, public void java.util.LinkedHashMap.clear()=[Ljava.lang.Class;@a34e5c, public java.lang.Object java.util.HashMap.computeIfPresent(java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1fcb13a, public java.lang.Object java.util.HashMap.compute(java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1a7c258, public final native java.lang.Class java.lang.Object.getClass()=[Ljava.lang.Class;@7397f, public void java.util.HashMap.putAll(java.util.Map)=[Ljava.lang.Class;@59cd, public void java.util.LinkedHashMap.replaceAll(java.util.function.BiFunction)=[Ljava.lang.Class;@994816, public java.lang.Object java.util.HashMap.merge(java.lang.Object,java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1b1e75f, public int java.util.HashMap.size()=[Ljava.lang.Class;@bee157, public boolean java.util.LinkedHashMap.containsValue(java.lang.Object)=[Ljava.lang.Class;@5e0d7c}, replaceAll=public void java.util.LinkedHashMap.replaceAll(java.util.function.BiFunction), remove=freemarker.ext.beans.OverloadedMethods@8d3a99, containsValue=public boolean java.util.LinkedHashMap.containsValue(java.lang.Object), put=public java.lang.Object java.util.HashMap.put(java.lang.Object,java.lang.Object), empty=java.beans.PropertyDescriptor[name=empty; propertyType=boolean; readMethod=public boolean java.util.HashMap.isEmpty()], compute=public java.lang.Object java.util.HashMap.compute(java.lang.Object,java.util.function.BiFunction), hashCode=public int java.util.AbstractMap.hashCode(), putAll=public void java.util.HashMap.putAll(java.util.Map), get=public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object), merge=public java.lang.Object java.util.HashMap.merge(java.lang.Object,java.lang.Object,java.util.function.BiFunction), class=java.beans.PropertyDescriptor[name=class; propertyType=class java.lang.Class; readMethod=public final native java.lang.Class java.lang.Object.getClass()], keySet=public java.util.Set java.util.LinkedHashMap.keySet(), java.lang.Object@1c0f21d=freemarker.ext.beans.OverloadedMethods@d4b988, entrySet=public java.util.Set java.util.LinkedHashMap.entrySet(), java.lang.Object@15be27d=public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object), forEach=public void java.util.LinkedHashMap.forEach(java.util.function.BiConsumer), containsKey=public boolean java.util.HashMap.containsKey(java.lang.Object), isEmpty=public boolean java.util.HashMap.isEmpty(), clear=public void java.util.LinkedHashMap.clear(), computeIfPresent=public java.lang.Object java.util.HashMap.computeIfPresent(java.lang.Object,java.util.function.BiFunction), size=public int java.util.HashMap.size(), equals=public boolean java.util.AbstractMap.equals(java.lang.Object), clone=public java.lang.Object java.util.HashMap.clone(), toString=public java.lang.String java.util.AbstractMap.toString(), putIfAbsent=public java.lang.Object java.util.HashMap.putIfAbsent(java.lang.Object,java.lang.Object)}
[DEBUG] 2017-05-24: 21:05:32 freemarker.log._Log4jLoggerFactory$Log4jLogger.debug(_Log4jLoggerFactory.java:45) :  Key "labelposition" was not found on instance of java.util.LinkedHashMap. Introspection information for the class is: {getClass=public final native java.lang.Class java.lang.Object.getClass(), getOrDefault=public java.lang.Object java.util.LinkedHashMap.getOrDefault(java.lang.Object,java.lang.Object), computeIfAbsent=public java.lang.Object java.util.HashMap.computeIfAbsent(java.lang.Object,java.util.function.Function), values=public java.util.Collection java.util.LinkedHashMap.values(), replace=freemarker.ext.beans.OverloadedMethods@11d0265, java.lang.Object@3e55b2={public boolean java.util.HashMap.isEmpty()=[Ljava.lang.Class;@c5aa3a, public int java.util.AbstractMap.hashCode()=[Ljava.lang.Class;@74a947, public java.lang.Object java.util.HashMap.put(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@1615a91, public boolean java.util.AbstractMap.equals(java.lang.Object)=[Ljava.lang.Class;@a46ab2, public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object)=[Ljava.lang.Class;@1c389e6, public java.lang.String java.util.AbstractMap.toString()=[Ljava.lang.Class;@a23548, public boolean java.util.HashMap.containsKey(java.lang.Object)=[Ljava.lang.Class;@1be4a9f, public java.util.Set java.util.LinkedHashMap.keySet()=[Ljava.lang.Class;@44c60, public java.lang.Object java.util.HashMap.computeIfAbsent(java.lang.Object,java.util.function.Function)=[Ljava.lang.Class;@10f7dff, public java.lang.Object java.util.HashMap.clone()=[Ljava.lang.Class;@d214e3, public java.lang.Object java.util.LinkedHashMap.getOrDefault(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@1a74254, public java.util.Set java.util.LinkedHashMap.entrySet()=[Ljava.lang.Class;@1c4740c, public void java.util.LinkedHashMap.forEach(java.util.function.BiConsumer)=[Ljava.lang.Class;@1fe0c8e, public java.lang.Object java.util.HashMap.putIfAbsent(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@16f73de, public java.util.Collection java.util.LinkedHashMap.values()=[Ljava.lang.Class;@b3e45, public void java.util.LinkedHashMap.clear()=[Ljava.lang.Class;@a34e5c, public java.lang.Object java.util.HashMap.computeIfPresent(java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1fcb13a, public java.lang.Object java.util.HashMap.compute(java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1a7c258, public final native java.lang.Class java.lang.Object.getClass()=[Ljava.lang.Class;@7397f, public void java.util.HashMap.putAll(java.util.Map)=[Ljava.lang.Class;@59cd, public void java.util.LinkedHashMap.replaceAll(java.util.function.BiFunction)=[Ljava.lang.Class;@994816, public java.lang.Object java.util.HashMap.merge(java.lang.Object,java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1b1e75f, public int java.util.HashMap.size()=[Ljava.lang.Class;@bee157, public boolean java.util.LinkedHashMap.containsValue(java.lang.Object)=[Ljava.lang.Class;@5e0d7c}, replaceAll=public void java.util.LinkedHashMap.replaceAll(java.util.function.BiFunction), remove=freemarker.ext.beans.OverloadedMethods@8d3a99, containsValue=public boolean java.util.LinkedHashMap.containsValue(java.lang.Object), put=public java.lang.Object java.util.HashMap.put(java.lang.Object,java.lang.Object), empty=java.beans.PropertyDescriptor[name=empty; propertyType=boolean; readMethod=public boolean java.util.HashMap.isEmpty()], compute=public java.lang.Object java.util.HashMap.compute(java.lang.Object,java.util.function.BiFunction), hashCode=public int java.util.AbstractMap.hashCode(), putAll=public void java.util.HashMap.putAll(java.util.Map), get=public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object), merge=public java.lang.Object java.util.HashMap.merge(java.lang.Object,java.lang.Object,java.util.function.BiFunction), class=java.beans.PropertyDescriptor[name=class; propertyType=class java.lang.Class; readMethod=public final native java.lang.Class java.lang.Object.getClass()], keySet=public java.util.Set java.util.LinkedHashMap.keySet(), java.lang.Object@1c0f21d=freemarker.ext.beans.OverloadedMethods@d4b988, entrySet=public java.util.Set java.util.LinkedHashMap.entrySet(), java.lang.Object@15be27d=public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object), forEach=public void java.util.LinkedHashMap.forEach(java.util.function.BiConsumer), containsKey=public boolean java.util.HashMap.containsKey(java.lang.Object), isEmpty=public boolean java.util.HashMap.isEmpty(), clear=public void java.util.LinkedHashMap.clear(), computeIfPresent=public java.lang.Object java.util.HashMap.computeIfPresent(java.lang.Object,java.util.function.BiFunction), size=public int java.util.HashMap.size(), equals=public boolean java.util.AbstractMap.equals(java.lang.Object), clone=public java.lang.Object java.util.HashMap.clone(), toString=public java.lang.String java.util.AbstractMap.toString(), putIfAbsent=public java.lang.Object java.util.HashMap.putIfAbsent(java.lang.Object,java.lang.Object)}
[DEBUG] 2017-05-24: 21:05:32 freemarker.log._Log4jLoggerFactory$Log4jLogger.debug(_Log4jLoggerFactory.java:45) :  Key "labelposition" was not found on instance of java.util.LinkedHashMap. Introspection information for the class is: {getClass=public final native java.lang.Class java.lang.Object.getClass(), getOrDefault=public java.lang.Object java.util.LinkedHashMap.getOrDefault(java.lang.Object,java.lang.Object), computeIfAbsent=public java.lang.Object java.util.HashMap.computeIfAbsent(java.lang.Object,java.util.function.Function), values=public java.util.Collection java.util.LinkedHashMap.values(), replace=freemarker.ext.beans.OverloadedMethods@11d0265, java.lang.Object@3e55b2={public boolean java.util.HashMap.isEmpty()=[Ljava.lang.Class;@c5aa3a, public int java.util.AbstractMap.hashCode()=[Ljava.lang.Class;@74a947, public java.lang.Object java.util.HashMap.put(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@1615a91, public boolean java.util.AbstractMap.equals(java.lang.Object)=[Ljava.lang.Class;@a46ab2, public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object)=[Ljava.lang.Class;@1c389e6, public java.lang.String java.util.AbstractMap.toString()=[Ljava.lang.Class;@a23548, public boolean java.util.HashMap.containsKey(java.lang.Object)=[Ljava.lang.Class;@1be4a9f, public java.util.Set java.util.LinkedHashMap.keySet()=[Ljava.lang.Class;@44c60, public java.lang.Object java.util.HashMap.computeIfAbsent(java.lang.Object,java.util.function.Function)=[Ljava.lang.Class;@10f7dff, public java.lang.Object java.util.HashMap.clone()=[Ljava.lang.Class;@d214e3, public java.lang.Object java.util.LinkedHashMap.getOrDefault(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@1a74254, public java.util.Set java.util.LinkedHashMap.entrySet()=[Ljava.lang.Class;@1c4740c, public void java.util.LinkedHashMap.forEach(java.util.function.BiConsumer)=[Ljava.lang.Class;@1fe0c8e, public java.lang.Object java.util.HashMap.putIfAbsent(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@16f73de, public java.util.Collection java.util.LinkedHashMap.values()=[Ljava.lang.Class;@b3e45, public void java.util.LinkedHashMap.clear()=[Ljava.lang.Class;@a34e5c, public java.lang.Object java.util.HashMap.computeIfPresent(java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1fcb13a, public java.lang.Object java.util.HashMap.compute(java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1a7c258, public final native java.lang.Class java.lang.Object.getClass()=[Ljava.lang.Class;@7397f, public void java.util.HashMap.putAll(java.util.Map)=[Ljava.lang.Class;@59cd, public void java.util.LinkedHashMap.replaceAll(java.util.function.BiFunction)=[Ljava.lang.Class;@994816, public java.lang.Object java.util.HashMap.merge(java.lang.Object,java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1b1e75f, public int java.util.HashMap.size()=[Ljava.lang.Class;@bee157, public boolean java.util.LinkedHashMap.containsValue(java.lang.Object)=[Ljava.lang.Class;@5e0d7c}, replaceAll=public void java.util.LinkedHashMap.replaceAll(java.util.function.BiFunction), remove=freemarker.ext.beans.OverloadedMethods@8d3a99, containsValue=public boolean java.util.LinkedHashMap.containsValue(java.lang.Object), put=public java.lang.Object java.util.HashMap.put(java.lang.Object,java.lang.Object), empty=java.beans.PropertyDescriptor[name=empty; propertyType=boolean; readMethod=public boolean java.util.HashMap.isEmpty()], compute=public java.lang.Object java.util.HashMap.compute(java.lang.Object,java.util.function.BiFunction), hashCode=public int java.util.AbstractMap.hashCode(), putAll=public void java.util.HashMap.putAll(java.util.Map), get=public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object), merge=public java.lang.Object java.util.HashMap.merge(java.lang.Object,java.lang.Object,java.util.function.BiFunction), class=java.beans.PropertyDescriptor[name=class; propertyType=class java.lang.Class; readMethod=public final native java.lang.Class java.lang.Object.getClass()], keySet=public java.util.Set java.util.LinkedHashMap.keySet(), java.lang.Object@1c0f21d=freemarker.ext.beans.OverloadedMethods@d4b988, entrySet=public java.util.Set java.util.LinkedHashMap.entrySet(), java.lang.Object@15be27d=public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object), forEach=public void java.util.LinkedHashMap.forEach(java.util.function.BiConsumer), containsKey=public boolean java.util.HashMap.containsKey(java.lang.Object), isEmpty=public boolean java.util.HashMap.isEmpty(), clear=public void java.util.LinkedHashMap.clear(), computeIfPresent=public java.lang.Object java.util.HashMap.computeIfPresent(java.lang.Object,java.util.function.BiFunction), size=public int java.util.HashMap.size(), equals=public boolean java.util.AbstractMap.equals(java.lang.Object), clone=public java.lang.Object java.util.HashMap.clone(), toString=public java.lang.String java.util.AbstractMap.toString(), putIfAbsent=public java.lang.Object java.util.HashMap.putIfAbsent(java.lang.Object,java.lang.Object)}
[DEBUG] 2017-05-24: 21:05:32 freemarker.log._Log4jLoggerFactory$Log4jLogger.debug(_Log4jLoggerFactory.java:45) :  Key "labelposition" was not found on instance of java.util.LinkedHashMap. Introspection information for the class is: {getClass=public final native java.lang.Class java.lang.Object.getClass(), getOrDefault=public java.lang.Object java.util.LinkedHashMap.getOrDefault(java.lang.Object,java.lang.Object), computeIfAbsent=public java.lang.Object java.util.HashMap.computeIfAbsent(java.lang.Object,java.util.function.Function), values=public java.util.Collection java.util.LinkedHashMap.values(), replace=freemarker.ext.beans.OverloadedMethods@11d0265, java.lang.Object@3e55b2={public boolean java.util.HashMap.isEmpty()=[Ljava.lang.Class;@c5aa3a, public int java.util.AbstractMap.hashCode()=[Ljava.lang.Class;@74a947, public java.lang.Object java.util.HashMap.put(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@1615a91, public boolean java.util.AbstractMap.equals(java.lang.Object)=[Ljava.lang.Class;@a46ab2, public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object)=[Ljava.lang.Class;@1c389e6, public java.lang.String java.util.AbstractMap.toString()=[Ljava.lang.Class;@a23548, public boolean java.util.HashMap.containsKey(java.lang.Object)=[Ljava.lang.Class;@1be4a9f, public java.util.Set java.util.LinkedHashMap.keySet()=[Ljava.lang.Class;@44c60, public java.lang.Object java.util.HashMap.computeIfAbsent(java.lang.Object,java.util.function.Function)=[Ljava.lang.Class;@10f7dff, public java.lang.Object java.util.HashMap.clone()=[Ljava.lang.Class;@d214e3, public java.lang.Object java.util.LinkedHashMap.getOrDefault(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@1a74254, public java.util.Set java.util.LinkedHashMap.entrySet()=[Ljava.lang.Class;@1c4740c, public void java.util.LinkedHashMap.forEach(java.util.function.BiConsumer)=[Ljava.lang.Class;@1fe0c8e, public java.lang.Object java.util.HashMap.putIfAbsent(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@16f73de, public java.util.Collection java.util.LinkedHashMap.values()=[Ljava.lang.Class;@b3e45, public void java.util.LinkedHashMap.clear()=[Ljava.lang.Class;@a34e5c, public java.lang.Object java.util.HashMap.computeIfPresent(java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1fcb13a, public java.lang.Object java.util.HashMap.compute(java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1a7c258, public final native java.lang.Class java.lang.Object.getClass()=[Ljava.lang.Class;@7397f, public void java.util.HashMap.putAll(java.util.Map)=[Ljava.lang.Class;@59cd, public void java.util.LinkedHashMap.replaceAll(java.util.function.BiFunction)=[Ljava.lang.Class;@994816, public java.lang.Object java.util.HashMap.merge(java.lang.Object,java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1b1e75f, public int java.util.HashMap.size()=[Ljava.lang.Class;@bee157, public boolean java.util.LinkedHashMap.containsValue(java.lang.Object)=[Ljava.lang.Class;@5e0d7c}, replaceAll=public void java.util.LinkedHashMap.replaceAll(java.util.function.BiFunction), remove=freemarker.ext.beans.OverloadedMethods@8d3a99, containsValue=public boolean java.util.LinkedHashMap.containsValue(java.lang.Object), put=public java.lang.Object java.util.HashMap.put(java.lang.Object,java.lang.Object), empty=java.beans.PropertyDescriptor[name=empty; propertyType=boolean; readMethod=public boolean java.util.HashMap.isEmpty()], compute=public java.lang.Object java.util.HashMap.compute(java.lang.Object,java.util.function.BiFunction), hashCode=public int java.util.AbstractMap.hashCode(), putAll=public void java.util.HashMap.putAll(java.util.Map), get=public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object), merge=public java.lang.Object java.util.HashMap.merge(java.lang.Object,java.lang.Object,java.util.function.BiFunction), class=java.beans.PropertyDescriptor[name=class; propertyType=class java.lang.Class; readMethod=public final native java.lang.Class java.lang.Object.getClass()], keySet=public java.util.Set java.util.LinkedHashMap.keySet(), java.lang.Object@1c0f21d=freemarker.ext.beans.OverloadedMethods@d4b988, entrySet=public java.util.Set java.util.LinkedHashMap.entrySet(), java.lang.Object@15be27d=public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object), forEach=public void java.util.LinkedHashMap.forEach(java.util.function.BiConsumer), containsKey=public boolean java.util.HashMap.containsKey(java.lang.Object), isEmpty=public boolean java.util.HashMap.isEmpty(), clear=public void java.util.LinkedHashMap.clear(), computeIfPresent=public java.lang.Object java.util.HashMap.computeIfPresent(java.lang.Object,java.util.function.BiFunction), size=public int java.util.HashMap.size(), equals=public boolean java.util.AbstractMap.equals(java.lang.Object), clone=public java.lang.Object java.util.HashMap.clone(), toString=public java.lang.String java.util.AbstractMap.toString(), putIfAbsent=public java.lang.Object java.util.HashMap.putIfAbsent(java.lang.Object,java.lang.Object)}
[DEBUG] 2017-05-24: 21:05:32 freemarker.log._Log4jLoggerFactory$Log4jLogger.debug(_Log4jLoggerFactory.java:45) :  Key "required" was not found on instance of java.util.LinkedHashMap. Introspection information for the class is: {getClass=public final native java.lang.Class java.lang.Object.getClass(), getOrDefault=public java.lang.Object java.util.LinkedHashMap.getOrDefault(java.lang.Object,java.lang.Object), computeIfAbsent=public java.lang.Object java.util.HashMap.computeIfAbsent(java.lang.Object,java.util.function.Function), values=public java.util.Collection java.util.LinkedHashMap.values(), replace=freemarker.ext.beans.OverloadedMethods@11d0265, java.lang.Object@3e55b2={public boolean java.util.HashMap.isEmpty()=[Ljava.lang.Class;@c5aa3a, public int java.util.AbstractMap.hashCode()=[Ljava.lang.Class;@74a947, public java.lang.Object java.util.HashMap.put(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@1615a91, public boolean java.util.AbstractMap.equals(java.lang.Object)=[Ljava.lang.Class;@a46ab2, public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object)=[Ljava.lang.Class;@1c389e6, public java.lang.String java.util.AbstractMap.toString()=[Ljava.lang.Class;@a23548, public boolean java.util.HashMap.containsKey(java.lang.Object)=[Ljava.lang.Class;@1be4a9f, public java.util.Set java.util.LinkedHashMap.keySet()=[Ljava.lang.Class;@44c60, public java.lang.Object java.util.HashMap.computeIfAbsent(java.lang.Object,java.util.function.Function)=[Ljava.lang.Class;@10f7dff, public java.lang.Object java.util.HashMap.clone()=[Ljava.lang.Class;@d214e3, public java.lang.Object java.util.LinkedHashMap.getOrDefault(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@1a74254, public java.util.Set java.util.LinkedHashMap.entrySet()=[Ljava.lang.Class;@1c4740c, public void java.util.LinkedHashMap.forEach(java.util.function.BiConsumer)=[Ljava.lang.Class;@1fe0c8e, public java.lang.Object java.util.HashMap.putIfAbsent(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@16f73de, public java.util.Collection java.util.LinkedHashMap.values()=[Ljava.lang.Class;@b3e45, public void java.util.LinkedHashMap.clear()=[Ljava.lang.Class;@a34e5c, public java.lang.Object java.util.HashMap.computeIfPresent(java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1fcb13a, public java.lang.Object java.util.HashMap.compute(java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1a7c258, public final native java.lang.Class java.lang.Object.getClass()=[Ljava.lang.Class;@7397f, public void java.util.HashMap.putAll(java.util.Map)=[Ljava.lang.Class;@59cd, public void java.util.LinkedHashMap.replaceAll(java.util.function.BiFunction)=[Ljava.lang.Class;@994816, public java.lang.Object java.util.HashMap.merge(java.lang.Object,java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1b1e75f, public int java.util.HashMap.size()=[Ljava.lang.Class;@bee157, public boolean java.util.LinkedHashMap.containsValue(java.lang.Object)=[Ljava.lang.Class;@5e0d7c}, replaceAll=public void java.util.LinkedHashMap.replaceAll(java.util.function.BiFunction), remove=freemarker.ext.beans.OverloadedMethods@8d3a99, containsValue=public boolean java.util.LinkedHashMap.containsValue(java.lang.Object), put=public java.lang.Object java.util.HashMap.put(java.lang.Object,java.lang.Object), empty=java.beans.PropertyDescriptor[name=empty; propertyType=boolean; readMethod=public boolean java.util.HashMap.isEmpty()], compute=public java.lang.Object java.util.HashMap.compute(java.lang.Object,java.util.function.BiFunction), hashCode=public int java.util.AbstractMap.hashCode(), putAll=public void java.util.HashMap.putAll(java.util.Map), get=public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object), merge=public java.lang.Object java.util.HashMap.merge(java.lang.Object,java.lang.Object,java.util.function.BiFunction), class=java.beans.PropertyDescriptor[name=class; propertyType=class java.lang.Class; readMethod=public final native java.lang.Class java.lang.Object.getClass()], keySet=public java.util.Set java.util.LinkedHashMap.keySet(), java.lang.Object@1c0f21d=freemarker.ext.beans.OverloadedMethods@d4b988, entrySet=public java.util.Set java.util.LinkedHashMap.entrySet(), java.lang.Object@15be27d=public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object), forEach=public void java.util.LinkedHashMap.forEach(java.util.function.BiConsumer), containsKey=public boolean java.util.HashMap.containsKey(java.lang.Object), isEmpty=public boolean java.util.HashMap.isEmpty(), clear=public void java.util.LinkedHashMap.clear(), computeIfPresent=public java.lang.Object java.util.HashMap.computeIfPresent(java.lang.Object,java.util.function.BiFunction), size=public int java.util.HashMap.size(), equals=public boolean java.util.AbstractMap.equals(java.lang.Object), clone=public java.lang.Object java.util.HashMap.clone(), toString=public java.lang.String java.util.AbstractMap.toString(), putIfAbsent=public java.lang.Object java.util.HashMap.putIfAbsent(java.lang.Object,java.lang.Object)}
[DEBUG] 2017-05-24: 21:05:32 freemarker.log._Log4jLoggerFactory$Log4jLogger.debug(_Log4jLoggerFactory.java:45) :  Key "required" was not found on instance of java.util.LinkedHashMap. Introspection information for the class is: {getClass=public final native java.lang.Class java.lang.Object.getClass(), getOrDefault=public java.lang.Object java.util.LinkedHashMap.getOrDefault(java.lang.Object,java.lang.Object), computeIfAbsent=public java.lang.Object java.util.HashMap.computeIfAbsent(java.lang.Object,java.util.function.Function), values=public java.util.Collection java.util.LinkedHashMap.values(), replace=freemarker.ext.beans.OverloadedMethods@11d0265, java.lang.Object@3e55b2={public boolean java.util.HashMap.isEmpty()=[Ljava.lang.Class;@c5aa3a, public int java.util.AbstractMap.hashCode()=[Ljava.lang.Class;@74a947, public java.lang.Object java.util.HashMap.put(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@1615a91, public boolean java.util.AbstractMap.equals(java.lang.Object)=[Ljava.lang.Class;@a46ab2, public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object)=[Ljava.lang.Class;@1c389e6, public java.lang.String java.util.AbstractMap.toString()=[Ljava.lang.Class;@a23548, public boolean java.util.HashMap.containsKey(java.lang.Object)=[Ljava.lang.Class;@1be4a9f, public java.util.Set java.util.LinkedHashMap.keySet()=[Ljava.lang.Class;@44c60, public java.lang.Object java.util.HashMap.computeIfAbsent(java.lang.Object,java.util.function.Function)=[Ljava.lang.Class;@10f7dff, public java.lang.Object java.util.HashMap.clone()=[Ljava.lang.Class;@d214e3, public java.lang.Object java.util.LinkedHashMap.getOrDefault(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@1a74254, public java.util.Set java.util.LinkedHashMap.entrySet()=[Ljava.lang.Class;@1c4740c, public void java.util.LinkedHashMap.forEach(java.util.function.BiConsumer)=[Ljava.lang.Class;@1fe0c8e, public java.lang.Object java.util.HashMap.putIfAbsent(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@16f73de, public java.util.Collection java.util.LinkedHashMap.values()=[Ljava.lang.Class;@b3e45, public void java.util.LinkedHashMap.clear()=[Ljava.lang.Class;@a34e5c, public java.lang.Object java.util.HashMap.computeIfPresent(java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1fcb13a, public java.lang.Object java.util.HashMap.compute(java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1a7c258, public final native java.lang.Class java.lang.Object.getClass()=[Ljava.lang.Class;@7397f, public void java.util.HashMap.putAll(java.util.Map)=[Ljava.lang.Class;@59cd, public void java.util.LinkedHashMap.replaceAll(java.util.function.BiFunction)=[Ljava.lang.Class;@994816, public java.lang.Object java.util.HashMap.merge(java.lang.Object,java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1b1e75f, public int java.util.HashMap.size()=[Ljava.lang.Class;@bee157, public boolean java.util.LinkedHashMap.containsValue(java.lang.Object)=[Ljava.lang.Class;@5e0d7c}, replaceAll=public void java.util.LinkedHashMap.replaceAll(java.util.function.BiFunction), remove=freemarker.ext.beans.OverloadedMethods@8d3a99, containsValue=public boolean java.util.LinkedHashMap.containsValue(java.lang.Object), put=public java.lang.Object java.util.HashMap.put(java.lang.Object,java.lang.Object), empty=java.beans.PropertyDescriptor[name=empty; propertyType=boolean; readMethod=public boolean java.util.HashMap.isEmpty()], compute=public java.lang.Object java.util.HashMap.compute(java.lang.Object,java.util.function.BiFunction), hashCode=public int java.util.AbstractMap.hashCode(), putAll=public void java.util.HashMap.putAll(java.util.Map), get=public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object), merge=public java.lang.Object java.util.HashMap.merge(java.lang.Object,java.lang.Object,java.util.function.BiFunction), class=java.beans.PropertyDescriptor[name=class; propertyType=class java.lang.Class; readMethod=public final native java.lang.Class java.lang.Object.getClass()], keySet=public java.util.Set java.util.LinkedHashMap.keySet(), java.lang.Object@1c0f21d=freemarker.ext.beans.OverloadedMethods@d4b988, entrySet=public java.util.Set java.util.LinkedHashMap.entrySet(), java.lang.Object@15be27d=public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object), forEach=public void java.util.LinkedHashMap.forEach(java.util.function.BiConsumer), containsKey=public boolean java.util.HashMap.containsKey(java.lang.Object), isEmpty=public boolean java.util.HashMap.isEmpty(), clear=public void java.util.LinkedHashMap.clear(), computeIfPresent=public java.lang.Object java.util.HashMap.computeIfPresent(java.lang.Object,java.util.function.BiFunction), size=public int java.util.HashMap.size(), equals=public boolean java.util.AbstractMap.equals(java.lang.Object), clone=public java.lang.Object java.util.HashMap.clone(), toString=public java.lang.String java.util.AbstractMap.toString(), putIfAbsent=public java.lang.Object java.util.HashMap.putIfAbsent(java.lang.Object,java.lang.Object)}
[DEBUG] 2017-05-24: 21:05:32 freemarker.log._Log4jLoggerFactory$Log4jLogger.debug(_Log4jLoggerFactory.java:45) :  Key "labelseparator" was not found on instance of java.util.LinkedHashMap. Introspection information for the class is: {getClass=public final native java.lang.Class java.lang.Object.getClass(), getOrDefault=public java.lang.Object java.util.LinkedHashMap.getOrDefault(java.lang.Object,java.lang.Object), computeIfAbsent=public java.lang.Object java.util.HashMap.computeIfAbsent(java.lang.Object,java.util.function.Function), values=public java.util.Collection java.util.LinkedHashMap.values(), replace=freemarker.ext.beans.OverloadedMethods@11d0265, java.lang.Object@3e55b2={public boolean java.util.HashMap.isEmpty()=[Ljava.lang.Class;@c5aa3a, public int java.util.AbstractMap.hashCode()=[Ljava.lang.Class;@74a947, public java.lang.Object java.util.HashMap.put(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@1615a91, public boolean java.util.AbstractMap.equals(java.lang.Object)=[Ljava.lang.Class;@a46ab2, public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object)=[Ljava.lang.Class;@1c389e6, public java.lang.String java.util.AbstractMap.toString()=[Ljava.lang.Class;@a23548, public boolean java.util.HashMap.containsKey(java.lang.Object)=[Ljava.lang.Class;@1be4a9f, public java.util.Set java.util.LinkedHashMap.keySet()=[Ljava.lang.Class;@44c60, public java.lang.Object java.util.HashMap.computeIfAbsent(java.lang.Object,java.util.function.Function)=[Ljava.lang.Class;@10f7dff, public java.lang.Object java.util.HashMap.clone()=[Ljava.lang.Class;@d214e3, public java.lang.Object java.util.LinkedHashMap.getOrDefault(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@1a74254, public java.util.Set java.util.LinkedHashMap.entrySet()=[Ljava.lang.Class;@1c4740c, public void java.util.LinkedHashMap.forEach(java.util.function.BiConsumer)=[Ljava.lang.Class;@1fe0c8e, public java.lang.Object java.util.HashMap.putIfAbsent(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@16f73de, public java.util.Collection java.util.LinkedHashMap.values()=[Ljava.lang.Class;@b3e45, public void java.util.LinkedHashMap.clear()=[Ljava.lang.Class;@a34e5c, public java.lang.Object java.util.HashMap.computeIfPresent(java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1fcb13a, public java.lang.Object java.util.HashMap.compute(java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1a7c258, public final native java.lang.Class java.lang.Object.getClass()=[Ljava.lang.Class;@7397f, public void java.util.HashMap.putAll(java.util.Map)=[Ljava.lang.Class;@59cd, public void java.util.LinkedHashMap.replaceAll(java.util.function.BiFunction)=[Ljava.lang.Class;@994816, public java.lang.Object java.util.HashMap.merge(java.lang.Object,java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1b1e75f, public int java.util.HashMap.size()=[Ljava.lang.Class;@bee157, public boolean java.util.LinkedHashMap.containsValue(java.lang.Object)=[Ljava.lang.Class;@5e0d7c}, replaceAll=public void java.util.LinkedHashMap.replaceAll(java.util.function.BiFunction), remove=freemarker.ext.beans.OverloadedMethods@8d3a99, containsValue=public boolean java.util.LinkedHashMap.containsValue(java.lang.Object), put=public java.lang.Object java.util.HashMap.put(java.lang.Object,java.lang.Object), empty=java.beans.PropertyDescriptor[name=empty; propertyType=boolean; readMethod=public boolean java.util.HashMap.isEmpty()], compute=public java.lang.Object java.util.HashMap.compute(java.lang.Object,java.util.function.BiFunction), hashCode=public int java.util.AbstractMap.hashCode(), putAll=public void java.util.HashMap.putAll(java.util.Map), get=public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object), merge=public java.lang.Object java.util.HashMap.merge(java.lang.Object,java.lang.Object,java.util.function.BiFunction), class=java.beans.PropertyDescriptor[name=class; propertyType=class java.lang.Class; readMethod=public final native java.lang.Class java.lang.Object.getClass()], keySet=public java.util.Set java.util.LinkedHashMap.keySet(), java.lang.Object@1c0f21d=freemarker.ext.beans.OverloadedMethods@d4b988, entrySet=public java.util.Set java.util.LinkedHashMap.entrySet(), java.lang.Object@15be27d=public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object), forEach=public void java.util.LinkedHashMap.forEach(java.util.function.BiConsumer), containsKey=public boolean java.util.HashMap.containsKey(java.lang.Object), isEmpty=public boolean java.util.HashMap.isEmpty(), clear=public void java.util.LinkedHashMap.clear(), computeIfPresent=public java.lang.Object java.util.HashMap.computeIfPresent(java.lang.Object,java.util.function.BiFunction), size=public int java.util.HashMap.size(), equals=public boolean java.util.AbstractMap.equals(java.lang.Object), clone=public java.lang.Object java.util.HashMap.clone(), toString=public java.lang.String java.util.AbstractMap.toString(), putIfAbsent=public java.lang.Object java.util.HashMap.putIfAbsent(java.lang.Object,java.lang.Object)}
[DEBUG] 2017-05-24: 21:05:32 freemarker.log._Log4jLoggerFactory$Log4jLogger.debug(_Log4jLoggerFactory.java:45) :  TemplateLoader.findTemplateSource("template/~~~xhtml/tooltip.ftl"): Found
[DEBUG] 2017-05-24: 21:05:32 freemarker.log._Log4jLoggerFactory$Log4jLogger.debug(_Log4jLoggerFactory.java:45) :  "template/~~~xhtml/tooltip.ftl"("zh_CN", UTF-8, parsed): using cached since jar:file:/D:/maven/repository/org/apache/struts/struts2-core/2.5.10/struts2-core-2.5.10.jar!/template/xhtml/tooltip.ftl hasn't changed.
[DEBUG] 2017-05-24: 21:05:32 freemarker.log._Log4jLoggerFactory$Log4jLogger.debug(_Log4jLoggerFactory.java:45) :  Key "tooltip" was not found on instance of java.util.LinkedHashMap. Introspection information for the class is: {getClass=public final native java.lang.Class java.lang.Object.getClass(), getOrDefault=public java.lang.Object java.util.LinkedHashMap.getOrDefault(java.lang.Object,java.lang.Object), computeIfAbsent=public java.lang.Object java.util.HashMap.computeIfAbsent(java.lang.Object,java.util.function.Function), values=public java.util.Collection java.util.LinkedHashMap.values(), replace=freemarker.ext.beans.OverloadedMethods@11d0265, java.lang.Object@3e55b2={public boolean java.util.HashMap.isEmpty()=[Ljava.lang.Class;@c5aa3a, public int java.util.AbstractMap.hashCode()=[Ljava.lang.Class;@74a947, public java.lang.Object java.util.HashMap.put(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@1615a91, public boolean java.util.AbstractMap.equals(java.lang.Object)=[Ljava.lang.Class;@a46ab2, public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object)=[Ljava.lang.Class;@1c389e6, public java.lang.String java.util.AbstractMap.toString()=[Ljava.lang.Class;@a23548, public boolean java.util.HashMap.containsKey(java.lang.Object)=[Ljava.lang.Class;@1be4a9f, public java.util.Set java.util.LinkedHashMap.keySet()=[Ljava.lang.Class;@44c60, public java.lang.Object java.util.HashMap.computeIfAbsent(java.lang.Object,java.util.function.Function)=[Ljava.lang.Class;@10f7dff, public java.lang.Object java.util.HashMap.clone()=[Ljava.lang.Class;@d214e3, public java.lang.Object java.util.LinkedHashMap.getOrDefault(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@1a74254, public java.util.Set java.util.LinkedHashMap.entrySet()=[Ljava.lang.Class;@1c4740c, public void java.util.LinkedHashMap.forEach(java.util.function.BiConsumer)=[Ljava.lang.Class;@1fe0c8e, public java.lang.Object java.util.HashMap.putIfAbsent(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@16f73de, public java.util.Collection java.util.LinkedHashMap.values()=[Ljava.lang.Class;@b3e45, public void java.util.LinkedHashMap.clear()=[Ljava.lang.Class;@a34e5c, public java.lang.Object java.util.HashMap.computeIfPresent(java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1fcb13a, public java.lang.Object java.util.HashMap.compute(java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1a7c258, public final native java.lang.Class java.lang.Object.getClass()=[Ljava.lang.Class;@7397f, public void java.util.HashMap.putAll(java.util.Map)=[Ljava.lang.Class;@59cd, public void java.util.LinkedHashMap.replaceAll(java.util.function.BiFunction)=[Ljava.lang.Class;@994816, public java.lang.Object java.util.HashMap.merge(java.lang.Object,java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1b1e75f, public int java.util.HashMap.size()=[Ljava.lang.Class;@bee157, public boolean java.util.LinkedHashMap.containsValue(java.lang.Object)=[Ljava.lang.Class;@5e0d7c}, replaceAll=public void java.util.LinkedHashMap.replaceAll(java.util.function.BiFunction), remove=freemarker.ext.beans.OverloadedMethods@8d3a99, containsValue=public boolean java.util.LinkedHashMap.containsValue(java.lang.Object), put=public java.lang.Object java.util.HashMap.put(java.lang.Object,java.lang.Object), empty=java.beans.PropertyDescriptor[name=empty; propertyType=boolean; readMethod=public boolean java.util.HashMap.isEmpty()], compute=public java.lang.Object java.util.HashMap.compute(java.lang.Object,java.util.function.BiFunction), hashCode=public int java.util.AbstractMap.hashCode(), putAll=public void java.util.HashMap.putAll(java.util.Map), get=public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object), merge=public java.lang.Object java.util.HashMap.merge(java.lang.Object,java.lang.Object,java.util.function.BiFunction), class=java.beans.PropertyDescriptor[name=class; propertyType=class java.lang.Class; readMethod=public final native java.lang.Class java.lang.Object.getClass()], keySet=public java.util.Set java.util.LinkedHashMap.keySet(), java.lang.Object@1c0f21d=freemarker.ext.beans.OverloadedMethods@d4b988, entrySet=public java.util.Set java.util.LinkedHashMap.entrySet(), java.lang.Object@15be27d=public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object), forEach=public void java.util.LinkedHashMap.forEach(java.util.function.BiConsumer), containsKey=public boolean java.util.HashMap.containsKey(java.lang.Object), isEmpty=public boolean java.util.HashMap.isEmpty(), clear=public void java.util.LinkedHashMap.clear(), computeIfPresent=public java.lang.Object java.util.HashMap.computeIfPresent(java.lang.Object,java.util.function.BiFunction), size=public int java.util.HashMap.size(), equals=public boolean java.util.AbstractMap.equals(java.lang.Object), clone=public java.lang.Object java.util.HashMap.clone(), toString=public java.lang.String java.util.AbstractMap.toString(), putIfAbsent=public java.lang.Object java.util.HashMap.putIfAbsent(java.lang.Object,java.lang.Object)}
[DEBUG] 2017-05-24: 21:05:32 freemarker.log._Log4jLoggerFactory$Log4jLogger.debug(_Log4jLoggerFactory.java:45) :  Key "align" was not found on instance of java.util.LinkedHashMap. Introspection information for the class is: {getClass=public final native java.lang.Class java.lang.Object.getClass(), getOrDefault=public java.lang.Object java.util.LinkedHashMap.getOrDefault(java.lang.Object,java.lang.Object), computeIfAbsent=public java.lang.Object java.util.HashMap.computeIfAbsent(java.lang.Object,java.util.function.Function), values=public java.util.Collection java.util.LinkedHashMap.values(), replace=freemarker.ext.beans.OverloadedMethods@11d0265, java.lang.Object@3e55b2={public boolean java.util.HashMap.isEmpty()=[Ljava.lang.Class;@c5aa3a, public int java.util.AbstractMap.hashCode()=[Ljava.lang.Class;@74a947, public java.lang.Object java.util.HashMap.put(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@1615a91, public boolean java.util.AbstractMap.equals(java.lang.Object)=[Ljava.lang.Class;@a46ab2, public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object)=[Ljava.lang.Class;@1c389e6, public java.lang.String java.util.AbstractMap.toString()=[Ljava.lang.Class;@a23548, public boolean java.util.HashMap.containsKey(java.lang.Object)=[Ljava.lang.Class;@1be4a9f, public java.util.Set java.util.LinkedHashMap.keySet()=[Ljava.lang.Class;@44c60, public java.lang.Object java.util.HashMap.computeIfAbsent(java.lang.Object,java.util.function.Function)=[Ljava.lang.Class;@10f7dff, public java.lang.Object java.util.HashMap.clone()=[Ljava.lang.Class;@d214e3, public java.lang.Object java.util.LinkedHashMap.getOrDefault(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@1a74254, public java.util.Set java.util.LinkedHashMap.entrySet()=[Ljava.lang.Class;@1c4740c, public void java.util.LinkedHashMap.forEach(java.util.function.BiConsumer)=[Ljava.lang.Class;@1fe0c8e, public java.lang.Object java.util.HashMap.putIfAbsent(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@16f73de, public java.util.Collection java.util.LinkedHashMap.values()=[Ljava.lang.Class;@b3e45, public void java.util.LinkedHashMap.clear()=[Ljava.lang.Class;@a34e5c, public java.lang.Object java.util.HashMap.computeIfPresent(java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1fcb13a, public java.lang.Object java.util.HashMap.compute(java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1a7c258, public final native java.lang.Class java.lang.Object.getClass()=[Ljava.lang.Class;@7397f, public void java.util.HashMap.putAll(java.util.Map)=[Ljava.lang.Class;@59cd, public void java.util.LinkedHashMap.replaceAll(java.util.function.BiFunction)=[Ljava.lang.Class;@994816, public java.lang.Object java.util.HashMap.merge(java.lang.Object,java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1b1e75f, public int java.util.HashMap.size()=[Ljava.lang.Class;@bee157, public boolean java.util.LinkedHashMap.containsValue(java.lang.Object)=[Ljava.lang.Class;@5e0d7c}, replaceAll=public void java.util.LinkedHashMap.replaceAll(java.util.function.BiFunction), remove=freemarker.ext.beans.OverloadedMethods@8d3a99, containsValue=public boolean java.util.LinkedHashMap.containsValue(java.lang.Object), put=public java.lang.Object java.util.HashMap.put(java.lang.Object,java.lang.Object), empty=java.beans.PropertyDescriptor[name=empty; propertyType=boolean; readMethod=public boolean java.util.HashMap.isEmpty()], compute=public java.lang.Object java.util.HashMap.compute(java.lang.Object,java.util.function.BiFunction), hashCode=public int java.util.AbstractMap.hashCode(), putAll=public void java.util.HashMap.putAll(java.util.Map), get=public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object), merge=public java.lang.Object java.util.HashMap.merge(java.lang.Object,java.lang.Object,java.util.function.BiFunction), class=java.beans.PropertyDescriptor[name=class; propertyType=class java.lang.Class; readMethod=public final native java.lang.Class java.lang.Object.getClass()], keySet=public java.util.Set java.util.LinkedHashMap.keySet(), java.lang.Object@1c0f21d=freemarker.ext.beans.OverloadedMethods@d4b988, entrySet=public java.util.Set java.util.LinkedHashMap.entrySet(), java.lang.Object@15be27d=public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object), forEach=public void java.util.LinkedHashMap.forEach(java.util.function.BiConsumer), containsKey=public boolean java.util.HashMap.containsKey(java.lang.Object), isEmpty=public boolean java.util.HashMap.isEmpty(), clear=public void java.util.LinkedHashMap.clear(), computeIfPresent=public java.lang.Object java.util.HashMap.computeIfPresent(java.lang.Object,java.util.function.BiFunction), size=public int java.util.HashMap.size(), equals=public boolean java.util.AbstractMap.equals(java.lang.Object), clone=public java.lang.Object java.util.HashMap.clone(), toString=public java.lang.String java.util.AbstractMap.toString(), putIfAbsent=public java.lang.Object java.util.HashMap.putIfAbsent(java.lang.Object,java.lang.Object)}
[DEBUG] 2017-05-24: 21:05:32 freemarker.log._Log4jLoggerFactory$Log4jLogger.debug(_Log4jLoggerFactory.java:45) :  TemplateLoader.findTemplateSource("template/simple/text.ftl"): Found
[DEBUG] 2017-05-24: 21:05:32 freemarker.log._Log4jLoggerFactory$Log4jLogger.debug(_Log4jLoggerFactory.java:45) :  "template/simple/text.ftl"("zh_CN", UTF-8, parsed): using cached since jar:file:/D:/maven/repository/org/apache/struts/struts2-core/2.5.10/struts2-core-2.5.10.jar!/template/simple/text.ftl hasn't changed.
[DEBUG] 2017-05-24: 21:05:32 freemarker.log._Log4jLoggerFactory$Log4jLogger.debug(_Log4jLoggerFactory.java:45) :  Key "type" was not found on instance of java.util.LinkedHashMap. Introspection information for the class is: {getClass=public final native java.lang.Class java.lang.Object.getClass(), getOrDefault=public java.lang.Object java.util.LinkedHashMap.getOrDefault(java.lang.Object,java.lang.Object), computeIfAbsent=public java.lang.Object java.util.HashMap.computeIfAbsent(java.lang.Object,java.util.function.Function), values=public java.util.Collection java.util.LinkedHashMap.values(), replace=freemarker.ext.beans.OverloadedMethods@11d0265, java.lang.Object@3e55b2={public boolean java.util.HashMap.isEmpty()=[Ljava.lang.Class;@c5aa3a, public int java.util.AbstractMap.hashCode()=[Ljava.lang.Class;@74a947, public java.lang.Object java.util.HashMap.put(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@1615a91, public boolean java.util.AbstractMap.equals(java.lang.Object)=[Ljava.lang.Class;@a46ab2, public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object)=[Ljava.lang.Class;@1c389e6, public java.lang.String java.util.AbstractMap.toString()=[Ljava.lang.Class;@a23548, public boolean java.util.HashMap.containsKey(java.lang.Object)=[Ljava.lang.Class;@1be4a9f, public java.util.Set java.util.LinkedHashMap.keySet()=[Ljava.lang.Class;@44c60, public java.lang.Object java.util.HashMap.computeIfAbsent(java.lang.Object,java.util.function.Function)=[Ljava.lang.Class;@10f7dff, public java.lang.Object java.util.HashMap.clone()=[Ljava.lang.Class;@d214e3, public java.lang.Object java.util.LinkedHashMap.getOrDefault(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@1a74254, public java.util.Set java.util.LinkedHashMap.entrySet()=[Ljava.lang.Class;@1c4740c, public void java.util.LinkedHashMap.forEach(java.util.function.BiConsumer)=[Ljava.lang.Class;@1fe0c8e, public java.lang.Object java.util.HashMap.putIfAbsent(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@16f73de, public java.util.Collection java.util.LinkedHashMap.values()=[Ljava.lang.Class;@b3e45, public void java.util.LinkedHashMap.clear()=[Ljava.lang.Class;@a34e5c, public java.lang.Object java.util.HashMap.computeIfPresent(java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1fcb13a, public java.lang.Object java.util.HashMap.compute(java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1a7c258, public final native java.lang.Class java.lang.Object.getClass()=[Ljava.lang.Class;@7397f, public void java.util.HashMap.putAll(java.util.Map)=[Ljava.lang.Class;@59cd, public void java.util.LinkedHashMap.replaceAll(java.util.function.BiFunction)=[Ljava.lang.Class;@994816, public java.lang.Object java.util.HashMap.merge(java.lang.Object,java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1b1e75f, public int java.util.HashMap.size()=[Ljava.lang.Class;@bee157, public boolean java.util.LinkedHashMap.containsValue(java.lang.Object)=[Ljava.lang.Class;@5e0d7c}, replaceAll=public void java.util.LinkedHashMap.replaceAll(java.util.function.BiFunction), remove=freemarker.ext.beans.OverloadedMethods@8d3a99, containsValue=public boolean java.util.LinkedHashMap.containsValue(java.lang.Object), put=public java.lang.Object java.util.HashMap.put(java.lang.Object,java.lang.Object), empty=java.beans.PropertyDescriptor[name=empty; propertyType=boolean; readMethod=public boolean java.util.HashMap.isEmpty()], compute=public java.lang.Object java.util.HashMap.compute(java.lang.Object,java.util.function.BiFunction), hashCode=public int java.util.AbstractMap.hashCode(), putAll=public void java.util.HashMap.putAll(java.util.Map), get=public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object), merge=public java.lang.Object java.util.HashMap.merge(java.lang.Object,java.lang.Object,java.util.function.BiFunction), class=java.beans.PropertyDescriptor[name=class; propertyType=class java.lang.Class; readMethod=public final native java.lang.Class java.lang.Object.getClass()], keySet=public java.util.Set java.util.LinkedHashMap.keySet(), java.lang.Object@1c0f21d=freemarker.ext.beans.OverloadedMethods@d4b988, entrySet=public java.util.Set java.util.LinkedHashMap.entrySet(), java.lang.Object@15be27d=public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object), forEach=public void java.util.LinkedHashMap.forEach(java.util.function.BiConsumer), containsKey=public boolean java.util.HashMap.containsKey(java.lang.Object), isEmpty=public boolean java.util.HashMap.isEmpty(), clear=public void java.util.LinkedHashMap.clear(), computeIfPresent=public java.lang.Object java.util.HashMap.computeIfPresent(java.lang.Object,java.util.function.BiFunction), size=public int java.util.HashMap.size(), equals=public boolean java.util.AbstractMap.equals(java.lang.Object), clone=public java.lang.Object java.util.HashMap.clone(), toString=public java.lang.String java.util.AbstractMap.toString(), putIfAbsent=public java.lang.Object java.util.HashMap.putIfAbsent(java.lang.Object,java.lang.Object)}
[DEBUG] 2017-05-24: 21:05:32 freemarker.log._Log4jLoggerFactory$Log4jLogger.debug(_Log4jLoggerFactory.java:45) :  Key "maxlength" was not found on instance of java.util.LinkedHashMap. Introspection information for the class is: {getClass=public final native java.lang.Class java.lang.Object.getClass(), getOrDefault=public java.lang.Object java.util.LinkedHashMap.getOrDefault(java.lang.Object,java.lang.Object), computeIfAbsent=public java.lang.Object java.util.HashMap.computeIfAbsent(java.lang.Object,java.util.function.Function), values=public java.util.Collection java.util.LinkedHashMap.values(), replace=freemarker.ext.beans.OverloadedMethods@11d0265, java.lang.Object@3e55b2={public boolean java.util.HashMap.isEmpty()=[Ljava.lang.Class;@c5aa3a, public int java.util.AbstractMap.hashCode()=[Ljava.lang.Class;@74a947, public java.lang.Object java.util.HashMap.put(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@1615a91, public boolean java.util.AbstractMap.equals(java.lang.Object)=[Ljava.lang.Class;@a46ab2, public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object)=[Ljava.lang.Class;@1c389e6, public java.lang.String java.util.AbstractMap.toString()=[Ljava.lang.Class;@a23548, public boolean java.util.HashMap.containsKey(java.lang.Object)=[Ljava.lang.Class;@1be4a9f, public java.util.Set java.util.LinkedHashMap.keySet()=[Ljava.lang.Class;@44c60, public java.lang.Object java.util.HashMap.computeIfAbsent(java.lang.Object,java.util.function.Function)=[Ljava.lang.Class;@10f7dff, public java.lang.Object java.util.HashMap.clone()=[Ljava.lang.Class;@d214e3, public java.lang.Object java.util.LinkedHashMap.getOrDefault(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@1a74254, public java.util.Set java.util.LinkedHashMap.entrySet()=[Ljava.lang.Class;@1c4740c, public void java.util.LinkedHashMap.forEach(java.util.function.BiConsumer)=[Ljava.lang.Class;@1fe0c8e, public java.lang.Object java.util.HashMap.putIfAbsent(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@16f73de, public java.util.Collection java.util.LinkedHashMap.values()=[Ljava.lang.Class;@b3e45, public void java.util.LinkedHashMap.clear()=[Ljava.lang.Class;@a34e5c, public java.lang.Object java.util.HashMap.computeIfPresent(java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1fcb13a, public java.lang.Object java.util.HashMap.compute(java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1a7c258, public final native java.lang.Class java.lang.Object.getClass()=[Ljava.lang.Class;@7397f, public void java.util.HashMap.putAll(java.util.Map)=[Ljava.lang.Class;@59cd, public void java.util.LinkedHashMap.replaceAll(java.util.function.BiFunction)=[Ljava.lang.Class;@994816, public java.lang.Object java.util.HashMap.merge(java.lang.Object,java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1b1e75f, public int java.util.HashMap.size()=[Ljava.lang.Class;@bee157, public boolean java.util.LinkedHashMap.containsValue(java.lang.Object)=[Ljava.lang.Class;@5e0d7c}, replaceAll=public void java.util.LinkedHashMap.replaceAll(java.util.function.BiFunction), remove=freemarker.ext.beans.OverloadedMethods@8d3a99, containsValue=public boolean java.util.LinkedHashMap.containsValue(java.lang.Object), put=public java.lang.Object java.util.HashMap.put(java.lang.Object,java.lang.Object), empty=java.beans.PropertyDescriptor[name=empty; propertyType=boolean; readMethod=public boolean java.util.HashMap.isEmpty()], compute=public java.lang.Object java.util.HashMap.compute(java.lang.Object,java.util.function.BiFunction), hashCode=public int java.util.AbstractMap.hashCode(), putAll=public void java.util.HashMap.putAll(java.util.Map), get=public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object), merge=public java.lang.Object java.util.HashMap.merge(java.lang.Object,java.lang.Object,java.util.function.BiFunction), class=java.beans.PropertyDescriptor[name=class; propertyType=class java.lang.Class; readMethod=public final native java.lang.Class java.lang.Object.getClass()], keySet=public java.util.Set java.util.LinkedHashMap.keySet(), java.lang.Object@1c0f21d=freemarker.ext.beans.OverloadedMethods@d4b988, entrySet=public java.util.Set java.util.LinkedHashMap.entrySet(), java.lang.Object@15be27d=public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object), forEach=public void java.util.LinkedHashMap.forEach(java.util.function.BiConsumer), containsKey=public boolean java.util.HashMap.containsKey(java.lang.Object), isEmpty=public boolean java.util.HashMap.isEmpty(), clear=public void java.util.LinkedHashMap.clear(), computeIfPresent=public java.lang.Object java.util.HashMap.computeIfPresent(java.lang.Object,java.util.function.BiFunction), size=public int java.util.HashMap.size(), equals=public boolean java.util.AbstractMap.equals(java.lang.Object), clone=public java.lang.Object java.util.HashMap.clone(), toString=public java.lang.String java.util.AbstractMap.toString(), putIfAbsent=public java.lang.Object java.util.HashMap.putIfAbsent(java.lang.Object,java.lang.Object)}
[DEBUG] 2017-05-24: 21:05:32 freemarker.log._Log4jLoggerFactory$Log4jLogger.debug(_Log4jLoggerFactory.java:45) :  Key "disabled" was not found on instance of java.util.LinkedHashMap. Introspection information for the class is: {getClass=public final native java.lang.Class java.lang.Object.getClass(), getOrDefault=public java.lang.Object java.util.LinkedHashMap.getOrDefault(java.lang.Object,java.lang.Object), computeIfAbsent=public java.lang.Object java.util.HashMap.computeIfAbsent(java.lang.Object,java.util.function.Function), values=public java.util.Collection java.util.LinkedHashMap.values(), replace=freemarker.ext.beans.OverloadedMethods@11d0265, java.lang.Object@3e55b2={public boolean java.util.HashMap.isEmpty()=[Ljava.lang.Class;@c5aa3a, public int java.util.AbstractMap.hashCode()=[Ljava.lang.Class;@74a947, public java.lang.Object java.util.HashMap.put(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@1615a91, public boolean java.util.AbstractMap.equals(java.lang.Object)=[Ljava.lang.Class;@a46ab2, public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object)=[Ljava.lang.Class;@1c389e6, public java.lang.String java.util.AbstractMap.toString()=[Ljava.lang.Class;@a23548, public boolean java.util.HashMap.containsKey(java.lang.Object)=[Ljava.lang.Class;@1be4a9f, public java.util.Set java.util.LinkedHashMap.keySet()=[Ljava.lang.Class;@44c60, public java.lang.Object java.util.HashMap.computeIfAbsent(java.lang.Object,java.util.function.Function)=[Ljava.lang.Class;@10f7dff, public java.lang.Object java.util.HashMap.clone()=[Ljava.lang.Class;@d214e3, public java.lang.Object java.util.LinkedHashMap.getOrDefault(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@1a74254, public java.util.Set java.util.LinkedHashMap.entrySet()=[Ljava.lang.Class;@1c4740c, public void java.util.LinkedHashMap.forEach(java.util.function.BiConsumer)=[Ljava.lang.Class;@1fe0c8e, public java.lang.Object java.util.HashMap.putIfAbsent(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@16f73de, public java.util.Collection java.util.LinkedHashMap.values()=[Ljava.lang.Class;@b3e45, public void java.util.LinkedHashMap.clear()=[Ljava.lang.Class;@a34e5c, public java.lang.Object java.util.HashMap.computeIfPresent(java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1fcb13a, public java.lang.Object java.util.HashMap.compute(java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1a7c258, public final native java.lang.Class java.lang.Object.getClass()=[Ljava.lang.Class;@7397f, public void java.util.HashMap.putAll(java.util.Map)=[Ljava.lang.Class;@59cd, public void java.util.LinkedHashMap.replaceAll(java.util.function.BiFunction)=[Ljava.lang.Class;@994816, public java.lang.Object java.util.HashMap.merge(java.lang.Object,java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1b1e75f, public int java.util.HashMap.size()=[Ljava.lang.Class;@bee157, public boolean java.util.LinkedHashMap.containsValue(java.lang.Object)=[Ljava.lang.Class;@5e0d7c}, replaceAll=public void java.util.LinkedHashMap.replaceAll(java.util.function.BiFunction), remove=freemarker.ext.beans.OverloadedMethods@8d3a99, containsValue=public boolean java.util.LinkedHashMap.containsValue(java.lang.Object), put=public java.lang.Object java.util.HashMap.put(java.lang.Object,java.lang.Object), empty=java.beans.PropertyDescriptor[name=empty; propertyType=boolean; readMethod=public boolean java.util.HashMap.isEmpty()], compute=public java.lang.Object java.util.HashMap.compute(java.lang.Object,java.util.function.BiFunction), hashCode=public int java.util.AbstractMap.hashCode(), putAll=public void java.util.HashMap.putAll(java.util.Map), get=public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object), merge=public java.lang.Object java.util.HashMap.merge(java.lang.Object,java.lang.Object,java.util.function.BiFunction), class=java.beans.PropertyDescriptor[name=class; propertyType=class java.lang.Class; readMethod=public final native java.lang.Class java.lang.Object.getClass()], keySet=public java.util.Set java.util.LinkedHashMap.keySet(), java.lang.Object@1c0f21d=freemarker.ext.beans.OverloadedMethods@d4b988, entrySet=public java.util.Set java.util.LinkedHashMap.entrySet(), java.lang.Object@15be27d=public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object), forEach=public void java.util.LinkedHashMap.forEach(java.util.function.BiConsumer), containsKey=public boolean java.util.HashMap.containsKey(java.lang.Object), isEmpty=public boolean java.util.HashMap.isEmpty(), clear=public void java.util.LinkedHashMap.clear(), computeIfPresent=public java.lang.Object java.util.HashMap.computeIfPresent(java.lang.Object,java.util.function.BiFunction), size=public int java.util.HashMap.size(), equals=public boolean java.util.AbstractMap.equals(java.lang.Object), clone=public java.lang.Object java.util.HashMap.clone(), toString=public java.lang.String java.util.AbstractMap.toString(), putIfAbsent=public java.lang.Object java.util.HashMap.putIfAbsent(java.lang.Object,java.lang.Object)}
[DEBUG] 2017-05-24: 21:05:32 freemarker.log._Log4jLoggerFactory$Log4jLogger.debug(_Log4jLoggerFactory.java:45) :  Key "readonly" was not found on instance of java.util.LinkedHashMap. Introspection information for the class is: {getClass=public final native java.lang.Class java.lang.Object.getClass(), getOrDefault=public java.lang.Object java.util.LinkedHashMap.getOrDefault(java.lang.Object,java.lang.Object), computeIfAbsent=public java.lang.Object java.util.HashMap.computeIfAbsent(java.lang.Object,java.util.function.Function), values=public java.util.Collection java.util.LinkedHashMap.values(), replace=freemarker.ext.beans.OverloadedMethods@11d0265, java.lang.Object@3e55b2={public boolean java.util.HashMap.isEmpty()=[Ljava.lang.Class;@c5aa3a, public int java.util.AbstractMap.hashCode()=[Ljava.lang.Class;@74a947, public java.lang.Object java.util.HashMap.put(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@1615a91, public boolean java.util.AbstractMap.equals(java.lang.Object)=[Ljava.lang.Class;@a46ab2, public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object)=[Ljava.lang.Class;@1c389e6, public java.lang.String java.util.AbstractMap.toString()=[Ljava.lang.Class;@a23548, public boolean java.util.HashMap.containsKey(java.lang.Object)=[Ljava.lang.Class;@1be4a9f, public java.util.Set java.util.LinkedHashMap.keySet()=[Ljava.lang.Class;@44c60, public java.lang.Object java.util.HashMap.computeIfAbsent(java.lang.Object,java.util.function.Function)=[Ljava.lang.Class;@10f7dff, public java.lang.Object java.util.HashMap.clone()=[Ljava.lang.Class;@d214e3, public java.lang.Object java.util.LinkedHashMap.getOrDefault(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@1a74254, public java.util.Set java.util.LinkedHashMap.entrySet()=[Ljava.lang.Class;@1c4740c, public void java.util.LinkedHashMap.forEach(java.util.function.BiConsumer)=[Ljava.lang.Class;@1fe0c8e, public java.lang.Object java.util.HashMap.putIfAbsent(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@16f73de, public java.util.Collection java.util.LinkedHashMap.values()=[Ljava.lang.Class;@b3e45, public void java.util.LinkedHashMap.clear()=[Ljava.lang.Class;@a34e5c, public java.lang.Object java.util.HashMap.computeIfPresent(java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1fcb13a, public java.lang.Object java.util.HashMap.compute(java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1a7c258, public final native java.lang.Class java.lang.Object.getClass()=[Ljava.lang.Class;@7397f, public void java.util.HashMap.putAll(java.util.Map)=[Ljava.lang.Class;@59cd, public void java.util.LinkedHashMap.replaceAll(java.util.function.BiFunction)=[Ljava.lang.Class;@994816, public java.lang.Object java.util.HashMap.merge(java.lang.Object,java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1b1e75f, public int java.util.HashMap.size()=[Ljava.lang.Class;@bee157, public boolean java.util.LinkedHashMap.containsValue(java.lang.Object)=[Ljava.lang.Class;@5e0d7c}, replaceAll=public void java.util.LinkedHashMap.replaceAll(java.util.function.BiFunction), remove=freemarker.ext.beans.OverloadedMethods@8d3a99, containsValue=public boolean java.util.LinkedHashMap.containsValue(java.lang.Object), put=public java.lang.Object java.util.HashMap.put(java.lang.Object,java.lang.Object), empty=java.beans.PropertyDescriptor[name=empty; propertyType=boolean; readMethod=public boolean java.util.HashMap.isEmpty()], compute=public java.lang.Object java.util.HashMap.compute(java.lang.Object,java.util.function.BiFunction), hashCode=public int java.util.AbstractMap.hashCode(), putAll=public void java.util.HashMap.putAll(java.util.Map), get=public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object), merge=public java.lang.Object java.util.HashMap.merge(java.lang.Object,java.lang.Object,java.util.function.BiFunction), class=java.beans.PropertyDescriptor[name=class; propertyType=class java.lang.Class; readMethod=public final native java.lang.Class java.lang.Object.getClass()], keySet=public java.util.Set java.util.LinkedHashMap.keySet(), java.lang.Object@1c0f21d=freemarker.ext.beans.OverloadedMethods@d4b988, entrySet=public java.util.Set java.util.LinkedHashMap.entrySet(), java.lang.Object@15be27d=public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object), forEach=public void java.util.LinkedHashMap.forEach(java.util.function.BiConsumer), containsKey=public boolean java.util.HashMap.containsKey(java.lang.Object), isEmpty=public boolean java.util.HashMap.isEmpty(), clear=public void java.util.LinkedHashMap.clear(), computeIfPresent=public java.lang.Object java.util.HashMap.computeIfPresent(java.lang.Object,java.util.function.BiFunction), size=public int java.util.HashMap.size(), equals=public boolean java.util.AbstractMap.equals(java.lang.Object), clone=public java.lang.Object java.util.HashMap.clone(), toString=public java.lang.String java.util.AbstractMap.toString(), putIfAbsent=public java.lang.Object java.util.HashMap.putIfAbsent(java.lang.Object,java.lang.Object)}
[DEBUG] 2017-05-24: 21:05:32 freemarker.log._Log4jLoggerFactory$Log4jLogger.debug(_Log4jLoggerFactory.java:45) :  Key "tabindex" was not found on instance of java.util.LinkedHashMap. Introspection information for the class is: {getClass=public final native java.lang.Class java.lang.Object.getClass(), getOrDefault=public java.lang.Object java.util.LinkedHashMap.getOrDefault(java.lang.Object,java.lang.Object), computeIfAbsent=public java.lang.Object java.util.HashMap.computeIfAbsent(java.lang.Object,java.util.function.Function), values=public java.util.Collection java.util.LinkedHashMap.values(), replace=freemarker.ext.beans.OverloadedMethods@11d0265, java.lang.Object@3e55b2={public boolean java.util.HashMap.isEmpty()=[Ljava.lang.Class;@c5aa3a, public int java.util.AbstractMap.hashCode()=[Ljava.lang.Class;@74a947, public java.lang.Object java.util.HashMap.put(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@1615a91, public boolean java.util.AbstractMap.equals(java.lang.Object)=[Ljava.lang.Class;@a46ab2, public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object)=[Ljava.lang.Class;@1c389e6, public java.lang.String java.util.AbstractMap.toString()=[Ljava.lang.Class;@a23548, public boolean java.util.HashMap.containsKey(java.lang.Object)=[Ljava.lang.Class;@1be4a9f, public java.util.Set java.util.LinkedHashMap.keySet()=[Ljava.lang.Class;@44c60, public java.lang.Object java.util.HashMap.computeIfAbsent(java.lang.Object,java.util.function.Function)=[Ljava.lang.Class;@10f7dff, public java.lang.Object java.util.HashMap.clone()=[Ljava.lang.Class;@d214e3, public java.lang.Object java.util.LinkedHashMap.getOrDefault(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@1a74254, public java.util.Set java.util.LinkedHashMap.entrySet()=[Ljava.lang.Class;@1c4740c, public void java.util.LinkedHashMap.forEach(java.util.function.BiConsumer)=[Ljava.lang.Class;@1fe0c8e, public java.lang.Object java.util.HashMap.putIfAbsent(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@16f73de, public java.util.Collection java.util.LinkedHashMap.values()=[Ljava.lang.Class;@b3e45, public void java.util.LinkedHashMap.clear()=[Ljava.lang.Class;@a34e5c, public java.lang.Object java.util.HashMap.computeIfPresent(java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1fcb13a, public java.lang.Object java.util.HashMap.compute(java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1a7c258, public final native java.lang.Class java.lang.Object.getClass()=[Ljava.lang.Class;@7397f, public void java.util.HashMap.putAll(java.util.Map)=[Ljava.lang.Class;@59cd, public void java.util.LinkedHashMap.replaceAll(java.util.function.BiFunction)=[Ljava.lang.Class;@994816, public java.lang.Object java.util.HashMap.merge(java.lang.Object,java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1b1e75f, public int java.util.HashMap.size()=[Ljava.lang.Class;@bee157, public boolean java.util.LinkedHashMap.containsValue(java.lang.Object)=[Ljava.lang.Class;@5e0d7c}, replaceAll=public void java.util.LinkedHashMap.replaceAll(java.util.function.BiFunction), remove=freemarker.ext.beans.OverloadedMethods@8d3a99, containsValue=public boolean java.util.LinkedHashMap.containsValue(java.lang.Object), put=public java.lang.Object java.util.HashMap.put(java.lang.Object,java.lang.Object), empty=java.beans.PropertyDescriptor[name=empty; propertyType=boolean; readMethod=public boolean java.util.HashMap.isEmpty()], compute=public java.lang.Object java.util.HashMap.compute(java.lang.Object,java.util.function.BiFunction), hashCode=public int java.util.AbstractMap.hashCode(), putAll=public void java.util.HashMap.putAll(java.util.Map), get=public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object), merge=public java.lang.Object java.util.HashMap.merge(java.lang.Object,java.lang.Object,java.util.function.BiFunction), class=java.beans.PropertyDescriptor[name=class; propertyType=class java.lang.Class; readMethod=public final native java.lang.Class java.lang.Object.getClass()], keySet=public java.util.Set java.util.LinkedHashMap.keySet(), java.lang.Object@1c0f21d=freemarker.ext.beans.OverloadedMethods@d4b988, entrySet=public java.util.Set java.util.LinkedHashMap.entrySet(), java.lang.Object@15be27d=public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object), forEach=public void java.util.LinkedHashMap.forEach(java.util.function.BiConsumer), containsKey=public boolean java.util.HashMap.containsKey(java.lang.Object), isEmpty=public boolean java.util.HashMap.isEmpty(), clear=public void java.util.LinkedHashMap.clear(), computeIfPresent=public java.lang.Object java.util.HashMap.computeIfPresent(java.lang.Object,java.util.function.BiFunction), size=public int java.util.HashMap.size(), equals=public boolean java.util.AbstractMap.equals(java.lang.Object), clone=public java.lang.Object java.util.HashMap.clone(), toString=public java.lang.String java.util.AbstractMap.toString(), putIfAbsent=public java.lang.Object java.util.HashMap.putIfAbsent(java.lang.Object,java.lang.Object)}
[DEBUG] 2017-05-24: 21:05:32 freemarker.log._Log4jLoggerFactory$Log4jLogger.debug(_Log4jLoggerFactory.java:45) :  TemplateLoader.findTemplateSource("template/~~~xhtml/css.ftl"): Found
[DEBUG] 2017-05-24: 21:05:32 freemarker.log._Log4jLoggerFactory$Log4jLogger.debug(_Log4jLoggerFactory.java:45) :  "template/~~~xhtml/css.ftl"("zh_CN", UTF-8, parsed): using cached since jar:file:/D:/maven/repository/org/apache/struts/struts2-core/2.5.10/struts2-core-2.5.10.jar!/template/simple/css.ftl hasn't changed.
[DEBUG] 2017-05-24: 21:05:32 freemarker.log._Log4jLoggerFactory$Log4jLogger.debug(_Log4jLoggerFactory.java:45) :  Key "cssClass" was not found on instance of java.util.LinkedHashMap. Introspection information for the class is: {getClass=public final native java.lang.Class java.lang.Object.getClass(), getOrDefault=public java.lang.Object java.util.LinkedHashMap.getOrDefault(java.lang.Object,java.lang.Object), computeIfAbsent=public java.lang.Object java.util.HashMap.computeIfAbsent(java.lang.Object,java.util.function.Function), values=public java.util.Collection java.util.LinkedHashMap.values(), replace=freemarker.ext.beans.OverloadedMethods@11d0265, java.lang.Object@3e55b2={public boolean java.util.HashMap.isEmpty()=[Ljava.lang.Class;@c5aa3a, public int java.util.AbstractMap.hashCode()=[Ljava.lang.Class;@74a947, public java.lang.Object java.util.HashMap.put(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@1615a91, public boolean java.util.AbstractMap.equals(java.lang.Object)=[Ljava.lang.Class;@a46ab2, public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object)=[Ljava.lang.Class;@1c389e6, public java.lang.String java.util.AbstractMap.toString()=[Ljava.lang.Class;@a23548, public boolean java.util.HashMap.containsKey(java.lang.Object)=[Ljava.lang.Class;@1be4a9f, public java.util.Set java.util.LinkedHashMap.keySet()=[Ljava.lang.Class;@44c60, public java.lang.Object java.util.HashMap.computeIfAbsent(java.lang.Object,java.util.function.Function)=[Ljava.lang.Class;@10f7dff, public java.lang.Object java.util.HashMap.clone()=[Ljava.lang.Class;@d214e3, public java.lang.Object java.util.LinkedHashMap.getOrDefault(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@1a74254, public java.util.Set java.util.LinkedHashMap.entrySet()=[Ljava.lang.Class;@1c4740c, public void java.util.LinkedHashMap.forEach(java.util.function.BiConsumer)=[Ljava.lang.Class;@1fe0c8e, public java.lang.Object java.util.HashMap.putIfAbsent(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@16f73de, public java.util.Collection java.util.LinkedHashMap.values()=[Ljava.lang.Class;@b3e45, public void java.util.LinkedHashMap.clear()=[Ljava.lang.Class;@a34e5c, public java.lang.Object java.util.HashMap.computeIfPresent(java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1fcb13a, public java.lang.Object java.util.HashMap.compute(java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1a7c258, public final native java.lang.Class java.lang.Object.getClass()=[Ljava.lang.Class;@7397f, public void java.util.HashMap.putAll(java.util.Map)=[Ljava.lang.Class;@59cd, public void java.util.LinkedHashMap.replaceAll(java.util.function.BiFunction)=[Ljava.lang.Class;@994816, public java.lang.Object java.util.HashMap.merge(java.lang.Object,java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1b1e75f, public int java.util.HashMap.size()=[Ljava.lang.Class;@bee157, public boolean java.util.LinkedHashMap.containsValue(java.lang.Object)=[Ljava.lang.Class;@5e0d7c}, replaceAll=public void java.util.LinkedHashMap.replaceAll(java.util.function.BiFunction), remove=freemarker.ext.beans.OverloadedMethods@8d3a99, containsValue=public boolean java.util.LinkedHashMap.containsValue(java.lang.Object), put=public java.lang.Object java.util.HashMap.put(java.lang.Object,java.lang.Object), empty=java.beans.PropertyDescriptor[name=empty; propertyType=boolean; readMethod=public boolean java.util.HashMap.isEmpty()], compute=public java.lang.Object java.util.HashMap.compute(java.lang.Object,java.util.function.BiFunction), hashCode=public int java.util.AbstractMap.hashCode(), putAll=public void java.util.HashMap.putAll(java.util.Map), get=public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object), merge=public java.lang.Object java.util.HashMap.merge(java.lang.Object,java.lang.Object,java.util.function.BiFunction), class=java.beans.PropertyDescriptor[name=class; propertyType=class java.lang.Class; readMethod=public final native java.lang.Class java.lang.Object.getClass()], keySet=public java.util.Set java.util.LinkedHashMap.keySet(), java.lang.Object@1c0f21d=freemarker.ext.beans.OverloadedMethods@d4b988, entrySet=public java.util.Set java.util.LinkedHashMap.entrySet(), java.lang.Object@15be27d=public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object), forEach=public void java.util.LinkedHashMap.forEach(java.util.function.BiConsumer), containsKey=public boolean java.util.HashMap.containsKey(java.lang.Object), isEmpty=public boolean java.util.HashMap.isEmpty(), clear=public void java.util.LinkedHashMap.clear(), computeIfPresent=public java.lang.Object java.util.HashMap.computeIfPresent(java.lang.Object,java.util.function.BiFunction), size=public int java.util.HashMap.size(), equals=public boolean java.util.AbstractMap.equals(java.lang.Object), clone=public java.lang.Object java.util.HashMap.clone(), toString=public java.lang.String java.util.AbstractMap.toString(), putIfAbsent=public java.lang.Object java.util.HashMap.putIfAbsent(java.lang.Object,java.lang.Object)}
[DEBUG] 2017-05-24: 21:05:32 freemarker.log._Log4jLoggerFactory$Log4jLogger.debug(_Log4jLoggerFactory.java:45) :  Key "cssClass" was not found on instance of java.util.LinkedHashMap. Introspection information for the class is: {getClass=public final native java.lang.Class java.lang.Object.getClass(), getOrDefault=public java.lang.Object java.util.LinkedHashMap.getOrDefault(java.lang.Object,java.lang.Object), computeIfAbsent=public java.lang.Object java.util.HashMap.computeIfAbsent(java.lang.Object,java.util.function.Function), values=public java.util.Collection java.util.LinkedHashMap.values(), replace=freemarker.ext.beans.OverloadedMethods@11d0265, java.lang.Object@3e55b2={public boolean java.util.HashMap.isEmpty()=[Ljava.lang.Class;@c5aa3a, public int java.util.AbstractMap.hashCode()=[Ljava.lang.Class;@74a947, public java.lang.Object java.util.HashMap.put(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@1615a91, public boolean java.util.AbstractMap.equals(java.lang.Object)=[Ljava.lang.Class;@a46ab2, public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object)=[Ljava.lang.Class;@1c389e6, public java.lang.String java.util.AbstractMap.toString()=[Ljava.lang.Class;@a23548, public boolean java.util.HashMap.containsKey(java.lang.Object)=[Ljava.lang.Class;@1be4a9f, public java.util.Set java.util.LinkedHashMap.keySet()=[Ljava.lang.Class;@44c60, public java.lang.Object java.util.HashMap.computeIfAbsent(java.lang.Object,java.util.function.Function)=[Ljava.lang.Class;@10f7dff, public java.lang.Object java.util.HashMap.clone()=[Ljava.lang.Class;@d214e3, public java.lang.Object java.util.LinkedHashMap.getOrDefault(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@1a74254, public java.util.Set java.util.LinkedHashMap.entrySet()=[Ljava.lang.Class;@1c4740c, public void java.util.LinkedHashMap.forEach(java.util.function.BiConsumer)=[Ljava.lang.Class;@1fe0c8e, public java.lang.Object java.util.HashMap.putIfAbsent(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@16f73de, public java.util.Collection java.util.LinkedHashMap.values()=[Ljava.lang.Class;@b3e45, public void java.util.LinkedHashMap.clear()=[Ljava.lang.Class;@a34e5c, public java.lang.Object java.util.HashMap.computeIfPresent(java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1fcb13a, public java.lang.Object java.util.HashMap.compute(java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1a7c258, public final native java.lang.Class java.lang.Object.getClass()=[Ljava.lang.Class;@7397f, public void java.util.HashMap.putAll(java.util.Map)=[Ljava.lang.Class;@59cd, public void java.util.LinkedHashMap.replaceAll(java.util.function.BiFunction)=[Ljava.lang.Class;@994816, public java.lang.Object java.util.HashMap.merge(java.lang.Object,java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1b1e75f, public int java.util.HashMap.size()=[Ljava.lang.Class;@bee157, public boolean java.util.LinkedHashMap.containsValue(java.lang.Object)=[Ljava.lang.Class;@5e0d7c}, replaceAll=public void java.util.LinkedHashMap.replaceAll(java.util.function.BiFunction), remove=freemarker.ext.beans.OverloadedMethods@8d3a99, containsValue=public boolean java.util.LinkedHashMap.containsValue(java.lang.Object), put=public java.lang.Object java.util.HashMap.put(java.lang.Object,java.lang.Object), empty=java.beans.PropertyDescriptor[name=empty; propertyType=boolean; readMethod=public boolean java.util.HashMap.isEmpty()], compute=public java.lang.Object java.util.HashMap.compute(java.lang.Object,java.util.function.BiFunction), hashCode=public int java.util.AbstractMap.hashCode(), putAll=public void java.util.HashMap.putAll(java.util.Map), get=public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object), merge=public java.lang.Object java.util.HashMap.merge(java.lang.Object,java.lang.Object,java.util.function.BiFunction), class=java.beans.PropertyDescriptor[name=class; propertyType=class java.lang.Class; readMethod=public final native java.lang.Class java.lang.Object.getClass()], keySet=public java.util.Set java.util.LinkedHashMap.keySet(), java.lang.Object@1c0f21d=freemarker.ext.beans.OverloadedMethods@d4b988, entrySet=public java.util.Set java.util.LinkedHashMap.entrySet(), java.lang.Object@15be27d=public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object), forEach=public void java.util.LinkedHashMap.forEach(java.util.function.BiConsumer), containsKey=public boolean java.util.HashMap.containsKey(java.lang.Object), isEmpty=public boolean java.util.HashMap.isEmpty(), clear=public void java.util.LinkedHashMap.clear(), computeIfPresent=public java.lang.Object java.util.HashMap.computeIfPresent(java.lang.Object,java.util.function.BiFunction), size=public int java.util.HashMap.size(), equals=public boolean java.util.AbstractMap.equals(java.lang.Object), clone=public java.lang.Object java.util.HashMap.clone(), toString=public java.lang.String java.util.AbstractMap.toString(), putIfAbsent=public java.lang.Object java.util.HashMap.putIfAbsent(java.lang.Object,java.lang.Object)}
[DEBUG] 2017-05-24: 21:05:32 freemarker.log._Log4jLoggerFactory$Log4jLogger.debug(_Log4jLoggerFactory.java:45) :  Key "cssClass" was not found on instance of java.util.LinkedHashMap. Introspection information for the class is: {getClass=public final native java.lang.Class java.lang.Object.getClass(), getOrDefault=public java.lang.Object java.util.LinkedHashMap.getOrDefault(java.lang.Object,java.lang.Object), computeIfAbsent=public java.lang.Object java.util.HashMap.computeIfAbsent(java.lang.Object,java.util.function.Function), values=public java.util.Collection java.util.LinkedHashMap.values(), replace=freemarker.ext.beans.OverloadedMethods@11d0265, java.lang.Object@3e55b2={public boolean java.util.HashMap.isEmpty()=[Ljava.lang.Class;@c5aa3a, public int java.util.AbstractMap.hashCode()=[Ljava.lang.Class;@74a947, public java.lang.Object java.util.HashMap.put(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@1615a91, public boolean java.util.AbstractMap.equals(java.lang.Object)=[Ljava.lang.Class;@a46ab2, public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object)=[Ljava.lang.Class;@1c389e6, public java.lang.String java.util.AbstractMap.toString()=[Ljava.lang.Class;@a23548, public boolean java.util.HashMap.containsKey(java.lang.Object)=[Ljava.lang.Class;@1be4a9f, public java.util.Set java.util.LinkedHashMap.keySet()=[Ljava.lang.Class;@44c60, public java.lang.Object java.util.HashMap.computeIfAbsent(java.lang.Object,java.util.function.Function)=[Ljava.lang.Class;@10f7dff, public java.lang.Object java.util.HashMap.clone()=[Ljava.lang.Class;@d214e3, public java.lang.Object java.util.LinkedHashMap.getOrDefault(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@1a74254, public java.util.Set java.util.LinkedHashMap.entrySet()=[Ljava.lang.Class;@1c4740c, public void java.util.LinkedHashMap.forEach(java.util.function.BiConsumer)=[Ljava.lang.Class;@1fe0c8e, public java.lang.Object java.util.HashMap.putIfAbsent(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@16f73de, public java.util.Collection java.util.LinkedHashMap.values()=[Ljava.lang.Class;@b3e45, public void java.util.LinkedHashMap.clear()=[Ljava.lang.Class;@a34e5c, public java.lang.Object java.util.HashMap.computeIfPresent(java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1fcb13a, public java.lang.Object java.util.HashMap.compute(java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1a7c258, public final native java.lang.Class java.lang.Object.getClass()=[Ljava.lang.Class;@7397f, public void java.util.HashMap.putAll(java.util.Map)=[Ljava.lang.Class;@59cd, public void java.util.LinkedHashMap.replaceAll(java.util.function.BiFunction)=[Ljava.lang.Class;@994816, public java.lang.Object java.util.HashMap.merge(java.lang.Object,java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1b1e75f, public int java.util.HashMap.size()=[Ljava.lang.Class;@bee157, public boolean java.util.LinkedHashMap.containsValue(java.lang.Object)=[Ljava.lang.Class;@5e0d7c}, replaceAll=public void java.util.LinkedHashMap.replaceAll(java.util.function.BiFunction), remove=freemarker.ext.beans.OverloadedMethods@8d3a99, containsValue=public boolean java.util.LinkedHashMap.containsValue(java.lang.Object), put=public java.lang.Object java.util.HashMap.put(java.lang.Object,java.lang.Object), empty=java.beans.PropertyDescriptor[name=empty; propertyType=boolean; readMethod=public boolean java.util.HashMap.isEmpty()], compute=public java.lang.Object java.util.HashMap.compute(java.lang.Object,java.util.function.BiFunction), hashCode=public int java.util.AbstractMap.hashCode(), putAll=public void java.util.HashMap.putAll(java.util.Map), get=public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object), merge=public java.lang.Object java.util.HashMap.merge(java.lang.Object,java.lang.Object,java.util.function.BiFunction), class=java.beans.PropertyDescriptor[name=class; propertyType=class java.lang.Class; readMethod=public final native java.lang.Class java.lang.Object.getClass()], keySet=public java.util.Set java.util.LinkedHashMap.keySet(), java.lang.Object@1c0f21d=freemarker.ext.beans.OverloadedMethods@d4b988, entrySet=public java.util.Set java.util.LinkedHashMap.entrySet(), java.lang.Object@15be27d=public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object), forEach=public void java.util.LinkedHashMap.forEach(java.util.function.BiConsumer), containsKey=public boolean java.util.HashMap.containsKey(java.lang.Object), isEmpty=public boolean java.util.HashMap.isEmpty(), clear=public void java.util.LinkedHashMap.clear(), computeIfPresent=public java.lang.Object java.util.HashMap.computeIfPresent(java.lang.Object,java.util.function.BiFunction), size=public int java.util.HashMap.size(), equals=public boolean java.util.AbstractMap.equals(java.lang.Object), clone=public java.lang.Object java.util.HashMap.clone(), toString=public java.lang.String java.util.AbstractMap.toString(), putIfAbsent=public java.lang.Object java.util.HashMap.putIfAbsent(java.lang.Object,java.lang.Object)}
[DEBUG] 2017-05-24: 21:05:32 freemarker.log._Log4jLoggerFactory$Log4jLogger.debug(_Log4jLoggerFactory.java:45) :  Key "cssStyle" was not found on instance of java.util.LinkedHashMap. Introspection information for the class is: {getClass=public final native java.lang.Class java.lang.Object.getClass(), getOrDefault=public java.lang.Object java.util.LinkedHashMap.getOrDefault(java.lang.Object,java.lang.Object), computeIfAbsent=public java.lang.Object java.util.HashMap.computeIfAbsent(java.lang.Object,java.util.function.Function), values=public java.util.Collection java.util.LinkedHashMap.values(), replace=freemarker.ext.beans.OverloadedMethods@11d0265, java.lang.Object@3e55b2={public boolean java.util.HashMap.isEmpty()=[Ljava.lang.Class;@c5aa3a, public int java.util.AbstractMap.hashCode()=[Ljava.lang.Class;@74a947, public java.lang.Object java.util.HashMap.put(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@1615a91, public boolean java.util.AbstractMap.equals(java.lang.Object)=[Ljava.lang.Class;@a46ab2, public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object)=[Ljava.lang.Class;@1c389e6, public java.lang.String java.util.AbstractMap.toString()=[Ljava.lang.Class;@a23548, public boolean java.util.HashMap.containsKey(java.lang.Object)=[Ljava.lang.Class;@1be4a9f, public java.util.Set java.util.LinkedHashMap.keySet()=[Ljava.lang.Class;@44c60, public java.lang.Object java.util.HashMap.computeIfAbsent(java.lang.Object,java.util.function.Function)=[Ljava.lang.Class;@10f7dff, public java.lang.Object java.util.HashMap.clone()=[Ljava.lang.Class;@d214e3, public java.lang.Object java.util.LinkedHashMap.getOrDefault(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@1a74254, public java.util.Set java.util.LinkedHashMap.entrySet()=[Ljava.lang.Class;@1c4740c, public void java.util.LinkedHashMap.forEach(java.util.function.BiConsumer)=[Ljava.lang.Class;@1fe0c8e, public java.lang.Object java.util.HashMap.putIfAbsent(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@16f73de, public java.util.Collection java.util.LinkedHashMap.values()=[Ljava.lang.Class;@b3e45, public void java.util.LinkedHashMap.clear()=[Ljava.lang.Class;@a34e5c, public java.lang.Object java.util.HashMap.computeIfPresent(java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1fcb13a, public java.lang.Object java.util.HashMap.compute(java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1a7c258, public final native java.lang.Class java.lang.Object.getClass()=[Ljava.lang.Class;@7397f, public void java.util.HashMap.putAll(java.util.Map)=[Ljava.lang.Class;@59cd, public void java.util.LinkedHashMap.replaceAll(java.util.function.BiFunction)=[Ljava.lang.Class;@994816, public java.lang.Object java.util.HashMap.merge(java.lang.Object,java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1b1e75f, public int java.util.HashMap.size()=[Ljava.lang.Class;@bee157, public boolean java.util.LinkedHashMap.containsValue(java.lang.Object)=[Ljava.lang.Class;@5e0d7c}, replaceAll=public void java.util.LinkedHashMap.replaceAll(java.util.function.BiFunction), remove=freemarker.ext.beans.OverloadedMethods@8d3a99, containsValue=public boolean java.util.LinkedHashMap.containsValue(java.lang.Object), put=public java.lang.Object java.util.HashMap.put(java.lang.Object,java.lang.Object), empty=java.beans.PropertyDescriptor[name=empty; propertyType=boolean; readMethod=public boolean java.util.HashMap.isEmpty()], compute=public java.lang.Object java.util.HashMap.compute(java.lang.Object,java.util.function.BiFunction), hashCode=public int java.util.AbstractMap.hashCode(), putAll=public void java.util.HashMap.putAll(java.util.Map), get=public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object), merge=public java.lang.Object java.util.HashMap.merge(java.lang.Object,java.lang.Object,java.util.function.BiFunction), class=java.beans.PropertyDescriptor[name=class; propertyType=class java.lang.Class; readMethod=public final native java.lang.Class java.lang.Object.getClass()], keySet=public java.util.Set java.util.LinkedHashMap.keySet(), java.lang.Object@1c0f21d=freemarker.ext.beans.OverloadedMethods@d4b988, entrySet=public java.util.Set java.util.LinkedHashMap.entrySet(), java.lang.Object@15be27d=public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object), forEach=public void java.util.LinkedHashMap.forEach(java.util.function.BiConsumer), containsKey=public boolean java.util.HashMap.containsKey(java.lang.Object), isEmpty=public boolean java.util.HashMap.isEmpty(), clear=public void java.util.LinkedHashMap.clear(), computeIfPresent=public java.lang.Object java.util.HashMap.computeIfPresent(java.lang.Object,java.util.function.BiFunction), size=public int java.util.HashMap.size(), equals=public boolean java.util.AbstractMap.equals(java.lang.Object), clone=public java.lang.Object java.util.HashMap.clone(), toString=public java.lang.String java.util.AbstractMap.toString(), putIfAbsent=public java.lang.Object java.util.HashMap.putIfAbsent(java.lang.Object,java.lang.Object)}
[DEBUG] 2017-05-24: 21:05:32 freemarker.log._Log4jLoggerFactory$Log4jLogger.debug(_Log4jLoggerFactory.java:45) :  Key "title" was not found on instance of java.util.LinkedHashMap. Introspection information for the class is: {getClass=public final native java.lang.Class java.lang.Object.getClass(), getOrDefault=public java.lang.Object java.util.LinkedHashMap.getOrDefault(java.lang.Object,java.lang.Object), computeIfAbsent=public java.lang.Object java.util.HashMap.computeIfAbsent(java.lang.Object,java.util.function.Function), values=public java.util.Collection java.util.LinkedHashMap.values(), replace=freemarker.ext.beans.OverloadedMethods@11d0265, java.lang.Object@3e55b2={public boolean java.util.HashMap.isEmpty()=[Ljava.lang.Class;@c5aa3a, public int java.util.AbstractMap.hashCode()=[Ljava.lang.Class;@74a947, public java.lang.Object java.util.HashMap.put(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@1615a91, public boolean java.util.AbstractMap.equals(java.lang.Object)=[Ljava.lang.Class;@a46ab2, public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object)=[Ljava.lang.Class;@1c389e6, public java.lang.String java.util.AbstractMap.toString()=[Ljava.lang.Class;@a23548, public boolean java.util.HashMap.containsKey(java.lang.Object)=[Ljava.lang.Class;@1be4a9f, public java.util.Set java.util.LinkedHashMap.keySet()=[Ljava.lang.Class;@44c60, public java.lang.Object java.util.HashMap.computeIfAbsent(java.lang.Object,java.util.function.Function)=[Ljava.lang.Class;@10f7dff, public java.lang.Object java.util.HashMap.clone()=[Ljava.lang.Class;@d214e3, public java.lang.Object java.util.LinkedHashMap.getOrDefault(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@1a74254, public java.util.Set java.util.LinkedHashMap.entrySet()=[Ljava.lang.Class;@1c4740c, public void java.util.LinkedHashMap.forEach(java.util.function.BiConsumer)=[Ljava.lang.Class;@1fe0c8e, public java.lang.Object java.util.HashMap.putIfAbsent(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@16f73de, public java.util.Collection java.util.LinkedHashMap.values()=[Ljava.lang.Class;@b3e45, public void java.util.LinkedHashMap.clear()=[Ljava.lang.Class;@a34e5c, public java.lang.Object java.util.HashMap.computeIfPresent(java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1fcb13a, public java.lang.Object java.util.HashMap.compute(java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1a7c258, public final native java.lang.Class java.lang.Object.getClass()=[Ljava.lang.Class;@7397f, public void java.util.HashMap.putAll(java.util.Map)=[Ljava.lang.Class;@59cd, public void java.util.LinkedHashMap.replaceAll(java.util.function.BiFunction)=[Ljava.lang.Class;@994816, public java.lang.Object java.util.HashMap.merge(java.lang.Object,java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1b1e75f, public int java.util.HashMap.size()=[Ljava.lang.Class;@bee157, public boolean java.util.LinkedHashMap.containsValue(java.lang.Object)=[Ljava.lang.Class;@5e0d7c}, replaceAll=public void java.util.LinkedHashMap.replaceAll(java.util.function.BiFunction), remove=freemarker.ext.beans.OverloadedMethods@8d3a99, containsValue=public boolean java.util.LinkedHashMap.containsValue(java.lang.Object), put=public java.lang.Object java.util.HashMap.put(java.lang.Object,java.lang.Object), empty=java.beans.PropertyDescriptor[name=empty; propertyType=boolean; readMethod=public boolean java.util.HashMap.isEmpty()], compute=public java.lang.Object java.util.HashMap.compute(java.lang.Object,java.util.function.BiFunction), hashCode=public int java.util.AbstractMap.hashCode(), putAll=public void java.util.HashMap.putAll(java.util.Map), get=public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object), merge=public java.lang.Object java.util.HashMap.merge(java.lang.Object,java.lang.Object,java.util.function.BiFunction), class=java.beans.PropertyDescriptor[name=class; propertyType=class java.lang.Class; readMethod=public final native java.lang.Class java.lang.Object.getClass()], keySet=public java.util.Set java.util.LinkedHashMap.keySet(), java.lang.Object@1c0f21d=freemarker.ext.beans.OverloadedMethods@d4b988, entrySet=public java.util.Set java.util.LinkedHashMap.entrySet(), java.lang.Object@15be27d=public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object), forEach=public void java.util.LinkedHashMap.forEach(java.util.function.BiConsumer), containsKey=public boolean java.util.HashMap.containsKey(java.lang.Object), isEmpty=public boolean java.util.HashMap.isEmpty(), clear=public void java.util.LinkedHashMap.clear(), computeIfPresent=public java.lang.Object java.util.HashMap.computeIfPresent(java.lang.Object,java.util.function.BiFunction), size=public int java.util.HashMap.size(), equals=public boolean java.util.AbstractMap.equals(java.lang.Object), clone=public java.lang.Object java.util.HashMap.clone(), toString=public java.lang.String java.util.AbstractMap.toString(), putIfAbsent=public java.lang.Object java.util.HashMap.putIfAbsent(java.lang.Object,java.lang.Object)}
[DEBUG] 2017-05-24: 21:05:32 freemarker.log._Log4jLoggerFactory$Log4jLogger.debug(_Log4jLoggerFactory.java:45) :  TemplateLoader.findTemplateSource("template/~~~xhtml/scripting-events.ftl"): Found
[DEBUG] 2017-05-24: 21:05:32 freemarker.log._Log4jLoggerFactory$Log4jLogger.debug(_Log4jLoggerFactory.java:45) :  "template/~~~xhtml/scripting-events.ftl"("zh_CN", UTF-8, parsed): using cached since jar:file:/D:/maven/repository/org/apache/struts/struts2-core/2.5.10/struts2-core-2.5.10.jar!/template/simple/scripting-events.ftl hasn't changed.
[DEBUG] 2017-05-24: 21:05:32 freemarker.log._Log4jLoggerFactory$Log4jLogger.debug(_Log4jLoggerFactory.java:45) :  Key "onclick" was not found on instance of java.util.LinkedHashMap. Introspection information for the class is: {getClass=public final native java.lang.Class java.lang.Object.getClass(), getOrDefault=public java.lang.Object java.util.LinkedHashMap.getOrDefault(java.lang.Object,java.lang.Object), computeIfAbsent=public java.lang.Object java.util.HashMap.computeIfAbsent(java.lang.Object,java.util.function.Function), values=public java.util.Collection java.util.LinkedHashMap.values(), replace=freemarker.ext.beans.OverloadedMethods@11d0265, java.lang.Object@3e55b2={public boolean java.util.HashMap.isEmpty()=[Ljava.lang.Class;@c5aa3a, public int java.util.AbstractMap.hashCode()=[Ljava.lang.Class;@74a947, public java.lang.Object java.util.HashMap.put(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@1615a91, public boolean java.util.AbstractMap.equals(java.lang.Object)=[Ljava.lang.Class;@a46ab2, public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object)=[Ljava.lang.Class;@1c389e6, public java.lang.String java.util.AbstractMap.toString()=[Ljava.lang.Class;@a23548, public boolean java.util.HashMap.containsKey(java.lang.Object)=[Ljava.lang.Class;@1be4a9f, public java.util.Set java.util.LinkedHashMap.keySet()=[Ljava.lang.Class;@44c60, public java.lang.Object java.util.HashMap.computeIfAbsent(java.lang.Object,java.util.function.Function)=[Ljava.lang.Class;@10f7dff, public java.lang.Object java.util.HashMap.clone()=[Ljava.lang.Class;@d214e3, public java.lang.Object java.util.LinkedHashMap.getOrDefault(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@1a74254, public java.util.Set java.util.LinkedHashMap.entrySet()=[Ljava.lang.Class;@1c4740c, public void java.util.LinkedHashMap.forEach(java.util.function.BiConsumer)=[Ljava.lang.Class;@1fe0c8e, public java.lang.Object java.util.HashMap.putIfAbsent(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@16f73de, public java.util.Collection java.util.LinkedHashMap.values()=[Ljava.lang.Class;@b3e45, public void java.util.LinkedHashMap.clear()=[Ljava.lang.Class;@a34e5c, public java.lang.Object java.util.HashMap.computeIfPresent(java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1fcb13a, public java.lang.Object java.util.HashMap.compute(java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1a7c258, public final native java.lang.Class java.lang.Object.getClass()=[Ljava.lang.Class;@7397f, public void java.util.HashMap.putAll(java.util.Map)=[Ljava.lang.Class;@59cd, public void java.util.LinkedHashMap.replaceAll(java.util.function.BiFunction)=[Ljava.lang.Class;@994816, public java.lang.Object java.util.HashMap.merge(java.lang.Object,java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1b1e75f, public int java.util.HashMap.size()=[Ljava.lang.Class;@bee157, public boolean java.util.LinkedHashMap.containsValue(java.lang.Object)=[Ljava.lang.Class;@5e0d7c}, replaceAll=public void java.util.LinkedHashMap.replaceAll(java.util.function.BiFunction), remove=freemarker.ext.beans.OverloadedMethods@8d3a99, containsValue=public boolean java.util.LinkedHashMap.containsValue(java.lang.Object), put=public java.lang.Object java.util.HashMap.put(java.lang.Object,java.lang.Object), empty=java.beans.PropertyDescriptor[name=empty; propertyType=boolean; readMethod=public boolean java.util.HashMap.isEmpty()], compute=public java.lang.Object java.util.HashMap.compute(java.lang.Object,java.util.function.BiFunction), hashCode=public int java.util.AbstractMap.hashCode(), putAll=public void java.util.HashMap.putAll(java.util.Map), get=public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object), merge=public java.lang.Object java.util.HashMap.merge(java.lang.Object,java.lang.Object,java.util.function.BiFunction), class=java.beans.PropertyDescriptor[name=class; propertyType=class java.lang.Class; readMethod=public final native java.lang.Class java.lang.Object.getClass()], keySet=public java.util.Set java.util.LinkedHashMap.keySet(), java.lang.Object@1c0f21d=freemarker.ext.beans.OverloadedMethods@d4b988, entrySet=public java.util.Set java.util.LinkedHashMap.entrySet(), java.lang.Object@15be27d=public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object), forEach=public void java.util.LinkedHashMap.forEach(java.util.function.BiConsumer), containsKey=public boolean java.util.HashMap.containsKey(java.lang.Object), isEmpty=public boolean java.util.HashMap.isEmpty(), clear=public void java.util.LinkedHashMap.clear(), computeIfPresent=public java.lang.Object java.util.HashMap.computeIfPresent(java.lang.Object,java.util.function.BiFunction), size=public int java.util.HashMap.size(), equals=public boolean java.util.AbstractMap.equals(java.lang.Object), clone=public java.lang.Object java.util.HashMap.clone(), toString=public java.lang.String java.util.AbstractMap.toString(), putIfAbsent=public java.lang.Object java.util.HashMap.putIfAbsent(java.lang.Object,java.lang.Object)}
[DEBUG] 2017-05-24: 21:05:32 freemarker.log._Log4jLoggerFactory$Log4jLogger.debug(_Log4jLoggerFactory.java:45) :  Key "ondblclick" was not found on instance of java.util.LinkedHashMap. Introspection information for the class is: {getClass=public final native java.lang.Class java.lang.Object.getClass(), getOrDefault=public java.lang.Object java.util.LinkedHashMap.getOrDefault(java.lang.Object,java.lang.Object), computeIfAbsent=public java.lang.Object java.util.HashMap.computeIfAbsent(java.lang.Object,java.util.function.Function), values=public java.util.Collection java.util.LinkedHashMap.values(), replace=freemarker.ext.beans.OverloadedMethods@11d0265, java.lang.Object@3e55b2={public boolean java.util.HashMap.isEmpty()=[Ljava.lang.Class;@c5aa3a, public int java.util.AbstractMap.hashCode()=[Ljava.lang.Class;@74a947, public java.lang.Object java.util.HashMap.put(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@1615a91, public boolean java.util.AbstractMap.equals(java.lang.Object)=[Ljava.lang.Class;@a46ab2, public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object)=[Ljava.lang.Class;@1c389e6, public java.lang.String java.util.AbstractMap.toString()=[Ljava.lang.Class;@a23548, public boolean java.util.HashMap.containsKey(java.lang.Object)=[Ljava.lang.Class;@1be4a9f, public java.util.Set java.util.LinkedHashMap.keySet()=[Ljava.lang.Class;@44c60, public java.lang.Object java.util.HashMap.computeIfAbsent(java.lang.Object,java.util.function.Function)=[Ljava.lang.Class;@10f7dff, public java.lang.Object java.util.HashMap.clone()=[Ljava.lang.Class;@d214e3, public java.lang.Object java.util.LinkedHashMap.getOrDefault(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@1a74254, public java.util.Set java.util.LinkedHashMap.entrySet()=[Ljava.lang.Class;@1c4740c, public void java.util.LinkedHashMap.forEach(java.util.function.BiConsumer)=[Ljava.lang.Class;@1fe0c8e, public java.lang.Object java.util.HashMap.putIfAbsent(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@16f73de, public java.util.Collection java.util.LinkedHashMap.values()=[Ljava.lang.Class;@b3e45, public void java.util.LinkedHashMap.clear()=[Ljava.lang.Class;@a34e5c, public java.lang.Object java.util.HashMap.computeIfPresent(java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1fcb13a, public java.lang.Object java.util.HashMap.compute(java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1a7c258, public final native java.lang.Class java.lang.Object.getClass()=[Ljava.lang.Class;@7397f, public void java.util.HashMap.putAll(java.util.Map)=[Ljava.lang.Class;@59cd, public void java.util.LinkedHashMap.replaceAll(java.util.function.BiFunction)=[Ljava.lang.Class;@994816, public java.lang.Object java.util.HashMap.merge(java.lang.Object,java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1b1e75f, public int java.util.HashMap.size()=[Ljava.lang.Class;@bee157, public boolean java.util.LinkedHashMap.containsValue(java.lang.Object)=[Ljava.lang.Class;@5e0d7c}, replaceAll=public void java.util.LinkedHashMap.replaceAll(java.util.function.BiFunction), remove=freemarker.ext.beans.OverloadedMethods@8d3a99, containsValue=public boolean java.util.LinkedHashMap.containsValue(java.lang.Object), put=public java.lang.Object java.util.HashMap.put(java.lang.Object,java.lang.Object), empty=java.beans.PropertyDescriptor[name=empty; propertyType=boolean; readMethod=public boolean java.util.HashMap.isEmpty()], compute=public java.lang.Object java.util.HashMap.compute(java.lang.Object,java.util.function.BiFunction), hashCode=public int java.util.AbstractMap.hashCode(), putAll=public void java.util.HashMap.putAll(java.util.Map), get=public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object), merge=public java.lang.Object java.util.HashMap.merge(java.lang.Object,java.lang.Object,java.util.function.BiFunction), class=java.beans.PropertyDescriptor[name=class; propertyType=class java.lang.Class; readMethod=public final native java.lang.Class java.lang.Object.getClass()], keySet=public java.util.Set java.util.LinkedHashMap.keySet(), java.lang.Object@1c0f21d=freemarker.ext.beans.OverloadedMethods@d4b988, entrySet=public java.util.Set java.util.LinkedHashMap.entrySet(), java.lang.Object@15be27d=public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object), forEach=public void java.util.LinkedHashMap.forEach(java.util.function.BiConsumer), containsKey=public boolean java.util.HashMap.containsKey(java.lang.Object), isEmpty=public boolean java.util.HashMap.isEmpty(), clear=public void java.util.LinkedHashMap.clear(), computeIfPresent=public java.lang.Object java.util.HashMap.computeIfPresent(java.lang.Object,java.util.function.BiFunction), size=public int java.util.HashMap.size(), equals=public boolean java.util.AbstractMap.equals(java.lang.Object), clone=public java.lang.Object java.util.HashMap.clone(), toString=public java.lang.String java.util.AbstractMap.toString(), putIfAbsent=public java.lang.Object java.util.HashMap.putIfAbsent(java.lang.Object,java.lang.Object)}
[DEBUG] 2017-05-24: 21:05:32 freemarker.log._Log4jLoggerFactory$Log4jLogger.debug(_Log4jLoggerFactory.java:45) :  Key "onmousedown" was not found on instance of java.util.LinkedHashMap. Introspection information for the class is: {getClass=public final native java.lang.Class java.lang.Object.getClass(), getOrDefault=public java.lang.Object java.util.LinkedHashMap.getOrDefault(java.lang.Object,java.lang.Object), computeIfAbsent=public java.lang.Object java.util.HashMap.computeIfAbsent(java.lang.Object,java.util.function.Function), values=public java.util.Collection java.util.LinkedHashMap.values(), replace=freemarker.ext.beans.OverloadedMethods@11d0265, java.lang.Object@3e55b2={public boolean java.util.HashMap.isEmpty()=[Ljava.lang.Class;@c5aa3a, public int java.util.AbstractMap.hashCode()=[Ljava.lang.Class;@74a947, public java.lang.Object java.util.HashMap.put(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@1615a91, public boolean java.util.AbstractMap.equals(java.lang.Object)=[Ljava.lang.Class;@a46ab2, public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object)=[Ljava.lang.Class;@1c389e6, public java.lang.String java.util.AbstractMap.toString()=[Ljava.lang.Class;@a23548, public boolean java.util.HashMap.containsKey(java.lang.Object)=[Ljava.lang.Class;@1be4a9f, public java.util.Set java.util.LinkedHashMap.keySet()=[Ljava.lang.Class;@44c60, public java.lang.Object java.util.HashMap.computeIfAbsent(java.lang.Object,java.util.function.Function)=[Ljava.lang.Class;@10f7dff, public java.lang.Object java.util.HashMap.clone()=[Ljava.lang.Class;@d214e3, public java.lang.Object java.util.LinkedHashMap.getOrDefault(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@1a74254, public java.util.Set java.util.LinkedHashMap.entrySet()=[Ljava.lang.Class;@1c4740c, public void java.util.LinkedHashMap.forEach(java.util.function.BiConsumer)=[Ljava.lang.Class;@1fe0c8e, public java.lang.Object java.util.HashMap.putIfAbsent(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@16f73de, public java.util.Collection java.util.LinkedHashMap.values()=[Ljava.lang.Class;@b3e45, public void java.util.LinkedHashMap.clear()=[Ljava.lang.Class;@a34e5c, public java.lang.Object java.util.HashMap.computeIfPresent(java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1fcb13a, public java.lang.Object java.util.HashMap.compute(java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1a7c258, public final native java.lang.Class java.lang.Object.getClass()=[Ljava.lang.Class;@7397f, public void java.util.HashMap.putAll(java.util.Map)=[Ljava.lang.Class;@59cd, public void java.util.LinkedHashMap.replaceAll(java.util.function.BiFunction)=[Ljava.lang.Class;@994816, public java.lang.Object java.util.HashMap.merge(java.lang.Object,java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1b1e75f, public int java.util.HashMap.size()=[Ljava.lang.Class;@bee157, public boolean java.util.LinkedHashMap.containsValue(java.lang.Object)=[Ljava.lang.Class;@5e0d7c}, replaceAll=public void java.util.LinkedHashMap.replaceAll(java.util.function.BiFunction), remove=freemarker.ext.beans.OverloadedMethods@8d3a99, containsValue=public boolean java.util.LinkedHashMap.containsValue(java.lang.Object), put=public java.lang.Object java.util.HashMap.put(java.lang.Object,java.lang.Object), empty=java.beans.PropertyDescriptor[name=empty; propertyType=boolean; readMethod=public boolean java.util.HashMap.isEmpty()], compute=public java.lang.Object java.util.HashMap.compute(java.lang.Object,java.util.function.BiFunction), hashCode=public int java.util.AbstractMap.hashCode(), putAll=public void java.util.HashMap.putAll(java.util.Map), get=public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object), merge=public java.lang.Object java.util.HashMap.merge(java.lang.Object,java.lang.Object,java.util.function.BiFunction), class=java.beans.PropertyDescriptor[name=class; propertyType=class java.lang.Class; readMethod=public final native java.lang.Class java.lang.Object.getClass()], keySet=public java.util.Set java.util.LinkedHashMap.keySet(), java.lang.Object@1c0f21d=freemarker.ext.beans.OverloadedMethods@d4b988, entrySet=public java.util.Set java.util.LinkedHashMap.entrySet(), java.lang.Object@15be27d=public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object), forEach=public void java.util.LinkedHashMap.forEach(java.util.function.BiConsumer), containsKey=public boolean java.util.HashMap.containsKey(java.lang.Object), isEmpty=public boolean java.util.HashMap.isEmpty(), clear=public void java.util.LinkedHashMap.clear(), computeIfPresent=public java.lang.Object java.util.HashMap.computeIfPresent(java.lang.Object,java.util.function.BiFunction), size=public int java.util.HashMap.size(), equals=public boolean java.util.AbstractMap.equals(java.lang.Object), clone=public java.lang.Object java.util.HashMap.clone(), toString=public java.lang.String java.util.AbstractMap.toString(), putIfAbsent=public java.lang.Object java.util.HashMap.putIfAbsent(java.lang.Object,java.lang.Object)}
[DEBUG] 2017-05-24: 21:05:32 freemarker.log._Log4jLoggerFactory$Log4jLogger.debug(_Log4jLoggerFactory.java:45) :  Key "onmouseup" was not found on instance of java.util.LinkedHashMap. Introspection information for the class is: {getClass=public final native java.lang.Class java.lang.Object.getClass(), getOrDefault=public java.lang.Object java.util.LinkedHashMap.getOrDefault(java.lang.Object,java.lang.Object), computeIfAbsent=public java.lang.Object java.util.HashMap.computeIfAbsent(java.lang.Object,java.util.function.Function), values=public java.util.Collection java.util.LinkedHashMap.values(), replace=freemarker.ext.beans.OverloadedMethods@11d0265, java.lang.Object@3e55b2={public boolean java.util.HashMap.isEmpty()=[Ljava.lang.Class;@c5aa3a, public int java.util.AbstractMap.hashCode()=[Ljava.lang.Class;@74a947, public java.lang.Object java.util.HashMap.put(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@1615a91, public boolean java.util.AbstractMap.equals(java.lang.Object)=[Ljava.lang.Class;@a46ab2, public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object)=[Ljava.lang.Class;@1c389e6, public java.lang.String java.util.AbstractMap.toString()=[Ljava.lang.Class;@a23548, public boolean java.util.HashMap.containsKey(java.lang.Object)=[Ljava.lang.Class;@1be4a9f, public java.util.Set java.util.LinkedHashMap.keySet()=[Ljava.lang.Class;@44c60, public java.lang.Object java.util.HashMap.computeIfAbsent(java.lang.Object,java.util.function.Function)=[Ljava.lang.Class;@10f7dff, public java.lang.Object java.util.HashMap.clone()=[Ljava.lang.Class;@d214e3, public java.lang.Object java.util.LinkedHashMap.getOrDefault(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@1a74254, public java.util.Set java.util.LinkedHashMap.entrySet()=[Ljava.lang.Class;@1c4740c, public void java.util.LinkedHashMap.forEach(java.util.function.BiConsumer)=[Ljava.lang.Class;@1fe0c8e, public java.lang.Object java.util.HashMap.putIfAbsent(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@16f73de, public java.util.Collection java.util.LinkedHashMap.values()=[Ljava.lang.Class;@b3e45, public void java.util.LinkedHashMap.clear()=[Ljava.lang.Class;@a34e5c, public java.lang.Object java.util.HashMap.computeIfPresent(java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1fcb13a, public java.lang.Object java.util.HashMap.compute(java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1a7c258, public final native java.lang.Class java.lang.Object.getClass()=[Ljava.lang.Class;@7397f, public void java.util.HashMap.putAll(java.util.Map)=[Ljava.lang.Class;@59cd, public void java.util.LinkedHashMap.replaceAll(java.util.function.BiFunction)=[Ljava.lang.Class;@994816, public java.lang.Object java.util.HashMap.merge(java.lang.Object,java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1b1e75f, public int java.util.HashMap.size()=[Ljava.lang.Class;@bee157, public boolean java.util.LinkedHashMap.containsValue(java.lang.Object)=[Ljava.lang.Class;@5e0d7c}, replaceAll=public void java.util.LinkedHashMap.replaceAll(java.util.function.BiFunction), remove=freemarker.ext.beans.OverloadedMethods@8d3a99, containsValue=public boolean java.util.LinkedHashMap.containsValue(java.lang.Object), put=public java.lang.Object java.util.HashMap.put(java.lang.Object,java.lang.Object), empty=java.beans.PropertyDescriptor[name=empty; propertyType=boolean; readMethod=public boolean java.util.HashMap.isEmpty()], compute=public java.lang.Object java.util.HashMap.compute(java.lang.Object,java.util.function.BiFunction), hashCode=public int java.util.AbstractMap.hashCode(), putAll=public void java.util.HashMap.putAll(java.util.Map), get=public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object), merge=public java.lang.Object java.util.HashMap.merge(java.lang.Object,java.lang.Object,java.util.function.BiFunction), class=java.beans.PropertyDescriptor[name=class; propertyType=class java.lang.Class; readMethod=public final native java.lang.Class java.lang.Object.getClass()], keySet=public java.util.Set java.util.LinkedHashMap.keySet(), java.lang.Object@1c0f21d=freemarker.ext.beans.OverloadedMethods@d4b988, entrySet=public java.util.Set java.util.LinkedHashMap.entrySet(), java.lang.Object@15be27d=public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object), forEach=public void java.util.LinkedHashMap.forEach(java.util.function.BiConsumer), containsKey=public boolean java.util.HashMap.containsKey(java.lang.Object), isEmpty=public boolean java.util.HashMap.isEmpty(), clear=public void java.util.LinkedHashMap.clear(), computeIfPresent=public java.lang.Object java.util.HashMap.computeIfPresent(java.lang.Object,java.util.function.BiFunction), size=public int java.util.HashMap.size(), equals=public boolean java.util.AbstractMap.equals(java.lang.Object), clone=public java.lang.Object java.util.HashMap.clone(), toString=public java.lang.String java.util.AbstractMap.toString(), putIfAbsent=public java.lang.Object java.util.HashMap.putIfAbsent(java.lang.Object,java.lang.Object)}
[DEBUG] 2017-05-24: 21:05:32 freemarker.log._Log4jLoggerFactory$Log4jLogger.debug(_Log4jLoggerFactory.java:45) :  Key "onmouseover" was not found on instance of java.util.LinkedHashMap. Introspection information for the class is: {getClass=public final native java.lang.Class java.lang.Object.getClass(), getOrDefault=public java.lang.Object java.util.LinkedHashMap.getOrDefault(java.lang.Object,java.lang.Object), computeIfAbsent=public java.lang.Object java.util.HashMap.computeIfAbsent(java.lang.Object,java.util.function.Function), values=public java.util.Collection java.util.LinkedHashMap.values(), replace=freemarker.ext.beans.OverloadedMethods@11d0265, java.lang.Object@3e55b2={public boolean java.util.HashMap.isEmpty()=[Ljava.lang.Class;@c5aa3a, public int java.util.AbstractMap.hashCode()=[Ljava.lang.Class;@74a947, public java.lang.Object java.util.HashMap.put(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@1615a91, public boolean java.util.AbstractMap.equals(java.lang.Object)=[Ljava.lang.Class;@a46ab2, public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object)=[Ljava.lang.Class;@1c389e6, public java.lang.String java.util.AbstractMap.toString()=[Ljava.lang.Class;@a23548, public boolean java.util.HashMap.containsKey(java.lang.Object)=[Ljava.lang.Class;@1be4a9f, public java.util.Set java.util.LinkedHashMap.keySet()=[Ljava.lang.Class;@44c60, public java.lang.Object java.util.HashMap.computeIfAbsent(java.lang.Object,java.util.function.Function)=[Ljava.lang.Class;@10f7dff, public java.lang.Object java.util.HashMap.clone()=[Ljava.lang.Class;@d214e3, public java.lang.Object java.util.LinkedHashMap.getOrDefault(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@1a74254, public java.util.Set java.util.LinkedHashMap.entrySet()=[Ljava.lang.Class;@1c4740c, public void java.util.LinkedHashMap.forEach(java.util.function.BiConsumer)=[Ljava.lang.Class;@1fe0c8e, public java.lang.Object java.util.HashMap.putIfAbsent(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@16f73de, public java.util.Collection java.util.LinkedHashMap.values()=[Ljava.lang.Class;@b3e45, public void java.util.LinkedHashMap.clear()=[Ljava.lang.Class;@a34e5c, public java.lang.Object java.util.HashMap.computeIfPresent(java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1fcb13a, public java.lang.Object java.util.HashMap.compute(java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1a7c258, public final native java.lang.Class java.lang.Object.getClass()=[Ljava.lang.Class;@7397f, public void java.util.HashMap.putAll(java.util.Map)=[Ljava.lang.Class;@59cd, public void java.util.LinkedHashMap.replaceAll(java.util.function.BiFunction)=[Ljava.lang.Class;@994816, public java.lang.Object java.util.HashMap.merge(java.lang.Object,java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1b1e75f, public int java.util.HashMap.size()=[Ljava.lang.Class;@bee157, public boolean java.util.LinkedHashMap.containsValue(java.lang.Object)=[Ljava.lang.Class;@5e0d7c}, replaceAll=public void java.util.LinkedHashMap.replaceAll(java.util.function.BiFunction), remove=freemarker.ext.beans.OverloadedMethods@8d3a99, containsValue=public boolean java.util.LinkedHashMap.containsValue(java.lang.Object), put=public java.lang.Object java.util.HashMap.put(java.lang.Object,java.lang.Object), empty=java.beans.PropertyDescriptor[name=empty; propertyType=boolean; readMethod=public boolean java.util.HashMap.isEmpty()], compute=public java.lang.Object java.util.HashMap.compute(java.lang.Object,java.util.function.BiFunction), hashCode=public int java.util.AbstractMap.hashCode(), putAll=public void java.util.HashMap.putAll(java.util.Map), get=public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object), merge=public java.lang.Object java.util.HashMap.merge(java.lang.Object,java.lang.Object,java.util.function.BiFunction), class=java.beans.PropertyDescriptor[name=class; propertyType=class java.lang.Class; readMethod=public final native java.lang.Class java.lang.Object.getClass()], keySet=public java.util.Set java.util.LinkedHashMap.keySet(), java.lang.Object@1c0f21d=freemarker.ext.beans.OverloadedMethods@d4b988, entrySet=public java.util.Set java.util.LinkedHashMap.entrySet(), java.lang.Object@15be27d=public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object), forEach=public void java.util.LinkedHashMap.forEach(java.util.function.BiConsumer), containsKey=public boolean java.util.HashMap.containsKey(java.lang.Object), isEmpty=public boolean java.util.HashMap.isEmpty(), clear=public void java.util.LinkedHashMap.clear(), computeIfPresent=public java.lang.Object java.util.HashMap.computeIfPresent(java.lang.Object,java.util.function.BiFunction), size=public int java.util.HashMap.size(), equals=public boolean java.util.AbstractMap.equals(java.lang.Object), clone=public java.lang.Object java.util.HashMap.clone(), toString=public java.lang.String java.util.AbstractMap.toString(), putIfAbsent=public java.lang.Object java.util.HashMap.putIfAbsent(java.lang.Object,java.lang.Object)}
[DEBUG] 2017-05-24: 21:05:32 freemarker.log._Log4jLoggerFactory$Log4jLogger.debug(_Log4jLoggerFactory.java:45) :  Key "onmousemove" was not found on instance of java.util.LinkedHashMap. Introspection information for the class is: {getClass=public final native java.lang.Class java.lang.Object.getClass(), getOrDefault=public java.lang.Object java.util.LinkedHashMap.getOrDefault(java.lang.Object,java.lang.Object), computeIfAbsent=public java.lang.Object java.util.HashMap.computeIfAbsent(java.lang.Object,java.util.function.Function), values=public java.util.Collection java.util.LinkedHashMap.values(), replace=freemarker.ext.beans.OverloadedMethods@11d0265, java.lang.Object@3e55b2={public boolean java.util.HashMap.isEmpty()=[Ljava.lang.Class;@c5aa3a, public int java.util.AbstractMap.hashCode()=[Ljava.lang.Class;@74a947, public java.lang.Object java.util.HashMap.put(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@1615a91, public boolean java.util.AbstractMap.equals(java.lang.Object)=[Ljava.lang.Class;@a46ab2, public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object)=[Ljava.lang.Class;@1c389e6, public java.lang.String java.util.AbstractMap.toString()=[Ljava.lang.Class;@a23548, public boolean java.util.HashMap.containsKey(java.lang.Object)=[Ljava.lang.Class;@1be4a9f, public java.util.Set java.util.LinkedHashMap.keySet()=[Ljava.lang.Class;@44c60, public java.lang.Object java.util.HashMap.computeIfAbsent(java.lang.Object,java.util.function.Function)=[Ljava.lang.Class;@10f7dff, public java.lang.Object java.util.HashMap.clone()=[Ljava.lang.Class;@d214e3, public java.lang.Object java.util.LinkedHashMap.getOrDefault(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@1a74254, public java.util.Set java.util.LinkedHashMap.entrySet()=[Ljava.lang.Class;@1c4740c, public void java.util.LinkedHashMap.forEach(java.util.function.BiConsumer)=[Ljava.lang.Class;@1fe0c8e, public java.lang.Object java.util.HashMap.putIfAbsent(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@16f73de, public java.util.Collection java.util.LinkedHashMap.values()=[Ljava.lang.Class;@b3e45, public void java.util.LinkedHashMap.clear()=[Ljava.lang.Class;@a34e5c, public java.lang.Object java.util.HashMap.computeIfPresent(java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1fcb13a, public java.lang.Object java.util.HashMap.compute(java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1a7c258, public final native java.lang.Class java.lang.Object.getClass()=[Ljava.lang.Class;@7397f, public void java.util.HashMap.putAll(java.util.Map)=[Ljava.lang.Class;@59cd, public void java.util.LinkedHashMap.replaceAll(java.util.function.BiFunction)=[Ljava.lang.Class;@994816, public java.lang.Object java.util.HashMap.merge(java.lang.Object,java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1b1e75f, public int java.util.HashMap.size()=[Ljava.lang.Class;@bee157, public boolean java.util.LinkedHashMap.containsValue(java.lang.Object)=[Ljava.lang.Class;@5e0d7c}, replaceAll=public void java.util.LinkedHashMap.replaceAll(java.util.function.BiFunction), remove=freemarker.ext.beans.OverloadedMethods@8d3a99, containsValue=public boolean java.util.LinkedHashMap.containsValue(java.lang.Object), put=public java.lang.Object java.util.HashMap.put(java.lang.Object,java.lang.Object), empty=java.beans.PropertyDescriptor[name=empty; propertyType=boolean; readMethod=public boolean java.util.HashMap.isEmpty()], compute=public java.lang.Object java.util.HashMap.compute(java.lang.Object,java.util.function.BiFunction), hashCode=public int java.util.AbstractMap.hashCode(), putAll=public void java.util.HashMap.putAll(java.util.Map), get=public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object), merge=public java.lang.Object java.util.HashMap.merge(java.lang.Object,java.lang.Object,java.util.function.BiFunction), class=java.beans.PropertyDescriptor[name=class; propertyType=class java.lang.Class; readMethod=public final native java.lang.Class java.lang.Object.getClass()], keySet=public java.util.Set java.util.LinkedHashMap.keySet(), java.lang.Object@1c0f21d=freemarker.ext.beans.OverloadedMethods@d4b988, entrySet=public java.util.Set java.util.LinkedHashMap.entrySet(), java.lang.Object@15be27d=public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object), forEach=public void java.util.LinkedHashMap.forEach(java.util.function.BiConsumer), containsKey=public boolean java.util.HashMap.containsKey(java.lang.Object), isEmpty=public boolean java.util.HashMap.isEmpty(), clear=public void java.util.LinkedHashMap.clear(), computeIfPresent=public java.lang.Object java.util.HashMap.computeIfPresent(java.lang.Object,java.util.function.BiFunction), size=public int java.util.HashMap.size(), equals=public boolean java.util.AbstractMap.equals(java.lang.Object), clone=public java.lang.Object java.util.HashMap.clone(), toString=public java.lang.String java.util.AbstractMap.toString(), putIfAbsent=public java.lang.Object java.util.HashMap.putIfAbsent(java.lang.Object,java.lang.Object)}
[DEBUG] 2017-05-24: 21:05:32 freemarker.log._Log4jLoggerFactory$Log4jLogger.debug(_Log4jLoggerFactory.java:45) :  Key "onmouseout" was not found on instance of java.util.LinkedHashMap. Introspection information for the class is: {getClass=public final native java.lang.Class java.lang.Object.getClass(), getOrDefault=public java.lang.Object java.util.LinkedHashMap.getOrDefault(java.lang.Object,java.lang.Object), computeIfAbsent=public java.lang.Object java.util.HashMap.computeIfAbsent(java.lang.Object,java.util.function.Function), values=public java.util.Collection java.util.LinkedHashMap.values(), replace=freemarker.ext.beans.OverloadedMethods@11d0265, java.lang.Object@3e55b2={public boolean java.util.HashMap.isEmpty()=[Ljava.lang.Class;@c5aa3a, public int java.util.AbstractMap.hashCode()=[Ljava.lang.Class;@74a947, public java.lang.Object java.util.HashMap.put(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@1615a91, public boolean java.util.AbstractMap.equals(java.lang.Object)=[Ljava.lang.Class;@a46ab2, public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object)=[Ljava.lang.Class;@1c389e6, public java.lang.String java.util.AbstractMap.toString()=[Ljava.lang.Class;@a23548, public boolean java.util.HashMap.containsKey(java.lang.Object)=[Ljava.lang.Class;@1be4a9f, public java.util.Set java.util.LinkedHashMap.keySet()=[Ljava.lang.Class;@44c60, public java.lang.Object java.util.HashMap.computeIfAbsent(java.lang.Object,java.util.function.Function)=[Ljava.lang.Class;@10f7dff, public java.lang.Object java.util.HashMap.clone()=[Ljava.lang.Class;@d214e3, public java.lang.Object java.util.LinkedHashMap.getOrDefault(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@1a74254, public java.util.Set java.util.LinkedHashMap.entrySet()=[Ljava.lang.Class;@1c4740c, public void java.util.LinkedHashMap.forEach(java.util.function.BiConsumer)=[Ljava.lang.Class;@1fe0c8e, public java.lang.Object java.util.HashMap.putIfAbsent(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@16f73de, public java.util.Collection java.util.LinkedHashMap.values()=[Ljava.lang.Class;@b3e45, public void java.util.LinkedHashMap.clear()=[Ljava.lang.Class;@a34e5c, public java.lang.Object java.util.HashMap.computeIfPresent(java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1fcb13a, public java.lang.Object java.util.HashMap.compute(java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1a7c258, public final native java.lang.Class java.lang.Object.getClass()=[Ljava.lang.Class;@7397f, public void java.util.HashMap.putAll(java.util.Map)=[Ljava.lang.Class;@59cd, public void java.util.LinkedHashMap.replaceAll(java.util.function.BiFunction)=[Ljava.lang.Class;@994816, public java.lang.Object java.util.HashMap.merge(java.lang.Object,java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1b1e75f, public int java.util.HashMap.size()=[Ljava.lang.Class;@bee157, public boolean java.util.LinkedHashMap.containsValue(java.lang.Object)=[Ljava.lang.Class;@5e0d7c}, replaceAll=public void java.util.LinkedHashMap.replaceAll(java.util.function.BiFunction), remove=freemarker.ext.beans.OverloadedMethods@8d3a99, containsValue=public boolean java.util.LinkedHashMap.containsValue(java.lang.Object), put=public java.lang.Object java.util.HashMap.put(java.lang.Object,java.lang.Object), empty=java.beans.PropertyDescriptor[name=empty; propertyType=boolean; readMethod=public boolean java.util.HashMap.isEmpty()], compute=public java.lang.Object java.util.HashMap.compute(java.lang.Object,java.util.function.BiFunction), hashCode=public int java.util.AbstractMap.hashCode(), putAll=public void java.util.HashMap.putAll(java.util.Map), get=public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object), merge=public java.lang.Object java.util.HashMap.merge(java.lang.Object,java.lang.Object,java.util.function.BiFunction), class=java.beans.PropertyDescriptor[name=class; propertyType=class java.lang.Class; readMethod=public final native java.lang.Class java.lang.Object.getClass()], keySet=public java.util.Set java.util.LinkedHashMap.keySet(), java.lang.Object@1c0f21d=freemarker.ext.beans.OverloadedMethods@d4b988, entrySet=public java.util.Set java.util.LinkedHashMap.entrySet(), java.lang.Object@15be27d=public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object), forEach=public void java.util.LinkedHashMap.forEach(java.util.function.BiConsumer), containsKey=public boolean java.util.HashMap.containsKey(java.lang.Object), isEmpty=public boolean java.util.HashMap.isEmpty(), clear=public void java.util.LinkedHashMap.clear(), computeIfPresent=public java.lang.Object java.util.HashMap.computeIfPresent(java.lang.Object,java.util.function.BiFunction), size=public int java.util.HashMap.size(), equals=public boolean java.util.AbstractMap.equals(java.lang.Object), clone=public java.lang.Object java.util.HashMap.clone(), toString=public java.lang.String java.util.AbstractMap.toString(), putIfAbsent=public java.lang.Object java.util.HashMap.putIfAbsent(java.lang.Object,java.lang.Object)}
[DEBUG] 2017-05-24: 21:05:32 freemarker.log._Log4jLoggerFactory$Log4jLogger.debug(_Log4jLoggerFactory.java:45) :  Key "onfocus" was not found on instance of java.util.LinkedHashMap. Introspection information for the class is: {getClass=public final native java.lang.Class java.lang.Object.getClass(), getOrDefault=public java.lang.Object java.util.LinkedHashMap.getOrDefault(java.lang.Object,java.lang.Object), computeIfAbsent=public java.lang.Object java.util.HashMap.computeIfAbsent(java.lang.Object,java.util.function.Function), values=public java.util.Collection java.util.LinkedHashMap.values(), replace=freemarker.ext.beans.OverloadedMethods@11d0265, java.lang.Object@3e55b2={public boolean java.util.HashMap.isEmpty()=[Ljava.lang.Class;@c5aa3a, public int java.util.AbstractMap.hashCode()=[Ljava.lang.Class;@74a947, public java.lang.Object java.util.HashMap.put(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@1615a91, public boolean java.util.AbstractMap.equals(java.lang.Object)=[Ljava.lang.Class;@a46ab2, public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object)=[Ljava.lang.Class;@1c389e6, public java.lang.String java.util.AbstractMap.toString()=[Ljava.lang.Class;@a23548, public boolean java.util.HashMap.containsKey(java.lang.Object)=[Ljava.lang.Class;@1be4a9f, public java.util.Set java.util.LinkedHashMap.keySet()=[Ljava.lang.Class;@44c60, public java.lang.Object java.util.HashMap.computeIfAbsent(java.lang.Object,java.util.function.Function)=[Ljava.lang.Class;@10f7dff, public java.lang.Object java.util.HashMap.clone()=[Ljava.lang.Class;@d214e3, public java.lang.Object java.util.LinkedHashMap.getOrDefault(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@1a74254, public java.util.Set java.util.LinkedHashMap.entrySet()=[Ljava.lang.Class;@1c4740c, public void java.util.LinkedHashMap.forEach(java.util.function.BiConsumer)=[Ljava.lang.Class;@1fe0c8e, public java.lang.Object java.util.HashMap.putIfAbsent(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@16f73de, public java.util.Collection java.util.LinkedHashMap.values()=[Ljava.lang.Class;@b3e45, public void java.util.LinkedHashMap.clear()=[Ljava.lang.Class;@a34e5c, public java.lang.Object java.util.HashMap.computeIfPresent(java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1fcb13a, public java.lang.Object java.util.HashMap.compute(java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1a7c258, public final native java.lang.Class java.lang.Object.getClass()=[Ljava.lang.Class;@7397f, public void java.util.HashMap.putAll(java.util.Map)=[Ljava.lang.Class;@59cd, public void java.util.LinkedHashMap.replaceAll(java.util.function.BiFunction)=[Ljava.lang.Class;@994816, public java.lang.Object java.util.HashMap.merge(java.lang.Object,java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1b1e75f, public int java.util.HashMap.size()=[Ljava.lang.Class;@bee157, public boolean java.util.LinkedHashMap.containsValue(java.lang.Object)=[Ljava.lang.Class;@5e0d7c}, replaceAll=public void java.util.LinkedHashMap.replaceAll(java.util.function.BiFunction), remove=freemarker.ext.beans.OverloadedMethods@8d3a99, containsValue=public boolean java.util.LinkedHashMap.containsValue(java.lang.Object), put=public java.lang.Object java.util.HashMap.put(java.lang.Object,java.lang.Object), empty=java.beans.PropertyDescriptor[name=empty; propertyType=boolean; readMethod=public boolean java.util.HashMap.isEmpty()], compute=public java.lang.Object java.util.HashMap.compute(java.lang.Object,java.util.function.BiFunction), hashCode=public int java.util.AbstractMap.hashCode(), putAll=public void java.util.HashMap.putAll(java.util.Map), get=public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object), merge=public java.lang.Object java.util.HashMap.merge(java.lang.Object,java.lang.Object,java.util.function.BiFunction), class=java.beans.PropertyDescriptor[name=class; propertyType=class java.lang.Class; readMethod=public final native java.lang.Class java.lang.Object.getClass()], keySet=public java.util.Set java.util.LinkedHashMap.keySet(), java.lang.Object@1c0f21d=freemarker.ext.beans.OverloadedMethods@d4b988, entrySet=public java.util.Set java.util.LinkedHashMap.entrySet(), java.lang.Object@15be27d=public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object), forEach=public void java.util.LinkedHashMap.forEach(java.util.function.BiConsumer), containsKey=public boolean java.util.HashMap.containsKey(java.lang.Object), isEmpty=public boolean java.util.HashMap.isEmpty(), clear=public void java.util.LinkedHashMap.clear(), computeIfPresent=public java.lang.Object java.util.HashMap.computeIfPresent(java.lang.Object,java.util.function.BiFunction), size=public int java.util.HashMap.size(), equals=public boolean java.util.AbstractMap.equals(java.lang.Object), clone=public java.lang.Object java.util.HashMap.clone(), toString=public java.lang.String java.util.AbstractMap.toString(), putIfAbsent=public java.lang.Object java.util.HashMap.putIfAbsent(java.lang.Object,java.lang.Object)}
[DEBUG] 2017-05-24: 21:05:32 freemarker.log._Log4jLoggerFactory$Log4jLogger.debug(_Log4jLoggerFactory.java:45) :  Key "onblur" was not found on instance of java.util.LinkedHashMap. Introspection information for the class is: {getClass=public final native java.lang.Class java.lang.Object.getClass(), getOrDefault=public java.lang.Object java.util.LinkedHashMap.getOrDefault(java.lang.Object,java.lang.Object), computeIfAbsent=public java.lang.Object java.util.HashMap.computeIfAbsent(java.lang.Object,java.util.function.Function), values=public java.util.Collection java.util.LinkedHashMap.values(), replace=freemarker.ext.beans.OverloadedMethods@11d0265, java.lang.Object@3e55b2={public boolean java.util.HashMap.isEmpty()=[Ljava.lang.Class;@c5aa3a, public int java.util.AbstractMap.hashCode()=[Ljava.lang.Class;@74a947, public java.lang.Object java.util.HashMap.put(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@1615a91, public boolean java.util.AbstractMap.equals(java.lang.Object)=[Ljava.lang.Class;@a46ab2, public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object)=[Ljava.lang.Class;@1c389e6, public java.lang.String java.util.AbstractMap.toString()=[Ljava.lang.Class;@a23548, public boolean java.util.HashMap.containsKey(java.lang.Object)=[Ljava.lang.Class;@1be4a9f, public java.util.Set java.util.LinkedHashMap.keySet()=[Ljava.lang.Class;@44c60, public java.lang.Object java.util.HashMap.computeIfAbsent(java.lang.Object,java.util.function.Function)=[Ljava.lang.Class;@10f7dff, public java.lang.Object java.util.HashMap.clone()=[Ljava.lang.Class;@d214e3, public java.lang.Object java.util.LinkedHashMap.getOrDefault(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@1a74254, public java.util.Set java.util.LinkedHashMap.entrySet()=[Ljava.lang.Class;@1c4740c, public void java.util.LinkedHashMap.forEach(java.util.function.BiConsumer)=[Ljava.lang.Class;@1fe0c8e, public java.lang.Object java.util.HashMap.putIfAbsent(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@16f73de, public java.util.Collection java.util.LinkedHashMap.values()=[Ljava.lang.Class;@b3e45, public void java.util.LinkedHashMap.clear()=[Ljava.lang.Class;@a34e5c, public java.lang.Object java.util.HashMap.computeIfPresent(java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1fcb13a, public java.lang.Object java.util.HashMap.compute(java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1a7c258, public final native java.lang.Class java.lang.Object.getClass()=[Ljava.lang.Class;@7397f, public void java.util.HashMap.putAll(java.util.Map)=[Ljava.lang.Class;@59cd, public void java.util.LinkedHashMap.replaceAll(java.util.function.BiFunction)=[Ljava.lang.Class;@994816, public java.lang.Object java.util.HashMap.merge(java.lang.Object,java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1b1e75f, public int java.util.HashMap.size()=[Ljava.lang.Class;@bee157, public boolean java.util.LinkedHashMap.containsValue(java.lang.Object)=[Ljava.lang.Class;@5e0d7c}, replaceAll=public void java.util.LinkedHashMap.replaceAll(java.util.function.BiFunction), remove=freemarker.ext.beans.OverloadedMethods@8d3a99, containsValue=public boolean java.util.LinkedHashMap.containsValue(java.lang.Object), put=public java.lang.Object java.util.HashMap.put(java.lang.Object,java.lang.Object), empty=java.beans.PropertyDescriptor[name=empty; propertyType=boolean; readMethod=public boolean java.util.HashMap.isEmpty()], compute=public java.lang.Object java.util.HashMap.compute(java.lang.Object,java.util.function.BiFunction), hashCode=public int java.util.AbstractMap.hashCode(), putAll=public void java.util.HashMap.putAll(java.util.Map), get=public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object), merge=public java.lang.Object java.util.HashMap.merge(java.lang.Object,java.lang.Object,java.util.function.BiFunction), class=java.beans.PropertyDescriptor[name=class; propertyType=class java.lang.Class; readMethod=public final native java.lang.Class java.lang.Object.getClass()], keySet=public java.util.Set java.util.LinkedHashMap.keySet(), java.lang.Object@1c0f21d=freemarker.ext.beans.OverloadedMethods@d4b988, entrySet=public java.util.Set java.util.LinkedHashMap.entrySet(), java.lang.Object@15be27d=public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object), forEach=public void java.util.LinkedHashMap.forEach(java.util.function.BiConsumer), containsKey=public boolean java.util.HashMap.containsKey(java.lang.Object), isEmpty=public boolean java.util.HashMap.isEmpty(), clear=public void java.util.LinkedHashMap.clear(), computeIfPresent=public java.lang.Object java.util.HashMap.computeIfPresent(java.lang.Object,java.util.function.BiFunction), size=public int java.util.HashMap.size(), equals=public boolean java.util.AbstractMap.equals(java.lang.Object), clone=public java.lang.Object java.util.HashMap.clone(), toString=public java.lang.String java.util.AbstractMap.toString(), putIfAbsent=public java.lang.Object java.util.HashMap.putIfAbsent(java.lang.Object,java.lang.Object)}
[DEBUG] 2017-05-24: 21:05:32 freemarker.log._Log4jLoggerFactory$Log4jLogger.debug(_Log4jLoggerFactory.java:45) :  Key "onkeypress" was not found on instance of java.util.LinkedHashMap. Introspection information for the class is: {getClass=public final native java.lang.Class java.lang.Object.getClass(), getOrDefault=public java.lang.Object java.util.LinkedHashMap.getOrDefault(java.lang.Object,java.lang.Object), computeIfAbsent=public java.lang.Object java.util.HashMap.computeIfAbsent(java.lang.Object,java.util.function.Function), values=public java.util.Collection java.util.LinkedHashMap.values(), replace=freemarker.ext.beans.OverloadedMethods@11d0265, java.lang.Object@3e55b2={public boolean java.util.HashMap.isEmpty()=[Ljava.lang.Class;@c5aa3a, public int java.util.AbstractMap.hashCode()=[Ljava.lang.Class;@74a947, public java.lang.Object java.util.HashMap.put(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@1615a91, public boolean java.util.AbstractMap.equals(java.lang.Object)=[Ljava.lang.Class;@a46ab2, public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object)=[Ljava.lang.Class;@1c389e6, public java.lang.String java.util.AbstractMap.toString()=[Ljava.lang.Class;@a23548, public boolean java.util.HashMap.containsKey(java.lang.Object)=[Ljava.lang.Class;@1be4a9f, public java.util.Set java.util.LinkedHashMap.keySet()=[Ljava.lang.Class;@44c60, public java.lang.Object java.util.HashMap.computeIfAbsent(java.lang.Object,java.util.function.Function)=[Ljava.lang.Class;@10f7dff, public java.lang.Object java.util.HashMap.clone()=[Ljava.lang.Class;@d214e3, public java.lang.Object java.util.LinkedHashMap.getOrDefault(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@1a74254, public java.util.Set java.util.LinkedHashMap.entrySet()=[Ljava.lang.Class;@1c4740c, public void java.util.LinkedHashMap.forEach(java.util.function.BiConsumer)=[Ljava.lang.Class;@1fe0c8e, public java.lang.Object java.util.HashMap.putIfAbsent(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@16f73de, public java.util.Collection java.util.LinkedHashMap.values()=[Ljava.lang.Class;@b3e45, public void java.util.LinkedHashMap.clear()=[Ljava.lang.Class;@a34e5c, public java.lang.Object java.util.HashMap.computeIfPresent(java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1fcb13a, public java.lang.Object java.util.HashMap.compute(java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1a7c258, public final native java.lang.Class java.lang.Object.getClass()=[Ljava.lang.Class;@7397f, public void java.util.HashMap.putAll(java.util.Map)=[Ljava.lang.Class;@59cd, public void java.util.LinkedHashMap.replaceAll(java.util.function.BiFunction)=[Ljava.lang.Class;@994816, public java.lang.Object java.util.HashMap.merge(java.lang.Object,java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1b1e75f, public int java.util.HashMap.size()=[Ljava.lang.Class;@bee157, public boolean java.util.LinkedHashMap.containsValue(java.lang.Object)=[Ljava.lang.Class;@5e0d7c}, replaceAll=public void java.util.LinkedHashMap.replaceAll(java.util.function.BiFunction), remove=freemarker.ext.beans.OverloadedMethods@8d3a99, containsValue=public boolean java.util.LinkedHashMap.containsValue(java.lang.Object), put=public java.lang.Object java.util.HashMap.put(java.lang.Object,java.lang.Object), empty=java.beans.PropertyDescriptor[name=empty; propertyType=boolean; readMethod=public boolean java.util.HashMap.isEmpty()], compute=public java.lang.Object java.util.HashMap.compute(java.lang.Object,java.util.function.BiFunction), hashCode=public int java.util.AbstractMap.hashCode(), putAll=public void java.util.HashMap.putAll(java.util.Map), get=public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object), merge=public java.lang.Object java.util.HashMap.merge(java.lang.Object,java.lang.Object,java.util.function.BiFunction), class=java.beans.PropertyDescriptor[name=class; propertyType=class java.lang.Class; readMethod=public final native java.lang.Class java.lang.Object.getClass()], keySet=public java.util.Set java.util.LinkedHashMap.keySet(), java.lang.Object@1c0f21d=freemarker.ext.beans.OverloadedMethods@d4b988, entrySet=public java.util.Set java.util.LinkedHashMap.entrySet(), java.lang.Object@15be27d=public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object), forEach=public void java.util.LinkedHashMap.forEach(java.util.function.BiConsumer), containsKey=public boolean java.util.HashMap.containsKey(java.lang.Object), isEmpty=public boolean java.util.HashMap.isEmpty(), clear=public void java.util.LinkedHashMap.clear(), computeIfPresent=public java.lang.Object java.util.HashMap.computeIfPresent(java.lang.Object,java.util.function.BiFunction), size=public int java.util.HashMap.size(), equals=public boolean java.util.AbstractMap.equals(java.lang.Object), clone=public java.lang.Object java.util.HashMap.clone(), toString=public java.lang.String java.util.AbstractMap.toString(), putIfAbsent=public java.lang.Object java.util.HashMap.putIfAbsent(java.lang.Object,java.lang.Object)}
[DEBUG] 2017-05-24: 21:05:32 freemarker.log._Log4jLoggerFactory$Log4jLogger.debug(_Log4jLoggerFactory.java:45) :  Key "onkeydown" was not found on instance of java.util.LinkedHashMap. Introspection information for the class is: {getClass=public final native java.lang.Class java.lang.Object.getClass(), getOrDefault=public java.lang.Object java.util.LinkedHashMap.getOrDefault(java.lang.Object,java.lang.Object), computeIfAbsent=public java.lang.Object java.util.HashMap.computeIfAbsent(java.lang.Object,java.util.function.Function), values=public java.util.Collection java.util.LinkedHashMap.values(), replace=freemarker.ext.beans.OverloadedMethods@11d0265, java.lang.Object@3e55b2={public boolean java.util.HashMap.isEmpty()=[Ljava.lang.Class;@c5aa3a, public int java.util.AbstractMap.hashCode()=[Ljava.lang.Class;@74a947, public java.lang.Object java.util.HashMap.put(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@1615a91, public boolean java.util.AbstractMap.equals(java.lang.Object)=[Ljava.lang.Class;@a46ab2, public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object)=[Ljava.lang.Class;@1c389e6, public java.lang.String java.util.AbstractMap.toString()=[Ljava.lang.Class;@a23548, public boolean java.util.HashMap.containsKey(java.lang.Object)=[Ljava.lang.Class;@1be4a9f, public java.util.Set java.util.LinkedHashMap.keySet()=[Ljava.lang.Class;@44c60, public java.lang.Object java.util.HashMap.computeIfAbsent(java.lang.Object,java.util.function.Function)=[Ljava.lang.Class;@10f7dff, public java.lang.Object java.util.HashMap.clone()=[Ljava.lang.Class;@d214e3, public java.lang.Object java.util.LinkedHashMap.getOrDefault(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@1a74254, public java.util.Set java.util.LinkedHashMap.entrySet()=[Ljava.lang.Class;@1c4740c, public void java.util.LinkedHashMap.forEach(java.util.function.BiConsumer)=[Ljava.lang.Class;@1fe0c8e, public java.lang.Object java.util.HashMap.putIfAbsent(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@16f73de, public java.util.Collection java.util.LinkedHashMap.values()=[Ljava.lang.Class;@b3e45, public void java.util.LinkedHashMap.clear()=[Ljava.lang.Class;@a34e5c, public java.lang.Object java.util.HashMap.computeIfPresent(java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1fcb13a, public java.lang.Object java.util.HashMap.compute(java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1a7c258, public final native java.lang.Class java.lang.Object.getClass()=[Ljava.lang.Class;@7397f, public void java.util.HashMap.putAll(java.util.Map)=[Ljava.lang.Class;@59cd, public void java.util.LinkedHashMap.replaceAll(java.util.function.BiFunction)=[Ljava.lang.Class;@994816, public java.lang.Object java.util.HashMap.merge(java.lang.Object,java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1b1e75f, public int java.util.HashMap.size()=[Ljava.lang.Class;@bee157, public boolean java.util.LinkedHashMap.containsValue(java.lang.Object)=[Ljava.lang.Class;@5e0d7c}, replaceAll=public void java.util.LinkedHashMap.replaceAll(java.util.function.BiFunction), remove=freemarker.ext.beans.OverloadedMethods@8d3a99, containsValue=public boolean java.util.LinkedHashMap.containsValue(java.lang.Object), put=public java.lang.Object java.util.HashMap.put(java.lang.Object,java.lang.Object), empty=java.beans.PropertyDescriptor[name=empty; propertyType=boolean; readMethod=public boolean java.util.HashMap.isEmpty()], compute=public java.lang.Object java.util.HashMap.compute(java.lang.Object,java.util.function.BiFunction), hashCode=public int java.util.AbstractMap.hashCode(), putAll=public void java.util.HashMap.putAll(java.util.Map), get=public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object), merge=public java.lang.Object java.util.HashMap.merge(java.lang.Object,java.lang.Object,java.util.function.BiFunction), class=java.beans.PropertyDescriptor[name=class; propertyType=class java.lang.Class; readMethod=public final native java.lang.Class java.lang.Object.getClass()], keySet=public java.util.Set java.util.LinkedHashMap.keySet(), java.lang.Object@1c0f21d=freemarker.ext.beans.OverloadedMethods@d4b988, entrySet=public java.util.Set java.util.LinkedHashMap.entrySet(), java.lang.Object@15be27d=public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object), forEach=public void java.util.LinkedHashMap.forEach(java.util.function.BiConsumer), containsKey=public boolean java.util.HashMap.containsKey(java.lang.Object), isEmpty=public boolean java.util.HashMap.isEmpty(), clear=public void java.util.LinkedHashMap.clear(), computeIfPresent=public java.lang.Object java.util.HashMap.computeIfPresent(java.lang.Object,java.util.function.BiFunction), size=public int java.util.HashMap.size(), equals=public boolean java.util.AbstractMap.equals(java.lang.Object), clone=public java.lang.Object java.util.HashMap.clone(), toString=public java.lang.String java.util.AbstractMap.toString(), putIfAbsent=public java.lang.Object java.util.HashMap.putIfAbsent(java.lang.Object,java.lang.Object)}
[DEBUG] 2017-05-24: 21:05:32 freemarker.log._Log4jLoggerFactory$Log4jLogger.debug(_Log4jLoggerFactory.java:45) :  Key "onkeyup" was not found on instance of java.util.LinkedHashMap. Introspection information for the class is: {getClass=public final native java.lang.Class java.lang.Object.getClass(), getOrDefault=public java.lang.Object java.util.LinkedHashMap.getOrDefault(java.lang.Object,java.lang.Object), computeIfAbsent=public java.lang.Object java.util.HashMap.computeIfAbsent(java.lang.Object,java.util.function.Function), values=public java.util.Collection java.util.LinkedHashMap.values(), replace=freemarker.ext.beans.OverloadedMethods@11d0265, java.lang.Object@3e55b2={public boolean java.util.HashMap.isEmpty()=[Ljava.lang.Class;@c5aa3a, public int java.util.AbstractMap.hashCode()=[Ljava.lang.Class;@74a947, public java.lang.Object java.util.HashMap.put(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@1615a91, public boolean java.util.AbstractMap.equals(java.lang.Object)=[Ljava.lang.Class;@a46ab2, public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object)=[Ljava.lang.Class;@1c389e6, public java.lang.String java.util.AbstractMap.toString()=[Ljava.lang.Class;@a23548, public boolean java.util.HashMap.containsKey(java.lang.Object)=[Ljava.lang.Class;@1be4a9f, public java.util.Set java.util.LinkedHashMap.keySet()=[Ljava.lang.Class;@44c60, public java.lang.Object java.util.HashMap.computeIfAbsent(java.lang.Object,java.util.function.Function)=[Ljava.lang.Class;@10f7dff, public java.lang.Object java.util.HashMap.clone()=[Ljava.lang.Class;@d214e3, public java.lang.Object java.util.LinkedHashMap.getOrDefault(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@1a74254, public java.util.Set java.util.LinkedHashMap.entrySet()=[Ljava.lang.Class;@1c4740c, public void java.util.LinkedHashMap.forEach(java.util.function.BiConsumer)=[Ljava.lang.Class;@1fe0c8e, public java.lang.Object java.util.HashMap.putIfAbsent(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@16f73de, public java.util.Collection java.util.LinkedHashMap.values()=[Ljava.lang.Class;@b3e45, public void java.util.LinkedHashMap.clear()=[Ljava.lang.Class;@a34e5c, public java.lang.Object java.util.HashMap.computeIfPresent(java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1fcb13a, public java.lang.Object java.util.HashMap.compute(java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1a7c258, public final native java.lang.Class java.lang.Object.getClass()=[Ljava.lang.Class;@7397f, public void java.util.HashMap.putAll(java.util.Map)=[Ljava.lang.Class;@59cd, public void java.util.LinkedHashMap.replaceAll(java.util.function.BiFunction)=[Ljava.lang.Class;@994816, public java.lang.Object java.util.HashMap.merge(java.lang.Object,java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1b1e75f, public int java.util.HashMap.size()=[Ljava.lang.Class;@bee157, public boolean java.util.LinkedHashMap.containsValue(java.lang.Object)=[Ljava.lang.Class;@5e0d7c}, replaceAll=public void java.util.LinkedHashMap.replaceAll(java.util.function.BiFunction), remove=freemarker.ext.beans.OverloadedMethods@8d3a99, containsValue=public boolean java.util.LinkedHashMap.containsValue(java.lang.Object), put=public java.lang.Object java.util.HashMap.put(java.lang.Object,java.lang.Object), empty=java.beans.PropertyDescriptor[name=empty; propertyType=boolean; readMethod=public boolean java.util.HashMap.isEmpty()], compute=public java.lang.Object java.util.HashMap.compute(java.lang.Object,java.util.function.BiFunction), hashCode=public int java.util.AbstractMap.hashCode(), putAll=public void java.util.HashMap.putAll(java.util.Map), get=public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object), merge=public java.lang.Object java.util.HashMap.merge(java.lang.Object,java.lang.Object,java.util.function.BiFunction), class=java.beans.PropertyDescriptor[name=class; propertyType=class java.lang.Class; readMethod=public final native java.lang.Class java.lang.Object.getClass()], keySet=public java.util.Set java.util.LinkedHashMap.keySet(), java.lang.Object@1c0f21d=freemarker.ext.beans.OverloadedMethods@d4b988, entrySet=public java.util.Set java.util.LinkedHashMap.entrySet(), java.lang.Object@15be27d=public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object), forEach=public void java.util.LinkedHashMap.forEach(java.util.function.BiConsumer), containsKey=public boolean java.util.HashMap.containsKey(java.lang.Object), isEmpty=public boolean java.util.HashMap.isEmpty(), clear=public void java.util.LinkedHashMap.clear(), computeIfPresent=public java.lang.Object java.util.HashMap.computeIfPresent(java.lang.Object,java.util.function.BiFunction), size=public int java.util.HashMap.size(), equals=public boolean java.util.AbstractMap.equals(java.lang.Object), clone=public java.lang.Object java.util.HashMap.clone(), toString=public java.lang.String java.util.AbstractMap.toString(), putIfAbsent=public java.lang.Object java.util.HashMap.putIfAbsent(java.lang.Object,java.lang.Object)}
[DEBUG] 2017-05-24: 21:05:32 freemarker.log._Log4jLoggerFactory$Log4jLogger.debug(_Log4jLoggerFactory.java:45) :  Key "onselect" was not found on instance of java.util.LinkedHashMap. Introspection information for the class is: {getClass=public final native java.lang.Class java.lang.Object.getClass(), getOrDefault=public java.lang.Object java.util.LinkedHashMap.getOrDefault(java.lang.Object,java.lang.Object), computeIfAbsent=public java.lang.Object java.util.HashMap.computeIfAbsent(java.lang.Object,java.util.function.Function), values=public java.util.Collection java.util.LinkedHashMap.values(), replace=freemarker.ext.beans.OverloadedMethods@11d0265, java.lang.Object@3e55b2={public boolean java.util.HashMap.isEmpty()=[Ljava.lang.Class;@c5aa3a, public int java.util.AbstractMap.hashCode()=[Ljava.lang.Class;@74a947, public java.lang.Object java.util.HashMap.put(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@1615a91, public boolean java.util.AbstractMap.equals(java.lang.Object)=[Ljava.lang.Class;@a46ab2, public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object)=[Ljava.lang.Class;@1c389e6, public java.lang.String java.util.AbstractMap.toString()=[Ljava.lang.Class;@a23548, public boolean java.util.HashMap.containsKey(java.lang.Object)=[Ljava.lang.Class;@1be4a9f, public java.util.Set java.util.LinkedHashMap.keySet()=[Ljava.lang.Class;@44c60, public java.lang.Object java.util.HashMap.computeIfAbsent(java.lang.Object,java.util.function.Function)=[Ljava.lang.Class;@10f7dff, public java.lang.Object java.util.HashMap.clone()=[Ljava.lang.Class;@d214e3, public java.lang.Object java.util.LinkedHashMap.getOrDefault(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@1a74254, public java.util.Set java.util.LinkedHashMap.entrySet()=[Ljava.lang.Class;@1c4740c, public void java.util.LinkedHashMap.forEach(java.util.function.BiConsumer)=[Ljava.lang.Class;@1fe0c8e, public java.lang.Object java.util.HashMap.putIfAbsent(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@16f73de, public java.util.Collection java.util.LinkedHashMap.values()=[Ljava.lang.Class;@b3e45, public void java.util.LinkedHashMap.clear()=[Ljava.lang.Class;@a34e5c, public java.lang.Object java.util.HashMap.computeIfPresent(java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1fcb13a, public java.lang.Object java.util.HashMap.compute(java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1a7c258, public final native java.lang.Class java.lang.Object.getClass()=[Ljava.lang.Class;@7397f, public void java.util.HashMap.putAll(java.util.Map)=[Ljava.lang.Class;@59cd, public void java.util.LinkedHashMap.replaceAll(java.util.function.BiFunction)=[Ljava.lang.Class;@994816, public java.lang.Object java.util.HashMap.merge(java.lang.Object,java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1b1e75f, public int java.util.HashMap.size()=[Ljava.lang.Class;@bee157, public boolean java.util.LinkedHashMap.containsValue(java.lang.Object)=[Ljava.lang.Class;@5e0d7c}, replaceAll=public void java.util.LinkedHashMap.replaceAll(java.util.function.BiFunction), remove=freemarker.ext.beans.OverloadedMethods@8d3a99, containsValue=public boolean java.util.LinkedHashMap.containsValue(java.lang.Object), put=public java.lang.Object java.util.HashMap.put(java.lang.Object,java.lang.Object), empty=java.beans.PropertyDescriptor[name=empty; propertyType=boolean; readMethod=public boolean java.util.HashMap.isEmpty()], compute=public java.lang.Object java.util.HashMap.compute(java.lang.Object,java.util.function.BiFunction), hashCode=public int java.util.AbstractMap.hashCode(), putAll=public void java.util.HashMap.putAll(java.util.Map), get=public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object), merge=public java.lang.Object java.util.HashMap.merge(java.lang.Object,java.lang.Object,java.util.function.BiFunction), class=java.beans.PropertyDescriptor[name=class; propertyType=class java.lang.Class; readMethod=public final native java.lang.Class java.lang.Object.getClass()], keySet=public java.util.Set java.util.LinkedHashMap.keySet(), java.lang.Object@1c0f21d=freemarker.ext.beans.OverloadedMethods@d4b988, entrySet=public java.util.Set java.util.LinkedHashMap.entrySet(), java.lang.Object@15be27d=public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object), forEach=public void java.util.LinkedHashMap.forEach(java.util.function.BiConsumer), containsKey=public boolean java.util.HashMap.containsKey(java.lang.Object), isEmpty=public boolean java.util.HashMap.isEmpty(), clear=public void java.util.LinkedHashMap.clear(), computeIfPresent=public java.lang.Object java.util.HashMap.computeIfPresent(java.lang.Object,java.util.function.BiFunction), size=public int java.util.HashMap.size(), equals=public boolean java.util.AbstractMap.equals(java.lang.Object), clone=public java.lang.Object java.util.HashMap.clone(), toString=public java.lang.String java.util.AbstractMap.toString(), putIfAbsent=public java.lang.Object java.util.HashMap.putIfAbsent(java.lang.Object,java.lang.Object)}
[DEBUG] 2017-05-24: 21:05:32 freemarker.log._Log4jLoggerFactory$Log4jLogger.debug(_Log4jLoggerFactory.java:45) :  Key "onchange" was not found on instance of java.util.LinkedHashMap. Introspection information for the class is: {getClass=public final native java.lang.Class java.lang.Object.getClass(), getOrDefault=public java.lang.Object java.util.LinkedHashMap.getOrDefault(java.lang.Object,java.lang.Object), computeIfAbsent=public java.lang.Object java.util.HashMap.computeIfAbsent(java.lang.Object,java.util.function.Function), values=public java.util.Collection java.util.LinkedHashMap.values(), replace=freemarker.ext.beans.OverloadedMethods@11d0265, java.lang.Object@3e55b2={public boolean java.util.HashMap.isEmpty()=[Ljava.lang.Class;@c5aa3a, public int java.util.AbstractMap.hashCode()=[Ljava.lang.Class;@74a947, public java.lang.Object java.util.HashMap.put(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@1615a91, public boolean java.util.AbstractMap.equals(java.lang.Object)=[Ljava.lang.Class;@a46ab2, public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object)=[Ljava.lang.Class;@1c389e6, public java.lang.String java.util.AbstractMap.toString()=[Ljava.lang.Class;@a23548, public boolean java.util.HashMap.containsKey(java.lang.Object)=[Ljava.lang.Class;@1be4a9f, public java.util.Set java.util.LinkedHashMap.keySet()=[Ljava.lang.Class;@44c60, public java.lang.Object java.util.HashMap.computeIfAbsent(java.lang.Object,java.util.function.Function)=[Ljava.lang.Class;@10f7dff, public java.lang.Object java.util.HashMap.clone()=[Ljava.lang.Class;@d214e3, public java.lang.Object java.util.LinkedHashMap.getOrDefault(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@1a74254, public java.util.Set java.util.LinkedHashMap.entrySet()=[Ljava.lang.Class;@1c4740c, public void java.util.LinkedHashMap.forEach(java.util.function.BiConsumer)=[Ljava.lang.Class;@1fe0c8e, public java.lang.Object java.util.HashMap.putIfAbsent(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@16f73de, public java.util.Collection java.util.LinkedHashMap.values()=[Ljava.lang.Class;@b3e45, public void java.util.LinkedHashMap.clear()=[Ljava.lang.Class;@a34e5c, public java.lang.Object java.util.HashMap.computeIfPresent(java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1fcb13a, public java.lang.Object java.util.HashMap.compute(java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1a7c258, public final native java.lang.Class java.lang.Object.getClass()=[Ljava.lang.Class;@7397f, public void java.util.HashMap.putAll(java.util.Map)=[Ljava.lang.Class;@59cd, public void java.util.LinkedHashMap.replaceAll(java.util.function.BiFunction)=[Ljava.lang.Class;@994816, public java.lang.Object java.util.HashMap.merge(java.lang.Object,java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1b1e75f, public int java.util.HashMap.size()=[Ljava.lang.Class;@bee157, public boolean java.util.LinkedHashMap.containsValue(java.lang.Object)=[Ljava.lang.Class;@5e0d7c}, replaceAll=public void java.util.LinkedHashMap.replaceAll(java.util.function.BiFunction), remove=freemarker.ext.beans.OverloadedMethods@8d3a99, containsValue=public boolean java.util.LinkedHashMap.containsValue(java.lang.Object), put=public java.lang.Object java.util.HashMap.put(java.lang.Object,java.lang.Object), empty=java.beans.PropertyDescriptor[name=empty; propertyType=boolean; readMethod=public boolean java.util.HashMap.isEmpty()], compute=public java.lang.Object java.util.HashMap.compute(java.lang.Object,java.util.function.BiFunction), hashCode=public int java.util.AbstractMap.hashCode(), putAll=public void java.util.HashMap.putAll(java.util.Map), get=public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object), merge=public java.lang.Object java.util.HashMap.merge(java.lang.Object,java.lang.Object,java.util.function.BiFunction), class=java.beans.PropertyDescriptor[name=class; propertyType=class java.lang.Class; readMethod=public final native java.lang.Class java.lang.Object.getClass()], keySet=public java.util.Set java.util.LinkedHashMap.keySet(), java.lang.Object@1c0f21d=freemarker.ext.beans.OverloadedMethods@d4b988, entrySet=public java.util.Set java.util.LinkedHashMap.entrySet(), java.lang.Object@15be27d=public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object), forEach=public void java.util.LinkedHashMap.forEach(java.util.function.BiConsumer), containsKey=public boolean java.util.HashMap.containsKey(java.lang.Object), isEmpty=public boolean java.util.HashMap.isEmpty(), clear=public void java.util.LinkedHashMap.clear(), computeIfPresent=public java.lang.Object java.util.HashMap.computeIfPresent(java.lang.Object,java.util.function.BiFunction), size=public int java.util.HashMap.size(), equals=public boolean java.util.AbstractMap.equals(java.lang.Object), clone=public java.lang.Object java.util.HashMap.clone(), toString=public java.lang.String java.util.AbstractMap.toString(), putIfAbsent=public java.lang.Object java.util.HashMap.putIfAbsent(java.lang.Object,java.lang.Object)}
[DEBUG] 2017-05-24: 21:05:32 freemarker.log._Log4jLoggerFactory$Log4jLogger.debug(_Log4jLoggerFactory.java:45) :  TemplateLoader.findTemplateSource("template/~~~xhtml/common-attributes.ftl"): Found
[DEBUG] 2017-05-24: 21:05:32 freemarker.log._Log4jLoggerFactory$Log4jLogger.debug(_Log4jLoggerFactory.java:45) :  "template/~~~xhtml/common-attributes.ftl"("zh_CN", UTF-8, parsed): using cached since jar:file:/D:/maven/repository/org/apache/struts/struts2-core/2.5.10/struts2-core-2.5.10.jar!/template/simple/common-attributes.ftl hasn't changed.
[DEBUG] 2017-05-24: 21:05:32 freemarker.log._Log4jLoggerFactory$Log4jLogger.debug(_Log4jLoggerFactory.java:45) :  Key "accesskey" was not found on instance of java.util.LinkedHashMap. Introspection information for the class is: {getClass=public final native java.lang.Class java.lang.Object.getClass(), getOrDefault=public java.lang.Object java.util.LinkedHashMap.getOrDefault(java.lang.Object,java.lang.Object), computeIfAbsent=public java.lang.Object java.util.HashMap.computeIfAbsent(java.lang.Object,java.util.function.Function), values=public java.util.Collection java.util.LinkedHashMap.values(), replace=freemarker.ext.beans.OverloadedMethods@11d0265, java.lang.Object@3e55b2={public boolean java.util.HashMap.isEmpty()=[Ljava.lang.Class;@c5aa3a, public int java.util.AbstractMap.hashCode()=[Ljava.lang.Class;@74a947, public java.lang.Object java.util.HashMap.put(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@1615a91, public boolean java.util.AbstractMap.equals(java.lang.Object)=[Ljava.lang.Class;@a46ab2, public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object)=[Ljava.lang.Class;@1c389e6, public java.lang.String java.util.AbstractMap.toString()=[Ljava.lang.Class;@a23548, public boolean java.util.HashMap.containsKey(java.lang.Object)=[Ljava.lang.Class;@1be4a9f, public java.util.Set java.util.LinkedHashMap.keySet()=[Ljava.lang.Class;@44c60, public java.lang.Object java.util.HashMap.computeIfAbsent(java.lang.Object,java.util.function.Function)=[Ljava.lang.Class;@10f7dff, public java.lang.Object java.util.HashMap.clone()=[Ljava.lang.Class;@d214e3, public java.lang.Object java.util.LinkedHashMap.getOrDefault(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@1a74254, public java.util.Set java.util.LinkedHashMap.entrySet()=[Ljava.lang.Class;@1c4740c, public void java.util.LinkedHashMap.forEach(java.util.function.BiConsumer)=[Ljava.lang.Class;@1fe0c8e, public java.lang.Object java.util.HashMap.putIfAbsent(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@16f73de, public java.util.Collection java.util.LinkedHashMap.values()=[Ljava.lang.Class;@b3e45, public void java.util.LinkedHashMap.clear()=[Ljava.lang.Class;@a34e5c, public java.lang.Object java.util.HashMap.computeIfPresent(java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1fcb13a, public java.lang.Object java.util.HashMap.compute(java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1a7c258, public final native java.lang.Class java.lang.Object.getClass()=[Ljava.lang.Class;@7397f, public void java.util.HashMap.putAll(java.util.Map)=[Ljava.lang.Class;@59cd, public void java.util.LinkedHashMap.replaceAll(java.util.function.BiFunction)=[Ljava.lang.Class;@994816, public java.lang.Object java.util.HashMap.merge(java.lang.Object,java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1b1e75f, public int java.util.HashMap.size()=[Ljava.lang.Class;@bee157, public boolean java.util.LinkedHashMap.containsValue(java.lang.Object)=[Ljava.lang.Class;@5e0d7c}, replaceAll=public void java.util.LinkedHashMap.replaceAll(java.util.function.BiFunction), remove=freemarker.ext.beans.OverloadedMethods@8d3a99, containsValue=public boolean java.util.LinkedHashMap.containsValue(java.lang.Object), put=public java.lang.Object java.util.HashMap.put(java.lang.Object,java.lang.Object), empty=java.beans.PropertyDescriptor[name=empty; propertyType=boolean; readMethod=public boolean java.util.HashMap.isEmpty()], compute=public java.lang.Object java.util.HashMap.compute(java.lang.Object,java.util.function.BiFunction), hashCode=public int java.util.AbstractMap.hashCode(), putAll=public void java.util.HashMap.putAll(java.util.Map), get=public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object), merge=public java.lang.Object java.util.HashMap.merge(java.lang.Object,java.lang.Object,java.util.function.BiFunction), class=java.beans.PropertyDescriptor[name=class; propertyType=class java.lang.Class; readMethod=public final native java.lang.Class java.lang.Object.getClass()], keySet=public java.util.Set java.util.LinkedHashMap.keySet(), java.lang.Object@1c0f21d=freemarker.ext.beans.OverloadedMethods@d4b988, entrySet=public java.util.Set java.util.LinkedHashMap.entrySet(), java.lang.Object@15be27d=public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object), forEach=public void java.util.LinkedHashMap.forEach(java.util.function.BiConsumer), containsKey=public boolean java.util.HashMap.containsKey(java.lang.Object), isEmpty=public boolean java.util.HashMap.isEmpty(), clear=public void java.util.LinkedHashMap.clear(), computeIfPresent=public java.lang.Object java.util.HashMap.computeIfPresent(java.lang.Object,java.util.function.BiFunction), size=public int java.util.HashMap.size(), equals=public boolean java.util.AbstractMap.equals(java.lang.Object), clone=public java.lang.Object java.util.HashMap.clone(), toString=public java.lang.String java.util.AbstractMap.toString(), putIfAbsent=public java.lang.Object java.util.HashMap.putIfAbsent(java.lang.Object,java.lang.Object)}
[DEBUG] 2017-05-24: 21:05:32 freemarker.log._Log4jLoggerFactory$Log4jLogger.debug(_Log4jLoggerFactory.java:45) :  TemplateLoader.findTemplateSource("template/~~~xhtml/dynamic-attributes.ftl"): Found
[DEBUG] 2017-05-24: 21:05:32 freemarker.log._Log4jLoggerFactory$Log4jLogger.debug(_Log4jLoggerFactory.java:45) :  "template/~~~xhtml/dynamic-attributes.ftl"("zh_CN", UTF-8, parsed): using cached since jar:file:/D:/maven/repository/org/apache/struts/struts2-core/2.5.10/struts2-core-2.5.10.jar!/template/simple/dynamic-attributes.ftl hasn't changed.
[DEBUG] 2017-05-24: 21:05:32 freemarker.log._Log4jLoggerFactory$Log4jLogger.debug(_Log4jLoggerFactory.java:45) :  TemplateLoader.findTemplateSource("template/~~~xhtml/controlfooter.ftl"): Found
[DEBUG] 2017-05-24: 21:05:32 freemarker.log._Log4jLoggerFactory$Log4jLogger.debug(_Log4jLoggerFactory.java:45) :  "template/~~~xhtml/controlfooter.ftl"("zh_CN", UTF-8, parsed): using cached since jar:file:/D:/maven/repository/org/apache/struts/struts2-core/2.5.10/struts2-core-2.5.10.jar!/template/xhtml/controlfooter.ftl hasn't changed.
[DEBUG] 2017-05-24: 21:05:32 freemarker.log._Log4jLoggerFactory$Log4jLogger.debug(_Log4jLoggerFactory.java:45) :  Key "after" was not found on instance of java.util.LinkedHashMap. Introspection information for the class is: {getClass=public final native java.lang.Class java.lang.Object.getClass(), getOrDefault=public java.lang.Object java.util.LinkedHashMap.getOrDefault(java.lang.Object,java.lang.Object), computeIfAbsent=public java.lang.Object java.util.HashMap.computeIfAbsent(java.lang.Object,java.util.function.Function), values=public java.util.Collection java.util.LinkedHashMap.values(), replace=freemarker.ext.beans.OverloadedMethods@11d0265, java.lang.Object@3e55b2={public boolean java.util.HashMap.isEmpty()=[Ljava.lang.Class;@c5aa3a, public int java.util.AbstractMap.hashCode()=[Ljava.lang.Class;@74a947, public java.lang.Object java.util.HashMap.put(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@1615a91, public boolean java.util.AbstractMap.equals(java.lang.Object)=[Ljava.lang.Class;@a46ab2, public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object)=[Ljava.lang.Class;@1c389e6, public java.lang.String java.util.AbstractMap.toString()=[Ljava.lang.Class;@a23548, public boolean java.util.HashMap.containsKey(java.lang.Object)=[Ljava.lang.Class;@1be4a9f, public java.util.Set java.util.LinkedHashMap.keySet()=[Ljava.lang.Class;@44c60, public java.lang.Object java.util.HashMap.computeIfAbsent(java.lang.Object,java.util.function.Function)=[Ljava.lang.Class;@10f7dff, public java.lang.Object java.util.HashMap.clone()=[Ljava.lang.Class;@d214e3, public java.lang.Object java.util.LinkedHashMap.getOrDefault(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@1a74254, public java.util.Set java.util.LinkedHashMap.entrySet()=[Ljava.lang.Class;@1c4740c, public void java.util.LinkedHashMap.forEach(java.util.function.BiConsumer)=[Ljava.lang.Class;@1fe0c8e, public java.lang.Object java.util.HashMap.putIfAbsent(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@16f73de, public java.util.Collection java.util.LinkedHashMap.values()=[Ljava.lang.Class;@b3e45, public void java.util.LinkedHashMap.clear()=[Ljava.lang.Class;@a34e5c, public java.lang.Object java.util.HashMap.computeIfPresent(java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1fcb13a, public java.lang.Object java.util.HashMap.compute(java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1a7c258, public final native java.lang.Class java.lang.Object.getClass()=[Ljava.lang.Class;@7397f, public void java.util.HashMap.putAll(java.util.Map)=[Ljava.lang.Class;@59cd, public void java.util.LinkedHashMap.replaceAll(java.util.function.BiFunction)=[Ljava.lang.Class;@994816, public java.lang.Object java.util.HashMap.merge(java.lang.Object,java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1b1e75f, public int java.util.HashMap.size()=[Ljava.lang.Class;@bee157, public boolean java.util.LinkedHashMap.containsValue(java.lang.Object)=[Ljava.lang.Class;@5e0d7c}, replaceAll=public void java.util.LinkedHashMap.replaceAll(java.util.function.BiFunction), remove=freemarker.ext.beans.OverloadedMethods@8d3a99, containsValue=public boolean java.util.LinkedHashMap.containsValue(java.lang.Object), put=public java.lang.Object java.util.HashMap.put(java.lang.Object,java.lang.Object), empty=java.beans.PropertyDescriptor[name=empty; propertyType=boolean; readMethod=public boolean java.util.HashMap.isEmpty()], compute=public java.lang.Object java.util.HashMap.compute(java.lang.Object,java.util.function.BiFunction), hashCode=public int java.util.AbstractMap.hashCode(), putAll=public void java.util.HashMap.putAll(java.util.Map), get=public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object), merge=public java.lang.Object java.util.HashMap.merge(java.lang.Object,java.lang.Object,java.util.function.BiFunction), class=java.beans.PropertyDescriptor[name=class; propertyType=class java.lang.Class; readMethod=public final native java.lang.Class java.lang.Object.getClass()], keySet=public java.util.Set java.util.LinkedHashMap.keySet(), java.lang.Object@1c0f21d=freemarker.ext.beans.OverloadedMethods@d4b988, entrySet=public java.util.Set java.util.LinkedHashMap.entrySet(), java.lang.Object@15be27d=public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object), forEach=public void java.util.LinkedHashMap.forEach(java.util.function.BiConsumer), containsKey=public boolean java.util.HashMap.containsKey(java.lang.Object), isEmpty=public boolean java.util.HashMap.isEmpty(), clear=public void java.util.LinkedHashMap.clear(), computeIfPresent=public java.lang.Object java.util.HashMap.computeIfPresent(java.lang.Object,java.util.function.BiFunction), size=public int java.util.HashMap.size(), equals=public boolean java.util.AbstractMap.equals(java.lang.Object), clone=public java.lang.Object java.util.HashMap.clone(), toString=public java.lang.String java.util.AbstractMap.toString(), putIfAbsent=public java.lang.Object java.util.HashMap.putIfAbsent(java.lang.Object,java.lang.Object)}
[DEBUG] 2017-05-24: 21:05:32 freemarker.log._Log4jLoggerFactory$Log4jLogger.debug(_Log4jLoggerFactory.java:45) :  Key "errorposition" was not found on instance of java.util.LinkedHashMap. Introspection information for the class is: {getClass=public final native java.lang.Class java.lang.Object.getClass(), getOrDefault=public java.lang.Object java.util.LinkedHashMap.getOrDefault(java.lang.Object,java.lang.Object), computeIfAbsent=public java.lang.Object java.util.HashMap.computeIfAbsent(java.lang.Object,java.util.function.Function), values=public java.util.Collection java.util.LinkedHashMap.values(), replace=freemarker.ext.beans.OverloadedMethods@11d0265, java.lang.Object@3e55b2={public boolean java.util.HashMap.isEmpty()=[Ljava.lang.Class;@c5aa3a, public int java.util.AbstractMap.hashCode()=[Ljava.lang.Class;@74a947, public java.lang.Object java.util.HashMap.put(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@1615a91, public boolean java.util.AbstractMap.equals(java.lang.Object)=[Ljava.lang.Class;@a46ab2, public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object)=[Ljava.lang.Class;@1c389e6, public java.lang.String java.util.AbstractMap.toString()=[Ljava.lang.Class;@a23548, public boolean java.util.HashMap.containsKey(java.lang.Object)=[Ljava.lang.Class;@1be4a9f, public java.util.Set java.util.LinkedHashMap.keySet()=[Ljava.lang.Class;@44c60, public java.lang.Object java.util.HashMap.computeIfAbsent(java.lang.Object,java.util.function.Function)=[Ljava.lang.Class;@10f7dff, public java.lang.Object java.util.HashMap.clone()=[Ljava.lang.Class;@d214e3, public java.lang.Object java.util.LinkedHashMap.getOrDefault(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@1a74254, public java.util.Set java.util.LinkedHashMap.entrySet()=[Ljava.lang.Class;@1c4740c, public void java.util.LinkedHashMap.forEach(java.util.function.BiConsumer)=[Ljava.lang.Class;@1fe0c8e, public java.lang.Object java.util.HashMap.putIfAbsent(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@16f73de, public java.util.Collection java.util.LinkedHashMap.values()=[Ljava.lang.Class;@b3e45, public void java.util.LinkedHashMap.clear()=[Ljava.lang.Class;@a34e5c, public java.lang.Object java.util.HashMap.computeIfPresent(java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1fcb13a, public java.lang.Object java.util.HashMap.compute(java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1a7c258, public final native java.lang.Class java.lang.Object.getClass()=[Ljava.lang.Class;@7397f, public void java.util.HashMap.putAll(java.util.Map)=[Ljava.lang.Class;@59cd, public void java.util.LinkedHashMap.replaceAll(java.util.function.BiFunction)=[Ljava.lang.Class;@994816, public java.lang.Object java.util.HashMap.merge(java.lang.Object,java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1b1e75f, public int java.util.HashMap.size()=[Ljava.lang.Class;@bee157, public boolean java.util.LinkedHashMap.containsValue(java.lang.Object)=[Ljava.lang.Class;@5e0d7c}, replaceAll=public void java.util.LinkedHashMap.replaceAll(java.util.function.BiFunction), remove=freemarker.ext.beans.OverloadedMethods@8d3a99, containsValue=public boolean java.util.LinkedHashMap.containsValue(java.lang.Object), put=public java.lang.Object java.util.HashMap.put(java.lang.Object,java.lang.Object), empty=java.beans.PropertyDescriptor[name=empty; propertyType=boolean; readMethod=public boolean java.util.HashMap.isEmpty()], compute=public java.lang.Object java.util.HashMap.compute(java.lang.Object,java.util.function.BiFunction), hashCode=public int java.util.AbstractMap.hashCode(), putAll=public void java.util.HashMap.putAll(java.util.Map), get=public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object), merge=public java.lang.Object java.util.HashMap.merge(java.lang.Object,java.lang.Object,java.util.function.BiFunction), class=java.beans.PropertyDescriptor[name=class; propertyType=class java.lang.Class; readMethod=public final native java.lang.Class java.lang.Object.getClass()], keySet=public java.util.Set java.util.LinkedHashMap.keySet(), java.lang.Object@1c0f21d=freemarker.ext.beans.OverloadedMethods@d4b988, entrySet=public java.util.Set java.util.LinkedHashMap.entrySet(), java.lang.Object@15be27d=public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object), forEach=public void java.util.LinkedHashMap.forEach(java.util.function.BiConsumer), containsKey=public boolean java.util.HashMap.containsKey(java.lang.Object), isEmpty=public boolean java.util.HashMap.isEmpty(), clear=public void java.util.LinkedHashMap.clear(), computeIfPresent=public java.lang.Object java.util.HashMap.computeIfPresent(java.lang.Object,java.util.function.BiFunction), size=public int java.util.HashMap.size(), equals=public boolean java.util.AbstractMap.equals(java.lang.Object), clone=public java.lang.Object java.util.HashMap.clone(), toString=public java.lang.String java.util.AbstractMap.toString(), putIfAbsent=public java.lang.Object java.util.HashMap.putIfAbsent(java.lang.Object,java.lang.Object)}
[DEBUG] 2017-05-24: 21:05:32 freemarker.log._Log4jLoggerFactory$Log4jLogger.debug(_Log4jLoggerFactory.java:45) :  Couldn't find template in cache for "template/xhtml/radiomap.ftl"("zh_CN", UTF-8, parsed); will try to load it.
[DEBUG] 2017-05-24: 21:05:32 freemarker.log._Log4jLoggerFactory$Log4jLogger.debug(_Log4jLoggerFactory.java:45) :  TemplateLoader.findTemplateSource("template/xhtml/radiomap.ftl"): Found
[DEBUG] 2017-05-24: 21:05:32 freemarker.log._Log4jLoggerFactory$Log4jLogger.debug(_Log4jLoggerFactory.java:45) :  Loading template for "template/xhtml/radiomap.ftl"("zh_CN", UTF-8, parsed) from "jar:file:/D:/maven/repository/org/apache/struts/struts2-core/2.5.10/struts2-core-2.5.10.jar!/template/xhtml/radiomap.ftl"
[DEBUG] 2017-05-24: 21:05:32 freemarker.log._Log4jLoggerFactory$Log4jLogger.debug(_Log4jLoggerFactory.java:45) :  TemplateLoader.findTemplateSource("template/~~~xhtml/controlheader.ftl"): Found
[DEBUG] 2017-05-24: 21:05:32 freemarker.log._Log4jLoggerFactory$Log4jLogger.debug(_Log4jLoggerFactory.java:45) :  "template/~~~xhtml/controlheader.ftl"("zh_CN", UTF-8, parsed): using cached since jar:file:/D:/maven/repository/org/apache/struts/struts2-core/2.5.10/struts2-core-2.5.10.jar!/template/xhtml/controlheader.ftl hasn't changed.
[DEBUG] 2017-05-24: 21:05:32 freemarker.log._Log4jLoggerFactory$Log4jLogger.debug(_Log4jLoggerFactory.java:45) :  TemplateLoader.findTemplateSource("template/~~~xhtml/controlheader-core.ftl"): Found
[DEBUG] 2017-05-24: 21:05:32 freemarker.log._Log4jLoggerFactory$Log4jLogger.debug(_Log4jLoggerFactory.java:45) :  "template/~~~xhtml/controlheader-core.ftl"("zh_CN", UTF-8, parsed): using cached since jar:file:/D:/maven/repository/org/apache/struts/struts2-core/2.5.10/struts2-core-2.5.10.jar!/template/xhtml/controlheader-core.ftl hasn't changed.
[DEBUG] 2017-05-24: 21:05:32 freemarker.log._Log4jLoggerFactory$Log4jLogger.debug(_Log4jLoggerFactory.java:45) :  Key "errorposition" was not found on instance of java.util.LinkedHashMap. Introspection information for the class is: {getClass=public final native java.lang.Class java.lang.Object.getClass(), getOrDefault=public java.lang.Object java.util.LinkedHashMap.getOrDefault(java.lang.Object,java.lang.Object), computeIfAbsent=public java.lang.Object java.util.HashMap.computeIfAbsent(java.lang.Object,java.util.function.Function), values=public java.util.Collection java.util.LinkedHashMap.values(), replace=freemarker.ext.beans.OverloadedMethods@11d0265, java.lang.Object@3e55b2={public boolean java.util.HashMap.isEmpty()=[Ljava.lang.Class;@c5aa3a, public int java.util.AbstractMap.hashCode()=[Ljava.lang.Class;@74a947, public java.lang.Object java.util.HashMap.put(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@1615a91, public boolean java.util.AbstractMap.equals(java.lang.Object)=[Ljava.lang.Class;@a46ab2, public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object)=[Ljava.lang.Class;@1c389e6, public java.lang.String java.util.AbstractMap.toString()=[Ljava.lang.Class;@a23548, public boolean java.util.HashMap.containsKey(java.lang.Object)=[Ljava.lang.Class;@1be4a9f, public java.util.Set java.util.LinkedHashMap.keySet()=[Ljava.lang.Class;@44c60, public java.lang.Object java.util.HashMap.computeIfAbsent(java.lang.Object,java.util.function.Function)=[Ljava.lang.Class;@10f7dff, public java.lang.Object java.util.HashMap.clone()=[Ljava.lang.Class;@d214e3, public java.lang.Object java.util.LinkedHashMap.getOrDefault(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@1a74254, public java.util.Set java.util.LinkedHashMap.entrySet()=[Ljava.lang.Class;@1c4740c, public void java.util.LinkedHashMap.forEach(java.util.function.BiConsumer)=[Ljava.lang.Class;@1fe0c8e, public java.lang.Object java.util.HashMap.putIfAbsent(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@16f73de, public java.util.Collection java.util.LinkedHashMap.values()=[Ljava.lang.Class;@b3e45, public void java.util.LinkedHashMap.clear()=[Ljava.lang.Class;@a34e5c, public java.lang.Object java.util.HashMap.computeIfPresent(java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1fcb13a, public java.lang.Object java.util.HashMap.compute(java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1a7c258, public final native java.lang.Class java.lang.Object.getClass()=[Ljava.lang.Class;@7397f, public void java.util.HashMap.putAll(java.util.Map)=[Ljava.lang.Class;@59cd, public void java.util.LinkedHashMap.replaceAll(java.util.function.BiFunction)=[Ljava.lang.Class;@994816, public java.lang.Object java.util.HashMap.merge(java.lang.Object,java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1b1e75f, public int java.util.HashMap.size()=[Ljava.lang.Class;@bee157, public boolean java.util.LinkedHashMap.containsValue(java.lang.Object)=[Ljava.lang.Class;@5e0d7c}, replaceAll=public void java.util.LinkedHashMap.replaceAll(java.util.function.BiFunction), remove=freemarker.ext.beans.OverloadedMethods@8d3a99, containsValue=public boolean java.util.LinkedHashMap.containsValue(java.lang.Object), put=public java.lang.Object java.util.HashMap.put(java.lang.Object,java.lang.Object), empty=java.beans.PropertyDescriptor[name=empty; propertyType=boolean; readMethod=public boolean java.util.HashMap.isEmpty()], compute=public java.lang.Object java.util.HashMap.compute(java.lang.Object,java.util.function.BiFunction), hashCode=public int java.util.AbstractMap.hashCode(), putAll=public void java.util.HashMap.putAll(java.util.Map), get=public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object), merge=public java.lang.Object java.util.HashMap.merge(java.lang.Object,java.lang.Object,java.util.function.BiFunction), class=java.beans.PropertyDescriptor[name=class; propertyType=class java.lang.Class; readMethod=public final native java.lang.Class java.lang.Object.getClass()], keySet=public java.util.Set java.util.LinkedHashMap.keySet(), java.lang.Object@1c0f21d=freemarker.ext.beans.OverloadedMethods@d4b988, entrySet=public java.util.Set java.util.LinkedHashMap.entrySet(), java.lang.Object@15be27d=public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object), forEach=public void java.util.LinkedHashMap.forEach(java.util.function.BiConsumer), containsKey=public boolean java.util.HashMap.containsKey(java.lang.Object), isEmpty=public boolean java.util.HashMap.isEmpty(), clear=public void java.util.LinkedHashMap.clear(), computeIfPresent=public java.lang.Object java.util.HashMap.computeIfPresent(java.lang.Object,java.util.function.BiFunction), size=public int java.util.HashMap.size(), equals=public boolean java.util.AbstractMap.equals(java.lang.Object), clone=public java.lang.Object java.util.HashMap.clone(), toString=public java.lang.String java.util.AbstractMap.toString(), putIfAbsent=public java.lang.Object java.util.HashMap.putIfAbsent(java.lang.Object,java.lang.Object)}
[DEBUG] 2017-05-24: 21:05:32 freemarker.log._Log4jLoggerFactory$Log4jLogger.debug(_Log4jLoggerFactory.java:45) :  Key "labelposition" was not found on instance of java.util.LinkedHashMap. Introspection information for the class is: {getClass=public final native java.lang.Class java.lang.Object.getClass(), getOrDefault=public java.lang.Object java.util.LinkedHashMap.getOrDefault(java.lang.Object,java.lang.Object), computeIfAbsent=public java.lang.Object java.util.HashMap.computeIfAbsent(java.lang.Object,java.util.function.Function), values=public java.util.Collection java.util.LinkedHashMap.values(), replace=freemarker.ext.beans.OverloadedMethods@11d0265, java.lang.Object@3e55b2={public boolean java.util.HashMap.isEmpty()=[Ljava.lang.Class;@c5aa3a, public int java.util.AbstractMap.hashCode()=[Ljava.lang.Class;@74a947, public java.lang.Object java.util.HashMap.put(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@1615a91, public boolean java.util.AbstractMap.equals(java.lang.Object)=[Ljava.lang.Class;@a46ab2, public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object)=[Ljava.lang.Class;@1c389e6, public java.lang.String java.util.AbstractMap.toString()=[Ljava.lang.Class;@a23548, public boolean java.util.HashMap.containsKey(java.lang.Object)=[Ljava.lang.Class;@1be4a9f, public java.util.Set java.util.LinkedHashMap.keySet()=[Ljava.lang.Class;@44c60, public java.lang.Object java.util.HashMap.computeIfAbsent(java.lang.Object,java.util.function.Function)=[Ljava.lang.Class;@10f7dff, public java.lang.Object java.util.HashMap.clone()=[Ljava.lang.Class;@d214e3, public java.lang.Object java.util.LinkedHashMap.getOrDefault(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@1a74254, public java.util.Set java.util.LinkedHashMap.entrySet()=[Ljava.lang.Class;@1c4740c, public void java.util.LinkedHashMap.forEach(java.util.function.BiConsumer)=[Ljava.lang.Class;@1fe0c8e, public java.lang.Object java.util.HashMap.putIfAbsent(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@16f73de, public java.util.Collection java.util.LinkedHashMap.values()=[Ljava.lang.Class;@b3e45, public void java.util.LinkedHashMap.clear()=[Ljava.lang.Class;@a34e5c, public java.lang.Object java.util.HashMap.computeIfPresent(java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1fcb13a, public java.lang.Object java.util.HashMap.compute(java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1a7c258, public final native java.lang.Class java.lang.Object.getClass()=[Ljava.lang.Class;@7397f, public void java.util.HashMap.putAll(java.util.Map)=[Ljava.lang.Class;@59cd, public void java.util.LinkedHashMap.replaceAll(java.util.function.BiFunction)=[Ljava.lang.Class;@994816, public java.lang.Object java.util.HashMap.merge(java.lang.Object,java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1b1e75f, public int java.util.HashMap.size()=[Ljava.lang.Class;@bee157, public boolean java.util.LinkedHashMap.containsValue(java.lang.Object)=[Ljava.lang.Class;@5e0d7c}, replaceAll=public void java.util.LinkedHashMap.replaceAll(java.util.function.BiFunction), remove=freemarker.ext.beans.OverloadedMethods@8d3a99, containsValue=public boolean java.util.LinkedHashMap.containsValue(java.lang.Object), put=public java.lang.Object java.util.HashMap.put(java.lang.Object,java.lang.Object), empty=java.beans.PropertyDescriptor[name=empty; propertyType=boolean; readMethod=public boolean java.util.HashMap.isEmpty()], compute=public java.lang.Object java.util.HashMap.compute(java.lang.Object,java.util.function.BiFunction), hashCode=public int java.util.AbstractMap.hashCode(), putAll=public void java.util.HashMap.putAll(java.util.Map), get=public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object), merge=public java.lang.Object java.util.HashMap.merge(java.lang.Object,java.lang.Object,java.util.function.BiFunction), class=java.beans.PropertyDescriptor[name=class; propertyType=class java.lang.Class; readMethod=public final native java.lang.Class java.lang.Object.getClass()], keySet=public java.util.Set java.util.LinkedHashMap.keySet(), java.lang.Object@1c0f21d=freemarker.ext.beans.OverloadedMethods@d4b988, entrySet=public java.util.Set java.util.LinkedHashMap.entrySet(), java.lang.Object@15be27d=public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object), forEach=public void java.util.LinkedHashMap.forEach(java.util.function.BiConsumer), containsKey=public boolean java.util.HashMap.containsKey(java.lang.Object), isEmpty=public boolean java.util.HashMap.isEmpty(), clear=public void java.util.LinkedHashMap.clear(), computeIfPresent=public java.lang.Object java.util.HashMap.computeIfPresent(java.lang.Object,java.util.function.BiFunction), size=public int java.util.HashMap.size(), equals=public boolean java.util.AbstractMap.equals(java.lang.Object), clone=public java.lang.Object java.util.HashMap.clone(), toString=public java.lang.String java.util.AbstractMap.toString(), putIfAbsent=public java.lang.Object java.util.HashMap.putIfAbsent(java.lang.Object,java.lang.Object)}
[DEBUG] 2017-05-24: 21:05:32 freemarker.log._Log4jLoggerFactory$Log4jLogger.debug(_Log4jLoggerFactory.java:45) :  Key "labelposition" was not found on instance of java.util.LinkedHashMap. Introspection information for the class is: {getClass=public final native java.lang.Class java.lang.Object.getClass(), getOrDefault=public java.lang.Object java.util.LinkedHashMap.getOrDefault(java.lang.Object,java.lang.Object), computeIfAbsent=public java.lang.Object java.util.HashMap.computeIfAbsent(java.lang.Object,java.util.function.Function), values=public java.util.Collection java.util.LinkedHashMap.values(), replace=freemarker.ext.beans.OverloadedMethods@11d0265, java.lang.Object@3e55b2={public boolean java.util.HashMap.isEmpty()=[Ljava.lang.Class;@c5aa3a, public int java.util.AbstractMap.hashCode()=[Ljava.lang.Class;@74a947, public java.lang.Object java.util.HashMap.put(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@1615a91, public boolean java.util.AbstractMap.equals(java.lang.Object)=[Ljava.lang.Class;@a46ab2, public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object)=[Ljava.lang.Class;@1c389e6, public java.lang.String java.util.AbstractMap.toString()=[Ljava.lang.Class;@a23548, public boolean java.util.HashMap.containsKey(java.lang.Object)=[Ljava.lang.Class;@1be4a9f, public java.util.Set java.util.LinkedHashMap.keySet()=[Ljava.lang.Class;@44c60, public java.lang.Object java.util.HashMap.computeIfAbsent(java.lang.Object,java.util.function.Function)=[Ljava.lang.Class;@10f7dff, public java.lang.Object java.util.HashMap.clone()=[Ljava.lang.Class;@d214e3, public java.lang.Object java.util.LinkedHashMap.getOrDefault(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@1a74254, public java.util.Set java.util.LinkedHashMap.entrySet()=[Ljava.lang.Class;@1c4740c, public void java.util.LinkedHashMap.forEach(java.util.function.BiConsumer)=[Ljava.lang.Class;@1fe0c8e, public java.lang.Object java.util.HashMap.putIfAbsent(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@16f73de, public java.util.Collection java.util.LinkedHashMap.values()=[Ljava.lang.Class;@b3e45, public void java.util.LinkedHashMap.clear()=[Ljava.lang.Class;@a34e5c, public java.lang.Object java.util.HashMap.computeIfPresent(java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1fcb13a, public java.lang.Object java.util.HashMap.compute(java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1a7c258, public final native java.lang.Class java.lang.Object.getClass()=[Ljava.lang.Class;@7397f, public void java.util.HashMap.putAll(java.util.Map)=[Ljava.lang.Class;@59cd, public void java.util.LinkedHashMap.replaceAll(java.util.function.BiFunction)=[Ljava.lang.Class;@994816, public java.lang.Object java.util.HashMap.merge(java.lang.Object,java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1b1e75f, public int java.util.HashMap.size()=[Ljava.lang.Class;@bee157, public boolean java.util.LinkedHashMap.containsValue(java.lang.Object)=[Ljava.lang.Class;@5e0d7c}, replaceAll=public void java.util.LinkedHashMap.replaceAll(java.util.function.BiFunction), remove=freemarker.ext.beans.OverloadedMethods@8d3a99, containsValue=public boolean java.util.LinkedHashMap.containsValue(java.lang.Object), put=public java.lang.Object java.util.HashMap.put(java.lang.Object,java.lang.Object), empty=java.beans.PropertyDescriptor[name=empty; propertyType=boolean; readMethod=public boolean java.util.HashMap.isEmpty()], compute=public java.lang.Object java.util.HashMap.compute(java.lang.Object,java.util.function.BiFunction), hashCode=public int java.util.AbstractMap.hashCode(), putAll=public void java.util.HashMap.putAll(java.util.Map), get=public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object), merge=public java.lang.Object java.util.HashMap.merge(java.lang.Object,java.lang.Object,java.util.function.BiFunction), class=java.beans.PropertyDescriptor[name=class; propertyType=class java.lang.Class; readMethod=public final native java.lang.Class java.lang.Object.getClass()], keySet=public java.util.Set java.util.LinkedHashMap.keySet(), java.lang.Object@1c0f21d=freemarker.ext.beans.OverloadedMethods@d4b988, entrySet=public java.util.Set java.util.LinkedHashMap.entrySet(), java.lang.Object@15be27d=public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object), forEach=public void java.util.LinkedHashMap.forEach(java.util.function.BiConsumer), containsKey=public boolean java.util.HashMap.containsKey(java.lang.Object), isEmpty=public boolean java.util.HashMap.isEmpty(), clear=public void java.util.LinkedHashMap.clear(), computeIfPresent=public java.lang.Object java.util.HashMap.computeIfPresent(java.lang.Object,java.util.function.BiFunction), size=public int java.util.HashMap.size(), equals=public boolean java.util.AbstractMap.equals(java.lang.Object), clone=public java.lang.Object java.util.HashMap.clone(), toString=public java.lang.String java.util.AbstractMap.toString(), putIfAbsent=public java.lang.Object java.util.HashMap.putIfAbsent(java.lang.Object,java.lang.Object)}
[DEBUG] 2017-05-24: 21:05:32 freemarker.log._Log4jLoggerFactory$Log4jLogger.debug(_Log4jLoggerFactory.java:45) :  Key "labelposition" was not found on instance of java.util.LinkedHashMap. Introspection information for the class is: {getClass=public final native java.lang.Class java.lang.Object.getClass(), getOrDefault=public java.lang.Object java.util.LinkedHashMap.getOrDefault(java.lang.Object,java.lang.Object), computeIfAbsent=public java.lang.Object java.util.HashMap.computeIfAbsent(java.lang.Object,java.util.function.Function), values=public java.util.Collection java.util.LinkedHashMap.values(), replace=freemarker.ext.beans.OverloadedMethods@11d0265, java.lang.Object@3e55b2={public boolean java.util.HashMap.isEmpty()=[Ljava.lang.Class;@c5aa3a, public int java.util.AbstractMap.hashCode()=[Ljava.lang.Class;@74a947, public java.lang.Object java.util.HashMap.put(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@1615a91, public boolean java.util.AbstractMap.equals(java.lang.Object)=[Ljava.lang.Class;@a46ab2, public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object)=[Ljava.lang.Class;@1c389e6, public java.lang.String java.util.AbstractMap.toString()=[Ljava.lang.Class;@a23548, public boolean java.util.HashMap.containsKey(java.lang.Object)=[Ljava.lang.Class;@1be4a9f, public java.util.Set java.util.LinkedHashMap.keySet()=[Ljava.lang.Class;@44c60, public java.lang.Object java.util.HashMap.computeIfAbsent(java.lang.Object,java.util.function.Function)=[Ljava.lang.Class;@10f7dff, public java.lang.Object java.util.HashMap.clone()=[Ljava.lang.Class;@d214e3, public java.lang.Object java.util.LinkedHashMap.getOrDefault(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@1a74254, public java.util.Set java.util.LinkedHashMap.entrySet()=[Ljava.lang.Class;@1c4740c, public void java.util.LinkedHashMap.forEach(java.util.function.BiConsumer)=[Ljava.lang.Class;@1fe0c8e, public java.lang.Object java.util.HashMap.putIfAbsent(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@16f73de, public java.util.Collection java.util.LinkedHashMap.values()=[Ljava.lang.Class;@b3e45, public void java.util.LinkedHashMap.clear()=[Ljava.lang.Class;@a34e5c, public java.lang.Object java.util.HashMap.computeIfPresent(java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1fcb13a, public java.lang.Object java.util.HashMap.compute(java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1a7c258, public final native java.lang.Class java.lang.Object.getClass()=[Ljava.lang.Class;@7397f, public void java.util.HashMap.putAll(java.util.Map)=[Ljava.lang.Class;@59cd, public void java.util.LinkedHashMap.replaceAll(java.util.function.BiFunction)=[Ljava.lang.Class;@994816, public java.lang.Object java.util.HashMap.merge(java.lang.Object,java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1b1e75f, public int java.util.HashMap.size()=[Ljava.lang.Class;@bee157, public boolean java.util.LinkedHashMap.containsValue(java.lang.Object)=[Ljava.lang.Class;@5e0d7c}, replaceAll=public void java.util.LinkedHashMap.replaceAll(java.util.function.BiFunction), remove=freemarker.ext.beans.OverloadedMethods@8d3a99, containsValue=public boolean java.util.LinkedHashMap.containsValue(java.lang.Object), put=public java.lang.Object java.util.HashMap.put(java.lang.Object,java.lang.Object), empty=java.beans.PropertyDescriptor[name=empty; propertyType=boolean; readMethod=public boolean java.util.HashMap.isEmpty()], compute=public java.lang.Object java.util.HashMap.compute(java.lang.Object,java.util.function.BiFunction), hashCode=public int java.util.AbstractMap.hashCode(), putAll=public void java.util.HashMap.putAll(java.util.Map), get=public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object), merge=public java.lang.Object java.util.HashMap.merge(java.lang.Object,java.lang.Object,java.util.function.BiFunction), class=java.beans.PropertyDescriptor[name=class; propertyType=class java.lang.Class; readMethod=public final native java.lang.Class java.lang.Object.getClass()], keySet=public java.util.Set java.util.LinkedHashMap.keySet(), java.lang.Object@1c0f21d=freemarker.ext.beans.OverloadedMethods@d4b988, entrySet=public java.util.Set java.util.LinkedHashMap.entrySet(), java.lang.Object@15be27d=public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object), forEach=public void java.util.LinkedHashMap.forEach(java.util.function.BiConsumer), containsKey=public boolean java.util.HashMap.containsKey(java.lang.Object), isEmpty=public boolean java.util.HashMap.isEmpty(), clear=public void java.util.LinkedHashMap.clear(), computeIfPresent=public java.lang.Object java.util.HashMap.computeIfPresent(java.lang.Object,java.util.function.BiFunction), size=public int java.util.HashMap.size(), equals=public boolean java.util.AbstractMap.equals(java.lang.Object), clone=public java.lang.Object java.util.HashMap.clone(), toString=public java.lang.String java.util.AbstractMap.toString(), putIfAbsent=public java.lang.Object java.util.HashMap.putIfAbsent(java.lang.Object,java.lang.Object)}
[DEBUG] 2017-05-24: 21:05:32 freemarker.log._Log4jLoggerFactory$Log4jLogger.debug(_Log4jLoggerFactory.java:45) :  Key "required" was not found on instance of java.util.LinkedHashMap. Introspection information for the class is: {getClass=public final native java.lang.Class java.lang.Object.getClass(), getOrDefault=public java.lang.Object java.util.LinkedHashMap.getOrDefault(java.lang.Object,java.lang.Object), computeIfAbsent=public java.lang.Object java.util.HashMap.computeIfAbsent(java.lang.Object,java.util.function.Function), values=public java.util.Collection java.util.LinkedHashMap.values(), replace=freemarker.ext.beans.OverloadedMethods@11d0265, java.lang.Object@3e55b2={public boolean java.util.HashMap.isEmpty()=[Ljava.lang.Class;@c5aa3a, public int java.util.AbstractMap.hashCode()=[Ljava.lang.Class;@74a947, public java.lang.Object java.util.HashMap.put(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@1615a91, public boolean java.util.AbstractMap.equals(java.lang.Object)=[Ljava.lang.Class;@a46ab2, public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object)=[Ljava.lang.Class;@1c389e6, public java.lang.String java.util.AbstractMap.toString()=[Ljava.lang.Class;@a23548, public boolean java.util.HashMap.containsKey(java.lang.Object)=[Ljava.lang.Class;@1be4a9f, public java.util.Set java.util.LinkedHashMap.keySet()=[Ljava.lang.Class;@44c60, public java.lang.Object java.util.HashMap.computeIfAbsent(java.lang.Object,java.util.function.Function)=[Ljava.lang.Class;@10f7dff, public java.lang.Object java.util.HashMap.clone()=[Ljava.lang.Class;@d214e3, public java.lang.Object java.util.LinkedHashMap.getOrDefault(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@1a74254, public java.util.Set java.util.LinkedHashMap.entrySet()=[Ljava.lang.Class;@1c4740c, public void java.util.LinkedHashMap.forEach(java.util.function.BiConsumer)=[Ljava.lang.Class;@1fe0c8e, public java.lang.Object java.util.HashMap.putIfAbsent(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@16f73de, public java.util.Collection java.util.LinkedHashMap.values()=[Ljava.lang.Class;@b3e45, public void java.util.LinkedHashMap.clear()=[Ljava.lang.Class;@a34e5c, public java.lang.Object java.util.HashMap.computeIfPresent(java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1fcb13a, public java.lang.Object java.util.HashMap.compute(java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1a7c258, public final native java.lang.Class java.lang.Object.getClass()=[Ljava.lang.Class;@7397f, public void java.util.HashMap.putAll(java.util.Map)=[Ljava.lang.Class;@59cd, public void java.util.LinkedHashMap.replaceAll(java.util.function.BiFunction)=[Ljava.lang.Class;@994816, public java.lang.Object java.util.HashMap.merge(java.lang.Object,java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1b1e75f, public int java.util.HashMap.size()=[Ljava.lang.Class;@bee157, public boolean java.util.LinkedHashMap.containsValue(java.lang.Object)=[Ljava.lang.Class;@5e0d7c}, replaceAll=public void java.util.LinkedHashMap.replaceAll(java.util.function.BiFunction), remove=freemarker.ext.beans.OverloadedMethods@8d3a99, containsValue=public boolean java.util.LinkedHashMap.containsValue(java.lang.Object), put=public java.lang.Object java.util.HashMap.put(java.lang.Object,java.lang.Object), empty=java.beans.PropertyDescriptor[name=empty; propertyType=boolean; readMethod=public boolean java.util.HashMap.isEmpty()], compute=public java.lang.Object java.util.HashMap.compute(java.lang.Object,java.util.function.BiFunction), hashCode=public int java.util.AbstractMap.hashCode(), putAll=public void java.util.HashMap.putAll(java.util.Map), get=public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object), merge=public java.lang.Object java.util.HashMap.merge(java.lang.Object,java.lang.Object,java.util.function.BiFunction), class=java.beans.PropertyDescriptor[name=class; propertyType=class java.lang.Class; readMethod=public final native java.lang.Class java.lang.Object.getClass()], keySet=public java.util.Set java.util.LinkedHashMap.keySet(), java.lang.Object@1c0f21d=freemarker.ext.beans.OverloadedMethods@d4b988, entrySet=public java.util.Set java.util.LinkedHashMap.entrySet(), java.lang.Object@15be27d=public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object), forEach=public void java.util.LinkedHashMap.forEach(java.util.function.BiConsumer), containsKey=public boolean java.util.HashMap.containsKey(java.lang.Object), isEmpty=public boolean java.util.HashMap.isEmpty(), clear=public void java.util.LinkedHashMap.clear(), computeIfPresent=public java.lang.Object java.util.HashMap.computeIfPresent(java.lang.Object,java.util.function.BiFunction), size=public int java.util.HashMap.size(), equals=public boolean java.util.AbstractMap.equals(java.lang.Object), clone=public java.lang.Object java.util.HashMap.clone(), toString=public java.lang.String java.util.AbstractMap.toString(), putIfAbsent=public java.lang.Object java.util.HashMap.putIfAbsent(java.lang.Object,java.lang.Object)}
[DEBUG] 2017-05-24: 21:05:32 freemarker.log._Log4jLoggerFactory$Log4jLogger.debug(_Log4jLoggerFactory.java:45) :  Key "required" was not found on instance of java.util.LinkedHashMap. Introspection information for the class is: {getClass=public final native java.lang.Class java.lang.Object.getClass(), getOrDefault=public java.lang.Object java.util.LinkedHashMap.getOrDefault(java.lang.Object,java.lang.Object), computeIfAbsent=public java.lang.Object java.util.HashMap.computeIfAbsent(java.lang.Object,java.util.function.Function), values=public java.util.Collection java.util.LinkedHashMap.values(), replace=freemarker.ext.beans.OverloadedMethods@11d0265, java.lang.Object@3e55b2={public boolean java.util.HashMap.isEmpty()=[Ljava.lang.Class;@c5aa3a, public int java.util.AbstractMap.hashCode()=[Ljava.lang.Class;@74a947, public java.lang.Object java.util.HashMap.put(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@1615a91, public boolean java.util.AbstractMap.equals(java.lang.Object)=[Ljava.lang.Class;@a46ab2, public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object)=[Ljava.lang.Class;@1c389e6, public java.lang.String java.util.AbstractMap.toString()=[Ljava.lang.Class;@a23548, public boolean java.util.HashMap.containsKey(java.lang.Object)=[Ljava.lang.Class;@1be4a9f, public java.util.Set java.util.LinkedHashMap.keySet()=[Ljava.lang.Class;@44c60, public java.lang.Object java.util.HashMap.computeIfAbsent(java.lang.Object,java.util.function.Function)=[Ljava.lang.Class;@10f7dff, public java.lang.Object java.util.HashMap.clone()=[Ljava.lang.Class;@d214e3, public java.lang.Object java.util.LinkedHashMap.getOrDefault(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@1a74254, public java.util.Set java.util.LinkedHashMap.entrySet()=[Ljava.lang.Class;@1c4740c, public void java.util.LinkedHashMap.forEach(java.util.function.BiConsumer)=[Ljava.lang.Class;@1fe0c8e, public java.lang.Object java.util.HashMap.putIfAbsent(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@16f73de, public java.util.Collection java.util.LinkedHashMap.values()=[Ljava.lang.Class;@b3e45, public void java.util.LinkedHashMap.clear()=[Ljava.lang.Class;@a34e5c, public java.lang.Object java.util.HashMap.computeIfPresent(java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1fcb13a, public java.lang.Object java.util.HashMap.compute(java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1a7c258, public final native java.lang.Class java.lang.Object.getClass()=[Ljava.lang.Class;@7397f, public void java.util.HashMap.putAll(java.util.Map)=[Ljava.lang.Class;@59cd, public void java.util.LinkedHashMap.replaceAll(java.util.function.BiFunction)=[Ljava.lang.Class;@994816, public java.lang.Object java.util.HashMap.merge(java.lang.Object,java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1b1e75f, public int java.util.HashMap.size()=[Ljava.lang.Class;@bee157, public boolean java.util.LinkedHashMap.containsValue(java.lang.Object)=[Ljava.lang.Class;@5e0d7c}, replaceAll=public void java.util.LinkedHashMap.replaceAll(java.util.function.BiFunction), remove=freemarker.ext.beans.OverloadedMethods@8d3a99, containsValue=public boolean java.util.LinkedHashMap.containsValue(java.lang.Object), put=public java.lang.Object java.util.HashMap.put(java.lang.Object,java.lang.Object), empty=java.beans.PropertyDescriptor[name=empty; propertyType=boolean; readMethod=public boolean java.util.HashMap.isEmpty()], compute=public java.lang.Object java.util.HashMap.compute(java.lang.Object,java.util.function.BiFunction), hashCode=public int java.util.AbstractMap.hashCode(), putAll=public void java.util.HashMap.putAll(java.util.Map), get=public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object), merge=public java.lang.Object java.util.HashMap.merge(java.lang.Object,java.lang.Object,java.util.function.BiFunction), class=java.beans.PropertyDescriptor[name=class; propertyType=class java.lang.Class; readMethod=public final native java.lang.Class java.lang.Object.getClass()], keySet=public java.util.Set java.util.LinkedHashMap.keySet(), java.lang.Object@1c0f21d=freemarker.ext.beans.OverloadedMethods@d4b988, entrySet=public java.util.Set java.util.LinkedHashMap.entrySet(), java.lang.Object@15be27d=public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object), forEach=public void java.util.LinkedHashMap.forEach(java.util.function.BiConsumer), containsKey=public boolean java.util.HashMap.containsKey(java.lang.Object), isEmpty=public boolean java.util.HashMap.isEmpty(), clear=public void java.util.LinkedHashMap.clear(), computeIfPresent=public java.lang.Object java.util.HashMap.computeIfPresent(java.lang.Object,java.util.function.BiFunction), size=public int java.util.HashMap.size(), equals=public boolean java.util.AbstractMap.equals(java.lang.Object), clone=public java.lang.Object java.util.HashMap.clone(), toString=public java.lang.String java.util.AbstractMap.toString(), putIfAbsent=public java.lang.Object java.util.HashMap.putIfAbsent(java.lang.Object,java.lang.Object)}
[DEBUG] 2017-05-24: 21:05:32 freemarker.log._Log4jLoggerFactory$Log4jLogger.debug(_Log4jLoggerFactory.java:45) :  Key "labelseparator" was not found on instance of java.util.LinkedHashMap. Introspection information for the class is: {getClass=public final native java.lang.Class java.lang.Object.getClass(), getOrDefault=public java.lang.Object java.util.LinkedHashMap.getOrDefault(java.lang.Object,java.lang.Object), computeIfAbsent=public java.lang.Object java.util.HashMap.computeIfAbsent(java.lang.Object,java.util.function.Function), values=public java.util.Collection java.util.LinkedHashMap.values(), replace=freemarker.ext.beans.OverloadedMethods@11d0265, java.lang.Object@3e55b2={public boolean java.util.HashMap.isEmpty()=[Ljava.lang.Class;@c5aa3a, public int java.util.AbstractMap.hashCode()=[Ljava.lang.Class;@74a947, public java.lang.Object java.util.HashMap.put(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@1615a91, public boolean java.util.AbstractMap.equals(java.lang.Object)=[Ljava.lang.Class;@a46ab2, public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object)=[Ljava.lang.Class;@1c389e6, public java.lang.String java.util.AbstractMap.toString()=[Ljava.lang.Class;@a23548, public boolean java.util.HashMap.containsKey(java.lang.Object)=[Ljava.lang.Class;@1be4a9f, public java.util.Set java.util.LinkedHashMap.keySet()=[Ljava.lang.Class;@44c60, public java.lang.Object java.util.HashMap.computeIfAbsent(java.lang.Object,java.util.function.Function)=[Ljava.lang.Class;@10f7dff, public java.lang.Object java.util.HashMap.clone()=[Ljava.lang.Class;@d214e3, public java.lang.Object java.util.LinkedHashMap.getOrDefault(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@1a74254, public java.util.Set java.util.LinkedHashMap.entrySet()=[Ljava.lang.Class;@1c4740c, public void java.util.LinkedHashMap.forEach(java.util.function.BiConsumer)=[Ljava.lang.Class;@1fe0c8e, public java.lang.Object java.util.HashMap.putIfAbsent(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@16f73de, public java.util.Collection java.util.LinkedHashMap.values()=[Ljava.lang.Class;@b3e45, public void java.util.LinkedHashMap.clear()=[Ljava.lang.Class;@a34e5c, public java.lang.Object java.util.HashMap.computeIfPresent(java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1fcb13a, public java.lang.Object java.util.HashMap.compute(java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1a7c258, public final native java.lang.Class java.lang.Object.getClass()=[Ljava.lang.Class;@7397f, public void java.util.HashMap.putAll(java.util.Map)=[Ljava.lang.Class;@59cd, public void java.util.LinkedHashMap.replaceAll(java.util.function.BiFunction)=[Ljava.lang.Class;@994816, public java.lang.Object java.util.HashMap.merge(java.lang.Object,java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1b1e75f, public int java.util.HashMap.size()=[Ljava.lang.Class;@bee157, public boolean java.util.LinkedHashMap.containsValue(java.lang.Object)=[Ljava.lang.Class;@5e0d7c}, replaceAll=public void java.util.LinkedHashMap.replaceAll(java.util.function.BiFunction), remove=freemarker.ext.beans.OverloadedMethods@8d3a99, containsValue=public boolean java.util.LinkedHashMap.containsValue(java.lang.Object), put=public java.lang.Object java.util.HashMap.put(java.lang.Object,java.lang.Object), empty=java.beans.PropertyDescriptor[name=empty; propertyType=boolean; readMethod=public boolean java.util.HashMap.isEmpty()], compute=public java.lang.Object java.util.HashMap.compute(java.lang.Object,java.util.function.BiFunction), hashCode=public int java.util.AbstractMap.hashCode(), putAll=public void java.util.HashMap.putAll(java.util.Map), get=public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object), merge=public java.lang.Object java.util.HashMap.merge(java.lang.Object,java.lang.Object,java.util.function.BiFunction), class=java.beans.PropertyDescriptor[name=class; propertyType=class java.lang.Class; readMethod=public final native java.lang.Class java.lang.Object.getClass()], keySet=public java.util.Set java.util.LinkedHashMap.keySet(), java.lang.Object@1c0f21d=freemarker.ext.beans.OverloadedMethods@d4b988, entrySet=public java.util.Set java.util.LinkedHashMap.entrySet(), java.lang.Object@15be27d=public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object), forEach=public void java.util.LinkedHashMap.forEach(java.util.function.BiConsumer), containsKey=public boolean java.util.HashMap.containsKey(java.lang.Object), isEmpty=public boolean java.util.HashMap.isEmpty(), clear=public void java.util.LinkedHashMap.clear(), computeIfPresent=public java.lang.Object java.util.HashMap.computeIfPresent(java.lang.Object,java.util.function.BiFunction), size=public int java.util.HashMap.size(), equals=public boolean java.util.AbstractMap.equals(java.lang.Object), clone=public java.lang.Object java.util.HashMap.clone(), toString=public java.lang.String java.util.AbstractMap.toString(), putIfAbsent=public java.lang.Object java.util.HashMap.putIfAbsent(java.lang.Object,java.lang.Object)}
[DEBUG] 2017-05-24: 21:05:32 freemarker.log._Log4jLoggerFactory$Log4jLogger.debug(_Log4jLoggerFactory.java:45) :  TemplateLoader.findTemplateSource("template/~~~xhtml/tooltip.ftl"): Found
[DEBUG] 2017-05-24: 21:05:32 freemarker.log._Log4jLoggerFactory$Log4jLogger.debug(_Log4jLoggerFactory.java:45) :  "template/~~~xhtml/tooltip.ftl"("zh_CN", UTF-8, parsed): using cached since jar:file:/D:/maven/repository/org/apache/struts/struts2-core/2.5.10/struts2-core-2.5.10.jar!/template/xhtml/tooltip.ftl hasn't changed.
[DEBUG] 2017-05-24: 21:05:32 freemarker.log._Log4jLoggerFactory$Log4jLogger.debug(_Log4jLoggerFactory.java:45) :  Key "tooltip" was not found on instance of java.util.LinkedHashMap. Introspection information for the class is: {getClass=public final native java.lang.Class java.lang.Object.getClass(), getOrDefault=public java.lang.Object java.util.LinkedHashMap.getOrDefault(java.lang.Object,java.lang.Object), computeIfAbsent=public java.lang.Object java.util.HashMap.computeIfAbsent(java.lang.Object,java.util.function.Function), values=public java.util.Collection java.util.LinkedHashMap.values(), replace=freemarker.ext.beans.OverloadedMethods@11d0265, java.lang.Object@3e55b2={public boolean java.util.HashMap.isEmpty()=[Ljava.lang.Class;@c5aa3a, public int java.util.AbstractMap.hashCode()=[Ljava.lang.Class;@74a947, public java.lang.Object java.util.HashMap.put(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@1615a91, public boolean java.util.AbstractMap.equals(java.lang.Object)=[Ljava.lang.Class;@a46ab2, public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object)=[Ljava.lang.Class;@1c389e6, public java.lang.String java.util.AbstractMap.toString()=[Ljava.lang.Class;@a23548, public boolean java.util.HashMap.containsKey(java.lang.Object)=[Ljava.lang.Class;@1be4a9f, public java.util.Set java.util.LinkedHashMap.keySet()=[Ljava.lang.Class;@44c60, public java.lang.Object java.util.HashMap.computeIfAbsent(java.lang.Object,java.util.function.Function)=[Ljava.lang.Class;@10f7dff, public java.lang.Object java.util.HashMap.clone()=[Ljava.lang.Class;@d214e3, public java.lang.Object java.util.LinkedHashMap.getOrDefault(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@1a74254, public java.util.Set java.util.LinkedHashMap.entrySet()=[Ljava.lang.Class;@1c4740c, public void java.util.LinkedHashMap.forEach(java.util.function.BiConsumer)=[Ljava.lang.Class;@1fe0c8e, public java.lang.Object java.util.HashMap.putIfAbsent(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@16f73de, public java.util.Collection java.util.LinkedHashMap.values()=[Ljava.lang.Class;@b3e45, public void java.util.LinkedHashMap.clear()=[Ljava.lang.Class;@a34e5c, public java.lang.Object java.util.HashMap.computeIfPresent(java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1fcb13a, public java.lang.Object java.util.HashMap.compute(java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1a7c258, public final native java.lang.Class java.lang.Object.getClass()=[Ljava.lang.Class;@7397f, public void java.util.HashMap.putAll(java.util.Map)=[Ljava.lang.Class;@59cd, public void java.util.LinkedHashMap.replaceAll(java.util.function.BiFunction)=[Ljava.lang.Class;@994816, public java.lang.Object java.util.HashMap.merge(java.lang.Object,java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1b1e75f, public int java.util.HashMap.size()=[Ljava.lang.Class;@bee157, public boolean java.util.LinkedHashMap.containsValue(java.lang.Object)=[Ljava.lang.Class;@5e0d7c}, replaceAll=public void java.util.LinkedHashMap.replaceAll(java.util.function.BiFunction), remove=freemarker.ext.beans.OverloadedMethods@8d3a99, containsValue=public boolean java.util.LinkedHashMap.containsValue(java.lang.Object), put=public java.lang.Object java.util.HashMap.put(java.lang.Object,java.lang.Object), empty=java.beans.PropertyDescriptor[name=empty; propertyType=boolean; readMethod=public boolean java.util.HashMap.isEmpty()], compute=public java.lang.Object java.util.HashMap.compute(java.lang.Object,java.util.function.BiFunction), hashCode=public int java.util.AbstractMap.hashCode(), putAll=public void java.util.HashMap.putAll(java.util.Map), get=public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object), merge=public java.lang.Object java.util.HashMap.merge(java.lang.Object,java.lang.Object,java.util.function.BiFunction), class=java.beans.PropertyDescriptor[name=class; propertyType=class java.lang.Class; readMethod=public final native java.lang.Class java.lang.Object.getClass()], keySet=public java.util.Set java.util.LinkedHashMap.keySet(), java.lang.Object@1c0f21d=freemarker.ext.beans.OverloadedMethods@d4b988, entrySet=public java.util.Set java.util.LinkedHashMap.entrySet(), java.lang.Object@15be27d=public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object), forEach=public void java.util.LinkedHashMap.forEach(java.util.function.BiConsumer), containsKey=public boolean java.util.HashMap.containsKey(java.lang.Object), isEmpty=public boolean java.util.HashMap.isEmpty(), clear=public void java.util.LinkedHashMap.clear(), computeIfPresent=public java.lang.Object java.util.HashMap.computeIfPresent(java.lang.Object,java.util.function.BiFunction), size=public int java.util.HashMap.size(), equals=public boolean java.util.AbstractMap.equals(java.lang.Object), clone=public java.lang.Object java.util.HashMap.clone(), toString=public java.lang.String java.util.AbstractMap.toString(), putIfAbsent=public java.lang.Object java.util.HashMap.putIfAbsent(java.lang.Object,java.lang.Object)}
[DEBUG] 2017-05-24: 21:05:32 freemarker.log._Log4jLoggerFactory$Log4jLogger.debug(_Log4jLoggerFactory.java:45) :  Key "align" was not found on instance of java.util.LinkedHashMap. Introspection information for the class is: {getClass=public final native java.lang.Class java.lang.Object.getClass(), getOrDefault=public java.lang.Object java.util.LinkedHashMap.getOrDefault(java.lang.Object,java.lang.Object), computeIfAbsent=public java.lang.Object java.util.HashMap.computeIfAbsent(java.lang.Object,java.util.function.Function), values=public java.util.Collection java.util.LinkedHashMap.values(), replace=freemarker.ext.beans.OverloadedMethods@11d0265, java.lang.Object@3e55b2={public boolean java.util.HashMap.isEmpty()=[Ljava.lang.Class;@c5aa3a, public int java.util.AbstractMap.hashCode()=[Ljava.lang.Class;@74a947, public java.lang.Object java.util.HashMap.put(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@1615a91, public boolean java.util.AbstractMap.equals(java.lang.Object)=[Ljava.lang.Class;@a46ab2, public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object)=[Ljava.lang.Class;@1c389e6, public java.lang.String java.util.AbstractMap.toString()=[Ljava.lang.Class;@a23548, public boolean java.util.HashMap.containsKey(java.lang.Object)=[Ljava.lang.Class;@1be4a9f, public java.util.Set java.util.LinkedHashMap.keySet()=[Ljava.lang.Class;@44c60, public java.lang.Object java.util.HashMap.computeIfAbsent(java.lang.Object,java.util.function.Function)=[Ljava.lang.Class;@10f7dff, public java.lang.Object java.util.HashMap.clone()=[Ljava.lang.Class;@d214e3, public java.lang.Object java.util.LinkedHashMap.getOrDefault(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@1a74254, public java.util.Set java.util.LinkedHashMap.entrySet()=[Ljava.lang.Class;@1c4740c, public void java.util.LinkedHashMap.forEach(java.util.function.BiConsumer)=[Ljava.lang.Class;@1fe0c8e, public java.lang.Object java.util.HashMap.putIfAbsent(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@16f73de, public java.util.Collection java.util.LinkedHashMap.values()=[Ljava.lang.Class;@b3e45, public void java.util.LinkedHashMap.clear()=[Ljava.lang.Class;@a34e5c, public java.lang.Object java.util.HashMap.computeIfPresent(java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1fcb13a, public java.lang.Object java.util.HashMap.compute(java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1a7c258, public final native java.lang.Class java.lang.Object.getClass()=[Ljava.lang.Class;@7397f, public void java.util.HashMap.putAll(java.util.Map)=[Ljava.lang.Class;@59cd, public void java.util.LinkedHashMap.replaceAll(java.util.function.BiFunction)=[Ljava.lang.Class;@994816, public java.lang.Object java.util.HashMap.merge(java.lang.Object,java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1b1e75f, public int java.util.HashMap.size()=[Ljava.lang.Class;@bee157, public boolean java.util.LinkedHashMap.containsValue(java.lang.Object)=[Ljava.lang.Class;@5e0d7c}, replaceAll=public void java.util.LinkedHashMap.replaceAll(java.util.function.BiFunction), remove=freemarker.ext.beans.OverloadedMethods@8d3a99, containsValue=public boolean java.util.LinkedHashMap.containsValue(java.lang.Object), put=public java.lang.Object java.util.HashMap.put(java.lang.Object,java.lang.Object), empty=java.beans.PropertyDescriptor[name=empty; propertyType=boolean; readMethod=public boolean java.util.HashMap.isEmpty()], compute=public java.lang.Object java.util.HashMap.compute(java.lang.Object,java.util.function.BiFunction), hashCode=public int java.util.AbstractMap.hashCode(), putAll=public void java.util.HashMap.putAll(java.util.Map), get=public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object), merge=public java.lang.Object java.util.HashMap.merge(java.lang.Object,java.lang.Object,java.util.function.BiFunction), class=java.beans.PropertyDescriptor[name=class; propertyType=class java.lang.Class; readMethod=public final native java.lang.Class java.lang.Object.getClass()], keySet=public java.util.Set java.util.LinkedHashMap.keySet(), java.lang.Object@1c0f21d=freemarker.ext.beans.OverloadedMethods@d4b988, entrySet=public java.util.Set java.util.LinkedHashMap.entrySet(), java.lang.Object@15be27d=public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object), forEach=public void java.util.LinkedHashMap.forEach(java.util.function.BiConsumer), containsKey=public boolean java.util.HashMap.containsKey(java.lang.Object), isEmpty=public boolean java.util.HashMap.isEmpty(), clear=public void java.util.LinkedHashMap.clear(), computeIfPresent=public java.lang.Object java.util.HashMap.computeIfPresent(java.lang.Object,java.util.function.BiFunction), size=public int java.util.HashMap.size(), equals=public boolean java.util.AbstractMap.equals(java.lang.Object), clone=public java.lang.Object java.util.HashMap.clone(), toString=public java.lang.String java.util.AbstractMap.toString(), putIfAbsent=public java.lang.Object java.util.HashMap.putIfAbsent(java.lang.Object,java.lang.Object)}
[DEBUG] 2017-05-24: 21:05:32 freemarker.log._Log4jLoggerFactory$Log4jLogger.debug(_Log4jLoggerFactory.java:45) :  Couldn't find template in cache for "template/simple/radiomap.ftl"("zh_CN", UTF-8, parsed); will try to load it.
[DEBUG] 2017-05-24: 21:05:32 freemarker.log._Log4jLoggerFactory$Log4jLogger.debug(_Log4jLoggerFactory.java:45) :  TemplateLoader.findTemplateSource("template/simple/radiomap.ftl"): Found
[DEBUG] 2017-05-24: 21:05:32 freemarker.log._Log4jLoggerFactory$Log4jLogger.debug(_Log4jLoggerFactory.java:45) :  Loading template for "template/simple/radiomap.ftl"("zh_CN", UTF-8, parsed) from "jar:file:/D:/maven/repository/org/apache/struts/struts2-core/2.5.10/struts2-core-2.5.10.jar!/template/simple/radiomap.ftl"
[DEBUG] 2017-05-24: 21:05:32 freemarker.log._Log4jLoggerFactory$Log4jLogger.debug(_Log4jLoggerFactory.java:45) :  Key "listValueKey" was not found on instance of java.util.LinkedHashMap. Introspection information for the class is: {getClass=public final native java.lang.Class java.lang.Object.getClass(), getOrDefault=public java.lang.Object java.util.LinkedHashMap.getOrDefault(java.lang.Object,java.lang.Object), computeIfAbsent=public java.lang.Object java.util.HashMap.computeIfAbsent(java.lang.Object,java.util.function.Function), values=public java.util.Collection java.util.LinkedHashMap.values(), replace=freemarker.ext.beans.OverloadedMethods@11d0265, java.lang.Object@3e55b2={public boolean java.util.HashMap.isEmpty()=[Ljava.lang.Class;@c5aa3a, public int java.util.AbstractMap.hashCode()=[Ljava.lang.Class;@74a947, public java.lang.Object java.util.HashMap.put(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@1615a91, public boolean java.util.AbstractMap.equals(java.lang.Object)=[Ljava.lang.Class;@a46ab2, public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object)=[Ljava.lang.Class;@1c389e6, public java.lang.String java.util.AbstractMap.toString()=[Ljava.lang.Class;@a23548, public boolean java.util.HashMap.containsKey(java.lang.Object)=[Ljava.lang.Class;@1be4a9f, public java.util.Set java.util.LinkedHashMap.keySet()=[Ljava.lang.Class;@44c60, public java.lang.Object java.util.HashMap.computeIfAbsent(java.lang.Object,java.util.function.Function)=[Ljava.lang.Class;@10f7dff, public java.lang.Object java.util.HashMap.clone()=[Ljava.lang.Class;@d214e3, public java.lang.Object java.util.LinkedHashMap.getOrDefault(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@1a74254, public java.util.Set java.util.LinkedHashMap.entrySet()=[Ljava.lang.Class;@1c4740c, public void java.util.LinkedHashMap.forEach(java.util.function.BiConsumer)=[Ljava.lang.Class;@1fe0c8e, public java.lang.Object java.util.HashMap.putIfAbsent(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@16f73de, public java.util.Collection java.util.LinkedHashMap.values()=[Ljava.lang.Class;@b3e45, public void java.util.LinkedHashMap.clear()=[Ljava.lang.Class;@a34e5c, public java.lang.Object java.util.HashMap.computeIfPresent(java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1fcb13a, public java.lang.Object java.util.HashMap.compute(java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1a7c258, public final native java.lang.Class java.lang.Object.getClass()=[Ljava.lang.Class;@7397f, public void java.util.HashMap.putAll(java.util.Map)=[Ljava.lang.Class;@59cd, public void java.util.LinkedHashMap.replaceAll(java.util.function.BiFunction)=[Ljava.lang.Class;@994816, public java.lang.Object java.util.HashMap.merge(java.lang.Object,java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1b1e75f, public int java.util.HashMap.size()=[Ljava.lang.Class;@bee157, public boolean java.util.LinkedHashMap.containsValue(java.lang.Object)=[Ljava.lang.Class;@5e0d7c}, replaceAll=public void java.util.LinkedHashMap.replaceAll(java.util.function.BiFunction), remove=freemarker.ext.beans.OverloadedMethods@8d3a99, containsValue=public boolean java.util.LinkedHashMap.containsValue(java.lang.Object), put=public java.lang.Object java.util.HashMap.put(java.lang.Object,java.lang.Object), empty=java.beans.PropertyDescriptor[name=empty; propertyType=boolean; readMethod=public boolean java.util.HashMap.isEmpty()], compute=public java.lang.Object java.util.HashMap.compute(java.lang.Object,java.util.function.BiFunction), hashCode=public int java.util.AbstractMap.hashCode(), putAll=public void java.util.HashMap.putAll(java.util.Map), get=public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object), merge=public java.lang.Object java.util.HashMap.merge(java.lang.Object,java.lang.Object,java.util.function.BiFunction), class=java.beans.PropertyDescriptor[name=class; propertyType=class java.lang.Class; readMethod=public final native java.lang.Class java.lang.Object.getClass()], keySet=public java.util.Set java.util.LinkedHashMap.keySet(), java.lang.Object@1c0f21d=freemarker.ext.beans.OverloadedMethods@d4b988, entrySet=public java.util.Set java.util.LinkedHashMap.entrySet(), java.lang.Object@15be27d=public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object), forEach=public void java.util.LinkedHashMap.forEach(java.util.function.BiConsumer), containsKey=public boolean java.util.HashMap.containsKey(java.lang.Object), isEmpty=public boolean java.util.HashMap.isEmpty(), clear=public void java.util.LinkedHashMap.clear(), computeIfPresent=public java.lang.Object java.util.HashMap.computeIfPresent(java.lang.Object,java.util.function.BiFunction), size=public int java.util.HashMap.size(), equals=public boolean java.util.AbstractMap.equals(java.lang.Object), clone=public java.lang.Object java.util.HashMap.clone(), toString=public java.lang.String java.util.AbstractMap.toString(), putIfAbsent=public java.lang.Object java.util.HashMap.putIfAbsent(java.lang.Object,java.lang.Object)}
[DEBUG] 2017-05-24: 21:05:32 freemarker.log._Log4jLoggerFactory$Log4jLogger.debug(_Log4jLoggerFactory.java:45) :  Key "listCssClass" was not found on instance of java.util.LinkedHashMap. Introspection information for the class is: {getClass=public final native java.lang.Class java.lang.Object.getClass(), getOrDefault=public java.lang.Object java.util.LinkedHashMap.getOrDefault(java.lang.Object,java.lang.Object), computeIfAbsent=public java.lang.Object java.util.HashMap.computeIfAbsent(java.lang.Object,java.util.function.Function), values=public java.util.Collection java.util.LinkedHashMap.values(), replace=freemarker.ext.beans.OverloadedMethods@11d0265, java.lang.Object@3e55b2={public boolean java.util.HashMap.isEmpty()=[Ljava.lang.Class;@c5aa3a, public int java.util.AbstractMap.hashCode()=[Ljava.lang.Class;@74a947, public java.lang.Object java.util.HashMap.put(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@1615a91, public boolean java.util.AbstractMap.equals(java.lang.Object)=[Ljava.lang.Class;@a46ab2, public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object)=[Ljava.lang.Class;@1c389e6, public java.lang.String java.util.AbstractMap.toString()=[Ljava.lang.Class;@a23548, public boolean java.util.HashMap.containsKey(java.lang.Object)=[Ljava.lang.Class;@1be4a9f, public java.util.Set java.util.LinkedHashMap.keySet()=[Ljava.lang.Class;@44c60, public java.lang.Object java.util.HashMap.computeIfAbsent(java.lang.Object,java.util.function.Function)=[Ljava.lang.Class;@10f7dff, public java.lang.Object java.util.HashMap.clone()=[Ljava.lang.Class;@d214e3, public java.lang.Object java.util.LinkedHashMap.getOrDefault(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@1a74254, public java.util.Set java.util.LinkedHashMap.entrySet()=[Ljava.lang.Class;@1c4740c, public void java.util.LinkedHashMap.forEach(java.util.function.BiConsumer)=[Ljava.lang.Class;@1fe0c8e, public java.lang.Object java.util.HashMap.putIfAbsent(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@16f73de, public java.util.Collection java.util.LinkedHashMap.values()=[Ljava.lang.Class;@b3e45, public void java.util.LinkedHashMap.clear()=[Ljava.lang.Class;@a34e5c, public java.lang.Object java.util.HashMap.computeIfPresent(java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1fcb13a, public java.lang.Object java.util.HashMap.compute(java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1a7c258, public final native java.lang.Class java.lang.Object.getClass()=[Ljava.lang.Class;@7397f, public void java.util.HashMap.putAll(java.util.Map)=[Ljava.lang.Class;@59cd, public void java.util.LinkedHashMap.replaceAll(java.util.function.BiFunction)=[Ljava.lang.Class;@994816, public java.lang.Object java.util.HashMap.merge(java.lang.Object,java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1b1e75f, public int java.util.HashMap.size()=[Ljava.lang.Class;@bee157, public boolean java.util.LinkedHashMap.containsValue(java.lang.Object)=[Ljava.lang.Class;@5e0d7c}, replaceAll=public void java.util.LinkedHashMap.replaceAll(java.util.function.BiFunction), remove=freemarker.ext.beans.OverloadedMethods@8d3a99, containsValue=public boolean java.util.LinkedHashMap.containsValue(java.lang.Object), put=public java.lang.Object java.util.HashMap.put(java.lang.Object,java.lang.Object), empty=java.beans.PropertyDescriptor[name=empty; propertyType=boolean; readMethod=public boolean java.util.HashMap.isEmpty()], compute=public java.lang.Object java.util.HashMap.compute(java.lang.Object,java.util.function.BiFunction), hashCode=public int java.util.AbstractMap.hashCode(), putAll=public void java.util.HashMap.putAll(java.util.Map), get=public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object), merge=public java.lang.Object java.util.HashMap.merge(java.lang.Object,java.lang.Object,java.util.function.BiFunction), class=java.beans.PropertyDescriptor[name=class; propertyType=class java.lang.Class; readMethod=public final native java.lang.Class java.lang.Object.getClass()], keySet=public java.util.Set java.util.LinkedHashMap.keySet(), java.lang.Object@1c0f21d=freemarker.ext.beans.OverloadedMethods@d4b988, entrySet=public java.util.Set java.util.LinkedHashMap.entrySet(), java.lang.Object@15be27d=public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object), forEach=public void java.util.LinkedHashMap.forEach(java.util.function.BiConsumer), containsKey=public boolean java.util.HashMap.containsKey(java.lang.Object), isEmpty=public boolean java.util.HashMap.isEmpty(), clear=public void java.util.LinkedHashMap.clear(), computeIfPresent=public java.lang.Object java.util.HashMap.computeIfPresent(java.lang.Object,java.util.function.BiFunction), size=public int java.util.HashMap.size(), equals=public boolean java.util.AbstractMap.equals(java.lang.Object), clone=public java.lang.Object java.util.HashMap.clone(), toString=public java.lang.String java.util.AbstractMap.toString(), putIfAbsent=public java.lang.Object java.util.HashMap.putIfAbsent(java.lang.Object,java.lang.Object)}
[DEBUG] 2017-05-24: 21:05:32 freemarker.log._Log4jLoggerFactory$Log4jLogger.debug(_Log4jLoggerFactory.java:45) :  Key "listCssStyle" was not found on instance of java.util.LinkedHashMap. Introspection information for the class is: {getClass=public final native java.lang.Class java.lang.Object.getClass(), getOrDefault=public java.lang.Object java.util.LinkedHashMap.getOrDefault(java.lang.Object,java.lang.Object), computeIfAbsent=public java.lang.Object java.util.HashMap.computeIfAbsent(java.lang.Object,java.util.function.Function), values=public java.util.Collection java.util.LinkedHashMap.values(), replace=freemarker.ext.beans.OverloadedMethods@11d0265, java.lang.Object@3e55b2={public boolean java.util.HashMap.isEmpty()=[Ljava.lang.Class;@c5aa3a, public int java.util.AbstractMap.hashCode()=[Ljava.lang.Class;@74a947, public java.lang.Object java.util.HashMap.put(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@1615a91, public boolean java.util.AbstractMap.equals(java.lang.Object)=[Ljava.lang.Class;@a46ab2, public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object)=[Ljava.lang.Class;@1c389e6, public java.lang.String java.util.AbstractMap.toString()=[Ljava.lang.Class;@a23548, public boolean java.util.HashMap.containsKey(java.lang.Object)=[Ljava.lang.Class;@1be4a9f, public java.util.Set java.util.LinkedHashMap.keySet()=[Ljava.lang.Class;@44c60, public java.lang.Object java.util.HashMap.computeIfAbsent(java.lang.Object,java.util.function.Function)=[Ljava.lang.Class;@10f7dff, public java.lang.Object java.util.HashMap.clone()=[Ljava.lang.Class;@d214e3, public java.lang.Object java.util.LinkedHashMap.getOrDefault(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@1a74254, public java.util.Set java.util.LinkedHashMap.entrySet()=[Ljava.lang.Class;@1c4740c, public void java.util.LinkedHashMap.forEach(java.util.function.BiConsumer)=[Ljava.lang.Class;@1fe0c8e, public java.lang.Object java.util.HashMap.putIfAbsent(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@16f73de, public java.util.Collection java.util.LinkedHashMap.values()=[Ljava.lang.Class;@b3e45, public void java.util.LinkedHashMap.clear()=[Ljava.lang.Class;@a34e5c, public java.lang.Object java.util.HashMap.computeIfPresent(java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1fcb13a, public java.lang.Object java.util.HashMap.compute(java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1a7c258, public final native java.lang.Class java.lang.Object.getClass()=[Ljava.lang.Class;@7397f, public void java.util.HashMap.putAll(java.util.Map)=[Ljava.lang.Class;@59cd, public void java.util.LinkedHashMap.replaceAll(java.util.function.BiFunction)=[Ljava.lang.Class;@994816, public java.lang.Object java.util.HashMap.merge(java.lang.Object,java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1b1e75f, public int java.util.HashMap.size()=[Ljava.lang.Class;@bee157, public boolean java.util.LinkedHashMap.containsValue(java.lang.Object)=[Ljava.lang.Class;@5e0d7c}, replaceAll=public void java.util.LinkedHashMap.replaceAll(java.util.function.BiFunction), remove=freemarker.ext.beans.OverloadedMethods@8d3a99, containsValue=public boolean java.util.LinkedHashMap.containsValue(java.lang.Object), put=public java.lang.Object java.util.HashMap.put(java.lang.Object,java.lang.Object), empty=java.beans.PropertyDescriptor[name=empty; propertyType=boolean; readMethod=public boolean java.util.HashMap.isEmpty()], compute=public java.lang.Object java.util.HashMap.compute(java.lang.Object,java.util.function.BiFunction), hashCode=public int java.util.AbstractMap.hashCode(), putAll=public void java.util.HashMap.putAll(java.util.Map), get=public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object), merge=public java.lang.Object java.util.HashMap.merge(java.lang.Object,java.lang.Object,java.util.function.BiFunction), class=java.beans.PropertyDescriptor[name=class; propertyType=class java.lang.Class; readMethod=public final native java.lang.Class java.lang.Object.getClass()], keySet=public java.util.Set java.util.LinkedHashMap.keySet(), java.lang.Object@1c0f21d=freemarker.ext.beans.OverloadedMethods@d4b988, entrySet=public java.util.Set java.util.LinkedHashMap.entrySet(), java.lang.Object@15be27d=public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object), forEach=public void java.util.LinkedHashMap.forEach(java.util.function.BiConsumer), containsKey=public boolean java.util.HashMap.containsKey(java.lang.Object), isEmpty=public boolean java.util.HashMap.isEmpty(), clear=public void java.util.LinkedHashMap.clear(), computeIfPresent=public java.lang.Object java.util.HashMap.computeIfPresent(java.lang.Object,java.util.function.BiFunction), size=public int java.util.HashMap.size(), equals=public boolean java.util.AbstractMap.equals(java.lang.Object), clone=public java.lang.Object java.util.HashMap.clone(), toString=public java.lang.String java.util.AbstractMap.toString(), putIfAbsent=public java.lang.Object java.util.HashMap.putIfAbsent(java.lang.Object,java.lang.Object)}
[DEBUG] 2017-05-24: 21:05:32 freemarker.log._Log4jLoggerFactory$Log4jLogger.debug(_Log4jLoggerFactory.java:45) :  Key "listTitle" was not found on instance of java.util.LinkedHashMap. Introspection information for the class is: {getClass=public final native java.lang.Class java.lang.Object.getClass(), getOrDefault=public java.lang.Object java.util.LinkedHashMap.getOrDefault(java.lang.Object,java.lang.Object), computeIfAbsent=public java.lang.Object java.util.HashMap.computeIfAbsent(java.lang.Object,java.util.function.Function), values=public java.util.Collection java.util.LinkedHashMap.values(), replace=freemarker.ext.beans.OverloadedMethods@11d0265, java.lang.Object@3e55b2={public boolean java.util.HashMap.isEmpty()=[Ljava.lang.Class;@c5aa3a, public int java.util.AbstractMap.hashCode()=[Ljava.lang.Class;@74a947, public java.lang.Object java.util.HashMap.put(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@1615a91, public boolean java.util.AbstractMap.equals(java.lang.Object)=[Ljava.lang.Class;@a46ab2, public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object)=[Ljava.lang.Class;@1c389e6, public java.lang.String java.util.AbstractMap.toString()=[Ljava.lang.Class;@a23548, public boolean java.util.HashMap.containsKey(java.lang.Object)=[Ljava.lang.Class;@1be4a9f, public java.util.Set java.util.LinkedHashMap.keySet()=[Ljava.lang.Class;@44c60, public java.lang.Object java.util.HashMap.computeIfAbsent(java.lang.Object,java.util.function.Function)=[Ljava.lang.Class;@10f7dff, public java.lang.Object java.util.HashMap.clone()=[Ljava.lang.Class;@d214e3, public java.lang.Object java.util.LinkedHashMap.getOrDefault(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@1a74254, public java.util.Set java.util.LinkedHashMap.entrySet()=[Ljava.lang.Class;@1c4740c, public void java.util.LinkedHashMap.forEach(java.util.function.BiConsumer)=[Ljava.lang.Class;@1fe0c8e, public java.lang.Object java.util.HashMap.putIfAbsent(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@16f73de, public java.util.Collection java.util.LinkedHashMap.values()=[Ljava.lang.Class;@b3e45, public void java.util.LinkedHashMap.clear()=[Ljava.lang.Class;@a34e5c, public java.lang.Object java.util.HashMap.computeIfPresent(java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1fcb13a, public java.lang.Object java.util.HashMap.compute(java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1a7c258, public final native java.lang.Class java.lang.Object.getClass()=[Ljava.lang.Class;@7397f, public void java.util.HashMap.putAll(java.util.Map)=[Ljava.lang.Class;@59cd, public void java.util.LinkedHashMap.replaceAll(java.util.function.BiFunction)=[Ljava.lang.Class;@994816, public java.lang.Object java.util.HashMap.merge(java.lang.Object,java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1b1e75f, public int java.util.HashMap.size()=[Ljava.lang.Class;@bee157, public boolean java.util.LinkedHashMap.containsValue(java.lang.Object)=[Ljava.lang.Class;@5e0d7c}, replaceAll=public void java.util.LinkedHashMap.replaceAll(java.util.function.BiFunction), remove=freemarker.ext.beans.OverloadedMethods@8d3a99, containsValue=public boolean java.util.LinkedHashMap.containsValue(java.lang.Object), put=public java.lang.Object java.util.HashMap.put(java.lang.Object,java.lang.Object), empty=java.beans.PropertyDescriptor[name=empty; propertyType=boolean; readMethod=public boolean java.util.HashMap.isEmpty()], compute=public java.lang.Object java.util.HashMap.compute(java.lang.Object,java.util.function.BiFunction), hashCode=public int java.util.AbstractMap.hashCode(), putAll=public void java.util.HashMap.putAll(java.util.Map), get=public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object), merge=public java.lang.Object java.util.HashMap.merge(java.lang.Object,java.lang.Object,java.util.function.BiFunction), class=java.beans.PropertyDescriptor[name=class; propertyType=class java.lang.Class; readMethod=public final native java.lang.Class java.lang.Object.getClass()], keySet=public java.util.Set java.util.LinkedHashMap.keySet(), java.lang.Object@1c0f21d=freemarker.ext.beans.OverloadedMethods@d4b988, entrySet=public java.util.Set java.util.LinkedHashMap.entrySet(), java.lang.Object@15be27d=public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object), forEach=public void java.util.LinkedHashMap.forEach(java.util.function.BiConsumer), containsKey=public boolean java.util.HashMap.containsKey(java.lang.Object), isEmpty=public boolean java.util.HashMap.isEmpty(), clear=public void java.util.LinkedHashMap.clear(), computeIfPresent=public java.lang.Object java.util.HashMap.computeIfPresent(java.lang.Object,java.util.function.BiFunction), size=public int java.util.HashMap.size(), equals=public boolean java.util.AbstractMap.equals(java.lang.Object), clone=public java.lang.Object java.util.HashMap.clone(), toString=public java.lang.String java.util.AbstractMap.toString(), putIfAbsent=public java.lang.Object java.util.HashMap.putIfAbsent(java.lang.Object,java.lang.Object)}
[DEBUG] 2017-05-24: 21:05:32 freemarker.log._Log4jLoggerFactory$Log4jLogger.debug(_Log4jLoggerFactory.java:45) :  Key "nameValue" was not found on instance of java.util.LinkedHashMap. Introspection information for the class is: {getClass=public final native java.lang.Class java.lang.Object.getClass(), getOrDefault=public java.lang.Object java.util.LinkedHashMap.getOrDefault(java.lang.Object,java.lang.Object), computeIfAbsent=public java.lang.Object java.util.HashMap.computeIfAbsent(java.lang.Object,java.util.function.Function), values=public java.util.Collection java.util.LinkedHashMap.values(), replace=freemarker.ext.beans.OverloadedMethods@11d0265, java.lang.Object@3e55b2={public boolean java.util.HashMap.isEmpty()=[Ljava.lang.Class;@c5aa3a, public int java.util.AbstractMap.hashCode()=[Ljava.lang.Class;@74a947, public java.lang.Object java.util.HashMap.put(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@1615a91, public boolean java.util.AbstractMap.equals(java.lang.Object)=[Ljava.lang.Class;@a46ab2, public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object)=[Ljava.lang.Class;@1c389e6, public java.lang.String java.util.AbstractMap.toString()=[Ljava.lang.Class;@a23548, public boolean java.util.HashMap.containsKey(java.lang.Object)=[Ljava.lang.Class;@1be4a9f, public java.util.Set java.util.LinkedHashMap.keySet()=[Ljava.lang.Class;@44c60, public java.lang.Object java.util.HashMap.computeIfAbsent(java.lang.Object,java.util.function.Function)=[Ljava.lang.Class;@10f7dff, public java.lang.Object java.util.HashMap.clone()=[Ljava.lang.Class;@d214e3, public java.lang.Object java.util.LinkedHashMap.getOrDefault(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@1a74254, public java.util.Set java.util.LinkedHashMap.entrySet()=[Ljava.lang.Class;@1c4740c, public void java.util.LinkedHashMap.forEach(java.util.function.BiConsumer)=[Ljava.lang.Class;@1fe0c8e, public java.lang.Object java.util.HashMap.putIfAbsent(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@16f73de, public java.util.Collection java.util.LinkedHashMap.values()=[Ljava.lang.Class;@b3e45, public void java.util.LinkedHashMap.clear()=[Ljava.lang.Class;@a34e5c, public java.lang.Object java.util.HashMap.computeIfPresent(java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1fcb13a, public java.lang.Object java.util.HashMap.compute(java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1a7c258, public final native java.lang.Class java.lang.Object.getClass()=[Ljava.lang.Class;@7397f, public void java.util.HashMap.putAll(java.util.Map)=[Ljava.lang.Class;@59cd, public void java.util.LinkedHashMap.replaceAll(java.util.function.BiFunction)=[Ljava.lang.Class;@994816, public java.lang.Object java.util.HashMap.merge(java.lang.Object,java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1b1e75f, public int java.util.HashMap.size()=[Ljava.lang.Class;@bee157, public boolean java.util.LinkedHashMap.containsValue(java.lang.Object)=[Ljava.lang.Class;@5e0d7c}, replaceAll=public void java.util.LinkedHashMap.replaceAll(java.util.function.BiFunction), remove=freemarker.ext.beans.OverloadedMethods@8d3a99, containsValue=public boolean java.util.LinkedHashMap.containsValue(java.lang.Object), put=public java.lang.Object java.util.HashMap.put(java.lang.Object,java.lang.Object), empty=java.beans.PropertyDescriptor[name=empty; propertyType=boolean; readMethod=public boolean java.util.HashMap.isEmpty()], compute=public java.lang.Object java.util.HashMap.compute(java.lang.Object,java.util.function.BiFunction), hashCode=public int java.util.AbstractMap.hashCode(), putAll=public void java.util.HashMap.putAll(java.util.Map), get=public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object), merge=public java.lang.Object java.util.HashMap.merge(java.lang.Object,java.lang.Object,java.util.function.BiFunction), class=java.beans.PropertyDescriptor[name=class; propertyType=class java.lang.Class; readMethod=public final native java.lang.Class java.lang.Object.getClass()], keySet=public java.util.Set java.util.LinkedHashMap.keySet(), java.lang.Object@1c0f21d=freemarker.ext.beans.OverloadedMethods@d4b988, entrySet=public java.util.Set java.util.LinkedHashMap.entrySet(), java.lang.Object@15be27d=public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object), forEach=public void java.util.LinkedHashMap.forEach(java.util.function.BiConsumer), containsKey=public boolean java.util.HashMap.containsKey(java.lang.Object), isEmpty=public boolean java.util.HashMap.isEmpty(), clear=public void java.util.LinkedHashMap.clear(), computeIfPresent=public java.lang.Object java.util.HashMap.computeIfPresent(java.lang.Object,java.util.function.BiFunction), size=public int java.util.HashMap.size(), equals=public boolean java.util.AbstractMap.equals(java.lang.Object), clone=public java.lang.Object java.util.HashMap.clone(), toString=public java.lang.String java.util.AbstractMap.toString(), putIfAbsent=public java.lang.Object java.util.HashMap.putIfAbsent(java.lang.Object,java.lang.Object)}
[DEBUG] 2017-05-24: 21:05:32 freemarker.log._Log4jLoggerFactory$Log4jLogger.debug(_Log4jLoggerFactory.java:45) :  Key "disabled" was not found on instance of java.util.LinkedHashMap. Introspection information for the class is: {getClass=public final native java.lang.Class java.lang.Object.getClass(), getOrDefault=public java.lang.Object java.util.LinkedHashMap.getOrDefault(java.lang.Object,java.lang.Object), computeIfAbsent=public java.lang.Object java.util.HashMap.computeIfAbsent(java.lang.Object,java.util.function.Function), values=public java.util.Collection java.util.LinkedHashMap.values(), replace=freemarker.ext.beans.OverloadedMethods@11d0265, java.lang.Object@3e55b2={public boolean java.util.HashMap.isEmpty()=[Ljava.lang.Class;@c5aa3a, public int java.util.AbstractMap.hashCode()=[Ljava.lang.Class;@74a947, public java.lang.Object java.util.HashMap.put(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@1615a91, public boolean java.util.AbstractMap.equals(java.lang.Object)=[Ljava.lang.Class;@a46ab2, public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object)=[Ljava.lang.Class;@1c389e6, public java.lang.String java.util.AbstractMap.toString()=[Ljava.lang.Class;@a23548, public boolean java.util.HashMap.containsKey(java.lang.Object)=[Ljava.lang.Class;@1be4a9f, public java.util.Set java.util.LinkedHashMap.keySet()=[Ljava.lang.Class;@44c60, public java.lang.Object java.util.HashMap.computeIfAbsent(java.lang.Object,java.util.function.Function)=[Ljava.lang.Class;@10f7dff, public java.lang.Object java.util.HashMap.clone()=[Ljava.lang.Class;@d214e3, public java.lang.Object java.util.LinkedHashMap.getOrDefault(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@1a74254, public java.util.Set java.util.LinkedHashMap.entrySet()=[Ljava.lang.Class;@1c4740c, public void java.util.LinkedHashMap.forEach(java.util.function.BiConsumer)=[Ljava.lang.Class;@1fe0c8e, public java.lang.Object java.util.HashMap.putIfAbsent(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@16f73de, public java.util.Collection java.util.LinkedHashMap.values()=[Ljava.lang.Class;@b3e45, public void java.util.LinkedHashMap.clear()=[Ljava.lang.Class;@a34e5c, public java.lang.Object java.util.HashMap.computeIfPresent(java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1fcb13a, public java.lang.Object java.util.HashMap.compute(java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1a7c258, public final native java.lang.Class java.lang.Object.getClass()=[Ljava.lang.Class;@7397f, public void java.util.HashMap.putAll(java.util.Map)=[Ljava.lang.Class;@59cd, public void java.util.LinkedHashMap.replaceAll(java.util.function.BiFunction)=[Ljava.lang.Class;@994816, public java.lang.Object java.util.HashMap.merge(java.lang.Object,java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1b1e75f, public int java.util.HashMap.size()=[Ljava.lang.Class;@bee157, public boolean java.util.LinkedHashMap.containsValue(java.lang.Object)=[Ljava.lang.Class;@5e0d7c}, replaceAll=public void java.util.LinkedHashMap.replaceAll(java.util.function.BiFunction), remove=freemarker.ext.beans.OverloadedMethods@8d3a99, containsValue=public boolean java.util.LinkedHashMap.containsValue(java.lang.Object), put=public java.lang.Object java.util.HashMap.put(java.lang.Object,java.lang.Object), empty=java.beans.PropertyDescriptor[name=empty; propertyType=boolean; readMethod=public boolean java.util.HashMap.isEmpty()], compute=public java.lang.Object java.util.HashMap.compute(java.lang.Object,java.util.function.BiFunction), hashCode=public int java.util.AbstractMap.hashCode(), putAll=public void java.util.HashMap.putAll(java.util.Map), get=public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object), merge=public java.lang.Object java.util.HashMap.merge(java.lang.Object,java.lang.Object,java.util.function.BiFunction), class=java.beans.PropertyDescriptor[name=class; propertyType=class java.lang.Class; readMethod=public final native java.lang.Class java.lang.Object.getClass()], keySet=public java.util.Set java.util.LinkedHashMap.keySet(), java.lang.Object@1c0f21d=freemarker.ext.beans.OverloadedMethods@d4b988, entrySet=public java.util.Set java.util.LinkedHashMap.entrySet(), java.lang.Object@15be27d=public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object), forEach=public void java.util.LinkedHashMap.forEach(java.util.function.BiConsumer), containsKey=public boolean java.util.HashMap.containsKey(java.lang.Object), isEmpty=public boolean java.util.HashMap.isEmpty(), clear=public void java.util.LinkedHashMap.clear(), computeIfPresent=public java.lang.Object java.util.HashMap.computeIfPresent(java.lang.Object,java.util.function.BiFunction), size=public int java.util.HashMap.size(), equals=public boolean java.util.AbstractMap.equals(java.lang.Object), clone=public java.lang.Object java.util.HashMap.clone(), toString=public java.lang.String java.util.AbstractMap.toString(), putIfAbsent=public java.lang.Object java.util.HashMap.putIfAbsent(java.lang.Object,java.lang.Object)}
[DEBUG] 2017-05-24: 21:05:32 freemarker.log._Log4jLoggerFactory$Log4jLogger.debug(_Log4jLoggerFactory.java:45) :  Key "tabindex" was not found on instance of java.util.LinkedHashMap. Introspection information for the class is: {getClass=public final native java.lang.Class java.lang.Object.getClass(), getOrDefault=public java.lang.Object java.util.LinkedHashMap.getOrDefault(java.lang.Object,java.lang.Object), computeIfAbsent=public java.lang.Object java.util.HashMap.computeIfAbsent(java.lang.Object,java.util.function.Function), values=public java.util.Collection java.util.LinkedHashMap.values(), replace=freemarker.ext.beans.OverloadedMethods@11d0265, java.lang.Object@3e55b2={public boolean java.util.HashMap.isEmpty()=[Ljava.lang.Class;@c5aa3a, public int java.util.AbstractMap.hashCode()=[Ljava.lang.Class;@74a947, public java.lang.Object java.util.HashMap.put(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@1615a91, public boolean java.util.AbstractMap.equals(java.lang.Object)=[Ljava.lang.Class;@a46ab2, public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object)=[Ljava.lang.Class;@1c389e6, public java.lang.String java.util.AbstractMap.toString()=[Ljava.lang.Class;@a23548, public boolean java.util.HashMap.containsKey(java.lang.Object)=[Ljava.lang.Class;@1be4a9f, public java.util.Set java.util.LinkedHashMap.keySet()=[Ljava.lang.Class;@44c60, public java.lang.Object java.util.HashMap.computeIfAbsent(java.lang.Object,java.util.function.Function)=[Ljava.lang.Class;@10f7dff, public java.lang.Object java.util.HashMap.clone()=[Ljava.lang.Class;@d214e3, public java.lang.Object java.util.LinkedHashMap.getOrDefault(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@1a74254, public java.util.Set java.util.LinkedHashMap.entrySet()=[Ljava.lang.Class;@1c4740c, public void java.util.LinkedHashMap.forEach(java.util.function.BiConsumer)=[Ljava.lang.Class;@1fe0c8e, public java.lang.Object java.util.HashMap.putIfAbsent(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@16f73de, public java.util.Collection java.util.LinkedHashMap.values()=[Ljava.lang.Class;@b3e45, public void java.util.LinkedHashMap.clear()=[Ljava.lang.Class;@a34e5c, public java.lang.Object java.util.HashMap.computeIfPresent(java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1fcb13a, public java.lang.Object java.util.HashMap.compute(java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1a7c258, public final native java.lang.Class java.lang.Object.getClass()=[Ljava.lang.Class;@7397f, public void java.util.HashMap.putAll(java.util.Map)=[Ljava.lang.Class;@59cd, public void java.util.LinkedHashMap.replaceAll(java.util.function.BiFunction)=[Ljava.lang.Class;@994816, public java.lang.Object java.util.HashMap.merge(java.lang.Object,java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1b1e75f, public int java.util.HashMap.size()=[Ljava.lang.Class;@bee157, public boolean java.util.LinkedHashMap.containsValue(java.lang.Object)=[Ljava.lang.Class;@5e0d7c}, replaceAll=public void java.util.LinkedHashMap.replaceAll(java.util.function.BiFunction), remove=freemarker.ext.beans.OverloadedMethods@8d3a99, containsValue=public boolean java.util.LinkedHashMap.containsValue(java.lang.Object), put=public java.lang.Object java.util.HashMap.put(java.lang.Object,java.lang.Object), empty=java.beans.PropertyDescriptor[name=empty; propertyType=boolean; readMethod=public boolean java.util.HashMap.isEmpty()], compute=public java.lang.Object java.util.HashMap.compute(java.lang.Object,java.util.function.BiFunction), hashCode=public int java.util.AbstractMap.hashCode(), putAll=public void java.util.HashMap.putAll(java.util.Map), get=public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object), merge=public java.lang.Object java.util.HashMap.merge(java.lang.Object,java.lang.Object,java.util.function.BiFunction), class=java.beans.PropertyDescriptor[name=class; propertyType=class java.lang.Class; readMethod=public final native java.lang.Class java.lang.Object.getClass()], keySet=public java.util.Set java.util.LinkedHashMap.keySet(), java.lang.Object@1c0f21d=freemarker.ext.beans.OverloadedMethods@d4b988, entrySet=public java.util.Set java.util.LinkedHashMap.entrySet(), java.lang.Object@15be27d=public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object), forEach=public void java.util.LinkedHashMap.forEach(java.util.function.BiConsumer), containsKey=public boolean java.util.HashMap.containsKey(java.lang.Object), isEmpty=public boolean java.util.HashMap.isEmpty(), clear=public void java.util.LinkedHashMap.clear(), computeIfPresent=public java.lang.Object java.util.HashMap.computeIfPresent(java.lang.Object,java.util.function.BiFunction), size=public int java.util.HashMap.size(), equals=public boolean java.util.AbstractMap.equals(java.lang.Object), clone=public java.lang.Object java.util.HashMap.clone(), toString=public java.lang.String java.util.AbstractMap.toString(), putIfAbsent=public java.lang.Object java.util.HashMap.putIfAbsent(java.lang.Object,java.lang.Object)}
[DEBUG] 2017-05-24: 21:05:32 freemarker.log._Log4jLoggerFactory$Log4jLogger.debug(_Log4jLoggerFactory.java:45) :  Key "title" was not found on instance of java.util.LinkedHashMap. Introspection information for the class is: {getClass=public final native java.lang.Class java.lang.Object.getClass(), getOrDefault=public java.lang.Object java.util.LinkedHashMap.getOrDefault(java.lang.Object,java.lang.Object), computeIfAbsent=public java.lang.Object java.util.HashMap.computeIfAbsent(java.lang.Object,java.util.function.Function), values=public java.util.Collection java.util.LinkedHashMap.values(), replace=freemarker.ext.beans.OverloadedMethods@11d0265, java.lang.Object@3e55b2={public boolean java.util.HashMap.isEmpty()=[Ljava.lang.Class;@c5aa3a, public int java.util.AbstractMap.hashCode()=[Ljava.lang.Class;@74a947, public java.lang.Object java.util.HashMap.put(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@1615a91, public boolean java.util.AbstractMap.equals(java.lang.Object)=[Ljava.lang.Class;@a46ab2, public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object)=[Ljava.lang.Class;@1c389e6, public java.lang.String java.util.AbstractMap.toString()=[Ljava.lang.Class;@a23548, public boolean java.util.HashMap.containsKey(java.lang.Object)=[Ljava.lang.Class;@1be4a9f, public java.util.Set java.util.LinkedHashMap.keySet()=[Ljava.lang.Class;@44c60, public java.lang.Object java.util.HashMap.computeIfAbsent(java.lang.Object,java.util.function.Function)=[Ljava.lang.Class;@10f7dff, public java.lang.Object java.util.HashMap.clone()=[Ljava.lang.Class;@d214e3, public java.lang.Object java.util.LinkedHashMap.getOrDefault(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@1a74254, public java.util.Set java.util.LinkedHashMap.entrySet()=[Ljava.lang.Class;@1c4740c, public void java.util.LinkedHashMap.forEach(java.util.function.BiConsumer)=[Ljava.lang.Class;@1fe0c8e, public java.lang.Object java.util.HashMap.putIfAbsent(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@16f73de, public java.util.Collection java.util.LinkedHashMap.values()=[Ljava.lang.Class;@b3e45, public void java.util.LinkedHashMap.clear()=[Ljava.lang.Class;@a34e5c, public java.lang.Object java.util.HashMap.computeIfPresent(java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1fcb13a, public java.lang.Object java.util.HashMap.compute(java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1a7c258, public final native java.lang.Class java.lang.Object.getClass()=[Ljava.lang.Class;@7397f, public void java.util.HashMap.putAll(java.util.Map)=[Ljava.lang.Class;@59cd, public void java.util.LinkedHashMap.replaceAll(java.util.function.BiFunction)=[Ljava.lang.Class;@994816, public java.lang.Object java.util.HashMap.merge(java.lang.Object,java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1b1e75f, public int java.util.HashMap.size()=[Ljava.lang.Class;@bee157, public boolean java.util.LinkedHashMap.containsValue(java.lang.Object)=[Ljava.lang.Class;@5e0d7c}, replaceAll=public void java.util.LinkedHashMap.replaceAll(java.util.function.BiFunction), remove=freemarker.ext.beans.OverloadedMethods@8d3a99, containsValue=public boolean java.util.LinkedHashMap.containsValue(java.lang.Object), put=public java.lang.Object java.util.HashMap.put(java.lang.Object,java.lang.Object), empty=java.beans.PropertyDescriptor[name=empty; propertyType=boolean; readMethod=public boolean java.util.HashMap.isEmpty()], compute=public java.lang.Object java.util.HashMap.compute(java.lang.Object,java.util.function.BiFunction), hashCode=public int java.util.AbstractMap.hashCode(), putAll=public void java.util.HashMap.putAll(java.util.Map), get=public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object), merge=public java.lang.Object java.util.HashMap.merge(java.lang.Object,java.lang.Object,java.util.function.BiFunction), class=java.beans.PropertyDescriptor[name=class; propertyType=class java.lang.Class; readMethod=public final native java.lang.Class java.lang.Object.getClass()], keySet=public java.util.Set java.util.LinkedHashMap.keySet(), java.lang.Object@1c0f21d=freemarker.ext.beans.OverloadedMethods@d4b988, entrySet=public java.util.Set java.util.LinkedHashMap.entrySet(), java.lang.Object@15be27d=public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object), forEach=public void java.util.LinkedHashMap.forEach(java.util.function.BiConsumer), containsKey=public boolean java.util.HashMap.containsKey(java.lang.Object), isEmpty=public boolean java.util.HashMap.isEmpty(), clear=public void java.util.LinkedHashMap.clear(), computeIfPresent=public java.lang.Object java.util.HashMap.computeIfPresent(java.lang.Object,java.util.function.BiFunction), size=public int java.util.HashMap.size(), equals=public boolean java.util.AbstractMap.equals(java.lang.Object), clone=public java.lang.Object java.util.HashMap.clone(), toString=public java.lang.String java.util.AbstractMap.toString(), putIfAbsent=public java.lang.Object java.util.HashMap.putIfAbsent(java.lang.Object,java.lang.Object)}
[DEBUG] 2017-05-24: 21:05:32 freemarker.log._Log4jLoggerFactory$Log4jLogger.debug(_Log4jLoggerFactory.java:45) :  TemplateLoader.findTemplateSource("template/~~~xhtml/css.ftl"): Found
[DEBUG] 2017-05-24: 21:05:32 freemarker.log._Log4jLoggerFactory$Log4jLogger.debug(_Log4jLoggerFactory.java:45) :  "template/~~~xhtml/css.ftl"("zh_CN", UTF-8, parsed): using cached since jar:file:/D:/maven/repository/org/apache/struts/struts2-core/2.5.10/struts2-core-2.5.10.jar!/template/simple/css.ftl hasn't changed.
[DEBUG] 2017-05-24: 21:05:32 freemarker.log._Log4jLoggerFactory$Log4jLogger.debug(_Log4jLoggerFactory.java:45) :  Key "cssClass" was not found on instance of java.util.LinkedHashMap. Introspection information for the class is: {getClass=public final native java.lang.Class java.lang.Object.getClass(), getOrDefault=public java.lang.Object java.util.LinkedHashMap.getOrDefault(java.lang.Object,java.lang.Object), computeIfAbsent=public java.lang.Object java.util.HashMap.computeIfAbsent(java.lang.Object,java.util.function.Function), values=public java.util.Collection java.util.LinkedHashMap.values(), replace=freemarker.ext.beans.OverloadedMethods@11d0265, java.lang.Object@3e55b2={public boolean java.util.HashMap.isEmpty()=[Ljava.lang.Class;@c5aa3a, public int java.util.AbstractMap.hashCode()=[Ljava.lang.Class;@74a947, public java.lang.Object java.util.HashMap.put(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@1615a91, public boolean java.util.AbstractMap.equals(java.lang.Object)=[Ljava.lang.Class;@a46ab2, public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object)=[Ljava.lang.Class;@1c389e6, public java.lang.String java.util.AbstractMap.toString()=[Ljava.lang.Class;@a23548, public boolean java.util.HashMap.containsKey(java.lang.Object)=[Ljava.lang.Class;@1be4a9f, public java.util.Set java.util.LinkedHashMap.keySet()=[Ljava.lang.Class;@44c60, public java.lang.Object java.util.HashMap.computeIfAbsent(java.lang.Object,java.util.function.Function)=[Ljava.lang.Class;@10f7dff, public java.lang.Object java.util.HashMap.clone()=[Ljava.lang.Class;@d214e3, public java.lang.Object java.util.LinkedHashMap.getOrDefault(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@1a74254, public java.util.Set java.util.LinkedHashMap.entrySet()=[Ljava.lang.Class;@1c4740c, public void java.util.LinkedHashMap.forEach(java.util.function.BiConsumer)=[Ljava.lang.Class;@1fe0c8e, public java.lang.Object java.util.HashMap.putIfAbsent(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@16f73de, public java.util.Collection java.util.LinkedHashMap.values()=[Ljava.lang.Class;@b3e45, public void java.util.LinkedHashMap.clear()=[Ljava.lang.Class;@a34e5c, public java.lang.Object java.util.HashMap.computeIfPresent(java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1fcb13a, public java.lang.Object java.util.HashMap.compute(java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1a7c258, public final native java.lang.Class java.lang.Object.getClass()=[Ljava.lang.Class;@7397f, public void java.util.HashMap.putAll(java.util.Map)=[Ljava.lang.Class;@59cd, public void java.util.LinkedHashMap.replaceAll(java.util.function.BiFunction)=[Ljava.lang.Class;@994816, public java.lang.Object java.util.HashMap.merge(java.lang.Object,java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1b1e75f, public int java.util.HashMap.size()=[Ljava.lang.Class;@bee157, public boolean java.util.LinkedHashMap.containsValue(java.lang.Object)=[Ljava.lang.Class;@5e0d7c}, replaceAll=public void java.util.LinkedHashMap.replaceAll(java.util.function.BiFunction), remove=freemarker.ext.beans.OverloadedMethods@8d3a99, containsValue=public boolean java.util.LinkedHashMap.containsValue(java.lang.Object), put=public java.lang.Object java.util.HashMap.put(java.lang.Object,java.lang.Object), empty=java.beans.PropertyDescriptor[name=empty; propertyType=boolean; readMethod=public boolean java.util.HashMap.isEmpty()], compute=public java.lang.Object java.util.HashMap.compute(java.lang.Object,java.util.function.BiFunction), hashCode=public int java.util.AbstractMap.hashCode(), putAll=public void java.util.HashMap.putAll(java.util.Map), get=public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object), merge=public java.lang.Object java.util.HashMap.merge(java.lang.Object,java.lang.Object,java.util.function.BiFunction), class=java.beans.PropertyDescriptor[name=class; propertyType=class java.lang.Class; readMethod=public final native java.lang.Class java.lang.Object.getClass()], keySet=public java.util.Set java.util.LinkedHashMap.keySet(), java.lang.Object@1c0f21d=freemarker.ext.beans.OverloadedMethods@d4b988, entrySet=public java.util.Set java.util.LinkedHashMap.entrySet(), java.lang.Object@15be27d=public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object), forEach=public void java.util.LinkedHashMap.forEach(java.util.function.BiConsumer), containsKey=public boolean java.util.HashMap.containsKey(java.lang.Object), isEmpty=public boolean java.util.HashMap.isEmpty(), clear=public void java.util.LinkedHashMap.clear(), computeIfPresent=public java.lang.Object java.util.HashMap.computeIfPresent(java.lang.Object,java.util.function.BiFunction), size=public int java.util.HashMap.size(), equals=public boolean java.util.AbstractMap.equals(java.lang.Object), clone=public java.lang.Object java.util.HashMap.clone(), toString=public java.lang.String java.util.AbstractMap.toString(), putIfAbsent=public java.lang.Object java.util.HashMap.putIfAbsent(java.lang.Object,java.lang.Object)}
[DEBUG] 2017-05-24: 21:05:32 freemarker.log._Log4jLoggerFactory$Log4jLogger.debug(_Log4jLoggerFactory.java:45) :  Key "cssClass" was not found on instance of java.util.LinkedHashMap. Introspection information for the class is: {getClass=public final native java.lang.Class java.lang.Object.getClass(), getOrDefault=public java.lang.Object java.util.LinkedHashMap.getOrDefault(java.lang.Object,java.lang.Object), computeIfAbsent=public java.lang.Object java.util.HashMap.computeIfAbsent(java.lang.Object,java.util.function.Function), values=public java.util.Collection java.util.LinkedHashMap.values(), replace=freemarker.ext.beans.OverloadedMethods@11d0265, java.lang.Object@3e55b2={public boolean java.util.HashMap.isEmpty()=[Ljava.lang.Class;@c5aa3a, public int java.util.AbstractMap.hashCode()=[Ljava.lang.Class;@74a947, public java.lang.Object java.util.HashMap.put(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@1615a91, public boolean java.util.AbstractMap.equals(java.lang.Object)=[Ljava.lang.Class;@a46ab2, public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object)=[Ljava.lang.Class;@1c389e6, public java.lang.String java.util.AbstractMap.toString()=[Ljava.lang.Class;@a23548, public boolean java.util.HashMap.containsKey(java.lang.Object)=[Ljava.lang.Class;@1be4a9f, public java.util.Set java.util.LinkedHashMap.keySet()=[Ljava.lang.Class;@44c60, public java.lang.Object java.util.HashMap.computeIfAbsent(java.lang.Object,java.util.function.Function)=[Ljava.lang.Class;@10f7dff, public java.lang.Object java.util.HashMap.clone()=[Ljava.lang.Class;@d214e3, public java.lang.Object java.util.LinkedHashMap.getOrDefault(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@1a74254, public java.util.Set java.util.LinkedHashMap.entrySet()=[Ljava.lang.Class;@1c4740c, public void java.util.LinkedHashMap.forEach(java.util.function.BiConsumer)=[Ljava.lang.Class;@1fe0c8e, public java.lang.Object java.util.HashMap.putIfAbsent(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@16f73de, public java.util.Collection java.util.LinkedHashMap.values()=[Ljava.lang.Class;@b3e45, public void java.util.LinkedHashMap.clear()=[Ljava.lang.Class;@a34e5c, public java.lang.Object java.util.HashMap.computeIfPresent(java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1fcb13a, public java.lang.Object java.util.HashMap.compute(java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1a7c258, public final native java.lang.Class java.lang.Object.getClass()=[Ljava.lang.Class;@7397f, public void java.util.HashMap.putAll(java.util.Map)=[Ljava.lang.Class;@59cd, public void java.util.LinkedHashMap.replaceAll(java.util.function.BiFunction)=[Ljava.lang.Class;@994816, public java.lang.Object java.util.HashMap.merge(java.lang.Object,java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1b1e75f, public int java.util.HashMap.size()=[Ljava.lang.Class;@bee157, public boolean java.util.LinkedHashMap.containsValue(java.lang.Object)=[Ljava.lang.Class;@5e0d7c}, replaceAll=public void java.util.LinkedHashMap.replaceAll(java.util.function.BiFunction), remove=freemarker.ext.beans.OverloadedMethods@8d3a99, containsValue=public boolean java.util.LinkedHashMap.containsValue(java.lang.Object), put=public java.lang.Object java.util.HashMap.put(java.lang.Object,java.lang.Object), empty=java.beans.PropertyDescriptor[name=empty; propertyType=boolean; readMethod=public boolean java.util.HashMap.isEmpty()], compute=public java.lang.Object java.util.HashMap.compute(java.lang.Object,java.util.function.BiFunction), hashCode=public int java.util.AbstractMap.hashCode(), putAll=public void java.util.HashMap.putAll(java.util.Map), get=public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object), merge=public java.lang.Object java.util.HashMap.merge(java.lang.Object,java.lang.Object,java.util.function.BiFunction), class=java.beans.PropertyDescriptor[name=class; propertyType=class java.lang.Class; readMethod=public final native java.lang.Class java.lang.Object.getClass()], keySet=public java.util.Set java.util.LinkedHashMap.keySet(), java.lang.Object@1c0f21d=freemarker.ext.beans.OverloadedMethods@d4b988, entrySet=public java.util.Set java.util.LinkedHashMap.entrySet(), java.lang.Object@15be27d=public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object), forEach=public void java.util.LinkedHashMap.forEach(java.util.function.BiConsumer), containsKey=public boolean java.util.HashMap.containsKey(java.lang.Object), isEmpty=public boolean java.util.HashMap.isEmpty(), clear=public void java.util.LinkedHashMap.clear(), computeIfPresent=public java.lang.Object java.util.HashMap.computeIfPresent(java.lang.Object,java.util.function.BiFunction), size=public int java.util.HashMap.size(), equals=public boolean java.util.AbstractMap.equals(java.lang.Object), clone=public java.lang.Object java.util.HashMap.clone(), toString=public java.lang.String java.util.AbstractMap.toString(), putIfAbsent=public java.lang.Object java.util.HashMap.putIfAbsent(java.lang.Object,java.lang.Object)}
[DEBUG] 2017-05-24: 21:05:32 freemarker.log._Log4jLoggerFactory$Log4jLogger.debug(_Log4jLoggerFactory.java:45) :  Key "cssClass" was not found on instance of java.util.LinkedHashMap. Introspection information for the class is: {getClass=public final native java.lang.Class java.lang.Object.getClass(), getOrDefault=public java.lang.Object java.util.LinkedHashMap.getOrDefault(java.lang.Object,java.lang.Object), computeIfAbsent=public java.lang.Object java.util.HashMap.computeIfAbsent(java.lang.Object,java.util.function.Function), values=public java.util.Collection java.util.LinkedHashMap.values(), replace=freemarker.ext.beans.OverloadedMethods@11d0265, java.lang.Object@3e55b2={public boolean java.util.HashMap.isEmpty()=[Ljava.lang.Class;@c5aa3a, public int java.util.AbstractMap.hashCode()=[Ljava.lang.Class;@74a947, public java.lang.Object java.util.HashMap.put(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@1615a91, public boolean java.util.AbstractMap.equals(java.lang.Object)=[Ljava.lang.Class;@a46ab2, public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object)=[Ljava.lang.Class;@1c389e6, public java.lang.String java.util.AbstractMap.toString()=[Ljava.lang.Class;@a23548, public boolean java.util.HashMap.containsKey(java.lang.Object)=[Ljava.lang.Class;@1be4a9f, public java.util.Set java.util.LinkedHashMap.keySet()=[Ljava.lang.Class;@44c60, public java.lang.Object java.util.HashMap.computeIfAbsent(java.lang.Object,java.util.function.Function)=[Ljava.lang.Class;@10f7dff, public java.lang.Object java.util.HashMap.clone()=[Ljava.lang.Class;@d214e3, public java.lang.Object java.util.LinkedHashMap.getOrDefault(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@1a74254, public java.util.Set java.util.LinkedHashMap.entrySet()=[Ljava.lang.Class;@1c4740c, public void java.util.LinkedHashMap.forEach(java.util.function.BiConsumer)=[Ljava.lang.Class;@1fe0c8e, public java.lang.Object java.util.HashMap.putIfAbsent(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@16f73de, public java.util.Collection java.util.LinkedHashMap.values()=[Ljava.lang.Class;@b3e45, public void java.util.LinkedHashMap.clear()=[Ljava.lang.Class;@a34e5c, public java.lang.Object java.util.HashMap.computeIfPresent(java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1fcb13a, public java.lang.Object java.util.HashMap.compute(java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1a7c258, public final native java.lang.Class java.lang.Object.getClass()=[Ljava.lang.Class;@7397f, public void java.util.HashMap.putAll(java.util.Map)=[Ljava.lang.Class;@59cd, public void java.util.LinkedHashMap.replaceAll(java.util.function.BiFunction)=[Ljava.lang.Class;@994816, public java.lang.Object java.util.HashMap.merge(java.lang.Object,java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1b1e75f, public int java.util.HashMap.size()=[Ljava.lang.Class;@bee157, public boolean java.util.LinkedHashMap.containsValue(java.lang.Object)=[Ljava.lang.Class;@5e0d7c}, replaceAll=public void java.util.LinkedHashMap.replaceAll(java.util.function.BiFunction), remove=freemarker.ext.beans.OverloadedMethods@8d3a99, containsValue=public boolean java.util.LinkedHashMap.containsValue(java.lang.Object), put=public java.lang.Object java.util.HashMap.put(java.lang.Object,java.lang.Object), empty=java.beans.PropertyDescriptor[name=empty; propertyType=boolean; readMethod=public boolean java.util.HashMap.isEmpty()], compute=public java.lang.Object java.util.HashMap.compute(java.lang.Object,java.util.function.BiFunction), hashCode=public int java.util.AbstractMap.hashCode(), putAll=public void java.util.HashMap.putAll(java.util.Map), get=public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object), merge=public java.lang.Object java.util.HashMap.merge(java.lang.Object,java.lang.Object,java.util.function.BiFunction), class=java.beans.PropertyDescriptor[name=class; propertyType=class java.lang.Class; readMethod=public final native java.lang.Class java.lang.Object.getClass()], keySet=public java.util.Set java.util.LinkedHashMap.keySet(), java.lang.Object@1c0f21d=freemarker.ext.beans.OverloadedMethods@d4b988, entrySet=public java.util.Set java.util.LinkedHashMap.entrySet(), java.lang.Object@15be27d=public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object), forEach=public void java.util.LinkedHashMap.forEach(java.util.function.BiConsumer), containsKey=public boolean java.util.HashMap.containsKey(java.lang.Object), isEmpty=public boolean java.util.HashMap.isEmpty(), clear=public void java.util.LinkedHashMap.clear(), computeIfPresent=public java.lang.Object java.util.HashMap.computeIfPresent(java.lang.Object,java.util.function.BiFunction), size=public int java.util.HashMap.size(), equals=public boolean java.util.AbstractMap.equals(java.lang.Object), clone=public java.lang.Object java.util.HashMap.clone(), toString=public java.lang.String java.util.AbstractMap.toString(), putIfAbsent=public java.lang.Object java.util.HashMap.putIfAbsent(java.lang.Object,java.lang.Object)}
[DEBUG] 2017-05-24: 21:05:32 freemarker.log._Log4jLoggerFactory$Log4jLogger.debug(_Log4jLoggerFactory.java:45) :  Key "cssStyle" was not found on instance of java.util.LinkedHashMap. Introspection information for the class is: {getClass=public final native java.lang.Class java.lang.Object.getClass(), getOrDefault=public java.lang.Object java.util.LinkedHashMap.getOrDefault(java.lang.Object,java.lang.Object), computeIfAbsent=public java.lang.Object java.util.HashMap.computeIfAbsent(java.lang.Object,java.util.function.Function), values=public java.util.Collection java.util.LinkedHashMap.values(), replace=freemarker.ext.beans.OverloadedMethods@11d0265, java.lang.Object@3e55b2={public boolean java.util.HashMap.isEmpty()=[Ljava.lang.Class;@c5aa3a, public int java.util.AbstractMap.hashCode()=[Ljava.lang.Class;@74a947, public java.lang.Object java.util.HashMap.put(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@1615a91, public boolean java.util.AbstractMap.equals(java.lang.Object)=[Ljava.lang.Class;@a46ab2, public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object)=[Ljava.lang.Class;@1c389e6, public java.lang.String java.util.AbstractMap.toString()=[Ljava.lang.Class;@a23548, public boolean java.util.HashMap.containsKey(java.lang.Object)=[Ljava.lang.Class;@1be4a9f, public java.util.Set java.util.LinkedHashMap.keySet()=[Ljava.lang.Class;@44c60, public java.lang.Object java.util.HashMap.computeIfAbsent(java.lang.Object,java.util.function.Function)=[Ljava.lang.Class;@10f7dff, public java.lang.Object java.util.HashMap.clone()=[Ljava.lang.Class;@d214e3, public java.lang.Object java.util.LinkedHashMap.getOrDefault(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@1a74254, public java.util.Set java.util.LinkedHashMap.entrySet()=[Ljava.lang.Class;@1c4740c, public void java.util.LinkedHashMap.forEach(java.util.function.BiConsumer)=[Ljava.lang.Class;@1fe0c8e, public java.lang.Object java.util.HashMap.putIfAbsent(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@16f73de, public java.util.Collection java.util.LinkedHashMap.values()=[Ljava.lang.Class;@b3e45, public void java.util.LinkedHashMap.clear()=[Ljava.lang.Class;@a34e5c, public java.lang.Object java.util.HashMap.computeIfPresent(java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1fcb13a, public java.lang.Object java.util.HashMap.compute(java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1a7c258, public final native java.lang.Class java.lang.Object.getClass()=[Ljava.lang.Class;@7397f, public void java.util.HashMap.putAll(java.util.Map)=[Ljava.lang.Class;@59cd, public void java.util.LinkedHashMap.replaceAll(java.util.function.BiFunction)=[Ljava.lang.Class;@994816, public java.lang.Object java.util.HashMap.merge(java.lang.Object,java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1b1e75f, public int java.util.HashMap.size()=[Ljava.lang.Class;@bee157, public boolean java.util.LinkedHashMap.containsValue(java.lang.Object)=[Ljava.lang.Class;@5e0d7c}, replaceAll=public void java.util.LinkedHashMap.replaceAll(java.util.function.BiFunction), remove=freemarker.ext.beans.OverloadedMethods@8d3a99, containsValue=public boolean java.util.LinkedHashMap.containsValue(java.lang.Object), put=public java.lang.Object java.util.HashMap.put(java.lang.Object,java.lang.Object), empty=java.beans.PropertyDescriptor[name=empty; propertyType=boolean; readMethod=public boolean java.util.HashMap.isEmpty()], compute=public java.lang.Object java.util.HashMap.compute(java.lang.Object,java.util.function.BiFunction), hashCode=public int java.util.AbstractMap.hashCode(), putAll=public void java.util.HashMap.putAll(java.util.Map), get=public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object), merge=public java.lang.Object java.util.HashMap.merge(java.lang.Object,java.lang.Object,java.util.function.BiFunction), class=java.beans.PropertyDescriptor[name=class; propertyType=class java.lang.Class; readMethod=public final native java.lang.Class java.lang.Object.getClass()], keySet=public java.util.Set java.util.LinkedHashMap.keySet(), java.lang.Object@1c0f21d=freemarker.ext.beans.OverloadedMethods@d4b988, entrySet=public java.util.Set java.util.LinkedHashMap.entrySet(), java.lang.Object@15be27d=public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object), forEach=public void java.util.LinkedHashMap.forEach(java.util.function.BiConsumer), containsKey=public boolean java.util.HashMap.containsKey(java.lang.Object), isEmpty=public boolean java.util.HashMap.isEmpty(), clear=public void java.util.LinkedHashMap.clear(), computeIfPresent=public java.lang.Object java.util.HashMap.computeIfPresent(java.lang.Object,java.util.function.BiFunction), size=public int java.util.HashMap.size(), equals=public boolean java.util.AbstractMap.equals(java.lang.Object), clone=public java.lang.Object java.util.HashMap.clone(), toString=public java.lang.String java.util.AbstractMap.toString(), putIfAbsent=public java.lang.Object java.util.HashMap.putIfAbsent(java.lang.Object,java.lang.Object)}
[DEBUG] 2017-05-24: 21:05:32 freemarker.log._Log4jLoggerFactory$Log4jLogger.debug(_Log4jLoggerFactory.java:45) :  TemplateLoader.findTemplateSource("template/~~~xhtml/scripting-events.ftl"): Found
[DEBUG] 2017-05-24: 21:05:32 freemarker.log._Log4jLoggerFactory$Log4jLogger.debug(_Log4jLoggerFactory.java:45) :  "template/~~~xhtml/scripting-events.ftl"("zh_CN", UTF-8, parsed): using cached since jar:file:/D:/maven/repository/org/apache/struts/struts2-core/2.5.10/struts2-core-2.5.10.jar!/template/simple/scripting-events.ftl hasn't changed.
[DEBUG] 2017-05-24: 21:05:32 freemarker.log._Log4jLoggerFactory$Log4jLogger.debug(_Log4jLoggerFactory.java:45) :  Key "onclick" was not found on instance of java.util.LinkedHashMap. Introspection information for the class is: {getClass=public final native java.lang.Class java.lang.Object.getClass(), getOrDefault=public java.lang.Object java.util.LinkedHashMap.getOrDefault(java.lang.Object,java.lang.Object), computeIfAbsent=public java.lang.Object java.util.HashMap.computeIfAbsent(java.lang.Object,java.util.function.Function), values=public java.util.Collection java.util.LinkedHashMap.values(), replace=freemarker.ext.beans.OverloadedMethods@11d0265, java.lang.Object@3e55b2={public boolean java.util.HashMap.isEmpty()=[Ljava.lang.Class;@c5aa3a, public int java.util.AbstractMap.hashCode()=[Ljava.lang.Class;@74a947, public java.lang.Object java.util.HashMap.put(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@1615a91, public boolean java.util.AbstractMap.equals(java.lang.Object)=[Ljava.lang.Class;@a46ab2, public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object)=[Ljava.lang.Class;@1c389e6, public java.lang.String java.util.AbstractMap.toString()=[Ljava.lang.Class;@a23548, public boolean java.util.HashMap.containsKey(java.lang.Object)=[Ljava.lang.Class;@1be4a9f, public java.util.Set java.util.LinkedHashMap.keySet()=[Ljava.lang.Class;@44c60, public java.lang.Object java.util.HashMap.computeIfAbsent(java.lang.Object,java.util.function.Function)=[Ljava.lang.Class;@10f7dff, public java.lang.Object java.util.HashMap.clone()=[Ljava.lang.Class;@d214e3, public java.lang.Object java.util.LinkedHashMap.getOrDefault(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@1a74254, public java.util.Set java.util.LinkedHashMap.entrySet()=[Ljava.lang.Class;@1c4740c, public void java.util.LinkedHashMap.forEach(java.util.function.BiConsumer)=[Ljava.lang.Class;@1fe0c8e, public java.lang.Object java.util.HashMap.putIfAbsent(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@16f73de, public java.util.Collection java.util.LinkedHashMap.values()=[Ljava.lang.Class;@b3e45, public void java.util.LinkedHashMap.clear()=[Ljava.lang.Class;@a34e5c, public java.lang.Object java.util.HashMap.computeIfPresent(java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1fcb13a, public java.lang.Object java.util.HashMap.compute(java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1a7c258, public final native java.lang.Class java.lang.Object.getClass()=[Ljava.lang.Class;@7397f, public void java.util.HashMap.putAll(java.util.Map)=[Ljava.lang.Class;@59cd, public void java.util.LinkedHashMap.replaceAll(java.util.function.BiFunction)=[Ljava.lang.Class;@994816, public java.lang.Object java.util.HashMap.merge(java.lang.Object,java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1b1e75f, public int java.util.HashMap.size()=[Ljava.lang.Class;@bee157, public boolean java.util.LinkedHashMap.containsValue(java.lang.Object)=[Ljava.lang.Class;@5e0d7c}, replaceAll=public void java.util.LinkedHashMap.replaceAll(java.util.function.BiFunction), remove=freemarker.ext.beans.OverloadedMethods@8d3a99, containsValue=public boolean java.util.LinkedHashMap.containsValue(java.lang.Object), put=public java.lang.Object java.util.HashMap.put(java.lang.Object,java.lang.Object), empty=java.beans.PropertyDescriptor[name=empty; propertyType=boolean; readMethod=public boolean java.util.HashMap.isEmpty()], compute=public java.lang.Object java.util.HashMap.compute(java.lang.Object,java.util.function.BiFunction), hashCode=public int java.util.AbstractMap.hashCode(), putAll=public void java.util.HashMap.putAll(java.util.Map), get=public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object), merge=public java.lang.Object java.util.HashMap.merge(java.lang.Object,java.lang.Object,java.util.function.BiFunction), class=java.beans.PropertyDescriptor[name=class; propertyType=class java.lang.Class; readMethod=public final native java.lang.Class java.lang.Object.getClass()], keySet=public java.util.Set java.util.LinkedHashMap.keySet(), java.lang.Object@1c0f21d=freemarker.ext.beans.OverloadedMethods@d4b988, entrySet=public java.util.Set java.util.LinkedHashMap.entrySet(), java.lang.Object@15be27d=public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object), forEach=public void java.util.LinkedHashMap.forEach(java.util.function.BiConsumer), containsKey=public boolean java.util.HashMap.containsKey(java.lang.Object), isEmpty=public boolean java.util.HashMap.isEmpty(), clear=public void java.util.LinkedHashMap.clear(), computeIfPresent=public java.lang.Object java.util.HashMap.computeIfPresent(java.lang.Object,java.util.function.BiFunction), size=public int java.util.HashMap.size(), equals=public boolean java.util.AbstractMap.equals(java.lang.Object), clone=public java.lang.Object java.util.HashMap.clone(), toString=public java.lang.String java.util.AbstractMap.toString(), putIfAbsent=public java.lang.Object java.util.HashMap.putIfAbsent(java.lang.Object,java.lang.Object)}
[DEBUG] 2017-05-24: 21:05:32 freemarker.log._Log4jLoggerFactory$Log4jLogger.debug(_Log4jLoggerFactory.java:45) :  Key "ondblclick" was not found on instance of java.util.LinkedHashMap. Introspection information for the class is: {getClass=public final native java.lang.Class java.lang.Object.getClass(), getOrDefault=public java.lang.Object java.util.LinkedHashMap.getOrDefault(java.lang.Object,java.lang.Object), computeIfAbsent=public java.lang.Object java.util.HashMap.computeIfAbsent(java.lang.Object,java.util.function.Function), values=public java.util.Collection java.util.LinkedHashMap.values(), replace=freemarker.ext.beans.OverloadedMethods@11d0265, java.lang.Object@3e55b2={public boolean java.util.HashMap.isEmpty()=[Ljava.lang.Class;@c5aa3a, public int java.util.AbstractMap.hashCode()=[Ljava.lang.Class;@74a947, public java.lang.Object java.util.HashMap.put(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@1615a91, public boolean java.util.AbstractMap.equals(java.lang.Object)=[Ljava.lang.Class;@a46ab2, public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object)=[Ljava.lang.Class;@1c389e6, public java.lang.String java.util.AbstractMap.toString()=[Ljava.lang.Class;@a23548, public boolean java.util.HashMap.containsKey(java.lang.Object)=[Ljava.lang.Class;@1be4a9f, public java.util.Set java.util.LinkedHashMap.keySet()=[Ljava.lang.Class;@44c60, public java.lang.Object java.util.HashMap.computeIfAbsent(java.lang.Object,java.util.function.Function)=[Ljava.lang.Class;@10f7dff, public java.lang.Object java.util.HashMap.clone()=[Ljava.lang.Class;@d214e3, public java.lang.Object java.util.LinkedHashMap.getOrDefault(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@1a74254, public java.util.Set java.util.LinkedHashMap.entrySet()=[Ljava.lang.Class;@1c4740c, public void java.util.LinkedHashMap.forEach(java.util.function.BiConsumer)=[Ljava.lang.Class;@1fe0c8e, public java.lang.Object java.util.HashMap.putIfAbsent(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@16f73de, public java.util.Collection java.util.LinkedHashMap.values()=[Ljava.lang.Class;@b3e45, public void java.util.LinkedHashMap.clear()=[Ljava.lang.Class;@a34e5c, public java.lang.Object java.util.HashMap.computeIfPresent(java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1fcb13a, public java.lang.Object java.util.HashMap.compute(java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1a7c258, public final native java.lang.Class java.lang.Object.getClass()=[Ljava.lang.Class;@7397f, public void java.util.HashMap.putAll(java.util.Map)=[Ljava.lang.Class;@59cd, public void java.util.LinkedHashMap.replaceAll(java.util.function.BiFunction)=[Ljava.lang.Class;@994816, public java.lang.Object java.util.HashMap.merge(java.lang.Object,java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1b1e75f, public int java.util.HashMap.size()=[Ljava.lang.Class;@bee157, public boolean java.util.LinkedHashMap.containsValue(java.lang.Object)=[Ljava.lang.Class;@5e0d7c}, replaceAll=public void java.util.LinkedHashMap.replaceAll(java.util.function.BiFunction), remove=freemarker.ext.beans.OverloadedMethods@8d3a99, containsValue=public boolean java.util.LinkedHashMap.containsValue(java.lang.Object), put=public java.lang.Object java.util.HashMap.put(java.lang.Object,java.lang.Object), empty=java.beans.PropertyDescriptor[name=empty; propertyType=boolean; readMethod=public boolean java.util.HashMap.isEmpty()], compute=public java.lang.Object java.util.HashMap.compute(java.lang.Object,java.util.function.BiFunction), hashCode=public int java.util.AbstractMap.hashCode(), putAll=public void java.util.HashMap.putAll(java.util.Map), get=public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object), merge=public java.lang.Object java.util.HashMap.merge(java.lang.Object,java.lang.Object,java.util.function.BiFunction), class=java.beans.PropertyDescriptor[name=class; propertyType=class java.lang.Class; readMethod=public final native java.lang.Class java.lang.Object.getClass()], keySet=public java.util.Set java.util.LinkedHashMap.keySet(), java.lang.Object@1c0f21d=freemarker.ext.beans.OverloadedMethods@d4b988, entrySet=public java.util.Set java.util.LinkedHashMap.entrySet(), java.lang.Object@15be27d=public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object), forEach=public void java.util.LinkedHashMap.forEach(java.util.function.BiConsumer), containsKey=public boolean java.util.HashMap.containsKey(java.lang.Object), isEmpty=public boolean java.util.HashMap.isEmpty(), clear=public void java.util.LinkedHashMap.clear(), computeIfPresent=public java.lang.Object java.util.HashMap.computeIfPresent(java.lang.Object,java.util.function.BiFunction), size=public int java.util.HashMap.size(), equals=public boolean java.util.AbstractMap.equals(java.lang.Object), clone=public java.lang.Object java.util.HashMap.clone(), toString=public java.lang.String java.util.AbstractMap.toString(), putIfAbsent=public java.lang.Object java.util.HashMap.putIfAbsent(java.lang.Object,java.lang.Object)}
[DEBUG] 2017-05-24: 21:05:32 freemarker.log._Log4jLoggerFactory$Log4jLogger.debug(_Log4jLoggerFactory.java:45) :  Key "onmousedown" was not found on instance of java.util.LinkedHashMap. Introspection information for the class is: {getClass=public final native java.lang.Class java.lang.Object.getClass(), getOrDefault=public java.lang.Object java.util.LinkedHashMap.getOrDefault(java.lang.Object,java.lang.Object), computeIfAbsent=public java.lang.Object java.util.HashMap.computeIfAbsent(java.lang.Object,java.util.function.Function), values=public java.util.Collection java.util.LinkedHashMap.values(), replace=freemarker.ext.beans.OverloadedMethods@11d0265, java.lang.Object@3e55b2={public boolean java.util.HashMap.isEmpty()=[Ljava.lang.Class;@c5aa3a, public int java.util.AbstractMap.hashCode()=[Ljava.lang.Class;@74a947, public java.lang.Object java.util.HashMap.put(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@1615a91, public boolean java.util.AbstractMap.equals(java.lang.Object)=[Ljava.lang.Class;@a46ab2, public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object)=[Ljava.lang.Class;@1c389e6, public java.lang.String java.util.AbstractMap.toString()=[Ljava.lang.Class;@a23548, public boolean java.util.HashMap.containsKey(java.lang.Object)=[Ljava.lang.Class;@1be4a9f, public java.util.Set java.util.LinkedHashMap.keySet()=[Ljava.lang.Class;@44c60, public java.lang.Object java.util.HashMap.computeIfAbsent(java.lang.Object,java.util.function.Function)=[Ljava.lang.Class;@10f7dff, public java.lang.Object java.util.HashMap.clone()=[Ljava.lang.Class;@d214e3, public java.lang.Object java.util.LinkedHashMap.getOrDefault(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@1a74254, public java.util.Set java.util.LinkedHashMap.entrySet()=[Ljava.lang.Class;@1c4740c, public void java.util.LinkedHashMap.forEach(java.util.function.BiConsumer)=[Ljava.lang.Class;@1fe0c8e, public java.lang.Object java.util.HashMap.putIfAbsent(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@16f73de, public java.util.Collection java.util.LinkedHashMap.values()=[Ljava.lang.Class;@b3e45, public void java.util.LinkedHashMap.clear()=[Ljava.lang.Class;@a34e5c, public java.lang.Object java.util.HashMap.computeIfPresent(java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1fcb13a, public java.lang.Object java.util.HashMap.compute(java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1a7c258, public final native java.lang.Class java.lang.Object.getClass()=[Ljava.lang.Class;@7397f, public void java.util.HashMap.putAll(java.util.Map)=[Ljava.lang.Class;@59cd, public void java.util.LinkedHashMap.replaceAll(java.util.function.BiFunction)=[Ljava.lang.Class;@994816, public java.lang.Object java.util.HashMap.merge(java.lang.Object,java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1b1e75f, public int java.util.HashMap.size()=[Ljava.lang.Class;@bee157, public boolean java.util.LinkedHashMap.containsValue(java.lang.Object)=[Ljava.lang.Class;@5e0d7c}, replaceAll=public void java.util.LinkedHashMap.replaceAll(java.util.function.BiFunction), remove=freemarker.ext.beans.OverloadedMethods@8d3a99, containsValue=public boolean java.util.LinkedHashMap.containsValue(java.lang.Object), put=public java.lang.Object java.util.HashMap.put(java.lang.Object,java.lang.Object), empty=java.beans.PropertyDescriptor[name=empty; propertyType=boolean; readMethod=public boolean java.util.HashMap.isEmpty()], compute=public java.lang.Object java.util.HashMap.compute(java.lang.Object,java.util.function.BiFunction), hashCode=public int java.util.AbstractMap.hashCode(), putAll=public void java.util.HashMap.putAll(java.util.Map), get=public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object), merge=public java.lang.Object java.util.HashMap.merge(java.lang.Object,java.lang.Object,java.util.function.BiFunction), class=java.beans.PropertyDescriptor[name=class; propertyType=class java.lang.Class; readMethod=public final native java.lang.Class java.lang.Object.getClass()], keySet=public java.util.Set java.util.LinkedHashMap.keySet(), java.lang.Object@1c0f21d=freemarker.ext.beans.OverloadedMethods@d4b988, entrySet=public java.util.Set java.util.LinkedHashMap.entrySet(), java.lang.Object@15be27d=public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object), forEach=public void java.util.LinkedHashMap.forEach(java.util.function.BiConsumer), containsKey=public boolean java.util.HashMap.containsKey(java.lang.Object), isEmpty=public boolean java.util.HashMap.isEmpty(), clear=public void java.util.LinkedHashMap.clear(), computeIfPresent=public java.lang.Object java.util.HashMap.computeIfPresent(java.lang.Object,java.util.function.BiFunction), size=public int java.util.HashMap.size(), equals=public boolean java.util.AbstractMap.equals(java.lang.Object), clone=public java.lang.Object java.util.HashMap.clone(), toString=public java.lang.String java.util.AbstractMap.toString(), putIfAbsent=public java.lang.Object java.util.HashMap.putIfAbsent(java.lang.Object,java.lang.Object)}
[DEBUG] 2017-05-24: 21:05:32 freemarker.log._Log4jLoggerFactory$Log4jLogger.debug(_Log4jLoggerFactory.java:45) :  Key "onmouseup" was not found on instance of java.util.LinkedHashMap. Introspection information for the class is: {getClass=public final native java.lang.Class java.lang.Object.getClass(), getOrDefault=public java.lang.Object java.util.LinkedHashMap.getOrDefault(java.lang.Object,java.lang.Object), computeIfAbsent=public java.lang.Object java.util.HashMap.computeIfAbsent(java.lang.Object,java.util.function.Function), values=public java.util.Collection java.util.LinkedHashMap.values(), replace=freemarker.ext.beans.OverloadedMethods@11d0265, java.lang.Object@3e55b2={public boolean java.util.HashMap.isEmpty()=[Ljava.lang.Class;@c5aa3a, public int java.util.AbstractMap.hashCode()=[Ljava.lang.Class;@74a947, public java.lang.Object java.util.HashMap.put(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@1615a91, public boolean java.util.AbstractMap.equals(java.lang.Object)=[Ljava.lang.Class;@a46ab2, public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object)=[Ljava.lang.Class;@1c389e6, public java.lang.String java.util.AbstractMap.toString()=[Ljava.lang.Class;@a23548, public boolean java.util.HashMap.containsKey(java.lang.Object)=[Ljava.lang.Class;@1be4a9f, public java.util.Set java.util.LinkedHashMap.keySet()=[Ljava.lang.Class;@44c60, public java.lang.Object java.util.HashMap.computeIfAbsent(java.lang.Object,java.util.function.Function)=[Ljava.lang.Class;@10f7dff, public java.lang.Object java.util.HashMap.clone()=[Ljava.lang.Class;@d214e3, public java.lang.Object java.util.LinkedHashMap.getOrDefault(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@1a74254, public java.util.Set java.util.LinkedHashMap.entrySet()=[Ljava.lang.Class;@1c4740c, public void java.util.LinkedHashMap.forEach(java.util.function.BiConsumer)=[Ljava.lang.Class;@1fe0c8e, public java.lang.Object java.util.HashMap.putIfAbsent(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@16f73de, public java.util.Collection java.util.LinkedHashMap.values()=[Ljava.lang.Class;@b3e45, public void java.util.LinkedHashMap.clear()=[Ljava.lang.Class;@a34e5c, public java.lang.Object java.util.HashMap.computeIfPresent(java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1fcb13a, public java.lang.Object java.util.HashMap.compute(java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1a7c258, public final native java.lang.Class java.lang.Object.getClass()=[Ljava.lang.Class;@7397f, public void java.util.HashMap.putAll(java.util.Map)=[Ljava.lang.Class;@59cd, public void java.util.LinkedHashMap.replaceAll(java.util.function.BiFunction)=[Ljava.lang.Class;@994816, public java.lang.Object java.util.HashMap.merge(java.lang.Object,java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1b1e75f, public int java.util.HashMap.size()=[Ljava.lang.Class;@bee157, public boolean java.util.LinkedHashMap.containsValue(java.lang.Object)=[Ljava.lang.Class;@5e0d7c}, replaceAll=public void java.util.LinkedHashMap.replaceAll(java.util.function.BiFunction), remove=freemarker.ext.beans.OverloadedMethods@8d3a99, containsValue=public boolean java.util.LinkedHashMap.containsValue(java.lang.Object), put=public java.lang.Object java.util.HashMap.put(java.lang.Object,java.lang.Object), empty=java.beans.PropertyDescriptor[name=empty; propertyType=boolean; readMethod=public boolean java.util.HashMap.isEmpty()], compute=public java.lang.Object java.util.HashMap.compute(java.lang.Object,java.util.function.BiFunction), hashCode=public int java.util.AbstractMap.hashCode(), putAll=public void java.util.HashMap.putAll(java.util.Map), get=public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object), merge=public java.lang.Object java.util.HashMap.merge(java.lang.Object,java.lang.Object,java.util.function.BiFunction), class=java.beans.PropertyDescriptor[name=class; propertyType=class java.lang.Class; readMethod=public final native java.lang.Class java.lang.Object.getClass()], keySet=public java.util.Set java.util.LinkedHashMap.keySet(), java.lang.Object@1c0f21d=freemarker.ext.beans.OverloadedMethods@d4b988, entrySet=public java.util.Set java.util.LinkedHashMap.entrySet(), java.lang.Object@15be27d=public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object), forEach=public void java.util.LinkedHashMap.forEach(java.util.function.BiConsumer), containsKey=public boolean java.util.HashMap.containsKey(java.lang.Object), isEmpty=public boolean java.util.HashMap.isEmpty(), clear=public void java.util.LinkedHashMap.clear(), computeIfPresent=public java.lang.Object java.util.HashMap.computeIfPresent(java.lang.Object,java.util.function.BiFunction), size=public int java.util.HashMap.size(), equals=public boolean java.util.AbstractMap.equals(java.lang.Object), clone=public java.lang.Object java.util.HashMap.clone(), toString=public java.lang.String java.util.AbstractMap.toString(), putIfAbsent=public java.lang.Object java.util.HashMap.putIfAbsent(java.lang.Object,java.lang.Object)}
[DEBUG] 2017-05-24: 21:05:32 freemarker.log._Log4jLoggerFactory$Log4jLogger.debug(_Log4jLoggerFactory.java:45) :  Key "onmouseover" was not found on instance of java.util.LinkedHashMap. Introspection information for the class is: {getClass=public final native java.lang.Class java.lang.Object.getClass(), getOrDefault=public java.lang.Object java.util.LinkedHashMap.getOrDefault(java.lang.Object,java.lang.Object), computeIfAbsent=public java.lang.Object java.util.HashMap.computeIfAbsent(java.lang.Object,java.util.function.Function), values=public java.util.Collection java.util.LinkedHashMap.values(), replace=freemarker.ext.beans.OverloadedMethods@11d0265, java.lang.Object@3e55b2={public boolean java.util.HashMap.isEmpty()=[Ljava.lang.Class;@c5aa3a, public int java.util.AbstractMap.hashCode()=[Ljava.lang.Class;@74a947, public java.lang.Object java.util.HashMap.put(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@1615a91, public boolean java.util.AbstractMap.equals(java.lang.Object)=[Ljava.lang.Class;@a46ab2, public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object)=[Ljava.lang.Class;@1c389e6, public java.lang.String java.util.AbstractMap.toString()=[Ljava.lang.Class;@a23548, public boolean java.util.HashMap.containsKey(java.lang.Object)=[Ljava.lang.Class;@1be4a9f, public java.util.Set java.util.LinkedHashMap.keySet()=[Ljava.lang.Class;@44c60, public java.lang.Object java.util.HashMap.computeIfAbsent(java.lang.Object,java.util.function.Function)=[Ljava.lang.Class;@10f7dff, public java.lang.Object java.util.HashMap.clone()=[Ljava.lang.Class;@d214e3, public java.lang.Object java.util.LinkedHashMap.getOrDefault(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@1a74254, public java.util.Set java.util.LinkedHashMap.entrySet()=[Ljava.lang.Class;@1c4740c, public void java.util.LinkedHashMap.forEach(java.util.function.BiConsumer)=[Ljava.lang.Class;@1fe0c8e, public java.lang.Object java.util.HashMap.putIfAbsent(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@16f73de, public java.util.Collection java.util.LinkedHashMap.values()=[Ljava.lang.Class;@b3e45, public void java.util.LinkedHashMap.clear()=[Ljava.lang.Class;@a34e5c, public java.lang.Object java.util.HashMap.computeIfPresent(java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1fcb13a, public java.lang.Object java.util.HashMap.compute(java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1a7c258, public final native java.lang.Class java.lang.Object.getClass()=[Ljava.lang.Class;@7397f, public void java.util.HashMap.putAll(java.util.Map)=[Ljava.lang.Class;@59cd, public void java.util.LinkedHashMap.replaceAll(java.util.function.BiFunction)=[Ljava.lang.Class;@994816, public java.lang.Object java.util.HashMap.merge(java.lang.Object,java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1b1e75f, public int java.util.HashMap.size()=[Ljava.lang.Class;@bee157, public boolean java.util.LinkedHashMap.containsValue(java.lang.Object)=[Ljava.lang.Class;@5e0d7c}, replaceAll=public void java.util.LinkedHashMap.replaceAll(java.util.function.BiFunction), remove=freemarker.ext.beans.OverloadedMethods@8d3a99, containsValue=public boolean java.util.LinkedHashMap.containsValue(java.lang.Object), put=public java.lang.Object java.util.HashMap.put(java.lang.Object,java.lang.Object), empty=java.beans.PropertyDescriptor[name=empty; propertyType=boolean; readMethod=public boolean java.util.HashMap.isEmpty()], compute=public java.lang.Object java.util.HashMap.compute(java.lang.Object,java.util.function.BiFunction), hashCode=public int java.util.AbstractMap.hashCode(), putAll=public void java.util.HashMap.putAll(java.util.Map), get=public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object), merge=public java.lang.Object java.util.HashMap.merge(java.lang.Object,java.lang.Object,java.util.function.BiFunction), class=java.beans.PropertyDescriptor[name=class; propertyType=class java.lang.Class; readMethod=public final native java.lang.Class java.lang.Object.getClass()], keySet=public java.util.Set java.util.LinkedHashMap.keySet(), java.lang.Object@1c0f21d=freemarker.ext.beans.OverloadedMethods@d4b988, entrySet=public java.util.Set java.util.LinkedHashMap.entrySet(), java.lang.Object@15be27d=public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object), forEach=public void java.util.LinkedHashMap.forEach(java.util.function.BiConsumer), containsKey=public boolean java.util.HashMap.containsKey(java.lang.Object), isEmpty=public boolean java.util.HashMap.isEmpty(), clear=public void java.util.LinkedHashMap.clear(), computeIfPresent=public java.lang.Object java.util.HashMap.computeIfPresent(java.lang.Object,java.util.function.BiFunction), size=public int java.util.HashMap.size(), equals=public boolean java.util.AbstractMap.equals(java.lang.Object), clone=public java.lang.Object java.util.HashMap.clone(), toString=public java.lang.String java.util.AbstractMap.toString(), putIfAbsent=public java.lang.Object java.util.HashMap.putIfAbsent(java.lang.Object,java.lang.Object)}
[DEBUG] 2017-05-24: 21:05:32 freemarker.log._Log4jLoggerFactory$Log4jLogger.debug(_Log4jLoggerFactory.java:45) :  Key "onmousemove" was not found on instance of java.util.LinkedHashMap. Introspection information for the class is: {getClass=public final native java.lang.Class java.lang.Object.getClass(), getOrDefault=public java.lang.Object java.util.LinkedHashMap.getOrDefault(java.lang.Object,java.lang.Object), computeIfAbsent=public java.lang.Object java.util.HashMap.computeIfAbsent(java.lang.Object,java.util.function.Function), values=public java.util.Collection java.util.LinkedHashMap.values(), replace=freemarker.ext.beans.OverloadedMethods@11d0265, java.lang.Object@3e55b2={public boolean java.util.HashMap.isEmpty()=[Ljava.lang.Class;@c5aa3a, public int java.util.AbstractMap.hashCode()=[Ljava.lang.Class;@74a947, public java.lang.Object java.util.HashMap.put(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@1615a91, public boolean java.util.AbstractMap.equals(java.lang.Object)=[Ljava.lang.Class;@a46ab2, public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object)=[Ljava.lang.Class;@1c389e6, public java.lang.String java.util.AbstractMap.toString()=[Ljava.lang.Class;@a23548, public boolean java.util.HashMap.containsKey(java.lang.Object)=[Ljava.lang.Class;@1be4a9f, public java.util.Set java.util.LinkedHashMap.keySet()=[Ljava.lang.Class;@44c60, public java.lang.Object java.util.HashMap.computeIfAbsent(java.lang.Object,java.util.function.Function)=[Ljava.lang.Class;@10f7dff, public java.lang.Object java.util.HashMap.clone()=[Ljava.lang.Class;@d214e3, public java.lang.Object java.util.LinkedHashMap.getOrDefault(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@1a74254, public java.util.Set java.util.LinkedHashMap.entrySet()=[Ljava.lang.Class;@1c4740c, public void java.util.LinkedHashMap.forEach(java.util.function.BiConsumer)=[Ljava.lang.Class;@1fe0c8e, public java.lang.Object java.util.HashMap.putIfAbsent(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@16f73de, public java.util.Collection java.util.LinkedHashMap.values()=[Ljava.lang.Class;@b3e45, public void java.util.LinkedHashMap.clear()=[Ljava.lang.Class;@a34e5c, public java.lang.Object java.util.HashMap.computeIfPresent(java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1fcb13a, public java.lang.Object java.util.HashMap.compute(java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1a7c258, public final native java.lang.Class java.lang.Object.getClass()=[Ljava.lang.Class;@7397f, public void java.util.HashMap.putAll(java.util.Map)=[Ljava.lang.Class;@59cd, public void java.util.LinkedHashMap.replaceAll(java.util.function.BiFunction)=[Ljava.lang.Class;@994816, public java.lang.Object java.util.HashMap.merge(java.lang.Object,java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1b1e75f, public int java.util.HashMap.size()=[Ljava.lang.Class;@bee157, public boolean java.util.LinkedHashMap.containsValue(java.lang.Object)=[Ljava.lang.Class;@5e0d7c}, replaceAll=public void java.util.LinkedHashMap.replaceAll(java.util.function.BiFunction), remove=freemarker.ext.beans.OverloadedMethods@8d3a99, containsValue=public boolean java.util.LinkedHashMap.containsValue(java.lang.Object), put=public java.lang.Object java.util.HashMap.put(java.lang.Object,java.lang.Object), empty=java.beans.PropertyDescriptor[name=empty; propertyType=boolean; readMethod=public boolean java.util.HashMap.isEmpty()], compute=public java.lang.Object java.util.HashMap.compute(java.lang.Object,java.util.function.BiFunction), hashCode=public int java.util.AbstractMap.hashCode(), putAll=public void java.util.HashMap.putAll(java.util.Map), get=public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object), merge=public java.lang.Object java.util.HashMap.merge(java.lang.Object,java.lang.Object,java.util.function.BiFunction), class=java.beans.PropertyDescriptor[name=class; propertyType=class java.lang.Class; readMethod=public final native java.lang.Class java.lang.Object.getClass()], keySet=public java.util.Set java.util.LinkedHashMap.keySet(), java.lang.Object@1c0f21d=freemarker.ext.beans.OverloadedMethods@d4b988, entrySet=public java.util.Set java.util.LinkedHashMap.entrySet(), java.lang.Object@15be27d=public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object), forEach=public void java.util.LinkedHashMap.forEach(java.util.function.BiConsumer), containsKey=public boolean java.util.HashMap.containsKey(java.lang.Object), isEmpty=public boolean java.util.HashMap.isEmpty(), clear=public void java.util.LinkedHashMap.clear(), computeIfPresent=public java.lang.Object java.util.HashMap.computeIfPresent(java.lang.Object,java.util.function.BiFunction), size=public int java.util.HashMap.size(), equals=public boolean java.util.AbstractMap.equals(java.lang.Object), clone=public java.lang.Object java.util.HashMap.clone(), toString=public java.lang.String java.util.AbstractMap.toString(), putIfAbsent=public java.lang.Object java.util.HashMap.putIfAbsent(java.lang.Object,java.lang.Object)}
[DEBUG] 2017-05-24: 21:05:32 freemarker.log._Log4jLoggerFactory$Log4jLogger.debug(_Log4jLoggerFactory.java:45) :  Key "onmouseout" was not found on instance of java.util.LinkedHashMap. Introspection information for the class is: {getClass=public final native java.lang.Class java.lang.Object.getClass(), getOrDefault=public java.lang.Object java.util.LinkedHashMap.getOrDefault(java.lang.Object,java.lang.Object), computeIfAbsent=public java.lang.Object java.util.HashMap.computeIfAbsent(java.lang.Object,java.util.function.Function), values=public java.util.Collection java.util.LinkedHashMap.values(), replace=freemarker.ext.beans.OverloadedMethods@11d0265, java.lang.Object@3e55b2={public boolean java.util.HashMap.isEmpty()=[Ljava.lang.Class;@c5aa3a, public int java.util.AbstractMap.hashCode()=[Ljava.lang.Class;@74a947, public java.lang.Object java.util.HashMap.put(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@1615a91, public boolean java.util.AbstractMap.equals(java.lang.Object)=[Ljava.lang.Class;@a46ab2, public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object)=[Ljava.lang.Class;@1c389e6, public java.lang.String java.util.AbstractMap.toString()=[Ljava.lang.Class;@a23548, public boolean java.util.HashMap.containsKey(java.lang.Object)=[Ljava.lang.Class;@1be4a9f, public java.util.Set java.util.LinkedHashMap.keySet()=[Ljava.lang.Class;@44c60, public java.lang.Object java.util.HashMap.computeIfAbsent(java.lang.Object,java.util.function.Function)=[Ljava.lang.Class;@10f7dff, public java.lang.Object java.util.HashMap.clone()=[Ljava.lang.Class;@d214e3, public java.lang.Object java.util.LinkedHashMap.getOrDefault(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@1a74254, public java.util.Set java.util.LinkedHashMap.entrySet()=[Ljava.lang.Class;@1c4740c, public void java.util.LinkedHashMap.forEach(java.util.function.BiConsumer)=[Ljava.lang.Class;@1fe0c8e, public java.lang.Object java.util.HashMap.putIfAbsent(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@16f73de, public java.util.Collection java.util.LinkedHashMap.values()=[Ljava.lang.Class;@b3e45, public void java.util.LinkedHashMap.clear()=[Ljava.lang.Class;@a34e5c, public java.lang.Object java.util.HashMap.computeIfPresent(java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1fcb13a, public java.lang.Object java.util.HashMap.compute(java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1a7c258, public final native java.lang.Class java.lang.Object.getClass()=[Ljava.lang.Class;@7397f, public void java.util.HashMap.putAll(java.util.Map)=[Ljava.lang.Class;@59cd, public void java.util.LinkedHashMap.replaceAll(java.util.function.BiFunction)=[Ljava.lang.Class;@994816, public java.lang.Object java.util.HashMap.merge(java.lang.Object,java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1b1e75f, public int java.util.HashMap.size()=[Ljava.lang.Class;@bee157, public boolean java.util.LinkedHashMap.containsValue(java.lang.Object)=[Ljava.lang.Class;@5e0d7c}, replaceAll=public void java.util.LinkedHashMap.replaceAll(java.util.function.BiFunction), remove=freemarker.ext.beans.OverloadedMethods@8d3a99, containsValue=public boolean java.util.LinkedHashMap.containsValue(java.lang.Object), put=public java.lang.Object java.util.HashMap.put(java.lang.Object,java.lang.Object), empty=java.beans.PropertyDescriptor[name=empty; propertyType=boolean; readMethod=public boolean java.util.HashMap.isEmpty()], compute=public java.lang.Object java.util.HashMap.compute(java.lang.Object,java.util.function.BiFunction), hashCode=public int java.util.AbstractMap.hashCode(), putAll=public void java.util.HashMap.putAll(java.util.Map), get=public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object), merge=public java.lang.Object java.util.HashMap.merge(java.lang.Object,java.lang.Object,java.util.function.BiFunction), class=java.beans.PropertyDescriptor[name=class; propertyType=class java.lang.Class; readMethod=public final native java.lang.Class java.lang.Object.getClass()], keySet=public java.util.Set java.util.LinkedHashMap.keySet(), java.lang.Object@1c0f21d=freemarker.ext.beans.OverloadedMethods@d4b988, entrySet=public java.util.Set java.util.LinkedHashMap.entrySet(), java.lang.Object@15be27d=public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object), forEach=public void java.util.LinkedHashMap.forEach(java.util.function.BiConsumer), containsKey=public boolean java.util.HashMap.containsKey(java.lang.Object), isEmpty=public boolean java.util.HashMap.isEmpty(), clear=public void java.util.LinkedHashMap.clear(), computeIfPresent=public java.lang.Object java.util.HashMap.computeIfPresent(java.lang.Object,java.util.function.BiFunction), size=public int java.util.HashMap.size(), equals=public boolean java.util.AbstractMap.equals(java.lang.Object), clone=public java.lang.Object java.util.HashMap.clone(), toString=public java.lang.String java.util.AbstractMap.toString(), putIfAbsent=public java.lang.Object java.util.HashMap.putIfAbsent(java.lang.Object,java.lang.Object)}
[DEBUG] 2017-05-24: 21:05:32 freemarker.log._Log4jLoggerFactory$Log4jLogger.debug(_Log4jLoggerFactory.java:45) :  Key "onfocus" was not found on instance of java.util.LinkedHashMap. Introspection information for the class is: {getClass=public final native java.lang.Class java.lang.Object.getClass(), getOrDefault=public java.lang.Object java.util.LinkedHashMap.getOrDefault(java.lang.Object,java.lang.Object), computeIfAbsent=public java.lang.Object java.util.HashMap.computeIfAbsent(java.lang.Object,java.util.function.Function), values=public java.util.Collection java.util.LinkedHashMap.values(), replace=freemarker.ext.beans.OverloadedMethods@11d0265, java.lang.Object@3e55b2={public boolean java.util.HashMap.isEmpty()=[Ljava.lang.Class;@c5aa3a, public int java.util.AbstractMap.hashCode()=[Ljava.lang.Class;@74a947, public java.lang.Object java.util.HashMap.put(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@1615a91, public boolean java.util.AbstractMap.equals(java.lang.Object)=[Ljava.lang.Class;@a46ab2, public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object)=[Ljava.lang.Class;@1c389e6, public java.lang.String java.util.AbstractMap.toString()=[Ljava.lang.Class;@a23548, public boolean java.util.HashMap.containsKey(java.lang.Object)=[Ljava.lang.Class;@1be4a9f, public java.util.Set java.util.LinkedHashMap.keySet()=[Ljava.lang.Class;@44c60, public java.lang.Object java.util.HashMap.computeIfAbsent(java.lang.Object,java.util.function.Function)=[Ljava.lang.Class;@10f7dff, public java.lang.Object java.util.HashMap.clone()=[Ljava.lang.Class;@d214e3, public java.lang.Object java.util.LinkedHashMap.getOrDefault(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@1a74254, public java.util.Set java.util.LinkedHashMap.entrySet()=[Ljava.lang.Class;@1c4740c, public void java.util.LinkedHashMap.forEach(java.util.function.BiConsumer)=[Ljava.lang.Class;@1fe0c8e, public java.lang.Object java.util.HashMap.putIfAbsent(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@16f73de, public java.util.Collection java.util.LinkedHashMap.values()=[Ljava.lang.Class;@b3e45, public void java.util.LinkedHashMap.clear()=[Ljava.lang.Class;@a34e5c, public java.lang.Object java.util.HashMap.computeIfPresent(java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1fcb13a, public java.lang.Object java.util.HashMap.compute(java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1a7c258, public final native java.lang.Class java.lang.Object.getClass()=[Ljava.lang.Class;@7397f, public void java.util.HashMap.putAll(java.util.Map)=[Ljava.lang.Class;@59cd, public void java.util.LinkedHashMap.replaceAll(java.util.function.BiFunction)=[Ljava.lang.Class;@994816, public java.lang.Object java.util.HashMap.merge(java.lang.Object,java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1b1e75f, public int java.util.HashMap.size()=[Ljava.lang.Class;@bee157, public boolean java.util.LinkedHashMap.containsValue(java.lang.Object)=[Ljava.lang.Class;@5e0d7c}, replaceAll=public void java.util.LinkedHashMap.replaceAll(java.util.function.BiFunction), remove=freemarker.ext.beans.OverloadedMethods@8d3a99, containsValue=public boolean java.util.LinkedHashMap.containsValue(java.lang.Object), put=public java.lang.Object java.util.HashMap.put(java.lang.Object,java.lang.Object), empty=java.beans.PropertyDescriptor[name=empty; propertyType=boolean; readMethod=public boolean java.util.HashMap.isEmpty()], compute=public java.lang.Object java.util.HashMap.compute(java.lang.Object,java.util.function.BiFunction), hashCode=public int java.util.AbstractMap.hashCode(), putAll=public void java.util.HashMap.putAll(java.util.Map), get=public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object), merge=public java.lang.Object java.util.HashMap.merge(java.lang.Object,java.lang.Object,java.util.function.BiFunction), class=java.beans.PropertyDescriptor[name=class; propertyType=class java.lang.Class; readMethod=public final native java.lang.Class java.lang.Object.getClass()], keySet=public java.util.Set java.util.LinkedHashMap.keySet(), java.lang.Object@1c0f21d=freemarker.ext.beans.OverloadedMethods@d4b988, entrySet=public java.util.Set java.util.LinkedHashMap.entrySet(), java.lang.Object@15be27d=public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object), forEach=public void java.util.LinkedHashMap.forEach(java.util.function.BiConsumer), containsKey=public boolean java.util.HashMap.containsKey(java.lang.Object), isEmpty=public boolean java.util.HashMap.isEmpty(), clear=public void java.util.LinkedHashMap.clear(), computeIfPresent=public java.lang.Object java.util.HashMap.computeIfPresent(java.lang.Object,java.util.function.BiFunction), size=public int java.util.HashMap.size(), equals=public boolean java.util.AbstractMap.equals(java.lang.Object), clone=public java.lang.Object java.util.HashMap.clone(), toString=public java.lang.String java.util.AbstractMap.toString(), putIfAbsent=public java.lang.Object java.util.HashMap.putIfAbsent(java.lang.Object,java.lang.Object)}
[DEBUG] 2017-05-24: 21:05:32 freemarker.log._Log4jLoggerFactory$Log4jLogger.debug(_Log4jLoggerFactory.java:45) :  Key "onblur" was not found on instance of java.util.LinkedHashMap. Introspection information for the class is: {getClass=public final native java.lang.Class java.lang.Object.getClass(), getOrDefault=public java.lang.Object java.util.LinkedHashMap.getOrDefault(java.lang.Object,java.lang.Object), computeIfAbsent=public java.lang.Object java.util.HashMap.computeIfAbsent(java.lang.Object,java.util.function.Function), values=public java.util.Collection java.util.LinkedHashMap.values(), replace=freemarker.ext.beans.OverloadedMethods@11d0265, java.lang.Object@3e55b2={public boolean java.util.HashMap.isEmpty()=[Ljava.lang.Class;@c5aa3a, public int java.util.AbstractMap.hashCode()=[Ljava.lang.Class;@74a947, public java.lang.Object java.util.HashMap.put(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@1615a91, public boolean java.util.AbstractMap.equals(java.lang.Object)=[Ljava.lang.Class;@a46ab2, public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object)=[Ljava.lang.Class;@1c389e6, public java.lang.String java.util.AbstractMap.toString()=[Ljava.lang.Class;@a23548, public boolean java.util.HashMap.containsKey(java.lang.Object)=[Ljava.lang.Class;@1be4a9f, public java.util.Set java.util.LinkedHashMap.keySet()=[Ljava.lang.Class;@44c60, public java.lang.Object java.util.HashMap.computeIfAbsent(java.lang.Object,java.util.function.Function)=[Ljava.lang.Class;@10f7dff, public java.lang.Object java.util.HashMap.clone()=[Ljava.lang.Class;@d214e3, public java.lang.Object java.util.LinkedHashMap.getOrDefault(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@1a74254, public java.util.Set java.util.LinkedHashMap.entrySet()=[Ljava.lang.Class;@1c4740c, public void java.util.LinkedHashMap.forEach(java.util.function.BiConsumer)=[Ljava.lang.Class;@1fe0c8e, public java.lang.Object java.util.HashMap.putIfAbsent(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@16f73de, public java.util.Collection java.util.LinkedHashMap.values()=[Ljava.lang.Class;@b3e45, public void java.util.LinkedHashMap.clear()=[Ljava.lang.Class;@a34e5c, public java.lang.Object java.util.HashMap.computeIfPresent(java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1fcb13a, public java.lang.Object java.util.HashMap.compute(java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1a7c258, public final native java.lang.Class java.lang.Object.getClass()=[Ljava.lang.Class;@7397f, public void java.util.HashMap.putAll(java.util.Map)=[Ljava.lang.Class;@59cd, public void java.util.LinkedHashMap.replaceAll(java.util.function.BiFunction)=[Ljava.lang.Class;@994816, public java.lang.Object java.util.HashMap.merge(java.lang.Object,java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1b1e75f, public int java.util.HashMap.size()=[Ljava.lang.Class;@bee157, public boolean java.util.LinkedHashMap.containsValue(java.lang.Object)=[Ljava.lang.Class;@5e0d7c}, replaceAll=public void java.util.LinkedHashMap.replaceAll(java.util.function.BiFunction), remove=freemarker.ext.beans.OverloadedMethods@8d3a99, containsValue=public boolean java.util.LinkedHashMap.containsValue(java.lang.Object), put=public java.lang.Object java.util.HashMap.put(java.lang.Object,java.lang.Object), empty=java.beans.PropertyDescriptor[name=empty; propertyType=boolean; readMethod=public boolean java.util.HashMap.isEmpty()], compute=public java.lang.Object java.util.HashMap.compute(java.lang.Object,java.util.function.BiFunction), hashCode=public int java.util.AbstractMap.hashCode(), putAll=public void java.util.HashMap.putAll(java.util.Map), get=public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object), merge=public java.lang.Object java.util.HashMap.merge(java.lang.Object,java.lang.Object,java.util.function.BiFunction), class=java.beans.PropertyDescriptor[name=class; propertyType=class java.lang.Class; readMethod=public final native java.lang.Class java.lang.Object.getClass()], keySet=public java.util.Set java.util.LinkedHashMap.keySet(), java.lang.Object@1c0f21d=freemarker.ext.beans.OverloadedMethods@d4b988, entrySet=public java.util.Set java.util.LinkedHashMap.entrySet(), java.lang.Object@15be27d=public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object), forEach=public void java.util.LinkedHashMap.forEach(java.util.function.BiConsumer), containsKey=public boolean java.util.HashMap.containsKey(java.lang.Object), isEmpty=public boolean java.util.HashMap.isEmpty(), clear=public void java.util.LinkedHashMap.clear(), computeIfPresent=public java.lang.Object java.util.HashMap.computeIfPresent(java.lang.Object,java.util.function.BiFunction), size=public int java.util.HashMap.size(), equals=public boolean java.util.AbstractMap.equals(java.lang.Object), clone=public java.lang.Object java.util.HashMap.clone(), toString=public java.lang.String java.util.AbstractMap.toString(), putIfAbsent=public java.lang.Object java.util.HashMap.putIfAbsent(java.lang.Object,java.lang.Object)}
[DEBUG] 2017-05-24: 21:05:32 freemarker.log._Log4jLoggerFactory$Log4jLogger.debug(_Log4jLoggerFactory.java:45) :  Key "onkeypress" was not found on instance of java.util.LinkedHashMap. Introspection information for the class is: {getClass=public final native java.lang.Class java.lang.Object.getClass(), getOrDefault=public java.lang.Object java.util.LinkedHashMap.getOrDefault(java.lang.Object,java.lang.Object), computeIfAbsent=public java.lang.Object java.util.HashMap.computeIfAbsent(java.lang.Object,java.util.function.Function), values=public java.util.Collection java.util.LinkedHashMap.values(), replace=freemarker.ext.beans.OverloadedMethods@11d0265, java.lang.Object@3e55b2={public boolean java.util.HashMap.isEmpty()=[Ljava.lang.Class;@c5aa3a, public int java.util.AbstractMap.hashCode()=[Ljava.lang.Class;@74a947, public java.lang.Object java.util.HashMap.put(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@1615a91, public boolean java.util.AbstractMap.equals(java.lang.Object)=[Ljava.lang.Class;@a46ab2, public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object)=[Ljava.lang.Class;@1c389e6, public java.lang.String java.util.AbstractMap.toString()=[Ljava.lang.Class;@a23548, public boolean java.util.HashMap.containsKey(java.lang.Object)=[Ljava.lang.Class;@1be4a9f, public java.util.Set java.util.LinkedHashMap.keySet()=[Ljava.lang.Class;@44c60, public java.lang.Object java.util.HashMap.computeIfAbsent(java.lang.Object,java.util.function.Function)=[Ljava.lang.Class;@10f7dff, public java.lang.Object java.util.HashMap.clone()=[Ljava.lang.Class;@d214e3, public java.lang.Object java.util.LinkedHashMap.getOrDefault(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@1a74254, public java.util.Set java.util.LinkedHashMap.entrySet()=[Ljava.lang.Class;@1c4740c, public void java.util.LinkedHashMap.forEach(java.util.function.BiConsumer)=[Ljava.lang.Class;@1fe0c8e, public java.lang.Object java.util.HashMap.putIfAbsent(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@16f73de, public java.util.Collection java.util.LinkedHashMap.values()=[Ljava.lang.Class;@b3e45, public void java.util.LinkedHashMap.clear()=[Ljava.lang.Class;@a34e5c, public java.lang.Object java.util.HashMap.computeIfPresent(java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1fcb13a, public java.lang.Object java.util.HashMap.compute(java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1a7c258, public final native java.lang.Class java.lang.Object.getClass()=[Ljava.lang.Class;@7397f, public void java.util.HashMap.putAll(java.util.Map)=[Ljava.lang.Class;@59cd, public void java.util.LinkedHashMap.replaceAll(java.util.function.BiFunction)=[Ljava.lang.Class;@994816, public java.lang.Object java.util.HashMap.merge(java.lang.Object,java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1b1e75f, public int java.util.HashMap.size()=[Ljava.lang.Class;@bee157, public boolean java.util.LinkedHashMap.containsValue(java.lang.Object)=[Ljava.lang.Class;@5e0d7c}, replaceAll=public void java.util.LinkedHashMap.replaceAll(java.util.function.BiFunction), remove=freemarker.ext.beans.OverloadedMethods@8d3a99, containsValue=public boolean java.util.LinkedHashMap.containsValue(java.lang.Object), put=public java.lang.Object java.util.HashMap.put(java.lang.Object,java.lang.Object), empty=java.beans.PropertyDescriptor[name=empty; propertyType=boolean; readMethod=public boolean java.util.HashMap.isEmpty()], compute=public java.lang.Object java.util.HashMap.compute(java.lang.Object,java.util.function.BiFunction), hashCode=public int java.util.AbstractMap.hashCode(), putAll=public void java.util.HashMap.putAll(java.util.Map), get=public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object), merge=public java.lang.Object java.util.HashMap.merge(java.lang.Object,java.lang.Object,java.util.function.BiFunction), class=java.beans.PropertyDescriptor[name=class; propertyType=class java.lang.Class; readMethod=public final native java.lang.Class java.lang.Object.getClass()], keySet=public java.util.Set java.util.LinkedHashMap.keySet(), java.lang.Object@1c0f21d=freemarker.ext.beans.OverloadedMethods@d4b988, entrySet=public java.util.Set java.util.LinkedHashMap.entrySet(), java.lang.Object@15be27d=public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object), forEach=public void java.util.LinkedHashMap.forEach(java.util.function.BiConsumer), containsKey=public boolean java.util.HashMap.containsKey(java.lang.Object), isEmpty=public boolean java.util.HashMap.isEmpty(), clear=public void java.util.LinkedHashMap.clear(), computeIfPresent=public java.lang.Object java.util.HashMap.computeIfPresent(java.lang.Object,java.util.function.BiFunction), size=public int java.util.HashMap.size(), equals=public boolean java.util.AbstractMap.equals(java.lang.Object), clone=public java.lang.Object java.util.HashMap.clone(), toString=public java.lang.String java.util.AbstractMap.toString(), putIfAbsent=public java.lang.Object java.util.HashMap.putIfAbsent(java.lang.Object,java.lang.Object)}
[DEBUG] 2017-05-24: 21:05:32 freemarker.log._Log4jLoggerFactory$Log4jLogger.debug(_Log4jLoggerFactory.java:45) :  Key "onkeydown" was not found on instance of java.util.LinkedHashMap. Introspection information for the class is: {getClass=public final native java.lang.Class java.lang.Object.getClass(), getOrDefault=public java.lang.Object java.util.LinkedHashMap.getOrDefault(java.lang.Object,java.lang.Object), computeIfAbsent=public java.lang.Object java.util.HashMap.computeIfAbsent(java.lang.Object,java.util.function.Function), values=public java.util.Collection java.util.LinkedHashMap.values(), replace=freemarker.ext.beans.OverloadedMethods@11d0265, java.lang.Object@3e55b2={public boolean java.util.HashMap.isEmpty()=[Ljava.lang.Class;@c5aa3a, public int java.util.AbstractMap.hashCode()=[Ljava.lang.Class;@74a947, public java.lang.Object java.util.HashMap.put(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@1615a91, public boolean java.util.AbstractMap.equals(java.lang.Object)=[Ljava.lang.Class;@a46ab2, public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object)=[Ljava.lang.Class;@1c389e6, public java.lang.String java.util.AbstractMap.toString()=[Ljava.lang.Class;@a23548, public boolean java.util.HashMap.containsKey(java.lang.Object)=[Ljava.lang.Class;@1be4a9f, public java.util.Set java.util.LinkedHashMap.keySet()=[Ljava.lang.Class;@44c60, public java.lang.Object java.util.HashMap.computeIfAbsent(java.lang.Object,java.util.function.Function)=[Ljava.lang.Class;@10f7dff, public java.lang.Object java.util.HashMap.clone()=[Ljava.lang.Class;@d214e3, public java.lang.Object java.util.LinkedHashMap.getOrDefault(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@1a74254, public java.util.Set java.util.LinkedHashMap.entrySet()=[Ljava.lang.Class;@1c4740c, public void java.util.LinkedHashMap.forEach(java.util.function.BiConsumer)=[Ljava.lang.Class;@1fe0c8e, public java.lang.Object java.util.HashMap.putIfAbsent(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@16f73de, public java.util.Collection java.util.LinkedHashMap.values()=[Ljava.lang.Class;@b3e45, public void java.util.LinkedHashMap.clear()=[Ljava.lang.Class;@a34e5c, public java.lang.Object java.util.HashMap.computeIfPresent(java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1fcb13a, public java.lang.Object java.util.HashMap.compute(java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1a7c258, public final native java.lang.Class java.lang.Object.getClass()=[Ljava.lang.Class;@7397f, public void java.util.HashMap.putAll(java.util.Map)=[Ljava.lang.Class;@59cd, public void java.util.LinkedHashMap.replaceAll(java.util.function.BiFunction)=[Ljava.lang.Class;@994816, public java.lang.Object java.util.HashMap.merge(java.lang.Object,java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1b1e75f, public int java.util.HashMap.size()=[Ljava.lang.Class;@bee157, public boolean java.util.LinkedHashMap.containsValue(java.lang.Object)=[Ljava.lang.Class;@5e0d7c}, replaceAll=public void java.util.LinkedHashMap.replaceAll(java.util.function.BiFunction), remove=freemarker.ext.beans.OverloadedMethods@8d3a99, containsValue=public boolean java.util.LinkedHashMap.containsValue(java.lang.Object), put=public java.lang.Object java.util.HashMap.put(java.lang.Object,java.lang.Object), empty=java.beans.PropertyDescriptor[name=empty; propertyType=boolean; readMethod=public boolean java.util.HashMap.isEmpty()], compute=public java.lang.Object java.util.HashMap.compute(java.lang.Object,java.util.function.BiFunction), hashCode=public int java.util.AbstractMap.hashCode(), putAll=public void java.util.HashMap.putAll(java.util.Map), get=public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object), merge=public java.lang.Object java.util.HashMap.merge(java.lang.Object,java.lang.Object,java.util.function.BiFunction), class=java.beans.PropertyDescriptor[name=class; propertyType=class java.lang.Class; readMethod=public final native java.lang.Class java.lang.Object.getClass()], keySet=public java.util.Set java.util.LinkedHashMap.keySet(), java.lang.Object@1c0f21d=freemarker.ext.beans.OverloadedMethods@d4b988, entrySet=public java.util.Set java.util.LinkedHashMap.entrySet(), java.lang.Object@15be27d=public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object), forEach=public void java.util.LinkedHashMap.forEach(java.util.function.BiConsumer), containsKey=public boolean java.util.HashMap.containsKey(java.lang.Object), isEmpty=public boolean java.util.HashMap.isEmpty(), clear=public void java.util.LinkedHashMap.clear(), computeIfPresent=public java.lang.Object java.util.HashMap.computeIfPresent(java.lang.Object,java.util.function.BiFunction), size=public int java.util.HashMap.size(), equals=public boolean java.util.AbstractMap.equals(java.lang.Object), clone=public java.lang.Object java.util.HashMap.clone(), toString=public java.lang.String java.util.AbstractMap.toString(), putIfAbsent=public java.lang.Object java.util.HashMap.putIfAbsent(java.lang.Object,java.lang.Object)}
[DEBUG] 2017-05-24: 21:05:32 freemarker.log._Log4jLoggerFactory$Log4jLogger.debug(_Log4jLoggerFactory.java:45) :  Key "onkeyup" was not found on instance of java.util.LinkedHashMap. Introspection information for the class is: {getClass=public final native java.lang.Class java.lang.Object.getClass(), getOrDefault=public java.lang.Object java.util.LinkedHashMap.getOrDefault(java.lang.Object,java.lang.Object), computeIfAbsent=public java.lang.Object java.util.HashMap.computeIfAbsent(java.lang.Object,java.util.function.Function), values=public java.util.Collection java.util.LinkedHashMap.values(), replace=freemarker.ext.beans.OverloadedMethods@11d0265, java.lang.Object@3e55b2={public boolean java.util.HashMap.isEmpty()=[Ljava.lang.Class;@c5aa3a, public int java.util.AbstractMap.hashCode()=[Ljava.lang.Class;@74a947, public java.lang.Object java.util.HashMap.put(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@1615a91, public boolean java.util.AbstractMap.equals(java.lang.Object)=[Ljava.lang.Class;@a46ab2, public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object)=[Ljava.lang.Class;@1c389e6, public java.lang.String java.util.AbstractMap.toString()=[Ljava.lang.Class;@a23548, public boolean java.util.HashMap.containsKey(java.lang.Object)=[Ljava.lang.Class;@1be4a9f, public java.util.Set java.util.LinkedHashMap.keySet()=[Ljava.lang.Class;@44c60, public java.lang.Object java.util.HashMap.computeIfAbsent(java.lang.Object,java.util.function.Function)=[Ljava.lang.Class;@10f7dff, public java.lang.Object java.util.HashMap.clone()=[Ljava.lang.Class;@d214e3, public java.lang.Object java.util.LinkedHashMap.getOrDefault(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@1a74254, public java.util.Set java.util.LinkedHashMap.entrySet()=[Ljava.lang.Class;@1c4740c, public void java.util.LinkedHashMap.forEach(java.util.function.BiConsumer)=[Ljava.lang.Class;@1fe0c8e, public java.lang.Object java.util.HashMap.putIfAbsent(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@16f73de, public java.util.Collection java.util.LinkedHashMap.values()=[Ljava.lang.Class;@b3e45, public void java.util.LinkedHashMap.clear()=[Ljava.lang.Class;@a34e5c, public java.lang.Object java.util.HashMap.computeIfPresent(java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1fcb13a, public java.lang.Object java.util.HashMap.compute(java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1a7c258, public final native java.lang.Class java.lang.Object.getClass()=[Ljava.lang.Class;@7397f, public void java.util.HashMap.putAll(java.util.Map)=[Ljava.lang.Class;@59cd, public void java.util.LinkedHashMap.replaceAll(java.util.function.BiFunction)=[Ljava.lang.Class;@994816, public java.lang.Object java.util.HashMap.merge(java.lang.Object,java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1b1e75f, public int java.util.HashMap.size()=[Ljava.lang.Class;@bee157, public boolean java.util.LinkedHashMap.containsValue(java.lang.Object)=[Ljava.lang.Class;@5e0d7c}, replaceAll=public void java.util.LinkedHashMap.replaceAll(java.util.function.BiFunction), remove=freemarker.ext.beans.OverloadedMethods@8d3a99, containsValue=public boolean java.util.LinkedHashMap.containsValue(java.lang.Object), put=public java.lang.Object java.util.HashMap.put(java.lang.Object,java.lang.Object), empty=java.beans.PropertyDescriptor[name=empty; propertyType=boolean; readMethod=public boolean java.util.HashMap.isEmpty()], compute=public java.lang.Object java.util.HashMap.compute(java.lang.Object,java.util.function.BiFunction), hashCode=public int java.util.AbstractMap.hashCode(), putAll=public void java.util.HashMap.putAll(java.util.Map), get=public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object), merge=public java.lang.Object java.util.HashMap.merge(java.lang.Object,java.lang.Object,java.util.function.BiFunction), class=java.beans.PropertyDescriptor[name=class; propertyType=class java.lang.Class; readMethod=public final native java.lang.Class java.lang.Object.getClass()], keySet=public java.util.Set java.util.LinkedHashMap.keySet(), java.lang.Object@1c0f21d=freemarker.ext.beans.OverloadedMethods@d4b988, entrySet=public java.util.Set java.util.LinkedHashMap.entrySet(), java.lang.Object@15be27d=public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object), forEach=public void java.util.LinkedHashMap.forEach(java.util.function.BiConsumer), containsKey=public boolean java.util.HashMap.containsKey(java.lang.Object), isEmpty=public boolean java.util.HashMap.isEmpty(), clear=public void java.util.LinkedHashMap.clear(), computeIfPresent=public java.lang.Object java.util.HashMap.computeIfPresent(java.lang.Object,java.util.function.BiFunction), size=public int java.util.HashMap.size(), equals=public boolean java.util.AbstractMap.equals(java.lang.Object), clone=public java.lang.Object java.util.HashMap.clone(), toString=public java.lang.String java.util.AbstractMap.toString(), putIfAbsent=public java.lang.Object java.util.HashMap.putIfAbsent(java.lang.Object,java.lang.Object)}
[DEBUG] 2017-05-24: 21:05:32 freemarker.log._Log4jLoggerFactory$Log4jLogger.debug(_Log4jLoggerFactory.java:45) :  Key "onselect" was not found on instance of java.util.LinkedHashMap. Introspection information for the class is: {getClass=public final native java.lang.Class java.lang.Object.getClass(), getOrDefault=public java.lang.Object java.util.LinkedHashMap.getOrDefault(java.lang.Object,java.lang.Object), computeIfAbsent=public java.lang.Object java.util.HashMap.computeIfAbsent(java.lang.Object,java.util.function.Function), values=public java.util.Collection java.util.LinkedHashMap.values(), replace=freemarker.ext.beans.OverloadedMethods@11d0265, java.lang.Object@3e55b2={public boolean java.util.HashMap.isEmpty()=[Ljava.lang.Class;@c5aa3a, public int java.util.AbstractMap.hashCode()=[Ljava.lang.Class;@74a947, public java.lang.Object java.util.HashMap.put(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@1615a91, public boolean java.util.AbstractMap.equals(java.lang.Object)=[Ljava.lang.Class;@a46ab2, public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object)=[Ljava.lang.Class;@1c389e6, public java.lang.String java.util.AbstractMap.toString()=[Ljava.lang.Class;@a23548, public boolean java.util.HashMap.containsKey(java.lang.Object)=[Ljava.lang.Class;@1be4a9f, public java.util.Set java.util.LinkedHashMap.keySet()=[Ljava.lang.Class;@44c60, public java.lang.Object java.util.HashMap.computeIfAbsent(java.lang.Object,java.util.function.Function)=[Ljava.lang.Class;@10f7dff, public java.lang.Object java.util.HashMap.clone()=[Ljava.lang.Class;@d214e3, public java.lang.Object java.util.LinkedHashMap.getOrDefault(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@1a74254, public java.util.Set java.util.LinkedHashMap.entrySet()=[Ljava.lang.Class;@1c4740c, public void java.util.LinkedHashMap.forEach(java.util.function.BiConsumer)=[Ljava.lang.Class;@1fe0c8e, public java.lang.Object java.util.HashMap.putIfAbsent(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@16f73de, public java.util.Collection java.util.LinkedHashMap.values()=[Ljava.lang.Class;@b3e45, public void java.util.LinkedHashMap.clear()=[Ljava.lang.Class;@a34e5c, public java.lang.Object java.util.HashMap.computeIfPresent(java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1fcb13a, public java.lang.Object java.util.HashMap.compute(java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1a7c258, public final native java.lang.Class java.lang.Object.getClass()=[Ljava.lang.Class;@7397f, public void java.util.HashMap.putAll(java.util.Map)=[Ljava.lang.Class;@59cd, public void java.util.LinkedHashMap.replaceAll(java.util.function.BiFunction)=[Ljava.lang.Class;@994816, public java.lang.Object java.util.HashMap.merge(java.lang.Object,java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1b1e75f, public int java.util.HashMap.size()=[Ljava.lang.Class;@bee157, public boolean java.util.LinkedHashMap.containsValue(java.lang.Object)=[Ljava.lang.Class;@5e0d7c}, replaceAll=public void java.util.LinkedHashMap.replaceAll(java.util.function.BiFunction), remove=freemarker.ext.beans.OverloadedMethods@8d3a99, containsValue=public boolean java.util.LinkedHashMap.containsValue(java.lang.Object), put=public java.lang.Object java.util.HashMap.put(java.lang.Object,java.lang.Object), empty=java.beans.PropertyDescriptor[name=empty; propertyType=boolean; readMethod=public boolean java.util.HashMap.isEmpty()], compute=public java.lang.Object java.util.HashMap.compute(java.lang.Object,java.util.function.BiFunction), hashCode=public int java.util.AbstractMap.hashCode(), putAll=public void java.util.HashMap.putAll(java.util.Map), get=public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object), merge=public java.lang.Object java.util.HashMap.merge(java.lang.Object,java.lang.Object,java.util.function.BiFunction), class=java.beans.PropertyDescriptor[name=class; propertyType=class java.lang.Class; readMethod=public final native java.lang.Class java.lang.Object.getClass()], keySet=public java.util.Set java.util.LinkedHashMap.keySet(), java.lang.Object@1c0f21d=freemarker.ext.beans.OverloadedMethods@d4b988, entrySet=public java.util.Set java.util.LinkedHashMap.entrySet(), java.lang.Object@15be27d=public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object), forEach=public void java.util.LinkedHashMap.forEach(java.util.function.BiConsumer), containsKey=public boolean java.util.HashMap.containsKey(java.lang.Object), isEmpty=public boolean java.util.HashMap.isEmpty(), clear=public void java.util.LinkedHashMap.clear(), computeIfPresent=public java.lang.Object java.util.HashMap.computeIfPresent(java.lang.Object,java.util.function.BiFunction), size=public int java.util.HashMap.size(), equals=public boolean java.util.AbstractMap.equals(java.lang.Object), clone=public java.lang.Object java.util.HashMap.clone(), toString=public java.lang.String java.util.AbstractMap.toString(), putIfAbsent=public java.lang.Object java.util.HashMap.putIfAbsent(java.lang.Object,java.lang.Object)}
[DEBUG] 2017-05-24: 21:05:32 freemarker.log._Log4jLoggerFactory$Log4jLogger.debug(_Log4jLoggerFactory.java:45) :  Key "onchange" was not found on instance of java.util.LinkedHashMap. Introspection information for the class is: {getClass=public final native java.lang.Class java.lang.Object.getClass(), getOrDefault=public java.lang.Object java.util.LinkedHashMap.getOrDefault(java.lang.Object,java.lang.Object), computeIfAbsent=public java.lang.Object java.util.HashMap.computeIfAbsent(java.lang.Object,java.util.function.Function), values=public java.util.Collection java.util.LinkedHashMap.values(), replace=freemarker.ext.beans.OverloadedMethods@11d0265, java.lang.Object@3e55b2={public boolean java.util.HashMap.isEmpty()=[Ljava.lang.Class;@c5aa3a, public int java.util.AbstractMap.hashCode()=[Ljava.lang.Class;@74a947, public java.lang.Object java.util.HashMap.put(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@1615a91, public boolean java.util.AbstractMap.equals(java.lang.Object)=[Ljava.lang.Class;@a46ab2, public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object)=[Ljava.lang.Class;@1c389e6, public java.lang.String java.util.AbstractMap.toString()=[Ljava.lang.Class;@a23548, public boolean java.util.HashMap.containsKey(java.lang.Object)=[Ljava.lang.Class;@1be4a9f, public java.util.Set java.util.LinkedHashMap.keySet()=[Ljava.lang.Class;@44c60, public java.lang.Object java.util.HashMap.computeIfAbsent(java.lang.Object,java.util.function.Function)=[Ljava.lang.Class;@10f7dff, public java.lang.Object java.util.HashMap.clone()=[Ljava.lang.Class;@d214e3, public java.lang.Object java.util.LinkedHashMap.getOrDefault(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@1a74254, public java.util.Set java.util.LinkedHashMap.entrySet()=[Ljava.lang.Class;@1c4740c, public void java.util.LinkedHashMap.forEach(java.util.function.BiConsumer)=[Ljava.lang.Class;@1fe0c8e, public java.lang.Object java.util.HashMap.putIfAbsent(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@16f73de, public java.util.Collection java.util.LinkedHashMap.values()=[Ljava.lang.Class;@b3e45, public void java.util.LinkedHashMap.clear()=[Ljava.lang.Class;@a34e5c, public java.lang.Object java.util.HashMap.computeIfPresent(java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1fcb13a, public java.lang.Object java.util.HashMap.compute(java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1a7c258, public final native java.lang.Class java.lang.Object.getClass()=[Ljava.lang.Class;@7397f, public void java.util.HashMap.putAll(java.util.Map)=[Ljava.lang.Class;@59cd, public void java.util.LinkedHashMap.replaceAll(java.util.function.BiFunction)=[Ljava.lang.Class;@994816, public java.lang.Object java.util.HashMap.merge(java.lang.Object,java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1b1e75f, public int java.util.HashMap.size()=[Ljava.lang.Class;@bee157, public boolean java.util.LinkedHashMap.containsValue(java.lang.Object)=[Ljava.lang.Class;@5e0d7c}, replaceAll=public void java.util.LinkedHashMap.replaceAll(java.util.function.BiFunction), remove=freemarker.ext.beans.OverloadedMethods@8d3a99, containsValue=public boolean java.util.LinkedHashMap.containsValue(java.lang.Object), put=public java.lang.Object java.util.HashMap.put(java.lang.Object,java.lang.Object), empty=java.beans.PropertyDescriptor[name=empty; propertyType=boolean; readMethod=public boolean java.util.HashMap.isEmpty()], compute=public java.lang.Object java.util.HashMap.compute(java.lang.Object,java.util.function.BiFunction), hashCode=public int java.util.AbstractMap.hashCode(), putAll=public void java.util.HashMap.putAll(java.util.Map), get=public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object), merge=public java.lang.Object java.util.HashMap.merge(java.lang.Object,java.lang.Object,java.util.function.BiFunction), class=java.beans.PropertyDescriptor[name=class; propertyType=class java.lang.Class; readMethod=public final native java.lang.Class java.lang.Object.getClass()], keySet=public java.util.Set java.util.LinkedHashMap.keySet(), java.lang.Object@1c0f21d=freemarker.ext.beans.OverloadedMethods@d4b988, entrySet=public java.util.Set java.util.LinkedHashMap.entrySet(), java.lang.Object@15be27d=public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object), forEach=public void java.util.LinkedHashMap.forEach(java.util.function.BiConsumer), containsKey=public boolean java.util.HashMap.containsKey(java.lang.Object), isEmpty=public boolean java.util.HashMap.isEmpty(), clear=public void java.util.LinkedHashMap.clear(), computeIfPresent=public java.lang.Object java.util.HashMap.computeIfPresent(java.lang.Object,java.util.function.BiFunction), size=public int java.util.HashMap.size(), equals=public boolean java.util.AbstractMap.equals(java.lang.Object), clone=public java.lang.Object java.util.HashMap.clone(), toString=public java.lang.String java.util.AbstractMap.toString(), putIfAbsent=public java.lang.Object java.util.HashMap.putIfAbsent(java.lang.Object,java.lang.Object)}
[DEBUG] 2017-05-24: 21:05:32 freemarker.log._Log4jLoggerFactory$Log4jLogger.debug(_Log4jLoggerFactory.java:45) :  TemplateLoader.findTemplateSource("template/~~~xhtml/common-attributes.ftl"): Found
[DEBUG] 2017-05-24: 21:05:32 freemarker.log._Log4jLoggerFactory$Log4jLogger.debug(_Log4jLoggerFactory.java:45) :  "template/~~~xhtml/common-attributes.ftl"("zh_CN", UTF-8, parsed): using cached since jar:file:/D:/maven/repository/org/apache/struts/struts2-core/2.5.10/struts2-core-2.5.10.jar!/template/simple/common-attributes.ftl hasn't changed.
[DEBUG] 2017-05-24: 21:05:32 freemarker.log._Log4jLoggerFactory$Log4jLogger.debug(_Log4jLoggerFactory.java:45) :  Key "accesskey" was not found on instance of java.util.LinkedHashMap. Introspection information for the class is: {getClass=public final native java.lang.Class java.lang.Object.getClass(), getOrDefault=public java.lang.Object java.util.LinkedHashMap.getOrDefault(java.lang.Object,java.lang.Object), computeIfAbsent=public java.lang.Object java.util.HashMap.computeIfAbsent(java.lang.Object,java.util.function.Function), values=public java.util.Collection java.util.LinkedHashMap.values(), replace=freemarker.ext.beans.OverloadedMethods@11d0265, java.lang.Object@3e55b2={public boolean java.util.HashMap.isEmpty()=[Ljava.lang.Class;@c5aa3a, public int java.util.AbstractMap.hashCode()=[Ljava.lang.Class;@74a947, public java.lang.Object java.util.HashMap.put(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@1615a91, public boolean java.util.AbstractMap.equals(java.lang.Object)=[Ljava.lang.Class;@a46ab2, public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object)=[Ljava.lang.Class;@1c389e6, public java.lang.String java.util.AbstractMap.toString()=[Ljava.lang.Class;@a23548, public boolean java.util.HashMap.containsKey(java.lang.Object)=[Ljava.lang.Class;@1be4a9f, public java.util.Set java.util.LinkedHashMap.keySet()=[Ljava.lang.Class;@44c60, public java.lang.Object java.util.HashMap.computeIfAbsent(java.lang.Object,java.util.function.Function)=[Ljava.lang.Class;@10f7dff, public java.lang.Object java.util.HashMap.clone()=[Ljava.lang.Class;@d214e3, public java.lang.Object java.util.LinkedHashMap.getOrDefault(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@1a74254, public java.util.Set java.util.LinkedHashMap.entrySet()=[Ljava.lang.Class;@1c4740c, public void java.util.LinkedHashMap.forEach(java.util.function.BiConsumer)=[Ljava.lang.Class;@1fe0c8e, public java.lang.Object java.util.HashMap.putIfAbsent(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@16f73de, public java.util.Collection java.util.LinkedHashMap.values()=[Ljava.lang.Class;@b3e45, public void java.util.LinkedHashMap.clear()=[Ljava.lang.Class;@a34e5c, public java.lang.Object java.util.HashMap.computeIfPresent(java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1fcb13a, public java.lang.Object java.util.HashMap.compute(java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1a7c258, public final native java.lang.Class java.lang.Object.getClass()=[Ljava.lang.Class;@7397f, public void java.util.HashMap.putAll(java.util.Map)=[Ljava.lang.Class;@59cd, public void java.util.LinkedHashMap.replaceAll(java.util.function.BiFunction)=[Ljava.lang.Class;@994816, public java.lang.Object java.util.HashMap.merge(java.lang.Object,java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1b1e75f, public int java.util.HashMap.size()=[Ljava.lang.Class;@bee157, public boolean java.util.LinkedHashMap.containsValue(java.lang.Object)=[Ljava.lang.Class;@5e0d7c}, replaceAll=public void java.util.LinkedHashMap.replaceAll(java.util.function.BiFunction), remove=freemarker.ext.beans.OverloadedMethods@8d3a99, containsValue=public boolean java.util.LinkedHashMap.containsValue(java.lang.Object), put=public java.lang.Object java.util.HashMap.put(java.lang.Object,java.lang.Object), empty=java.beans.PropertyDescriptor[name=empty; propertyType=boolean; readMethod=public boolean java.util.HashMap.isEmpty()], compute=public java.lang.Object java.util.HashMap.compute(java.lang.Object,java.util.function.BiFunction), hashCode=public int java.util.AbstractMap.hashCode(), putAll=public void java.util.HashMap.putAll(java.util.Map), get=public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object), merge=public java.lang.Object java.util.HashMap.merge(java.lang.Object,java.lang.Object,java.util.function.BiFunction), class=java.beans.PropertyDescriptor[name=class; propertyType=class java.lang.Class; readMethod=public final native java.lang.Class java.lang.Object.getClass()], keySet=public java.util.Set java.util.LinkedHashMap.keySet(), java.lang.Object@1c0f21d=freemarker.ext.beans.OverloadedMethods@d4b988, entrySet=public java.util.Set java.util.LinkedHashMap.entrySet(), java.lang.Object@15be27d=public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object), forEach=public void java.util.LinkedHashMap.forEach(java.util.function.BiConsumer), containsKey=public boolean java.util.HashMap.containsKey(java.lang.Object), isEmpty=public boolean java.util.HashMap.isEmpty(), clear=public void java.util.LinkedHashMap.clear(), computeIfPresent=public java.lang.Object java.util.HashMap.computeIfPresent(java.lang.Object,java.util.function.BiFunction), size=public int java.util.HashMap.size(), equals=public boolean java.util.AbstractMap.equals(java.lang.Object), clone=public java.lang.Object java.util.HashMap.clone(), toString=public java.lang.String java.util.AbstractMap.toString(), putIfAbsent=public java.lang.Object java.util.HashMap.putIfAbsent(java.lang.Object,java.lang.Object)}
[DEBUG] 2017-05-24: 21:05:32 freemarker.log._Log4jLoggerFactory$Log4jLogger.debug(_Log4jLoggerFactory.java:45) :  TemplateLoader.findTemplateSource("template/~~~xhtml/dynamic-attributes.ftl"): Found
[DEBUG] 2017-05-24: 21:05:32 freemarker.log._Log4jLoggerFactory$Log4jLogger.debug(_Log4jLoggerFactory.java:45) :  "template/~~~xhtml/dynamic-attributes.ftl"("zh_CN", UTF-8, parsed): using cached since jar:file:/D:/maven/repository/org/apache/struts/struts2-core/2.5.10/struts2-core-2.5.10.jar!/template/simple/dynamic-attributes.ftl hasn't changed.
[DEBUG] 2017-05-24: 21:05:32 freemarker.log._Log4jLoggerFactory$Log4jLogger.debug(_Log4jLoggerFactory.java:45) :  TemplateLoader.findTemplateSource("template/~~~xhtml/css.ftl"): Found
[DEBUG] 2017-05-24: 21:05:32 freemarker.log._Log4jLoggerFactory$Log4jLogger.debug(_Log4jLoggerFactory.java:45) :  "template/~~~xhtml/css.ftl"("zh_CN", UTF-8, parsed): using cached since jar:file:/D:/maven/repository/org/apache/struts/struts2-core/2.5.10/struts2-core-2.5.10.jar!/template/simple/css.ftl hasn't changed.
[DEBUG] 2017-05-24: 21:05:32 freemarker.log._Log4jLoggerFactory$Log4jLogger.debug(_Log4jLoggerFactory.java:45) :  Key "cssClass" was not found on instance of java.util.LinkedHashMap. Introspection information for the class is: {getClass=public final native java.lang.Class java.lang.Object.getClass(), getOrDefault=public java.lang.Object java.util.LinkedHashMap.getOrDefault(java.lang.Object,java.lang.Object), computeIfAbsent=public java.lang.Object java.util.HashMap.computeIfAbsent(java.lang.Object,java.util.function.Function), values=public java.util.Collection java.util.LinkedHashMap.values(), replace=freemarker.ext.beans.OverloadedMethods@11d0265, java.lang.Object@3e55b2={public boolean java.util.HashMap.isEmpty()=[Ljava.lang.Class;@c5aa3a, public int java.util.AbstractMap.hashCode()=[Ljava.lang.Class;@74a947, public java.lang.Object java.util.HashMap.put(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@1615a91, public boolean java.util.AbstractMap.equals(java.lang.Object)=[Ljava.lang.Class;@a46ab2, public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object)=[Ljava.lang.Class;@1c389e6, public java.lang.String java.util.AbstractMap.toString()=[Ljava.lang.Class;@a23548, public boolean java.util.HashMap.containsKey(java.lang.Object)=[Ljava.lang.Class;@1be4a9f, public java.util.Set java.util.LinkedHashMap.keySet()=[Ljava.lang.Class;@44c60, public java.lang.Object java.util.HashMap.computeIfAbsent(java.lang.Object,java.util.function.Function)=[Ljava.lang.Class;@10f7dff, public java.lang.Object java.util.HashMap.clone()=[Ljava.lang.Class;@d214e3, public java.lang.Object java.util.LinkedHashMap.getOrDefault(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@1a74254, public java.util.Set java.util.LinkedHashMap.entrySet()=[Ljava.lang.Class;@1c4740c, public void java.util.LinkedHashMap.forEach(java.util.function.BiConsumer)=[Ljava.lang.Class;@1fe0c8e, public java.lang.Object java.util.HashMap.putIfAbsent(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@16f73de, public java.util.Collection java.util.LinkedHashMap.values()=[Ljava.lang.Class;@b3e45, public void java.util.LinkedHashMap.clear()=[Ljava.lang.Class;@a34e5c, public java.lang.Object java.util.HashMap.computeIfPresent(java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1fcb13a, public java.lang.Object java.util.HashMap.compute(java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1a7c258, public final native java.lang.Class java.lang.Object.getClass()=[Ljava.lang.Class;@7397f, public void java.util.HashMap.putAll(java.util.Map)=[Ljava.lang.Class;@59cd, public void java.util.LinkedHashMap.replaceAll(java.util.function.BiFunction)=[Ljava.lang.Class;@994816, public java.lang.Object java.util.HashMap.merge(java.lang.Object,java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1b1e75f, public int java.util.HashMap.size()=[Ljava.lang.Class;@bee157, public boolean java.util.LinkedHashMap.containsValue(java.lang.Object)=[Ljava.lang.Class;@5e0d7c}, replaceAll=public void java.util.LinkedHashMap.replaceAll(java.util.function.BiFunction), remove=freemarker.ext.beans.OverloadedMethods@8d3a99, containsValue=public boolean java.util.LinkedHashMap.containsValue(java.lang.Object), put=public java.lang.Object java.util.HashMap.put(java.lang.Object,java.lang.Object), empty=java.beans.PropertyDescriptor[name=empty; propertyType=boolean; readMethod=public boolean java.util.HashMap.isEmpty()], compute=public java.lang.Object java.util.HashMap.compute(java.lang.Object,java.util.function.BiFunction), hashCode=public int java.util.AbstractMap.hashCode(), putAll=public void java.util.HashMap.putAll(java.util.Map), get=public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object), merge=public java.lang.Object java.util.HashMap.merge(java.lang.Object,java.lang.Object,java.util.function.BiFunction), class=java.beans.PropertyDescriptor[name=class; propertyType=class java.lang.Class; readMethod=public final native java.lang.Class java.lang.Object.getClass()], keySet=public java.util.Set java.util.LinkedHashMap.keySet(), java.lang.Object@1c0f21d=freemarker.ext.beans.OverloadedMethods@d4b988, entrySet=public java.util.Set java.util.LinkedHashMap.entrySet(), java.lang.Object@15be27d=public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object), forEach=public void java.util.LinkedHashMap.forEach(java.util.function.BiConsumer), containsKey=public boolean java.util.HashMap.containsKey(java.lang.Object), isEmpty=public boolean java.util.HashMap.isEmpty(), clear=public void java.util.LinkedHashMap.clear(), computeIfPresent=public java.lang.Object java.util.HashMap.computeIfPresent(java.lang.Object,java.util.function.BiFunction), size=public int java.util.HashMap.size(), equals=public boolean java.util.AbstractMap.equals(java.lang.Object), clone=public java.lang.Object java.util.HashMap.clone(), toString=public java.lang.String java.util.AbstractMap.toString(), putIfAbsent=public java.lang.Object java.util.HashMap.putIfAbsent(java.lang.Object,java.lang.Object)}
[DEBUG] 2017-05-24: 21:05:32 freemarker.log._Log4jLoggerFactory$Log4jLogger.debug(_Log4jLoggerFactory.java:45) :  Key "cssClass" was not found on instance of java.util.LinkedHashMap. Introspection information for the class is: {getClass=public final native java.lang.Class java.lang.Object.getClass(), getOrDefault=public java.lang.Object java.util.LinkedHashMap.getOrDefault(java.lang.Object,java.lang.Object), computeIfAbsent=public java.lang.Object java.util.HashMap.computeIfAbsent(java.lang.Object,java.util.function.Function), values=public java.util.Collection java.util.LinkedHashMap.values(), replace=freemarker.ext.beans.OverloadedMethods@11d0265, java.lang.Object@3e55b2={public boolean java.util.HashMap.isEmpty()=[Ljava.lang.Class;@c5aa3a, public int java.util.AbstractMap.hashCode()=[Ljava.lang.Class;@74a947, public java.lang.Object java.util.HashMap.put(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@1615a91, public boolean java.util.AbstractMap.equals(java.lang.Object)=[Ljava.lang.Class;@a46ab2, public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object)=[Ljava.lang.Class;@1c389e6, public java.lang.String java.util.AbstractMap.toString()=[Ljava.lang.Class;@a23548, public boolean java.util.HashMap.containsKey(java.lang.Object)=[Ljava.lang.Class;@1be4a9f, public java.util.Set java.util.LinkedHashMap.keySet()=[Ljava.lang.Class;@44c60, public java.lang.Object java.util.HashMap.computeIfAbsent(java.lang.Object,java.util.function.Function)=[Ljava.lang.Class;@10f7dff, public java.lang.Object java.util.HashMap.clone()=[Ljava.lang.Class;@d214e3, public java.lang.Object java.util.LinkedHashMap.getOrDefault(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@1a74254, public java.util.Set java.util.LinkedHashMap.entrySet()=[Ljava.lang.Class;@1c4740c, public void java.util.LinkedHashMap.forEach(java.util.function.BiConsumer)=[Ljava.lang.Class;@1fe0c8e, public java.lang.Object java.util.HashMap.putIfAbsent(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@16f73de, public java.util.Collection java.util.LinkedHashMap.values()=[Ljava.lang.Class;@b3e45, public void java.util.LinkedHashMap.clear()=[Ljava.lang.Class;@a34e5c, public java.lang.Object java.util.HashMap.computeIfPresent(java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1fcb13a, public java.lang.Object java.util.HashMap.compute(java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1a7c258, public final native java.lang.Class java.lang.Object.getClass()=[Ljava.lang.Class;@7397f, public void java.util.HashMap.putAll(java.util.Map)=[Ljava.lang.Class;@59cd, public void java.util.LinkedHashMap.replaceAll(java.util.function.BiFunction)=[Ljava.lang.Class;@994816, public java.lang.Object java.util.HashMap.merge(java.lang.Object,java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1b1e75f, public int java.util.HashMap.size()=[Ljava.lang.Class;@bee157, public boolean java.util.LinkedHashMap.containsValue(java.lang.Object)=[Ljava.lang.Class;@5e0d7c}, replaceAll=public void java.util.LinkedHashMap.replaceAll(java.util.function.BiFunction), remove=freemarker.ext.beans.OverloadedMethods@8d3a99, containsValue=public boolean java.util.LinkedHashMap.containsValue(java.lang.Object), put=public java.lang.Object java.util.HashMap.put(java.lang.Object,java.lang.Object), empty=java.beans.PropertyDescriptor[name=empty; propertyType=boolean; readMethod=public boolean java.util.HashMap.isEmpty()], compute=public java.lang.Object java.util.HashMap.compute(java.lang.Object,java.util.function.BiFunction), hashCode=public int java.util.AbstractMap.hashCode(), putAll=public void java.util.HashMap.putAll(java.util.Map), get=public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object), merge=public java.lang.Object java.util.HashMap.merge(java.lang.Object,java.lang.Object,java.util.function.BiFunction), class=java.beans.PropertyDescriptor[name=class; propertyType=class java.lang.Class; readMethod=public final native java.lang.Class java.lang.Object.getClass()], keySet=public java.util.Set java.util.LinkedHashMap.keySet(), java.lang.Object@1c0f21d=freemarker.ext.beans.OverloadedMethods@d4b988, entrySet=public java.util.Set java.util.LinkedHashMap.entrySet(), java.lang.Object@15be27d=public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object), forEach=public void java.util.LinkedHashMap.forEach(java.util.function.BiConsumer), containsKey=public boolean java.util.HashMap.containsKey(java.lang.Object), isEmpty=public boolean java.util.HashMap.isEmpty(), clear=public void java.util.LinkedHashMap.clear(), computeIfPresent=public java.lang.Object java.util.HashMap.computeIfPresent(java.lang.Object,java.util.function.BiFunction), size=public int java.util.HashMap.size(), equals=public boolean java.util.AbstractMap.equals(java.lang.Object), clone=public java.lang.Object java.util.HashMap.clone(), toString=public java.lang.String java.util.AbstractMap.toString(), putIfAbsent=public java.lang.Object java.util.HashMap.putIfAbsent(java.lang.Object,java.lang.Object)}
[DEBUG] 2017-05-24: 21:05:32 freemarker.log._Log4jLoggerFactory$Log4jLogger.debug(_Log4jLoggerFactory.java:45) :  Key "cssClass" was not found on instance of java.util.LinkedHashMap. Introspection information for the class is: {getClass=public final native java.lang.Class java.lang.Object.getClass(), getOrDefault=public java.lang.Object java.util.LinkedHashMap.getOrDefault(java.lang.Object,java.lang.Object), computeIfAbsent=public java.lang.Object java.util.HashMap.computeIfAbsent(java.lang.Object,java.util.function.Function), values=public java.util.Collection java.util.LinkedHashMap.values(), replace=freemarker.ext.beans.OverloadedMethods@11d0265, java.lang.Object@3e55b2={public boolean java.util.HashMap.isEmpty()=[Ljava.lang.Class;@c5aa3a, public int java.util.AbstractMap.hashCode()=[Ljava.lang.Class;@74a947, public java.lang.Object java.util.HashMap.put(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@1615a91, public boolean java.util.AbstractMap.equals(java.lang.Object)=[Ljava.lang.Class;@a46ab2, public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object)=[Ljava.lang.Class;@1c389e6, public java.lang.String java.util.AbstractMap.toString()=[Ljava.lang.Class;@a23548, public boolean java.util.HashMap.containsKey(java.lang.Object)=[Ljava.lang.Class;@1be4a9f, public java.util.Set java.util.LinkedHashMap.keySet()=[Ljava.lang.Class;@44c60, public java.lang.Object java.util.HashMap.computeIfAbsent(java.lang.Object,java.util.function.Function)=[Ljava.lang.Class;@10f7dff, public java.lang.Object java.util.HashMap.clone()=[Ljava.lang.Class;@d214e3, public java.lang.Object java.util.LinkedHashMap.getOrDefault(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@1a74254, public java.util.Set java.util.LinkedHashMap.entrySet()=[Ljava.lang.Class;@1c4740c, public void java.util.LinkedHashMap.forEach(java.util.function.BiConsumer)=[Ljava.lang.Class;@1fe0c8e, public java.lang.Object java.util.HashMap.putIfAbsent(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@16f73de, public java.util.Collection java.util.LinkedHashMap.values()=[Ljava.lang.Class;@b3e45, public void java.util.LinkedHashMap.clear()=[Ljava.lang.Class;@a34e5c, public java.lang.Object java.util.HashMap.computeIfPresent(java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1fcb13a, public java.lang.Object java.util.HashMap.compute(java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1a7c258, public final native java.lang.Class java.lang.Object.getClass()=[Ljava.lang.Class;@7397f, public void java.util.HashMap.putAll(java.util.Map)=[Ljava.lang.Class;@59cd, public void java.util.LinkedHashMap.replaceAll(java.util.function.BiFunction)=[Ljava.lang.Class;@994816, public java.lang.Object java.util.HashMap.merge(java.lang.Object,java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1b1e75f, public int java.util.HashMap.size()=[Ljava.lang.Class;@bee157, public boolean java.util.LinkedHashMap.containsValue(java.lang.Object)=[Ljava.lang.Class;@5e0d7c}, replaceAll=public void java.util.LinkedHashMap.replaceAll(java.util.function.BiFunction), remove=freemarker.ext.beans.OverloadedMethods@8d3a99, containsValue=public boolean java.util.LinkedHashMap.containsValue(java.lang.Object), put=public java.lang.Object java.util.HashMap.put(java.lang.Object,java.lang.Object), empty=java.beans.PropertyDescriptor[name=empty; propertyType=boolean; readMethod=public boolean java.util.HashMap.isEmpty()], compute=public java.lang.Object java.util.HashMap.compute(java.lang.Object,java.util.function.BiFunction), hashCode=public int java.util.AbstractMap.hashCode(), putAll=public void java.util.HashMap.putAll(java.util.Map), get=public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object), merge=public java.lang.Object java.util.HashMap.merge(java.lang.Object,java.lang.Object,java.util.function.BiFunction), class=java.beans.PropertyDescriptor[name=class; propertyType=class java.lang.Class; readMethod=public final native java.lang.Class java.lang.Object.getClass()], keySet=public java.util.Set java.util.LinkedHashMap.keySet(), java.lang.Object@1c0f21d=freemarker.ext.beans.OverloadedMethods@d4b988, entrySet=public java.util.Set java.util.LinkedHashMap.entrySet(), java.lang.Object@15be27d=public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object), forEach=public void java.util.LinkedHashMap.forEach(java.util.function.BiConsumer), containsKey=public boolean java.util.HashMap.containsKey(java.lang.Object), isEmpty=public boolean java.util.HashMap.isEmpty(), clear=public void java.util.LinkedHashMap.clear(), computeIfPresent=public java.lang.Object java.util.HashMap.computeIfPresent(java.lang.Object,java.util.function.BiFunction), size=public int java.util.HashMap.size(), equals=public boolean java.util.AbstractMap.equals(java.lang.Object), clone=public java.lang.Object java.util.HashMap.clone(), toString=public java.lang.String java.util.AbstractMap.toString(), putIfAbsent=public java.lang.Object java.util.HashMap.putIfAbsent(java.lang.Object,java.lang.Object)}
[DEBUG] 2017-05-24: 21:05:32 freemarker.log._Log4jLoggerFactory$Log4jLogger.debug(_Log4jLoggerFactory.java:45) :  Key "cssStyle" was not found on instance of java.util.LinkedHashMap. Introspection information for the class is: {getClass=public final native java.lang.Class java.lang.Object.getClass(), getOrDefault=public java.lang.Object java.util.LinkedHashMap.getOrDefault(java.lang.Object,java.lang.Object), computeIfAbsent=public java.lang.Object java.util.HashMap.computeIfAbsent(java.lang.Object,java.util.function.Function), values=public java.util.Collection java.util.LinkedHashMap.values(), replace=freemarker.ext.beans.OverloadedMethods@11d0265, java.lang.Object@3e55b2={public boolean java.util.HashMap.isEmpty()=[Ljava.lang.Class;@c5aa3a, public int java.util.AbstractMap.hashCode()=[Ljava.lang.Class;@74a947, public java.lang.Object java.util.HashMap.put(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@1615a91, public boolean java.util.AbstractMap.equals(java.lang.Object)=[Ljava.lang.Class;@a46ab2, public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object)=[Ljava.lang.Class;@1c389e6, public java.lang.String java.util.AbstractMap.toString()=[Ljava.lang.Class;@a23548, public boolean java.util.HashMap.containsKey(java.lang.Object)=[Ljava.lang.Class;@1be4a9f, public java.util.Set java.util.LinkedHashMap.keySet()=[Ljava.lang.Class;@44c60, public java.lang.Object java.util.HashMap.computeIfAbsent(java.lang.Object,java.util.function.Function)=[Ljava.lang.Class;@10f7dff, public java.lang.Object java.util.HashMap.clone()=[Ljava.lang.Class;@d214e3, public java.lang.Object java.util.LinkedHashMap.getOrDefault(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@1a74254, public java.util.Set java.util.LinkedHashMap.entrySet()=[Ljava.lang.Class;@1c4740c, public void java.util.LinkedHashMap.forEach(java.util.function.BiConsumer)=[Ljava.lang.Class;@1fe0c8e, public java.lang.Object java.util.HashMap.putIfAbsent(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@16f73de, public java.util.Collection java.util.LinkedHashMap.values()=[Ljava.lang.Class;@b3e45, public void java.util.LinkedHashMap.clear()=[Ljava.lang.Class;@a34e5c, public java.lang.Object java.util.HashMap.computeIfPresent(java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1fcb13a, public java.lang.Object java.util.HashMap.compute(java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1a7c258, public final native java.lang.Class java.lang.Object.getClass()=[Ljava.lang.Class;@7397f, public void java.util.HashMap.putAll(java.util.Map)=[Ljava.lang.Class;@59cd, public void java.util.LinkedHashMap.replaceAll(java.util.function.BiFunction)=[Ljava.lang.Class;@994816, public java.lang.Object java.util.HashMap.merge(java.lang.Object,java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1b1e75f, public int java.util.HashMap.size()=[Ljava.lang.Class;@bee157, public boolean java.util.LinkedHashMap.containsValue(java.lang.Object)=[Ljava.lang.Class;@5e0d7c}, replaceAll=public void java.util.LinkedHashMap.replaceAll(java.util.function.BiFunction), remove=freemarker.ext.beans.OverloadedMethods@8d3a99, containsValue=public boolean java.util.LinkedHashMap.containsValue(java.lang.Object), put=public java.lang.Object java.util.HashMap.put(java.lang.Object,java.lang.Object), empty=java.beans.PropertyDescriptor[name=empty; propertyType=boolean; readMethod=public boolean java.util.HashMap.isEmpty()], compute=public java.lang.Object java.util.HashMap.compute(java.lang.Object,java.util.function.BiFunction), hashCode=public int java.util.AbstractMap.hashCode(), putAll=public void java.util.HashMap.putAll(java.util.Map), get=public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object), merge=public java.lang.Object java.util.HashMap.merge(java.lang.Object,java.lang.Object,java.util.function.BiFunction), class=java.beans.PropertyDescriptor[name=class; propertyType=class java.lang.Class; readMethod=public final native java.lang.Class java.lang.Object.getClass()], keySet=public java.util.Set java.util.LinkedHashMap.keySet(), java.lang.Object@1c0f21d=freemarker.ext.beans.OverloadedMethods@d4b988, entrySet=public java.util.Set java.util.LinkedHashMap.entrySet(), java.lang.Object@15be27d=public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object), forEach=public void java.util.LinkedHashMap.forEach(java.util.function.BiConsumer), containsKey=public boolean java.util.HashMap.containsKey(java.lang.Object), isEmpty=public boolean java.util.HashMap.isEmpty(), clear=public void java.util.LinkedHashMap.clear(), computeIfPresent=public java.lang.Object java.util.HashMap.computeIfPresent(java.lang.Object,java.util.function.BiFunction), size=public int java.util.HashMap.size(), equals=public boolean java.util.AbstractMap.equals(java.lang.Object), clone=public java.lang.Object java.util.HashMap.clone(), toString=public java.lang.String java.util.AbstractMap.toString(), putIfAbsent=public java.lang.Object java.util.HashMap.putIfAbsent(java.lang.Object,java.lang.Object)}
[DEBUG] 2017-05-24: 21:05:32 freemarker.log._Log4jLoggerFactory$Log4jLogger.debug(_Log4jLoggerFactory.java:45) :  Key "listValueKey" was not found on instance of java.util.LinkedHashMap. Introspection information for the class is: {getClass=public final native java.lang.Class java.lang.Object.getClass(), getOrDefault=public java.lang.Object java.util.LinkedHashMap.getOrDefault(java.lang.Object,java.lang.Object), computeIfAbsent=public java.lang.Object java.util.HashMap.computeIfAbsent(java.lang.Object,java.util.function.Function), values=public java.util.Collection java.util.LinkedHashMap.values(), replace=freemarker.ext.beans.OverloadedMethods@11d0265, java.lang.Object@3e55b2={public boolean java.util.HashMap.isEmpty()=[Ljava.lang.Class;@c5aa3a, public int java.util.AbstractMap.hashCode()=[Ljava.lang.Class;@74a947, public java.lang.Object java.util.HashMap.put(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@1615a91, public boolean java.util.AbstractMap.equals(java.lang.Object)=[Ljava.lang.Class;@a46ab2, public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object)=[Ljava.lang.Class;@1c389e6, public java.lang.String java.util.AbstractMap.toString()=[Ljava.lang.Class;@a23548, public boolean java.util.HashMap.containsKey(java.lang.Object)=[Ljava.lang.Class;@1be4a9f, public java.util.Set java.util.LinkedHashMap.keySet()=[Ljava.lang.Class;@44c60, public java.lang.Object java.util.HashMap.computeIfAbsent(java.lang.Object,java.util.function.Function)=[Ljava.lang.Class;@10f7dff, public java.lang.Object java.util.HashMap.clone()=[Ljava.lang.Class;@d214e3, public java.lang.Object java.util.LinkedHashMap.getOrDefault(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@1a74254, public java.util.Set java.util.LinkedHashMap.entrySet()=[Ljava.lang.Class;@1c4740c, public void java.util.LinkedHashMap.forEach(java.util.function.BiConsumer)=[Ljava.lang.Class;@1fe0c8e, public java.lang.Object java.util.HashMap.putIfAbsent(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@16f73de, public java.util.Collection java.util.LinkedHashMap.values()=[Ljava.lang.Class;@b3e45, public void java.util.LinkedHashMap.clear()=[Ljava.lang.Class;@a34e5c, public java.lang.Object java.util.HashMap.computeIfPresent(java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1fcb13a, public java.lang.Object java.util.HashMap.compute(java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1a7c258, public final native java.lang.Class java.lang.Object.getClass()=[Ljava.lang.Class;@7397f, public void java.util.HashMap.putAll(java.util.Map)=[Ljava.lang.Class;@59cd, public void java.util.LinkedHashMap.replaceAll(java.util.function.BiFunction)=[Ljava.lang.Class;@994816, public java.lang.Object java.util.HashMap.merge(java.lang.Object,java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1b1e75f, public int java.util.HashMap.size()=[Ljava.lang.Class;@bee157, public boolean java.util.LinkedHashMap.containsValue(java.lang.Object)=[Ljava.lang.Class;@5e0d7c}, replaceAll=public void java.util.LinkedHashMap.replaceAll(java.util.function.BiFunction), remove=freemarker.ext.beans.OverloadedMethods@8d3a99, containsValue=public boolean java.util.LinkedHashMap.containsValue(java.lang.Object), put=public java.lang.Object java.util.HashMap.put(java.lang.Object,java.lang.Object), empty=java.beans.PropertyDescriptor[name=empty; propertyType=boolean; readMethod=public boolean java.util.HashMap.isEmpty()], compute=public java.lang.Object java.util.HashMap.compute(java.lang.Object,java.util.function.BiFunction), hashCode=public int java.util.AbstractMap.hashCode(), putAll=public void java.util.HashMap.putAll(java.util.Map), get=public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object), merge=public java.lang.Object java.util.HashMap.merge(java.lang.Object,java.lang.Object,java.util.function.BiFunction), class=java.beans.PropertyDescriptor[name=class; propertyType=class java.lang.Class; readMethod=public final native java.lang.Class java.lang.Object.getClass()], keySet=public java.util.Set java.util.LinkedHashMap.keySet(), java.lang.Object@1c0f21d=freemarker.ext.beans.OverloadedMethods@d4b988, entrySet=public java.util.Set java.util.LinkedHashMap.entrySet(), java.lang.Object@15be27d=public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object), forEach=public void java.util.LinkedHashMap.forEach(java.util.function.BiConsumer), containsKey=public boolean java.util.HashMap.containsKey(java.lang.Object), isEmpty=public boolean java.util.HashMap.isEmpty(), clear=public void java.util.LinkedHashMap.clear(), computeIfPresent=public java.lang.Object java.util.HashMap.computeIfPresent(java.lang.Object,java.util.function.BiFunction), size=public int java.util.HashMap.size(), equals=public boolean java.util.AbstractMap.equals(java.lang.Object), clone=public java.lang.Object java.util.HashMap.clone(), toString=public java.lang.String java.util.AbstractMap.toString(), putIfAbsent=public java.lang.Object java.util.HashMap.putIfAbsent(java.lang.Object,java.lang.Object)}
[DEBUG] 2017-05-24: 21:05:32 freemarker.log._Log4jLoggerFactory$Log4jLogger.debug(_Log4jLoggerFactory.java:45) :  Key "listCssClass" was not found on instance of java.util.LinkedHashMap. Introspection information for the class is: {getClass=public final native java.lang.Class java.lang.Object.getClass(), getOrDefault=public java.lang.Object java.util.LinkedHashMap.getOrDefault(java.lang.Object,java.lang.Object), computeIfAbsent=public java.lang.Object java.util.HashMap.computeIfAbsent(java.lang.Object,java.util.function.Function), values=public java.util.Collection java.util.LinkedHashMap.values(), replace=freemarker.ext.beans.OverloadedMethods@11d0265, java.lang.Object@3e55b2={public boolean java.util.HashMap.isEmpty()=[Ljava.lang.Class;@c5aa3a, public int java.util.AbstractMap.hashCode()=[Ljava.lang.Class;@74a947, public java.lang.Object java.util.HashMap.put(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@1615a91, public boolean java.util.AbstractMap.equals(java.lang.Object)=[Ljava.lang.Class;@a46ab2, public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object)=[Ljava.lang.Class;@1c389e6, public java.lang.String java.util.AbstractMap.toString()=[Ljava.lang.Class;@a23548, public boolean java.util.HashMap.containsKey(java.lang.Object)=[Ljava.lang.Class;@1be4a9f, public java.util.Set java.util.LinkedHashMap.keySet()=[Ljava.lang.Class;@44c60, public java.lang.Object java.util.HashMap.computeIfAbsent(java.lang.Object,java.util.function.Function)=[Ljava.lang.Class;@10f7dff, public java.lang.Object java.util.HashMap.clone()=[Ljava.lang.Class;@d214e3, public java.lang.Object java.util.LinkedHashMap.getOrDefault(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@1a74254, public java.util.Set java.util.LinkedHashMap.entrySet()=[Ljava.lang.Class;@1c4740c, public void java.util.LinkedHashMap.forEach(java.util.function.BiConsumer)=[Ljava.lang.Class;@1fe0c8e, public java.lang.Object java.util.HashMap.putIfAbsent(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@16f73de, public java.util.Collection java.util.LinkedHashMap.values()=[Ljava.lang.Class;@b3e45, public void java.util.LinkedHashMap.clear()=[Ljava.lang.Class;@a34e5c, public java.lang.Object java.util.HashMap.computeIfPresent(java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1fcb13a, public java.lang.Object java.util.HashMap.compute(java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1a7c258, public final native java.lang.Class java.lang.Object.getClass()=[Ljava.lang.Class;@7397f, public void java.util.HashMap.putAll(java.util.Map)=[Ljava.lang.Class;@59cd, public void java.util.LinkedHashMap.replaceAll(java.util.function.BiFunction)=[Ljava.lang.Class;@994816, public java.lang.Object java.util.HashMap.merge(java.lang.Object,java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1b1e75f, public int java.util.HashMap.size()=[Ljava.lang.Class;@bee157, public boolean java.util.LinkedHashMap.containsValue(java.lang.Object)=[Ljava.lang.Class;@5e0d7c}, replaceAll=public void java.util.LinkedHashMap.replaceAll(java.util.function.BiFunction), remove=freemarker.ext.beans.OverloadedMethods@8d3a99, containsValue=public boolean java.util.LinkedHashMap.containsValue(java.lang.Object), put=public java.lang.Object java.util.HashMap.put(java.lang.Object,java.lang.Object), empty=java.beans.PropertyDescriptor[name=empty; propertyType=boolean; readMethod=public boolean java.util.HashMap.isEmpty()], compute=public java.lang.Object java.util.HashMap.compute(java.lang.Object,java.util.function.BiFunction), hashCode=public int java.util.AbstractMap.hashCode(), putAll=public void java.util.HashMap.putAll(java.util.Map), get=public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object), merge=public java.lang.Object java.util.HashMap.merge(java.lang.Object,java.lang.Object,java.util.function.BiFunction), class=java.beans.PropertyDescriptor[name=class; propertyType=class java.lang.Class; readMethod=public final native java.lang.Class java.lang.Object.getClass()], keySet=public java.util.Set java.util.LinkedHashMap.keySet(), java.lang.Object@1c0f21d=freemarker.ext.beans.OverloadedMethods@d4b988, entrySet=public java.util.Set java.util.LinkedHashMap.entrySet(), java.lang.Object@15be27d=public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object), forEach=public void java.util.LinkedHashMap.forEach(java.util.function.BiConsumer), containsKey=public boolean java.util.HashMap.containsKey(java.lang.Object), isEmpty=public boolean java.util.HashMap.isEmpty(), clear=public void java.util.LinkedHashMap.clear(), computeIfPresent=public java.lang.Object java.util.HashMap.computeIfPresent(java.lang.Object,java.util.function.BiFunction), size=public int java.util.HashMap.size(), equals=public boolean java.util.AbstractMap.equals(java.lang.Object), clone=public java.lang.Object java.util.HashMap.clone(), toString=public java.lang.String java.util.AbstractMap.toString(), putIfAbsent=public java.lang.Object java.util.HashMap.putIfAbsent(java.lang.Object,java.lang.Object)}
[DEBUG] 2017-05-24: 21:05:32 freemarker.log._Log4jLoggerFactory$Log4jLogger.debug(_Log4jLoggerFactory.java:45) :  Key "listCssStyle" was not found on instance of java.util.LinkedHashMap. Introspection information for the class is: {getClass=public final native java.lang.Class java.lang.Object.getClass(), getOrDefault=public java.lang.Object java.util.LinkedHashMap.getOrDefault(java.lang.Object,java.lang.Object), computeIfAbsent=public java.lang.Object java.util.HashMap.computeIfAbsent(java.lang.Object,java.util.function.Function), values=public java.util.Collection java.util.LinkedHashMap.values(), replace=freemarker.ext.beans.OverloadedMethods@11d0265, java.lang.Object@3e55b2={public boolean java.util.HashMap.isEmpty()=[Ljava.lang.Class;@c5aa3a, public int java.util.AbstractMap.hashCode()=[Ljava.lang.Class;@74a947, public java.lang.Object java.util.HashMap.put(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@1615a91, public boolean java.util.AbstractMap.equals(java.lang.Object)=[Ljava.lang.Class;@a46ab2, public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object)=[Ljava.lang.Class;@1c389e6, public java.lang.String java.util.AbstractMap.toString()=[Ljava.lang.Class;@a23548, public boolean java.util.HashMap.containsKey(java.lang.Object)=[Ljava.lang.Class;@1be4a9f, public java.util.Set java.util.LinkedHashMap.keySet()=[Ljava.lang.Class;@44c60, public java.lang.Object java.util.HashMap.computeIfAbsent(java.lang.Object,java.util.function.Function)=[Ljava.lang.Class;@10f7dff, public java.lang.Object java.util.HashMap.clone()=[Ljava.lang.Class;@d214e3, public java.lang.Object java.util.LinkedHashMap.getOrDefault(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@1a74254, public java.util.Set java.util.LinkedHashMap.entrySet()=[Ljava.lang.Class;@1c4740c, public void java.util.LinkedHashMap.forEach(java.util.function.BiConsumer)=[Ljava.lang.Class;@1fe0c8e, public java.lang.Object java.util.HashMap.putIfAbsent(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@16f73de, public java.util.Collection java.util.LinkedHashMap.values()=[Ljava.lang.Class;@b3e45, public void java.util.LinkedHashMap.clear()=[Ljava.lang.Class;@a34e5c, public java.lang.Object java.util.HashMap.computeIfPresent(java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1fcb13a, public java.lang.Object java.util.HashMap.compute(java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1a7c258, public final native java.lang.Class java.lang.Object.getClass()=[Ljava.lang.Class;@7397f, public void java.util.HashMap.putAll(java.util.Map)=[Ljava.lang.Class;@59cd, public void java.util.LinkedHashMap.replaceAll(java.util.function.BiFunction)=[Ljava.lang.Class;@994816, public java.lang.Object java.util.HashMap.merge(java.lang.Object,java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1b1e75f, public int java.util.HashMap.size()=[Ljava.lang.Class;@bee157, public boolean java.util.LinkedHashMap.containsValue(java.lang.Object)=[Ljava.lang.Class;@5e0d7c}, replaceAll=public void java.util.LinkedHashMap.replaceAll(java.util.function.BiFunction), remove=freemarker.ext.beans.OverloadedMethods@8d3a99, containsValue=public boolean java.util.LinkedHashMap.containsValue(java.lang.Object), put=public java.lang.Object java.util.HashMap.put(java.lang.Object,java.lang.Object), empty=java.beans.PropertyDescriptor[name=empty; propertyType=boolean; readMethod=public boolean java.util.HashMap.isEmpty()], compute=public java.lang.Object java.util.HashMap.compute(java.lang.Object,java.util.function.BiFunction), hashCode=public int java.util.AbstractMap.hashCode(), putAll=public void java.util.HashMap.putAll(java.util.Map), get=public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object), merge=public java.lang.Object java.util.HashMap.merge(java.lang.Object,java.lang.Object,java.util.function.BiFunction), class=java.beans.PropertyDescriptor[name=class; propertyType=class java.lang.Class; readMethod=public final native java.lang.Class java.lang.Object.getClass()], keySet=public java.util.Set java.util.LinkedHashMap.keySet(), java.lang.Object@1c0f21d=freemarker.ext.beans.OverloadedMethods@d4b988, entrySet=public java.util.Set java.util.LinkedHashMap.entrySet(), java.lang.Object@15be27d=public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object), forEach=public void java.util.LinkedHashMap.forEach(java.util.function.BiConsumer), containsKey=public boolean java.util.HashMap.containsKey(java.lang.Object), isEmpty=public boolean java.util.HashMap.isEmpty(), clear=public void java.util.LinkedHashMap.clear(), computeIfPresent=public java.lang.Object java.util.HashMap.computeIfPresent(java.lang.Object,java.util.function.BiFunction), size=public int java.util.HashMap.size(), equals=public boolean java.util.AbstractMap.equals(java.lang.Object), clone=public java.lang.Object java.util.HashMap.clone(), toString=public java.lang.String java.util.AbstractMap.toString(), putIfAbsent=public java.lang.Object java.util.HashMap.putIfAbsent(java.lang.Object,java.lang.Object)}
[DEBUG] 2017-05-24: 21:05:32 freemarker.log._Log4jLoggerFactory$Log4jLogger.debug(_Log4jLoggerFactory.java:45) :  Key "listTitle" was not found on instance of java.util.LinkedHashMap. Introspection information for the class is: {getClass=public final native java.lang.Class java.lang.Object.getClass(), getOrDefault=public java.lang.Object java.util.LinkedHashMap.getOrDefault(java.lang.Object,java.lang.Object), computeIfAbsent=public java.lang.Object java.util.HashMap.computeIfAbsent(java.lang.Object,java.util.function.Function), values=public java.util.Collection java.util.LinkedHashMap.values(), replace=freemarker.ext.beans.OverloadedMethods@11d0265, java.lang.Object@3e55b2={public boolean java.util.HashMap.isEmpty()=[Ljava.lang.Class;@c5aa3a, public int java.util.AbstractMap.hashCode()=[Ljava.lang.Class;@74a947, public java.lang.Object java.util.HashMap.put(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@1615a91, public boolean java.util.AbstractMap.equals(java.lang.Object)=[Ljava.lang.Class;@a46ab2, public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object)=[Ljava.lang.Class;@1c389e6, public java.lang.String java.util.AbstractMap.toString()=[Ljava.lang.Class;@a23548, public boolean java.util.HashMap.containsKey(java.lang.Object)=[Ljava.lang.Class;@1be4a9f, public java.util.Set java.util.LinkedHashMap.keySet()=[Ljava.lang.Class;@44c60, public java.lang.Object java.util.HashMap.computeIfAbsent(java.lang.Object,java.util.function.Function)=[Ljava.lang.Class;@10f7dff, public java.lang.Object java.util.HashMap.clone()=[Ljava.lang.Class;@d214e3, public java.lang.Object java.util.LinkedHashMap.getOrDefault(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@1a74254, public java.util.Set java.util.LinkedHashMap.entrySet()=[Ljava.lang.Class;@1c4740c, public void java.util.LinkedHashMap.forEach(java.util.function.BiConsumer)=[Ljava.lang.Class;@1fe0c8e, public java.lang.Object java.util.HashMap.putIfAbsent(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@16f73de, public java.util.Collection java.util.LinkedHashMap.values()=[Ljava.lang.Class;@b3e45, public void java.util.LinkedHashMap.clear()=[Ljava.lang.Class;@a34e5c, public java.lang.Object java.util.HashMap.computeIfPresent(java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1fcb13a, public java.lang.Object java.util.HashMap.compute(java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1a7c258, public final native java.lang.Class java.lang.Object.getClass()=[Ljava.lang.Class;@7397f, public void java.util.HashMap.putAll(java.util.Map)=[Ljava.lang.Class;@59cd, public void java.util.LinkedHashMap.replaceAll(java.util.function.BiFunction)=[Ljava.lang.Class;@994816, public java.lang.Object java.util.HashMap.merge(java.lang.Object,java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1b1e75f, public int java.util.HashMap.size()=[Ljava.lang.Class;@bee157, public boolean java.util.LinkedHashMap.containsValue(java.lang.Object)=[Ljava.lang.Class;@5e0d7c}, replaceAll=public void java.util.LinkedHashMap.replaceAll(java.util.function.BiFunction), remove=freemarker.ext.beans.OverloadedMethods@8d3a99, containsValue=public boolean java.util.LinkedHashMap.containsValue(java.lang.Object), put=public java.lang.Object java.util.HashMap.put(java.lang.Object,java.lang.Object), empty=java.beans.PropertyDescriptor[name=empty; propertyType=boolean; readMethod=public boolean java.util.HashMap.isEmpty()], compute=public java.lang.Object java.util.HashMap.compute(java.lang.Object,java.util.function.BiFunction), hashCode=public int java.util.AbstractMap.hashCode(), putAll=public void java.util.HashMap.putAll(java.util.Map), get=public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object), merge=public java.lang.Object java.util.HashMap.merge(java.lang.Object,java.lang.Object,java.util.function.BiFunction), class=java.beans.PropertyDescriptor[name=class; propertyType=class java.lang.Class; readMethod=public final native java.lang.Class java.lang.Object.getClass()], keySet=public java.util.Set java.util.LinkedHashMap.keySet(), java.lang.Object@1c0f21d=freemarker.ext.beans.OverloadedMethods@d4b988, entrySet=public java.util.Set java.util.LinkedHashMap.entrySet(), java.lang.Object@15be27d=public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object), forEach=public void java.util.LinkedHashMap.forEach(java.util.function.BiConsumer), containsKey=public boolean java.util.HashMap.containsKey(java.lang.Object), isEmpty=public boolean java.util.HashMap.isEmpty(), clear=public void java.util.LinkedHashMap.clear(), computeIfPresent=public java.lang.Object java.util.HashMap.computeIfPresent(java.lang.Object,java.util.function.BiFunction), size=public int java.util.HashMap.size(), equals=public boolean java.util.AbstractMap.equals(java.lang.Object), clone=public java.lang.Object java.util.HashMap.clone(), toString=public java.lang.String java.util.AbstractMap.toString(), putIfAbsent=public java.lang.Object java.util.HashMap.putIfAbsent(java.lang.Object,java.lang.Object)}
[DEBUG] 2017-05-24: 21:05:32 freemarker.log._Log4jLoggerFactory$Log4jLogger.debug(_Log4jLoggerFactory.java:45) :  Key "nameValue" was not found on instance of java.util.LinkedHashMap. Introspection information for the class is: {getClass=public final native java.lang.Class java.lang.Object.getClass(), getOrDefault=public java.lang.Object java.util.LinkedHashMap.getOrDefault(java.lang.Object,java.lang.Object), computeIfAbsent=public java.lang.Object java.util.HashMap.computeIfAbsent(java.lang.Object,java.util.function.Function), values=public java.util.Collection java.util.LinkedHashMap.values(), replace=freemarker.ext.beans.OverloadedMethods@11d0265, java.lang.Object@3e55b2={public boolean java.util.HashMap.isEmpty()=[Ljava.lang.Class;@c5aa3a, public int java.util.AbstractMap.hashCode()=[Ljava.lang.Class;@74a947, public java.lang.Object java.util.HashMap.put(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@1615a91, public boolean java.util.AbstractMap.equals(java.lang.Object)=[Ljava.lang.Class;@a46ab2, public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object)=[Ljava.lang.Class;@1c389e6, public java.lang.String java.util.AbstractMap.toString()=[Ljava.lang.Class;@a23548, public boolean java.util.HashMap.containsKey(java.lang.Object)=[Ljava.lang.Class;@1be4a9f, public java.util.Set java.util.LinkedHashMap.keySet()=[Ljava.lang.Class;@44c60, public java.lang.Object java.util.HashMap.computeIfAbsent(java.lang.Object,java.util.function.Function)=[Ljava.lang.Class;@10f7dff, public java.lang.Object java.util.HashMap.clone()=[Ljava.lang.Class;@d214e3, public java.lang.Object java.util.LinkedHashMap.getOrDefault(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@1a74254, public java.util.Set java.util.LinkedHashMap.entrySet()=[Ljava.lang.Class;@1c4740c, public void java.util.LinkedHashMap.forEach(java.util.function.BiConsumer)=[Ljava.lang.Class;@1fe0c8e, public java.lang.Object java.util.HashMap.putIfAbsent(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@16f73de, public java.util.Collection java.util.LinkedHashMap.values()=[Ljava.lang.Class;@b3e45, public void java.util.LinkedHashMap.clear()=[Ljava.lang.Class;@a34e5c, public java.lang.Object java.util.HashMap.computeIfPresent(java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1fcb13a, public java.lang.Object java.util.HashMap.compute(java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1a7c258, public final native java.lang.Class java.lang.Object.getClass()=[Ljava.lang.Class;@7397f, public void java.util.HashMap.putAll(java.util.Map)=[Ljava.lang.Class;@59cd, public void java.util.LinkedHashMap.replaceAll(java.util.function.BiFunction)=[Ljava.lang.Class;@994816, public java.lang.Object java.util.HashMap.merge(java.lang.Object,java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1b1e75f, public int java.util.HashMap.size()=[Ljava.lang.Class;@bee157, public boolean java.util.LinkedHashMap.containsValue(java.lang.Object)=[Ljava.lang.Class;@5e0d7c}, replaceAll=public void java.util.LinkedHashMap.replaceAll(java.util.function.BiFunction), remove=freemarker.ext.beans.OverloadedMethods@8d3a99, containsValue=public boolean java.util.LinkedHashMap.containsValue(java.lang.Object), put=public java.lang.Object java.util.HashMap.put(java.lang.Object,java.lang.Object), empty=java.beans.PropertyDescriptor[name=empty; propertyType=boolean; readMethod=public boolean java.util.HashMap.isEmpty()], compute=public java.lang.Object java.util.HashMap.compute(java.lang.Object,java.util.function.BiFunction), hashCode=public int java.util.AbstractMap.hashCode(), putAll=public void java.util.HashMap.putAll(java.util.Map), get=public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object), merge=public java.lang.Object java.util.HashMap.merge(java.lang.Object,java.lang.Object,java.util.function.BiFunction), class=java.beans.PropertyDescriptor[name=class; propertyType=class java.lang.Class; readMethod=public final native java.lang.Class java.lang.Object.getClass()], keySet=public java.util.Set java.util.LinkedHashMap.keySet(), java.lang.Object@1c0f21d=freemarker.ext.beans.OverloadedMethods@d4b988, entrySet=public java.util.Set java.util.LinkedHashMap.entrySet(), java.lang.Object@15be27d=public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object), forEach=public void java.util.LinkedHashMap.forEach(java.util.function.BiConsumer), containsKey=public boolean java.util.HashMap.containsKey(java.lang.Object), isEmpty=public boolean java.util.HashMap.isEmpty(), clear=public void java.util.LinkedHashMap.clear(), computeIfPresent=public java.lang.Object java.util.HashMap.computeIfPresent(java.lang.Object,java.util.function.BiFunction), size=public int java.util.HashMap.size(), equals=public boolean java.util.AbstractMap.equals(java.lang.Object), clone=public java.lang.Object java.util.HashMap.clone(), toString=public java.lang.String java.util.AbstractMap.toString(), putIfAbsent=public java.lang.Object java.util.HashMap.putIfAbsent(java.lang.Object,java.lang.Object)}
[DEBUG] 2017-05-24: 21:05:32 freemarker.log._Log4jLoggerFactory$Log4jLogger.debug(_Log4jLoggerFactory.java:45) :  Key "disabled" was not found on instance of java.util.LinkedHashMap. Introspection information for the class is: {getClass=public final native java.lang.Class java.lang.Object.getClass(), getOrDefault=public java.lang.Object java.util.LinkedHashMap.getOrDefault(java.lang.Object,java.lang.Object), computeIfAbsent=public java.lang.Object java.util.HashMap.computeIfAbsent(java.lang.Object,java.util.function.Function), values=public java.util.Collection java.util.LinkedHashMap.values(), replace=freemarker.ext.beans.OverloadedMethods@11d0265, java.lang.Object@3e55b2={public boolean java.util.HashMap.isEmpty()=[Ljava.lang.Class;@c5aa3a, public int java.util.AbstractMap.hashCode()=[Ljava.lang.Class;@74a947, public java.lang.Object java.util.HashMap.put(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@1615a91, public boolean java.util.AbstractMap.equals(java.lang.Object)=[Ljava.lang.Class;@a46ab2, public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object)=[Ljava.lang.Class;@1c389e6, public java.lang.String java.util.AbstractMap.toString()=[Ljava.lang.Class;@a23548, public boolean java.util.HashMap.containsKey(java.lang.Object)=[Ljava.lang.Class;@1be4a9f, public java.util.Set java.util.LinkedHashMap.keySet()=[Ljava.lang.Class;@44c60, public java.lang.Object java.util.HashMap.computeIfAbsent(java.lang.Object,java.util.function.Function)=[Ljava.lang.Class;@10f7dff, public java.lang.Object java.util.HashMap.clone()=[Ljava.lang.Class;@d214e3, public java.lang.Object java.util.LinkedHashMap.getOrDefault(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@1a74254, public java.util.Set java.util.LinkedHashMap.entrySet()=[Ljava.lang.Class;@1c4740c, public void java.util.LinkedHashMap.forEach(java.util.function.BiConsumer)=[Ljava.lang.Class;@1fe0c8e, public java.lang.Object java.util.HashMap.putIfAbsent(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@16f73de, public java.util.Collection java.util.LinkedHashMap.values()=[Ljava.lang.Class;@b3e45, public void java.util.LinkedHashMap.clear()=[Ljava.lang.Class;@a34e5c, public java.lang.Object java.util.HashMap.computeIfPresent(java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1fcb13a, public java.lang.Object java.util.HashMap.compute(java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1a7c258, public final native java.lang.Class java.lang.Object.getClass()=[Ljava.lang.Class;@7397f, public void java.util.HashMap.putAll(java.util.Map)=[Ljava.lang.Class;@59cd, public void java.util.LinkedHashMap.replaceAll(java.util.function.BiFunction)=[Ljava.lang.Class;@994816, public java.lang.Object java.util.HashMap.merge(java.lang.Object,java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1b1e75f, public int java.util.HashMap.size()=[Ljava.lang.Class;@bee157, public boolean java.util.LinkedHashMap.containsValue(java.lang.Object)=[Ljava.lang.Class;@5e0d7c}, replaceAll=public void java.util.LinkedHashMap.replaceAll(java.util.function.BiFunction), remove=freemarker.ext.beans.OverloadedMethods@8d3a99, containsValue=public boolean java.util.LinkedHashMap.containsValue(java.lang.Object), put=public java.lang.Object java.util.HashMap.put(java.lang.Object,java.lang.Object), empty=java.beans.PropertyDescriptor[name=empty; propertyType=boolean; readMethod=public boolean java.util.HashMap.isEmpty()], compute=public java.lang.Object java.util.HashMap.compute(java.lang.Object,java.util.function.BiFunction), hashCode=public int java.util.AbstractMap.hashCode(), putAll=public void java.util.HashMap.putAll(java.util.Map), get=public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object), merge=public java.lang.Object java.util.HashMap.merge(java.lang.Object,java.lang.Object,java.util.function.BiFunction), class=java.beans.PropertyDescriptor[name=class; propertyType=class java.lang.Class; readMethod=public final native java.lang.Class java.lang.Object.getClass()], keySet=public java.util.Set java.util.LinkedHashMap.keySet(), java.lang.Object@1c0f21d=freemarker.ext.beans.OverloadedMethods@d4b988, entrySet=public java.util.Set java.util.LinkedHashMap.entrySet(), java.lang.Object@15be27d=public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object), forEach=public void java.util.LinkedHashMap.forEach(java.util.function.BiConsumer), containsKey=public boolean java.util.HashMap.containsKey(java.lang.Object), isEmpty=public boolean java.util.HashMap.isEmpty(), clear=public void java.util.LinkedHashMap.clear(), computeIfPresent=public java.lang.Object java.util.HashMap.computeIfPresent(java.lang.Object,java.util.function.BiFunction), size=public int java.util.HashMap.size(), equals=public boolean java.util.AbstractMap.equals(java.lang.Object), clone=public java.lang.Object java.util.HashMap.clone(), toString=public java.lang.String java.util.AbstractMap.toString(), putIfAbsent=public java.lang.Object java.util.HashMap.putIfAbsent(java.lang.Object,java.lang.Object)}
[DEBUG] 2017-05-24: 21:05:32 freemarker.log._Log4jLoggerFactory$Log4jLogger.debug(_Log4jLoggerFactory.java:45) :  Key "tabindex" was not found on instance of java.util.LinkedHashMap. Introspection information for the class is: {getClass=public final native java.lang.Class java.lang.Object.getClass(), getOrDefault=public java.lang.Object java.util.LinkedHashMap.getOrDefault(java.lang.Object,java.lang.Object), computeIfAbsent=public java.lang.Object java.util.HashMap.computeIfAbsent(java.lang.Object,java.util.function.Function), values=public java.util.Collection java.util.LinkedHashMap.values(), replace=freemarker.ext.beans.OverloadedMethods@11d0265, java.lang.Object@3e55b2={public boolean java.util.HashMap.isEmpty()=[Ljava.lang.Class;@c5aa3a, public int java.util.AbstractMap.hashCode()=[Ljava.lang.Class;@74a947, public java.lang.Object java.util.HashMap.put(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@1615a91, public boolean java.util.AbstractMap.equals(java.lang.Object)=[Ljava.lang.Class;@a46ab2, public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object)=[Ljava.lang.Class;@1c389e6, public java.lang.String java.util.AbstractMap.toString()=[Ljava.lang.Class;@a23548, public boolean java.util.HashMap.containsKey(java.lang.Object)=[Ljava.lang.Class;@1be4a9f, public java.util.Set java.util.LinkedHashMap.keySet()=[Ljava.lang.Class;@44c60, public java.lang.Object java.util.HashMap.computeIfAbsent(java.lang.Object,java.util.function.Function)=[Ljava.lang.Class;@10f7dff, public java.lang.Object java.util.HashMap.clone()=[Ljava.lang.Class;@d214e3, public java.lang.Object java.util.LinkedHashMap.getOrDefault(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@1a74254, public java.util.Set java.util.LinkedHashMap.entrySet()=[Ljava.lang.Class;@1c4740c, public void java.util.LinkedHashMap.forEach(java.util.function.BiConsumer)=[Ljava.lang.Class;@1fe0c8e, public java.lang.Object java.util.HashMap.putIfAbsent(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@16f73de, public java.util.Collection java.util.LinkedHashMap.values()=[Ljava.lang.Class;@b3e45, public void java.util.LinkedHashMap.clear()=[Ljava.lang.Class;@a34e5c, public java.lang.Object java.util.HashMap.computeIfPresent(java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1fcb13a, public java.lang.Object java.util.HashMap.compute(java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1a7c258, public final native java.lang.Class java.lang.Object.getClass()=[Ljava.lang.Class;@7397f, public void java.util.HashMap.putAll(java.util.Map)=[Ljava.lang.Class;@59cd, public void java.util.LinkedHashMap.replaceAll(java.util.function.BiFunction)=[Ljava.lang.Class;@994816, public java.lang.Object java.util.HashMap.merge(java.lang.Object,java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1b1e75f, public int java.util.HashMap.size()=[Ljava.lang.Class;@bee157, public boolean java.util.LinkedHashMap.containsValue(java.lang.Object)=[Ljava.lang.Class;@5e0d7c}, replaceAll=public void java.util.LinkedHashMap.replaceAll(java.util.function.BiFunction), remove=freemarker.ext.beans.OverloadedMethods@8d3a99, containsValue=public boolean java.util.LinkedHashMap.containsValue(java.lang.Object), put=public java.lang.Object java.util.HashMap.put(java.lang.Object,java.lang.Object), empty=java.beans.PropertyDescriptor[name=empty; propertyType=boolean; readMethod=public boolean java.util.HashMap.isEmpty()], compute=public java.lang.Object java.util.HashMap.compute(java.lang.Object,java.util.function.BiFunction), hashCode=public int java.util.AbstractMap.hashCode(), putAll=public void java.util.HashMap.putAll(java.util.Map), get=public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object), merge=public java.lang.Object java.util.HashMap.merge(java.lang.Object,java.lang.Object,java.util.function.BiFunction), class=java.beans.PropertyDescriptor[name=class; propertyType=class java.lang.Class; readMethod=public final native java.lang.Class java.lang.Object.getClass()], keySet=public java.util.Set java.util.LinkedHashMap.keySet(), java.lang.Object@1c0f21d=freemarker.ext.beans.OverloadedMethods@d4b988, entrySet=public java.util.Set java.util.LinkedHashMap.entrySet(), java.lang.Object@15be27d=public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object), forEach=public void java.util.LinkedHashMap.forEach(java.util.function.BiConsumer), containsKey=public boolean java.util.HashMap.containsKey(java.lang.Object), isEmpty=public boolean java.util.HashMap.isEmpty(), clear=public void java.util.LinkedHashMap.clear(), computeIfPresent=public java.lang.Object java.util.HashMap.computeIfPresent(java.lang.Object,java.util.function.BiFunction), size=public int java.util.HashMap.size(), equals=public boolean java.util.AbstractMap.equals(java.lang.Object), clone=public java.lang.Object java.util.HashMap.clone(), toString=public java.lang.String java.util.AbstractMap.toString(), putIfAbsent=public java.lang.Object java.util.HashMap.putIfAbsent(java.lang.Object,java.lang.Object)}
[DEBUG] 2017-05-24: 21:05:32 freemarker.log._Log4jLoggerFactory$Log4jLogger.debug(_Log4jLoggerFactory.java:45) :  Key "title" was not found on instance of java.util.LinkedHashMap. Introspection information for the class is: {getClass=public final native java.lang.Class java.lang.Object.getClass(), getOrDefault=public java.lang.Object java.util.LinkedHashMap.getOrDefault(java.lang.Object,java.lang.Object), computeIfAbsent=public java.lang.Object java.util.HashMap.computeIfAbsent(java.lang.Object,java.util.function.Function), values=public java.util.Collection java.util.LinkedHashMap.values(), replace=freemarker.ext.beans.OverloadedMethods@11d0265, java.lang.Object@3e55b2={public boolean java.util.HashMap.isEmpty()=[Ljava.lang.Class;@c5aa3a, public int java.util.AbstractMap.hashCode()=[Ljava.lang.Class;@74a947, public java.lang.Object java.util.HashMap.put(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@1615a91, public boolean java.util.AbstractMap.equals(java.lang.Object)=[Ljava.lang.Class;@a46ab2, public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object)=[Ljava.lang.Class;@1c389e6, public java.lang.String java.util.AbstractMap.toString()=[Ljava.lang.Class;@a23548, public boolean java.util.HashMap.containsKey(java.lang.Object)=[Ljava.lang.Class;@1be4a9f, public java.util.Set java.util.LinkedHashMap.keySet()=[Ljava.lang.Class;@44c60, public java.lang.Object java.util.HashMap.computeIfAbsent(java.lang.Object,java.util.function.Function)=[Ljava.lang.Class;@10f7dff, public java.lang.Object java.util.HashMap.clone()=[Ljava.lang.Class;@d214e3, public java.lang.Object java.util.LinkedHashMap.getOrDefault(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@1a74254, public java.util.Set java.util.LinkedHashMap.entrySet()=[Ljava.lang.Class;@1c4740c, public void java.util.LinkedHashMap.forEach(java.util.function.BiConsumer)=[Ljava.lang.Class;@1fe0c8e, public java.lang.Object java.util.HashMap.putIfAbsent(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@16f73de, public java.util.Collection java.util.LinkedHashMap.values()=[Ljava.lang.Class;@b3e45, public void java.util.LinkedHashMap.clear()=[Ljava.lang.Class;@a34e5c, public java.lang.Object java.util.HashMap.computeIfPresent(java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1fcb13a, public java.lang.Object java.util.HashMap.compute(java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1a7c258, public final native java.lang.Class java.lang.Object.getClass()=[Ljava.lang.Class;@7397f, public void java.util.HashMap.putAll(java.util.Map)=[Ljava.lang.Class;@59cd, public void java.util.LinkedHashMap.replaceAll(java.util.function.BiFunction)=[Ljava.lang.Class;@994816, public java.lang.Object java.util.HashMap.merge(java.lang.Object,java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1b1e75f, public int java.util.HashMap.size()=[Ljava.lang.Class;@bee157, public boolean java.util.LinkedHashMap.containsValue(java.lang.Object)=[Ljava.lang.Class;@5e0d7c}, replaceAll=public void java.util.LinkedHashMap.replaceAll(java.util.function.BiFunction), remove=freemarker.ext.beans.OverloadedMethods@8d3a99, containsValue=public boolean java.util.LinkedHashMap.containsValue(java.lang.Object), put=public java.lang.Object java.util.HashMap.put(java.lang.Object,java.lang.Object), empty=java.beans.PropertyDescriptor[name=empty; propertyType=boolean; readMethod=public boolean java.util.HashMap.isEmpty()], compute=public java.lang.Object java.util.HashMap.compute(java.lang.Object,java.util.function.BiFunction), hashCode=public int java.util.AbstractMap.hashCode(), putAll=public void java.util.HashMap.putAll(java.util.Map), get=public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object), merge=public java.lang.Object java.util.HashMap.merge(java.lang.Object,java.lang.Object,java.util.function.BiFunction), class=java.beans.PropertyDescriptor[name=class; propertyType=class java.lang.Class; readMethod=public final native java.lang.Class java.lang.Object.getClass()], keySet=public java.util.Set java.util.LinkedHashMap.keySet(), java.lang.Object@1c0f21d=freemarker.ext.beans.OverloadedMethods@d4b988, entrySet=public java.util.Set java.util.LinkedHashMap.entrySet(), java.lang.Object@15be27d=public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object), forEach=public void java.util.LinkedHashMap.forEach(java.util.function.BiConsumer), containsKey=public boolean java.util.HashMap.containsKey(java.lang.Object), isEmpty=public boolean java.util.HashMap.isEmpty(), clear=public void java.util.LinkedHashMap.clear(), computeIfPresent=public java.lang.Object java.util.HashMap.computeIfPresent(java.lang.Object,java.util.function.BiFunction), size=public int java.util.HashMap.size(), equals=public boolean java.util.AbstractMap.equals(java.lang.Object), clone=public java.lang.Object java.util.HashMap.clone(), toString=public java.lang.String java.util.AbstractMap.toString(), putIfAbsent=public java.lang.Object java.util.HashMap.putIfAbsent(java.lang.Object,java.lang.Object)}
[DEBUG] 2017-05-24: 21:05:32 freemarker.log._Log4jLoggerFactory$Log4jLogger.debug(_Log4jLoggerFactory.java:45) :  TemplateLoader.findTemplateSource("template/~~~xhtml/css.ftl"): Found
[DEBUG] 2017-05-24: 21:05:32 freemarker.log._Log4jLoggerFactory$Log4jLogger.debug(_Log4jLoggerFactory.java:45) :  "template/~~~xhtml/css.ftl"("zh_CN", UTF-8, parsed): using cached since jar:file:/D:/maven/repository/org/apache/struts/struts2-core/2.5.10/struts2-core-2.5.10.jar!/template/simple/css.ftl hasn't changed.
[DEBUG] 2017-05-24: 21:05:32 freemarker.log._Log4jLoggerFactory$Log4jLogger.debug(_Log4jLoggerFactory.java:45) :  Key "cssClass" was not found on instance of java.util.LinkedHashMap. Introspection information for the class is: {getClass=public final native java.lang.Class java.lang.Object.getClass(), getOrDefault=public java.lang.Object java.util.LinkedHashMap.getOrDefault(java.lang.Object,java.lang.Object), computeIfAbsent=public java.lang.Object java.util.HashMap.computeIfAbsent(java.lang.Object,java.util.function.Function), values=public java.util.Collection java.util.LinkedHashMap.values(), replace=freemarker.ext.beans.OverloadedMethods@11d0265, java.lang.Object@3e55b2={public boolean java.util.HashMap.isEmpty()=[Ljava.lang.Class;@c5aa3a, public int java.util.AbstractMap.hashCode()=[Ljava.lang.Class;@74a947, public java.lang.Object java.util.HashMap.put(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@1615a91, public boolean java.util.AbstractMap.equals(java.lang.Object)=[Ljava.lang.Class;@a46ab2, public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object)=[Ljava.lang.Class;@1c389e6, public java.lang.String java.util.AbstractMap.toString()=[Ljava.lang.Class;@a23548, public boolean java.util.HashMap.containsKey(java.lang.Object)=[Ljava.lang.Class;@1be4a9f, public java.util.Set java.util.LinkedHashMap.keySet()=[Ljava.lang.Class;@44c60, public java.lang.Object java.util.HashMap.computeIfAbsent(java.lang.Object,java.util.function.Function)=[Ljava.lang.Class;@10f7dff, public java.lang.Object java.util.HashMap.clone()=[Ljava.lang.Class;@d214e3, public java.lang.Object java.util.LinkedHashMap.getOrDefault(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@1a74254, public java.util.Set java.util.LinkedHashMap.entrySet()=[Ljava.lang.Class;@1c4740c, public void java.util.LinkedHashMap.forEach(java.util.function.BiConsumer)=[Ljava.lang.Class;@1fe0c8e, public java.lang.Object java.util.HashMap.putIfAbsent(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@16f73de, public java.util.Collection java.util.LinkedHashMap.values()=[Ljava.lang.Class;@b3e45, public void java.util.LinkedHashMap.clear()=[Ljava.lang.Class;@a34e5c, public java.lang.Object java.util.HashMap.computeIfPresent(java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1fcb13a, public java.lang.Object java.util.HashMap.compute(java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1a7c258, public final native java.lang.Class java.lang.Object.getClass()=[Ljava.lang.Class;@7397f, public void java.util.HashMap.putAll(java.util.Map)=[Ljava.lang.Class;@59cd, public void java.util.LinkedHashMap.replaceAll(java.util.function.BiFunction)=[Ljava.lang.Class;@994816, public java.lang.Object java.util.HashMap.merge(java.lang.Object,java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1b1e75f, public int java.util.HashMap.size()=[Ljava.lang.Class;@bee157, public boolean java.util.LinkedHashMap.containsValue(java.lang.Object)=[Ljava.lang.Class;@5e0d7c}, replaceAll=public void java.util.LinkedHashMap.replaceAll(java.util.function.BiFunction), remove=freemarker.ext.beans.OverloadedMethods@8d3a99, containsValue=public boolean java.util.LinkedHashMap.containsValue(java.lang.Object), put=public java.lang.Object java.util.HashMap.put(java.lang.Object,java.lang.Object), empty=java.beans.PropertyDescriptor[name=empty; propertyType=boolean; readMethod=public boolean java.util.HashMap.isEmpty()], compute=public java.lang.Object java.util.HashMap.compute(java.lang.Object,java.util.function.BiFunction), hashCode=public int java.util.AbstractMap.hashCode(), putAll=public void java.util.HashMap.putAll(java.util.Map), get=public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object), merge=public java.lang.Object java.util.HashMap.merge(java.lang.Object,java.lang.Object,java.util.function.BiFunction), class=java.beans.PropertyDescriptor[name=class; propertyType=class java.lang.Class; readMethod=public final native java.lang.Class java.lang.Object.getClass()], keySet=public java.util.Set java.util.LinkedHashMap.keySet(), java.lang.Object@1c0f21d=freemarker.ext.beans.OverloadedMethods@d4b988, entrySet=public java.util.Set java.util.LinkedHashMap.entrySet(), java.lang.Object@15be27d=public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object), forEach=public void java.util.LinkedHashMap.forEach(java.util.function.BiConsumer), containsKey=public boolean java.util.HashMap.containsKey(java.lang.Object), isEmpty=public boolean java.util.HashMap.isEmpty(), clear=public void java.util.LinkedHashMap.clear(), computeIfPresent=public java.lang.Object java.util.HashMap.computeIfPresent(java.lang.Object,java.util.function.BiFunction), size=public int java.util.HashMap.size(), equals=public boolean java.util.AbstractMap.equals(java.lang.Object), clone=public java.lang.Object java.util.HashMap.clone(), toString=public java.lang.String java.util.AbstractMap.toString(), putIfAbsent=public java.lang.Object java.util.HashMap.putIfAbsent(java.lang.Object,java.lang.Object)}
[DEBUG] 2017-05-24: 21:05:33 freemarker.log._Log4jLoggerFactory$Log4jLogger.debug(_Log4jLoggerFactory.java:45) :  Key "cssClass" was not found on instance of java.util.LinkedHashMap. Introspection information for the class is: {getClass=public final native java.lang.Class java.lang.Object.getClass(), getOrDefault=public java.lang.Object java.util.LinkedHashMap.getOrDefault(java.lang.Object,java.lang.Object), computeIfAbsent=public java.lang.Object java.util.HashMap.computeIfAbsent(java.lang.Object,java.util.function.Function), values=public java.util.Collection java.util.LinkedHashMap.values(), replace=freemarker.ext.beans.OverloadedMethods@11d0265, java.lang.Object@3e55b2={public boolean java.util.HashMap.isEmpty()=[Ljava.lang.Class;@c5aa3a, public int java.util.AbstractMap.hashCode()=[Ljava.lang.Class;@74a947, public java.lang.Object java.util.HashMap.put(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@1615a91, public boolean java.util.AbstractMap.equals(java.lang.Object)=[Ljava.lang.Class;@a46ab2, public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object)=[Ljava.lang.Class;@1c389e6, public java.lang.String java.util.AbstractMap.toString()=[Ljava.lang.Class;@a23548, public boolean java.util.HashMap.containsKey(java.lang.Object)=[Ljava.lang.Class;@1be4a9f, public java.util.Set java.util.LinkedHashMap.keySet()=[Ljava.lang.Class;@44c60, public java.lang.Object java.util.HashMap.computeIfAbsent(java.lang.Object,java.util.function.Function)=[Ljava.lang.Class;@10f7dff, public java.lang.Object java.util.HashMap.clone()=[Ljava.lang.Class;@d214e3, public java.lang.Object java.util.LinkedHashMap.getOrDefault(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@1a74254, public java.util.Set java.util.LinkedHashMap.entrySet()=[Ljava.lang.Class;@1c4740c, public void java.util.LinkedHashMap.forEach(java.util.function.BiConsumer)=[Ljava.lang.Class;@1fe0c8e, public java.lang.Object java.util.HashMap.putIfAbsent(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@16f73de, public java.util.Collection java.util.LinkedHashMap.values()=[Ljava.lang.Class;@b3e45, public void java.util.LinkedHashMap.clear()=[Ljava.lang.Class;@a34e5c, public java.lang.Object java.util.HashMap.computeIfPresent(java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1fcb13a, public java.lang.Object java.util.HashMap.compute(java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1a7c258, public final native java.lang.Class java.lang.Object.getClass()=[Ljava.lang.Class;@7397f, public void java.util.HashMap.putAll(java.util.Map)=[Ljava.lang.Class;@59cd, public void java.util.LinkedHashMap.replaceAll(java.util.function.BiFunction)=[Ljava.lang.Class;@994816, public java.lang.Object java.util.HashMap.merge(java.lang.Object,java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1b1e75f, public int java.util.HashMap.size()=[Ljava.lang.Class;@bee157, public boolean java.util.LinkedHashMap.containsValue(java.lang.Object)=[Ljava.lang.Class;@5e0d7c}, replaceAll=public void java.util.LinkedHashMap.replaceAll(java.util.function.BiFunction), remove=freemarker.ext.beans.OverloadedMethods@8d3a99, containsValue=public boolean java.util.LinkedHashMap.containsValue(java.lang.Object), put=public java.lang.Object java.util.HashMap.put(java.lang.Object,java.lang.Object), empty=java.beans.PropertyDescriptor[name=empty; propertyType=boolean; readMethod=public boolean java.util.HashMap.isEmpty()], compute=public java.lang.Object java.util.HashMap.compute(java.lang.Object,java.util.function.BiFunction), hashCode=public int java.util.AbstractMap.hashCode(), putAll=public void java.util.HashMap.putAll(java.util.Map), get=public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object), merge=public java.lang.Object java.util.HashMap.merge(java.lang.Object,java.lang.Object,java.util.function.BiFunction), class=java.beans.PropertyDescriptor[name=class; propertyType=class java.lang.Class; readMethod=public final native java.lang.Class java.lang.Object.getClass()], keySet=public java.util.Set java.util.LinkedHashMap.keySet(), java.lang.Object@1c0f21d=freemarker.ext.beans.OverloadedMethods@d4b988, entrySet=public java.util.Set java.util.LinkedHashMap.entrySet(), java.lang.Object@15be27d=public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object), forEach=public void java.util.LinkedHashMap.forEach(java.util.function.BiConsumer), containsKey=public boolean java.util.HashMap.containsKey(java.lang.Object), isEmpty=public boolean java.util.HashMap.isEmpty(), clear=public void java.util.LinkedHashMap.clear(), computeIfPresent=public java.lang.Object java.util.HashMap.computeIfPresent(java.lang.Object,java.util.function.BiFunction), size=public int java.util.HashMap.size(), equals=public boolean java.util.AbstractMap.equals(java.lang.Object), clone=public java.lang.Object java.util.HashMap.clone(), toString=public java.lang.String java.util.AbstractMap.toString(), putIfAbsent=public java.lang.Object java.util.HashMap.putIfAbsent(java.lang.Object,java.lang.Object)}
[DEBUG] 2017-05-24: 21:05:33 freemarker.log._Log4jLoggerFactory$Log4jLogger.debug(_Log4jLoggerFactory.java:45) :  Key "cssClass" was not found on instance of java.util.LinkedHashMap. Introspection information for the class is: {getClass=public final native java.lang.Class java.lang.Object.getClass(), getOrDefault=public java.lang.Object java.util.LinkedHashMap.getOrDefault(java.lang.Object,java.lang.Object), computeIfAbsent=public java.lang.Object java.util.HashMap.computeIfAbsent(java.lang.Object,java.util.function.Function), values=public java.util.Collection java.util.LinkedHashMap.values(), replace=freemarker.ext.beans.OverloadedMethods@11d0265, java.lang.Object@3e55b2={public boolean java.util.HashMap.isEmpty()=[Ljava.lang.Class;@c5aa3a, public int java.util.AbstractMap.hashCode()=[Ljava.lang.Class;@74a947, public java.lang.Object java.util.HashMap.put(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@1615a91, public boolean java.util.AbstractMap.equals(java.lang.Object)=[Ljava.lang.Class;@a46ab2, public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object)=[Ljava.lang.Class;@1c389e6, public java.lang.String java.util.AbstractMap.toString()=[Ljava.lang.Class;@a23548, public boolean java.util.HashMap.containsKey(java.lang.Object)=[Ljava.lang.Class;@1be4a9f, public java.util.Set java.util.LinkedHashMap.keySet()=[Ljava.lang.Class;@44c60, public java.lang.Object java.util.HashMap.computeIfAbsent(java.lang.Object,java.util.function.Function)=[Ljava.lang.Class;@10f7dff, public java.lang.Object java.util.HashMap.clone()=[Ljava.lang.Class;@d214e3, public java.lang.Object java.util.LinkedHashMap.getOrDefault(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@1a74254, public java.util.Set java.util.LinkedHashMap.entrySet()=[Ljava.lang.Class;@1c4740c, public void java.util.LinkedHashMap.forEach(java.util.function.BiConsumer)=[Ljava.lang.Class;@1fe0c8e, public java.lang.Object java.util.HashMap.putIfAbsent(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@16f73de, public java.util.Collection java.util.LinkedHashMap.values()=[Ljava.lang.Class;@b3e45, public void java.util.LinkedHashMap.clear()=[Ljava.lang.Class;@a34e5c, public java.lang.Object java.util.HashMap.computeIfPresent(java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1fcb13a, public java.lang.Object java.util.HashMap.compute(java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1a7c258, public final native java.lang.Class java.lang.Object.getClass()=[Ljava.lang.Class;@7397f, public void java.util.HashMap.putAll(java.util.Map)=[Ljava.lang.Class;@59cd, public void java.util.LinkedHashMap.replaceAll(java.util.function.BiFunction)=[Ljava.lang.Class;@994816, public java.lang.Object java.util.HashMap.merge(java.lang.Object,java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1b1e75f, public int java.util.HashMap.size()=[Ljava.lang.Class;@bee157, public boolean java.util.LinkedHashMap.containsValue(java.lang.Object)=[Ljava.lang.Class;@5e0d7c}, replaceAll=public void java.util.LinkedHashMap.replaceAll(java.util.function.BiFunction), remove=freemarker.ext.beans.OverloadedMethods@8d3a99, containsValue=public boolean java.util.LinkedHashMap.containsValue(java.lang.Object), put=public java.lang.Object java.util.HashMap.put(java.lang.Object,java.lang.Object), empty=java.beans.PropertyDescriptor[name=empty; propertyType=boolean; readMethod=public boolean java.util.HashMap.isEmpty()], compute=public java.lang.Object java.util.HashMap.compute(java.lang.Object,java.util.function.BiFunction), hashCode=public int java.util.AbstractMap.hashCode(), putAll=public void java.util.HashMap.putAll(java.util.Map), get=public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object), merge=public java.lang.Object java.util.HashMap.merge(java.lang.Object,java.lang.Object,java.util.function.BiFunction), class=java.beans.PropertyDescriptor[name=class; propertyType=class java.lang.Class; readMethod=public final native java.lang.Class java.lang.Object.getClass()], keySet=public java.util.Set java.util.LinkedHashMap.keySet(), java.lang.Object@1c0f21d=freemarker.ext.beans.OverloadedMethods@d4b988, entrySet=public java.util.Set java.util.LinkedHashMap.entrySet(), java.lang.Object@15be27d=public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object), forEach=public void java.util.LinkedHashMap.forEach(java.util.function.BiConsumer), containsKey=public boolean java.util.HashMap.containsKey(java.lang.Object), isEmpty=public boolean java.util.HashMap.isEmpty(), clear=public void java.util.LinkedHashMap.clear(), computeIfPresent=public java.lang.Object java.util.HashMap.computeIfPresent(java.lang.Object,java.util.function.BiFunction), size=public int java.util.HashMap.size(), equals=public boolean java.util.AbstractMap.equals(java.lang.Object), clone=public java.lang.Object java.util.HashMap.clone(), toString=public java.lang.String java.util.AbstractMap.toString(), putIfAbsent=public java.lang.Object java.util.HashMap.putIfAbsent(java.lang.Object,java.lang.Object)}
[DEBUG] 2017-05-24: 21:05:33 freemarker.log._Log4jLoggerFactory$Log4jLogger.debug(_Log4jLoggerFactory.java:45) :  Key "cssStyle" was not found on instance of java.util.LinkedHashMap. Introspection information for the class is: {getClass=public final native java.lang.Class java.lang.Object.getClass(), getOrDefault=public java.lang.Object java.util.LinkedHashMap.getOrDefault(java.lang.Object,java.lang.Object), computeIfAbsent=public java.lang.Object java.util.HashMap.computeIfAbsent(java.lang.Object,java.util.function.Function), values=public java.util.Collection java.util.LinkedHashMap.values(), replace=freemarker.ext.beans.OverloadedMethods@11d0265, java.lang.Object@3e55b2={public boolean java.util.HashMap.isEmpty()=[Ljava.lang.Class;@c5aa3a, public int java.util.AbstractMap.hashCode()=[Ljava.lang.Class;@74a947, public java.lang.Object java.util.HashMap.put(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@1615a91, public boolean java.util.AbstractMap.equals(java.lang.Object)=[Ljava.lang.Class;@a46ab2, public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object)=[Ljava.lang.Class;@1c389e6, public java.lang.String java.util.AbstractMap.toString()=[Ljava.lang.Class;@a23548, public boolean java.util.HashMap.containsKey(java.lang.Object)=[Ljava.lang.Class;@1be4a9f, public java.util.Set java.util.LinkedHashMap.keySet()=[Ljava.lang.Class;@44c60, public java.lang.Object java.util.HashMap.computeIfAbsent(java.lang.Object,java.util.function.Function)=[Ljava.lang.Class;@10f7dff, public java.lang.Object java.util.HashMap.clone()=[Ljava.lang.Class;@d214e3, public java.lang.Object java.util.LinkedHashMap.getOrDefault(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@1a74254, public java.util.Set java.util.LinkedHashMap.entrySet()=[Ljava.lang.Class;@1c4740c, public void java.util.LinkedHashMap.forEach(java.util.function.BiConsumer)=[Ljava.lang.Class;@1fe0c8e, public java.lang.Object java.util.HashMap.putIfAbsent(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@16f73de, public java.util.Collection java.util.LinkedHashMap.values()=[Ljava.lang.Class;@b3e45, public void java.util.LinkedHashMap.clear()=[Ljava.lang.Class;@a34e5c, public java.lang.Object java.util.HashMap.computeIfPresent(java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1fcb13a, public java.lang.Object java.util.HashMap.compute(java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1a7c258, public final native java.lang.Class java.lang.Object.getClass()=[Ljava.lang.Class;@7397f, public void java.util.HashMap.putAll(java.util.Map)=[Ljava.lang.Class;@59cd, public void java.util.LinkedHashMap.replaceAll(java.util.function.BiFunction)=[Ljava.lang.Class;@994816, public java.lang.Object java.util.HashMap.merge(java.lang.Object,java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1b1e75f, public int java.util.HashMap.size()=[Ljava.lang.Class;@bee157, public boolean java.util.LinkedHashMap.containsValue(java.lang.Object)=[Ljava.lang.Class;@5e0d7c}, replaceAll=public void java.util.LinkedHashMap.replaceAll(java.util.function.BiFunction), remove=freemarker.ext.beans.OverloadedMethods@8d3a99, containsValue=public boolean java.util.LinkedHashMap.containsValue(java.lang.Object), put=public java.lang.Object java.util.HashMap.put(java.lang.Object,java.lang.Object), empty=java.beans.PropertyDescriptor[name=empty; propertyType=boolean; readMethod=public boolean java.util.HashMap.isEmpty()], compute=public java.lang.Object java.util.HashMap.compute(java.lang.Object,java.util.function.BiFunction), hashCode=public int java.util.AbstractMap.hashCode(), putAll=public void java.util.HashMap.putAll(java.util.Map), get=public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object), merge=public java.lang.Object java.util.HashMap.merge(java.lang.Object,java.lang.Object,java.util.function.BiFunction), class=java.beans.PropertyDescriptor[name=class; propertyType=class java.lang.Class; readMethod=public final native java.lang.Class java.lang.Object.getClass()], keySet=public java.util.Set java.util.LinkedHashMap.keySet(), java.lang.Object@1c0f21d=freemarker.ext.beans.OverloadedMethods@d4b988, entrySet=public java.util.Set java.util.LinkedHashMap.entrySet(), java.lang.Object@15be27d=public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object), forEach=public void java.util.LinkedHashMap.forEach(java.util.function.BiConsumer), containsKey=public boolean java.util.HashMap.containsKey(java.lang.Object), isEmpty=public boolean java.util.HashMap.isEmpty(), clear=public void java.util.LinkedHashMap.clear(), computeIfPresent=public java.lang.Object java.util.HashMap.computeIfPresent(java.lang.Object,java.util.function.BiFunction), size=public int java.util.HashMap.size(), equals=public boolean java.util.AbstractMap.equals(java.lang.Object), clone=public java.lang.Object java.util.HashMap.clone(), toString=public java.lang.String java.util.AbstractMap.toString(), putIfAbsent=public java.lang.Object java.util.HashMap.putIfAbsent(java.lang.Object,java.lang.Object)}
[DEBUG] 2017-05-24: 21:05:33 freemarker.log._Log4jLoggerFactory$Log4jLogger.debug(_Log4jLoggerFactory.java:45) :  TemplateLoader.findTemplateSource("template/~~~xhtml/scripting-events.ftl"): Found
[DEBUG] 2017-05-24: 21:05:33 freemarker.log._Log4jLoggerFactory$Log4jLogger.debug(_Log4jLoggerFactory.java:45) :  "template/~~~xhtml/scripting-events.ftl"("zh_CN", UTF-8, parsed): using cached since jar:file:/D:/maven/repository/org/apache/struts/struts2-core/2.5.10/struts2-core-2.5.10.jar!/template/simple/scripting-events.ftl hasn't changed.
[DEBUG] 2017-05-24: 21:05:33 freemarker.log._Log4jLoggerFactory$Log4jLogger.debug(_Log4jLoggerFactory.java:45) :  Key "onclick" was not found on instance of java.util.LinkedHashMap. Introspection information for the class is: {getClass=public final native java.lang.Class java.lang.Object.getClass(), getOrDefault=public java.lang.Object java.util.LinkedHashMap.getOrDefault(java.lang.Object,java.lang.Object), computeIfAbsent=public java.lang.Object java.util.HashMap.computeIfAbsent(java.lang.Object,java.util.function.Function), values=public java.util.Collection java.util.LinkedHashMap.values(), replace=freemarker.ext.beans.OverloadedMethods@11d0265, java.lang.Object@3e55b2={public boolean java.util.HashMap.isEmpty()=[Ljava.lang.Class;@c5aa3a, public int java.util.AbstractMap.hashCode()=[Ljava.lang.Class;@74a947, public java.lang.Object java.util.HashMap.put(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@1615a91, public boolean java.util.AbstractMap.equals(java.lang.Object)=[Ljava.lang.Class;@a46ab2, public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object)=[Ljava.lang.Class;@1c389e6, public java.lang.String java.util.AbstractMap.toString()=[Ljava.lang.Class;@a23548, public boolean java.util.HashMap.containsKey(java.lang.Object)=[Ljava.lang.Class;@1be4a9f, public java.util.Set java.util.LinkedHashMap.keySet()=[Ljava.lang.Class;@44c60, public java.lang.Object java.util.HashMap.computeIfAbsent(java.lang.Object,java.util.function.Function)=[Ljava.lang.Class;@10f7dff, public java.lang.Object java.util.HashMap.clone()=[Ljava.lang.Class;@d214e3, public java.lang.Object java.util.LinkedHashMap.getOrDefault(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@1a74254, public java.util.Set java.util.LinkedHashMap.entrySet()=[Ljava.lang.Class;@1c4740c, public void java.util.LinkedHashMap.forEach(java.util.function.BiConsumer)=[Ljava.lang.Class;@1fe0c8e, public java.lang.Object java.util.HashMap.putIfAbsent(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@16f73de, public java.util.Collection java.util.LinkedHashMap.values()=[Ljava.lang.Class;@b3e45, public void java.util.LinkedHashMap.clear()=[Ljava.lang.Class;@a34e5c, public java.lang.Object java.util.HashMap.computeIfPresent(java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1fcb13a, public java.lang.Object java.util.HashMap.compute(java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1a7c258, public final native java.lang.Class java.lang.Object.getClass()=[Ljava.lang.Class;@7397f, public void java.util.HashMap.putAll(java.util.Map)=[Ljava.lang.Class;@59cd, public void java.util.LinkedHashMap.replaceAll(java.util.function.BiFunction)=[Ljava.lang.Class;@994816, public java.lang.Object java.util.HashMap.merge(java.lang.Object,java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1b1e75f, public int java.util.HashMap.size()=[Ljava.lang.Class;@bee157, public boolean java.util.LinkedHashMap.containsValue(java.lang.Object)=[Ljava.lang.Class;@5e0d7c}, replaceAll=public void java.util.LinkedHashMap.replaceAll(java.util.function.BiFunction), remove=freemarker.ext.beans.OverloadedMethods@8d3a99, containsValue=public boolean java.util.LinkedHashMap.containsValue(java.lang.Object), put=public java.lang.Object java.util.HashMap.put(java.lang.Object,java.lang.Object), empty=java.beans.PropertyDescriptor[name=empty; propertyType=boolean; readMethod=public boolean java.util.HashMap.isEmpty()], compute=public java.lang.Object java.util.HashMap.compute(java.lang.Object,java.util.function.BiFunction), hashCode=public int java.util.AbstractMap.hashCode(), putAll=public void java.util.HashMap.putAll(java.util.Map), get=public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object), merge=public java.lang.Object java.util.HashMap.merge(java.lang.Object,java.lang.Object,java.util.function.BiFunction), class=java.beans.PropertyDescriptor[name=class; propertyType=class java.lang.Class; readMethod=public final native java.lang.Class java.lang.Object.getClass()], keySet=public java.util.Set java.util.LinkedHashMap.keySet(), java.lang.Object@1c0f21d=freemarker.ext.beans.OverloadedMethods@d4b988, entrySet=public java.util.Set java.util.LinkedHashMap.entrySet(), java.lang.Object@15be27d=public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object), forEach=public void java.util.LinkedHashMap.forEach(java.util.function.BiConsumer), containsKey=public boolean java.util.HashMap.containsKey(java.lang.Object), isEmpty=public boolean java.util.HashMap.isEmpty(), clear=public void java.util.LinkedHashMap.clear(), computeIfPresent=public java.lang.Object java.util.HashMap.computeIfPresent(java.lang.Object,java.util.function.BiFunction), size=public int java.util.HashMap.size(), equals=public boolean java.util.AbstractMap.equals(java.lang.Object), clone=public java.lang.Object java.util.HashMap.clone(), toString=public java.lang.String java.util.AbstractMap.toString(), putIfAbsent=public java.lang.Object java.util.HashMap.putIfAbsent(java.lang.Object,java.lang.Object)}
[DEBUG] 2017-05-24: 21:05:33 freemarker.log._Log4jLoggerFactory$Log4jLogger.debug(_Log4jLoggerFactory.java:45) :  Key "ondblclick" was not found on instance of java.util.LinkedHashMap. Introspection information for the class is: {getClass=public final native java.lang.Class java.lang.Object.getClass(), getOrDefault=public java.lang.Object java.util.LinkedHashMap.getOrDefault(java.lang.Object,java.lang.Object), computeIfAbsent=public java.lang.Object java.util.HashMap.computeIfAbsent(java.lang.Object,java.util.function.Function), values=public java.util.Collection java.util.LinkedHashMap.values(), replace=freemarker.ext.beans.OverloadedMethods@11d0265, java.lang.Object@3e55b2={public boolean java.util.HashMap.isEmpty()=[Ljava.lang.Class;@c5aa3a, public int java.util.AbstractMap.hashCode()=[Ljava.lang.Class;@74a947, public java.lang.Object java.util.HashMap.put(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@1615a91, public boolean java.util.AbstractMap.equals(java.lang.Object)=[Ljava.lang.Class;@a46ab2, public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object)=[Ljava.lang.Class;@1c389e6, public java.lang.String java.util.AbstractMap.toString()=[Ljava.lang.Class;@a23548, public boolean java.util.HashMap.containsKey(java.lang.Object)=[Ljava.lang.Class;@1be4a9f, public java.util.Set java.util.LinkedHashMap.keySet()=[Ljava.lang.Class;@44c60, public java.lang.Object java.util.HashMap.computeIfAbsent(java.lang.Object,java.util.function.Function)=[Ljava.lang.Class;@10f7dff, public java.lang.Object java.util.HashMap.clone()=[Ljava.lang.Class;@d214e3, public java.lang.Object java.util.LinkedHashMap.getOrDefault(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@1a74254, public java.util.Set java.util.LinkedHashMap.entrySet()=[Ljava.lang.Class;@1c4740c, public void java.util.LinkedHashMap.forEach(java.util.function.BiConsumer)=[Ljava.lang.Class;@1fe0c8e, public java.lang.Object java.util.HashMap.putIfAbsent(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@16f73de, public java.util.Collection java.util.LinkedHashMap.values()=[Ljava.lang.Class;@b3e45, public void java.util.LinkedHashMap.clear()=[Ljava.lang.Class;@a34e5c, public java.lang.Object java.util.HashMap.computeIfPresent(java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1fcb13a, public java.lang.Object java.util.HashMap.compute(java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1a7c258, public final native java.lang.Class java.lang.Object.getClass()=[Ljava.lang.Class;@7397f, public void java.util.HashMap.putAll(java.util.Map)=[Ljava.lang.Class;@59cd, public void java.util.LinkedHashMap.replaceAll(java.util.function.BiFunction)=[Ljava.lang.Class;@994816, public java.lang.Object java.util.HashMap.merge(java.lang.Object,java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1b1e75f, public int java.util.HashMap.size()=[Ljava.lang.Class;@bee157, public boolean java.util.LinkedHashMap.containsValue(java.lang.Object)=[Ljava.lang.Class;@5e0d7c}, replaceAll=public void java.util.LinkedHashMap.replaceAll(java.util.function.BiFunction), remove=freemarker.ext.beans.OverloadedMethods@8d3a99, containsValue=public boolean java.util.LinkedHashMap.containsValue(java.lang.Object), put=public java.lang.Object java.util.HashMap.put(java.lang.Object,java.lang.Object), empty=java.beans.PropertyDescriptor[name=empty; propertyType=boolean; readMethod=public boolean java.util.HashMap.isEmpty()], compute=public java.lang.Object java.util.HashMap.compute(java.lang.Object,java.util.function.BiFunction), hashCode=public int java.util.AbstractMap.hashCode(), putAll=public void java.util.HashMap.putAll(java.util.Map), get=public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object), merge=public java.lang.Object java.util.HashMap.merge(java.lang.Object,java.lang.Object,java.util.function.BiFunction), class=java.beans.PropertyDescriptor[name=class; propertyType=class java.lang.Class; readMethod=public final native java.lang.Class java.lang.Object.getClass()], keySet=public java.util.Set java.util.LinkedHashMap.keySet(), java.lang.Object@1c0f21d=freemarker.ext.beans.OverloadedMethods@d4b988, entrySet=public java.util.Set java.util.LinkedHashMap.entrySet(), java.lang.Object@15be27d=public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object), forEach=public void java.util.LinkedHashMap.forEach(java.util.function.BiConsumer), containsKey=public boolean java.util.HashMap.containsKey(java.lang.Object), isEmpty=public boolean java.util.HashMap.isEmpty(), clear=public void java.util.LinkedHashMap.clear(), computeIfPresent=public java.lang.Object java.util.HashMap.computeIfPresent(java.lang.Object,java.util.function.BiFunction), size=public int java.util.HashMap.size(), equals=public boolean java.util.AbstractMap.equals(java.lang.Object), clone=public java.lang.Object java.util.HashMap.clone(), toString=public java.lang.String java.util.AbstractMap.toString(), putIfAbsent=public java.lang.Object java.util.HashMap.putIfAbsent(java.lang.Object,java.lang.Object)}
[DEBUG] 2017-05-24: 21:05:33 freemarker.log._Log4jLoggerFactory$Log4jLogger.debug(_Log4jLoggerFactory.java:45) :  Key "onmousedown" was not found on instance of java.util.LinkedHashMap. Introspection information for the class is: {getClass=public final native java.lang.Class java.lang.Object.getClass(), getOrDefault=public java.lang.Object java.util.LinkedHashMap.getOrDefault(java.lang.Object,java.lang.Object), computeIfAbsent=public java.lang.Object java.util.HashMap.computeIfAbsent(java.lang.Object,java.util.function.Function), values=public java.util.Collection java.util.LinkedHashMap.values(), replace=freemarker.ext.beans.OverloadedMethods@11d0265, java.lang.Object@3e55b2={public boolean java.util.HashMap.isEmpty()=[Ljava.lang.Class;@c5aa3a, public int java.util.AbstractMap.hashCode()=[Ljava.lang.Class;@74a947, public java.lang.Object java.util.HashMap.put(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@1615a91, public boolean java.util.AbstractMap.equals(java.lang.Object)=[Ljava.lang.Class;@a46ab2, public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object)=[Ljava.lang.Class;@1c389e6, public java.lang.String java.util.AbstractMap.toString()=[Ljava.lang.Class;@a23548, public boolean java.util.HashMap.containsKey(java.lang.Object)=[Ljava.lang.Class;@1be4a9f, public java.util.Set java.util.LinkedHashMap.keySet()=[Ljava.lang.Class;@44c60, public java.lang.Object java.util.HashMap.computeIfAbsent(java.lang.Object,java.util.function.Function)=[Ljava.lang.Class;@10f7dff, public java.lang.Object java.util.HashMap.clone()=[Ljava.lang.Class;@d214e3, public java.lang.Object java.util.LinkedHashMap.getOrDefault(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@1a74254, public java.util.Set java.util.LinkedHashMap.entrySet()=[Ljava.lang.Class;@1c4740c, public void java.util.LinkedHashMap.forEach(java.util.function.BiConsumer)=[Ljava.lang.Class;@1fe0c8e, public java.lang.Object java.util.HashMap.putIfAbsent(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@16f73de, public java.util.Collection java.util.LinkedHashMap.values()=[Ljava.lang.Class;@b3e45, public void java.util.LinkedHashMap.clear()=[Ljava.lang.Class;@a34e5c, public java.lang.Object java.util.HashMap.computeIfPresent(java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1fcb13a, public java.lang.Object java.util.HashMap.compute(java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1a7c258, public final native java.lang.Class java.lang.Object.getClass()=[Ljava.lang.Class;@7397f, public void java.util.HashMap.putAll(java.util.Map)=[Ljava.lang.Class;@59cd, public void java.util.LinkedHashMap.replaceAll(java.util.function.BiFunction)=[Ljava.lang.Class;@994816, public java.lang.Object java.util.HashMap.merge(java.lang.Object,java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1b1e75f, public int java.util.HashMap.size()=[Ljava.lang.Class;@bee157, public boolean java.util.LinkedHashMap.containsValue(java.lang.Object)=[Ljava.lang.Class;@5e0d7c}, replaceAll=public void java.util.LinkedHashMap.replaceAll(java.util.function.BiFunction), remove=freemarker.ext.beans.OverloadedMethods@8d3a99, containsValue=public boolean java.util.LinkedHashMap.containsValue(java.lang.Object), put=public java.lang.Object java.util.HashMap.put(java.lang.Object,java.lang.Object), empty=java.beans.PropertyDescriptor[name=empty; propertyType=boolean; readMethod=public boolean java.util.HashMap.isEmpty()], compute=public java.lang.Object java.util.HashMap.compute(java.lang.Object,java.util.function.BiFunction), hashCode=public int java.util.AbstractMap.hashCode(), putAll=public void java.util.HashMap.putAll(java.util.Map), get=public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object), merge=public java.lang.Object java.util.HashMap.merge(java.lang.Object,java.lang.Object,java.util.function.BiFunction), class=java.beans.PropertyDescriptor[name=class; propertyType=class java.lang.Class; readMethod=public final native java.lang.Class java.lang.Object.getClass()], keySet=public java.util.Set java.util.LinkedHashMap.keySet(), java.lang.Object@1c0f21d=freemarker.ext.beans.OverloadedMethods@d4b988, entrySet=public java.util.Set java.util.LinkedHashMap.entrySet(), java.lang.Object@15be27d=public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object), forEach=public void java.util.LinkedHashMap.forEach(java.util.function.BiConsumer), containsKey=public boolean java.util.HashMap.containsKey(java.lang.Object), isEmpty=public boolean java.util.HashMap.isEmpty(), clear=public void java.util.LinkedHashMap.clear(), computeIfPresent=public java.lang.Object java.util.HashMap.computeIfPresent(java.lang.Object,java.util.function.BiFunction), size=public int java.util.HashMap.size(), equals=public boolean java.util.AbstractMap.equals(java.lang.Object), clone=public java.lang.Object java.util.HashMap.clone(), toString=public java.lang.String java.util.AbstractMap.toString(), putIfAbsent=public java.lang.Object java.util.HashMap.putIfAbsent(java.lang.Object,java.lang.Object)}
[DEBUG] 2017-05-24: 21:05:33 freemarker.log._Log4jLoggerFactory$Log4jLogger.debug(_Log4jLoggerFactory.java:45) :  Key "onmouseup" was not found on instance of java.util.LinkedHashMap. Introspection information for the class is: {getClass=public final native java.lang.Class java.lang.Object.getClass(), getOrDefault=public java.lang.Object java.util.LinkedHashMap.getOrDefault(java.lang.Object,java.lang.Object), computeIfAbsent=public java.lang.Object java.util.HashMap.computeIfAbsent(java.lang.Object,java.util.function.Function), values=public java.util.Collection java.util.LinkedHashMap.values(), replace=freemarker.ext.beans.OverloadedMethods@11d0265, java.lang.Object@3e55b2={public boolean java.util.HashMap.isEmpty()=[Ljava.lang.Class;@c5aa3a, public int java.util.AbstractMap.hashCode()=[Ljava.lang.Class;@74a947, public java.lang.Object java.util.HashMap.put(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@1615a91, public boolean java.util.AbstractMap.equals(java.lang.Object)=[Ljava.lang.Class;@a46ab2, public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object)=[Ljava.lang.Class;@1c389e6, public java.lang.String java.util.AbstractMap.toString()=[Ljava.lang.Class;@a23548, public boolean java.util.HashMap.containsKey(java.lang.Object)=[Ljava.lang.Class;@1be4a9f, public java.util.Set java.util.LinkedHashMap.keySet()=[Ljava.lang.Class;@44c60, public java.lang.Object java.util.HashMap.computeIfAbsent(java.lang.Object,java.util.function.Function)=[Ljava.lang.Class;@10f7dff, public java.lang.Object java.util.HashMap.clone()=[Ljava.lang.Class;@d214e3, public java.lang.Object java.util.LinkedHashMap.getOrDefault(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@1a74254, public java.util.Set java.util.LinkedHashMap.entrySet()=[Ljava.lang.Class;@1c4740c, public void java.util.LinkedHashMap.forEach(java.util.function.BiConsumer)=[Ljava.lang.Class;@1fe0c8e, public java.lang.Object java.util.HashMap.putIfAbsent(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@16f73de, public java.util.Collection java.util.LinkedHashMap.values()=[Ljava.lang.Class;@b3e45, public void java.util.LinkedHashMap.clear()=[Ljava.lang.Class;@a34e5c, public java.lang.Object java.util.HashMap.computeIfPresent(java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1fcb13a, public java.lang.Object java.util.HashMap.compute(java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1a7c258, public final native java.lang.Class java.lang.Object.getClass()=[Ljava.lang.Class;@7397f, public void java.util.HashMap.putAll(java.util.Map)=[Ljava.lang.Class;@59cd, public void java.util.LinkedHashMap.replaceAll(java.util.function.BiFunction)=[Ljava.lang.Class;@994816, public java.lang.Object java.util.HashMap.merge(java.lang.Object,java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1b1e75f, public int java.util.HashMap.size()=[Ljava.lang.Class;@bee157, public boolean java.util.LinkedHashMap.containsValue(java.lang.Object)=[Ljava.lang.Class;@5e0d7c}, replaceAll=public void java.util.LinkedHashMap.replaceAll(java.util.function.BiFunction), remove=freemarker.ext.beans.OverloadedMethods@8d3a99, containsValue=public boolean java.util.LinkedHashMap.containsValue(java.lang.Object), put=public java.lang.Object java.util.HashMap.put(java.lang.Object,java.lang.Object), empty=java.beans.PropertyDescriptor[name=empty; propertyType=boolean; readMethod=public boolean java.util.HashMap.isEmpty()], compute=public java.lang.Object java.util.HashMap.compute(java.lang.Object,java.util.function.BiFunction), hashCode=public int java.util.AbstractMap.hashCode(), putAll=public void java.util.HashMap.putAll(java.util.Map), get=public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object), merge=public java.lang.Object java.util.HashMap.merge(java.lang.Object,java.lang.Object,java.util.function.BiFunction), class=java.beans.PropertyDescriptor[name=class; propertyType=class java.lang.Class; readMethod=public final native java.lang.Class java.lang.Object.getClass()], keySet=public java.util.Set java.util.LinkedHashMap.keySet(), java.lang.Object@1c0f21d=freemarker.ext.beans.OverloadedMethods@d4b988, entrySet=public java.util.Set java.util.LinkedHashMap.entrySet(), java.lang.Object@15be27d=public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object), forEach=public void java.util.LinkedHashMap.forEach(java.util.function.BiConsumer), containsKey=public boolean java.util.HashMap.containsKey(java.lang.Object), isEmpty=public boolean java.util.HashMap.isEmpty(), clear=public void java.util.LinkedHashMap.clear(), computeIfPresent=public java.lang.Object java.util.HashMap.computeIfPresent(java.lang.Object,java.util.function.BiFunction), size=public int java.util.HashMap.size(), equals=public boolean java.util.AbstractMap.equals(java.lang.Object), clone=public java.lang.Object java.util.HashMap.clone(), toString=public java.lang.String java.util.AbstractMap.toString(), putIfAbsent=public java.lang.Object java.util.HashMap.putIfAbsent(java.lang.Object,java.lang.Object)}
[DEBUG] 2017-05-24: 21:05:33 freemarker.log._Log4jLoggerFactory$Log4jLogger.debug(_Log4jLoggerFactory.java:45) :  Key "onmouseover" was not found on instance of java.util.LinkedHashMap. Introspection information for the class is: {getClass=public final native java.lang.Class java.lang.Object.getClass(), getOrDefault=public java.lang.Object java.util.LinkedHashMap.getOrDefault(java.lang.Object,java.lang.Object), computeIfAbsent=public java.lang.Object java.util.HashMap.computeIfAbsent(java.lang.Object,java.util.function.Function), values=public java.util.Collection java.util.LinkedHashMap.values(), replace=freemarker.ext.beans.OverloadedMethods@11d0265, java.lang.Object@3e55b2={public boolean java.util.HashMap.isEmpty()=[Ljava.lang.Class;@c5aa3a, public int java.util.AbstractMap.hashCode()=[Ljava.lang.Class;@74a947, public java.lang.Object java.util.HashMap.put(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@1615a91, public boolean java.util.AbstractMap.equals(java.lang.Object)=[Ljava.lang.Class;@a46ab2, public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object)=[Ljava.lang.Class;@1c389e6, public java.lang.String java.util.AbstractMap.toString()=[Ljava.lang.Class;@a23548, public boolean java.util.HashMap.containsKey(java.lang.Object)=[Ljava.lang.Class;@1be4a9f, public java.util.Set java.util.LinkedHashMap.keySet()=[Ljava.lang.Class;@44c60, public java.lang.Object java.util.HashMap.computeIfAbsent(java.lang.Object,java.util.function.Function)=[Ljava.lang.Class;@10f7dff, public java.lang.Object java.util.HashMap.clone()=[Ljava.lang.Class;@d214e3, public java.lang.Object java.util.LinkedHashMap.getOrDefault(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@1a74254, public java.util.Set java.util.LinkedHashMap.entrySet()=[Ljava.lang.Class;@1c4740c, public void java.util.LinkedHashMap.forEach(java.util.function.BiConsumer)=[Ljava.lang.Class;@1fe0c8e, public java.lang.Object java.util.HashMap.putIfAbsent(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@16f73de, public java.util.Collection java.util.LinkedHashMap.values()=[Ljava.lang.Class;@b3e45, public void java.util.LinkedHashMap.clear()=[Ljava.lang.Class;@a34e5c, public java.lang.Object java.util.HashMap.computeIfPresent(java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1fcb13a, public java.lang.Object java.util.HashMap.compute(java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1a7c258, public final native java.lang.Class java.lang.Object.getClass()=[Ljava.lang.Class;@7397f, public void java.util.HashMap.putAll(java.util.Map)=[Ljava.lang.Class;@59cd, public void java.util.LinkedHashMap.replaceAll(java.util.function.BiFunction)=[Ljava.lang.Class;@994816, public java.lang.Object java.util.HashMap.merge(java.lang.Object,java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1b1e75f, public int java.util.HashMap.size()=[Ljava.lang.Class;@bee157, public boolean java.util.LinkedHashMap.containsValue(java.lang.Object)=[Ljava.lang.Class;@5e0d7c}, replaceAll=public void java.util.LinkedHashMap.replaceAll(java.util.function.BiFunction), remove=freemarker.ext.beans.OverloadedMethods@8d3a99, containsValue=public boolean java.util.LinkedHashMap.containsValue(java.lang.Object), put=public java.lang.Object java.util.HashMap.put(java.lang.Object,java.lang.Object), empty=java.beans.PropertyDescriptor[name=empty; propertyType=boolean; readMethod=public boolean java.util.HashMap.isEmpty()], compute=public java.lang.Object java.util.HashMap.compute(java.lang.Object,java.util.function.BiFunction), hashCode=public int java.util.AbstractMap.hashCode(), putAll=public void java.util.HashMap.putAll(java.util.Map), get=public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object), merge=public java.lang.Object java.util.HashMap.merge(java.lang.Object,java.lang.Object,java.util.function.BiFunction), class=java.beans.PropertyDescriptor[name=class; propertyType=class java.lang.Class; readMethod=public final native java.lang.Class java.lang.Object.getClass()], keySet=public java.util.Set java.util.LinkedHashMap.keySet(), java.lang.Object@1c0f21d=freemarker.ext.beans.OverloadedMethods@d4b988, entrySet=public java.util.Set java.util.LinkedHashMap.entrySet(), java.lang.Object@15be27d=public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object), forEach=public void java.util.LinkedHashMap.forEach(java.util.function.BiConsumer), containsKey=public boolean java.util.HashMap.containsKey(java.lang.Object), isEmpty=public boolean java.util.HashMap.isEmpty(), clear=public void java.util.LinkedHashMap.clear(), computeIfPresent=public java.lang.Object java.util.HashMap.computeIfPresent(java.lang.Object,java.util.function.BiFunction), size=public int java.util.HashMap.size(), equals=public boolean java.util.AbstractMap.equals(java.lang.Object), clone=public java.lang.Object java.util.HashMap.clone(), toString=public java.lang.String java.util.AbstractMap.toString(), putIfAbsent=public java.lang.Object java.util.HashMap.putIfAbsent(java.lang.Object,java.lang.Object)}
[DEBUG] 2017-05-24: 21:05:33 freemarker.log._Log4jLoggerFactory$Log4jLogger.debug(_Log4jLoggerFactory.java:45) :  Key "onmousemove" was not found on instance of java.util.LinkedHashMap. Introspection information for the class is: {getClass=public final native java.lang.Class java.lang.Object.getClass(), getOrDefault=public java.lang.Object java.util.LinkedHashMap.getOrDefault(java.lang.Object,java.lang.Object), computeIfAbsent=public java.lang.Object java.util.HashMap.computeIfAbsent(java.lang.Object,java.util.function.Function), values=public java.util.Collection java.util.LinkedHashMap.values(), replace=freemarker.ext.beans.OverloadedMethods@11d0265, java.lang.Object@3e55b2={public boolean java.util.HashMap.isEmpty()=[Ljava.lang.Class;@c5aa3a, public int java.util.AbstractMap.hashCode()=[Ljava.lang.Class;@74a947, public java.lang.Object java.util.HashMap.put(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@1615a91, public boolean java.util.AbstractMap.equals(java.lang.Object)=[Ljava.lang.Class;@a46ab2, public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object)=[Ljava.lang.Class;@1c389e6, public java.lang.String java.util.AbstractMap.toString()=[Ljava.lang.Class;@a23548, public boolean java.util.HashMap.containsKey(java.lang.Object)=[Ljava.lang.Class;@1be4a9f, public java.util.Set java.util.LinkedHashMap.keySet()=[Ljava.lang.Class;@44c60, public java.lang.Object java.util.HashMap.computeIfAbsent(java.lang.Object,java.util.function.Function)=[Ljava.lang.Class;@10f7dff, public java.lang.Object java.util.HashMap.clone()=[Ljava.lang.Class;@d214e3, public java.lang.Object java.util.LinkedHashMap.getOrDefault(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@1a74254, public java.util.Set java.util.LinkedHashMap.entrySet()=[Ljava.lang.Class;@1c4740c, public void java.util.LinkedHashMap.forEach(java.util.function.BiConsumer)=[Ljava.lang.Class;@1fe0c8e, public java.lang.Object java.util.HashMap.putIfAbsent(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@16f73de, public java.util.Collection java.util.LinkedHashMap.values()=[Ljava.lang.Class;@b3e45, public void java.util.LinkedHashMap.clear()=[Ljava.lang.Class;@a34e5c, public java.lang.Object java.util.HashMap.computeIfPresent(java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1fcb13a, public java.lang.Object java.util.HashMap.compute(java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1a7c258, public final native java.lang.Class java.lang.Object.getClass()=[Ljava.lang.Class;@7397f, public void java.util.HashMap.putAll(java.util.Map)=[Ljava.lang.Class;@59cd, public void java.util.LinkedHashMap.replaceAll(java.util.function.BiFunction)=[Ljava.lang.Class;@994816, public java.lang.Object java.util.HashMap.merge(java.lang.Object,java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1b1e75f, public int java.util.HashMap.size()=[Ljava.lang.Class;@bee157, public boolean java.util.LinkedHashMap.containsValue(java.lang.Object)=[Ljava.lang.Class;@5e0d7c}, replaceAll=public void java.util.LinkedHashMap.replaceAll(java.util.function.BiFunction), remove=freemarker.ext.beans.OverloadedMethods@8d3a99, containsValue=public boolean java.util.LinkedHashMap.containsValue(java.lang.Object), put=public java.lang.Object java.util.HashMap.put(java.lang.Object,java.lang.Object), empty=java.beans.PropertyDescriptor[name=empty; propertyType=boolean; readMethod=public boolean java.util.HashMap.isEmpty()], compute=public java.lang.Object java.util.HashMap.compute(java.lang.Object,java.util.function.BiFunction), hashCode=public int java.util.AbstractMap.hashCode(), putAll=public void java.util.HashMap.putAll(java.util.Map), get=public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object), merge=public java.lang.Object java.util.HashMap.merge(java.lang.Object,java.lang.Object,java.util.function.BiFunction), class=java.beans.PropertyDescriptor[name=class; propertyType=class java.lang.Class; readMethod=public final native java.lang.Class java.lang.Object.getClass()], keySet=public java.util.Set java.util.LinkedHashMap.keySet(), java.lang.Object@1c0f21d=freemarker.ext.beans.OverloadedMethods@d4b988, entrySet=public java.util.Set java.util.LinkedHashMap.entrySet(), java.lang.Object@15be27d=public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object), forEach=public void java.util.LinkedHashMap.forEach(java.util.function.BiConsumer), containsKey=public boolean java.util.HashMap.containsKey(java.lang.Object), isEmpty=public boolean java.util.HashMap.isEmpty(), clear=public void java.util.LinkedHashMap.clear(), computeIfPresent=public java.lang.Object java.util.HashMap.computeIfPresent(java.lang.Object,java.util.function.BiFunction), size=public int java.util.HashMap.size(), equals=public boolean java.util.AbstractMap.equals(java.lang.Object), clone=public java.lang.Object java.util.HashMap.clone(), toString=public java.lang.String java.util.AbstractMap.toString(), putIfAbsent=public java.lang.Object java.util.HashMap.putIfAbsent(java.lang.Object,java.lang.Object)}
[DEBUG] 2017-05-24: 21:05:33 freemarker.log._Log4jLoggerFactory$Log4jLogger.debug(_Log4jLoggerFactory.java:45) :  Key "onmouseout" was not found on instance of java.util.LinkedHashMap. Introspection information for the class is: {getClass=public final native java.lang.Class java.lang.Object.getClass(), getOrDefault=public java.lang.Object java.util.LinkedHashMap.getOrDefault(java.lang.Object,java.lang.Object), computeIfAbsent=public java.lang.Object java.util.HashMap.computeIfAbsent(java.lang.Object,java.util.function.Function), values=public java.util.Collection java.util.LinkedHashMap.values(), replace=freemarker.ext.beans.OverloadedMethods@11d0265, java.lang.Object@3e55b2={public boolean java.util.HashMap.isEmpty()=[Ljava.lang.Class;@c5aa3a, public int java.util.AbstractMap.hashCode()=[Ljava.lang.Class;@74a947, public java.lang.Object java.util.HashMap.put(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@1615a91, public boolean java.util.AbstractMap.equals(java.lang.Object)=[Ljava.lang.Class;@a46ab2, public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object)=[Ljava.lang.Class;@1c389e6, public java.lang.String java.util.AbstractMap.toString()=[Ljava.lang.Class;@a23548, public boolean java.util.HashMap.containsKey(java.lang.Object)=[Ljava.lang.Class;@1be4a9f, public java.util.Set java.util.LinkedHashMap.keySet()=[Ljava.lang.Class;@44c60, public java.lang.Object java.util.HashMap.computeIfAbsent(java.lang.Object,java.util.function.Function)=[Ljava.lang.Class;@10f7dff, public java.lang.Object java.util.HashMap.clone()=[Ljava.lang.Class;@d214e3, public java.lang.Object java.util.LinkedHashMap.getOrDefault(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@1a74254, public java.util.Set java.util.LinkedHashMap.entrySet()=[Ljava.lang.Class;@1c4740c, public void java.util.LinkedHashMap.forEach(java.util.function.BiConsumer)=[Ljava.lang.Class;@1fe0c8e, public java.lang.Object java.util.HashMap.putIfAbsent(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@16f73de, public java.util.Collection java.util.LinkedHashMap.values()=[Ljava.lang.Class;@b3e45, public void java.util.LinkedHashMap.clear()=[Ljava.lang.Class;@a34e5c, public java.lang.Object java.util.HashMap.computeIfPresent(java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1fcb13a, public java.lang.Object java.util.HashMap.compute(java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1a7c258, public final native java.lang.Class java.lang.Object.getClass()=[Ljava.lang.Class;@7397f, public void java.util.HashMap.putAll(java.util.Map)=[Ljava.lang.Class;@59cd, public void java.util.LinkedHashMap.replaceAll(java.util.function.BiFunction)=[Ljava.lang.Class;@994816, public java.lang.Object java.util.HashMap.merge(java.lang.Object,java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1b1e75f, public int java.util.HashMap.size()=[Ljava.lang.Class;@bee157, public boolean java.util.LinkedHashMap.containsValue(java.lang.Object)=[Ljava.lang.Class;@5e0d7c}, replaceAll=public void java.util.LinkedHashMap.replaceAll(java.util.function.BiFunction), remove=freemarker.ext.beans.OverloadedMethods@8d3a99, containsValue=public boolean java.util.LinkedHashMap.containsValue(java.lang.Object), put=public java.lang.Object java.util.HashMap.put(java.lang.Object,java.lang.Object), empty=java.beans.PropertyDescriptor[name=empty; propertyType=boolean; readMethod=public boolean java.util.HashMap.isEmpty()], compute=public java.lang.Object java.util.HashMap.compute(java.lang.Object,java.util.function.BiFunction), hashCode=public int java.util.AbstractMap.hashCode(), putAll=public void java.util.HashMap.putAll(java.util.Map), get=public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object), merge=public java.lang.Object java.util.HashMap.merge(java.lang.Object,java.lang.Object,java.util.function.BiFunction), class=java.beans.PropertyDescriptor[name=class; propertyType=class java.lang.Class; readMethod=public final native java.lang.Class java.lang.Object.getClass()], keySet=public java.util.Set java.util.LinkedHashMap.keySet(), java.lang.Object@1c0f21d=freemarker.ext.beans.OverloadedMethods@d4b988, entrySet=public java.util.Set java.util.LinkedHashMap.entrySet(), java.lang.Object@15be27d=public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object), forEach=public void java.util.LinkedHashMap.forEach(java.util.function.BiConsumer), containsKey=public boolean java.util.HashMap.containsKey(java.lang.Object), isEmpty=public boolean java.util.HashMap.isEmpty(), clear=public void java.util.LinkedHashMap.clear(), computeIfPresent=public java.lang.Object java.util.HashMap.computeIfPresent(java.lang.Object,java.util.function.BiFunction), size=public int java.util.HashMap.size(), equals=public boolean java.util.AbstractMap.equals(java.lang.Object), clone=public java.lang.Object java.util.HashMap.clone(), toString=public java.lang.String java.util.AbstractMap.toString(), putIfAbsent=public java.lang.Object java.util.HashMap.putIfAbsent(java.lang.Object,java.lang.Object)}
[DEBUG] 2017-05-24: 21:05:33 freemarker.log._Log4jLoggerFactory$Log4jLogger.debug(_Log4jLoggerFactory.java:45) :  Key "onfocus" was not found on instance of java.util.LinkedHashMap. Introspection information for the class is: {getClass=public final native java.lang.Class java.lang.Object.getClass(), getOrDefault=public java.lang.Object java.util.LinkedHashMap.getOrDefault(java.lang.Object,java.lang.Object), computeIfAbsent=public java.lang.Object java.util.HashMap.computeIfAbsent(java.lang.Object,java.util.function.Function), values=public java.util.Collection java.util.LinkedHashMap.values(), replace=freemarker.ext.beans.OverloadedMethods@11d0265, java.lang.Object@3e55b2={public boolean java.util.HashMap.isEmpty()=[Ljava.lang.Class;@c5aa3a, public int java.util.AbstractMap.hashCode()=[Ljava.lang.Class;@74a947, public java.lang.Object java.util.HashMap.put(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@1615a91, public boolean java.util.AbstractMap.equals(java.lang.Object)=[Ljava.lang.Class;@a46ab2, public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object)=[Ljava.lang.Class;@1c389e6, public java.lang.String java.util.AbstractMap.toString()=[Ljava.lang.Class;@a23548, public boolean java.util.HashMap.containsKey(java.lang.Object)=[Ljava.lang.Class;@1be4a9f, public java.util.Set java.util.LinkedHashMap.keySet()=[Ljava.lang.Class;@44c60, public java.lang.Object java.util.HashMap.computeIfAbsent(java.lang.Object,java.util.function.Function)=[Ljava.lang.Class;@10f7dff, public java.lang.Object java.util.HashMap.clone()=[Ljava.lang.Class;@d214e3, public java.lang.Object java.util.LinkedHashMap.getOrDefault(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@1a74254, public java.util.Set java.util.LinkedHashMap.entrySet()=[Ljava.lang.Class;@1c4740c, public void java.util.LinkedHashMap.forEach(java.util.function.BiConsumer)=[Ljava.lang.Class;@1fe0c8e, public java.lang.Object java.util.HashMap.putIfAbsent(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@16f73de, public java.util.Collection java.util.LinkedHashMap.values()=[Ljava.lang.Class;@b3e45, public void java.util.LinkedHashMap.clear()=[Ljava.lang.Class;@a34e5c, public java.lang.Object java.util.HashMap.computeIfPresent(java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1fcb13a, public java.lang.Object java.util.HashMap.compute(java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1a7c258, public final native java.lang.Class java.lang.Object.getClass()=[Ljava.lang.Class;@7397f, public void java.util.HashMap.putAll(java.util.Map)=[Ljava.lang.Class;@59cd, public void java.util.LinkedHashMap.replaceAll(java.util.function.BiFunction)=[Ljava.lang.Class;@994816, public java.lang.Object java.util.HashMap.merge(java.lang.Object,java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1b1e75f, public int java.util.HashMap.size()=[Ljava.lang.Class;@bee157, public boolean java.util.LinkedHashMap.containsValue(java.lang.Object)=[Ljava.lang.Class;@5e0d7c}, replaceAll=public void java.util.LinkedHashMap.replaceAll(java.util.function.BiFunction), remove=freemarker.ext.beans.OverloadedMethods@8d3a99, containsValue=public boolean java.util.LinkedHashMap.containsValue(java.lang.Object), put=public java.lang.Object java.util.HashMap.put(java.lang.Object,java.lang.Object), empty=java.beans.PropertyDescriptor[name=empty; propertyType=boolean; readMethod=public boolean java.util.HashMap.isEmpty()], compute=public java.lang.Object java.util.HashMap.compute(java.lang.Object,java.util.function.BiFunction), hashCode=public int java.util.AbstractMap.hashCode(), putAll=public void java.util.HashMap.putAll(java.util.Map), get=public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object), merge=public java.lang.Object java.util.HashMap.merge(java.lang.Object,java.lang.Object,java.util.function.BiFunction), class=java.beans.PropertyDescriptor[name=class; propertyType=class java.lang.Class; readMethod=public final native java.lang.Class java.lang.Object.getClass()], keySet=public java.util.Set java.util.LinkedHashMap.keySet(), java.lang.Object@1c0f21d=freemarker.ext.beans.OverloadedMethods@d4b988, entrySet=public java.util.Set java.util.LinkedHashMap.entrySet(), java.lang.Object@15be27d=public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object), forEach=public void java.util.LinkedHashMap.forEach(java.util.function.BiConsumer), containsKey=public boolean java.util.HashMap.containsKey(java.lang.Object), isEmpty=public boolean java.util.HashMap.isEmpty(), clear=public void java.util.LinkedHashMap.clear(), computeIfPresent=public java.lang.Object java.util.HashMap.computeIfPresent(java.lang.Object,java.util.function.BiFunction), size=public int java.util.HashMap.size(), equals=public boolean java.util.AbstractMap.equals(java.lang.Object), clone=public java.lang.Object java.util.HashMap.clone(), toString=public java.lang.String java.util.AbstractMap.toString(), putIfAbsent=public java.lang.Object java.util.HashMap.putIfAbsent(java.lang.Object,java.lang.Object)}
[DEBUG] 2017-05-24: 21:05:33 freemarker.log._Log4jLoggerFactory$Log4jLogger.debug(_Log4jLoggerFactory.java:45) :  Key "onblur" was not found on instance of java.util.LinkedHashMap. Introspection information for the class is: {getClass=public final native java.lang.Class java.lang.Object.getClass(), getOrDefault=public java.lang.Object java.util.LinkedHashMap.getOrDefault(java.lang.Object,java.lang.Object), computeIfAbsent=public java.lang.Object java.util.HashMap.computeIfAbsent(java.lang.Object,java.util.function.Function), values=public java.util.Collection java.util.LinkedHashMap.values(), replace=freemarker.ext.beans.OverloadedMethods@11d0265, java.lang.Object@3e55b2={public boolean java.util.HashMap.isEmpty()=[Ljava.lang.Class;@c5aa3a, public int java.util.AbstractMap.hashCode()=[Ljava.lang.Class;@74a947, public java.lang.Object java.util.HashMap.put(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@1615a91, public boolean java.util.AbstractMap.equals(java.lang.Object)=[Ljava.lang.Class;@a46ab2, public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object)=[Ljava.lang.Class;@1c389e6, public java.lang.String java.util.AbstractMap.toString()=[Ljava.lang.Class;@a23548, public boolean java.util.HashMap.containsKey(java.lang.Object)=[Ljava.lang.Class;@1be4a9f, public java.util.Set java.util.LinkedHashMap.keySet()=[Ljava.lang.Class;@44c60, public java.lang.Object java.util.HashMap.computeIfAbsent(java.lang.Object,java.util.function.Function)=[Ljava.lang.Class;@10f7dff, public java.lang.Object java.util.HashMap.clone()=[Ljava.lang.Class;@d214e3, public java.lang.Object java.util.LinkedHashMap.getOrDefault(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@1a74254, public java.util.Set java.util.LinkedHashMap.entrySet()=[Ljava.lang.Class;@1c4740c, public void java.util.LinkedHashMap.forEach(java.util.function.BiConsumer)=[Ljava.lang.Class;@1fe0c8e, public java.lang.Object java.util.HashMap.putIfAbsent(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@16f73de, public java.util.Collection java.util.LinkedHashMap.values()=[Ljava.lang.Class;@b3e45, public void java.util.LinkedHashMap.clear()=[Ljava.lang.Class;@a34e5c, public java.lang.Object java.util.HashMap.computeIfPresent(java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1fcb13a, public java.lang.Object java.util.HashMap.compute(java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1a7c258, public final native java.lang.Class java.lang.Object.getClass()=[Ljava.lang.Class;@7397f, public void java.util.HashMap.putAll(java.util.Map)=[Ljava.lang.Class;@59cd, public void java.util.LinkedHashMap.replaceAll(java.util.function.BiFunction)=[Ljava.lang.Class;@994816, public java.lang.Object java.util.HashMap.merge(java.lang.Object,java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1b1e75f, public int java.util.HashMap.size()=[Ljava.lang.Class;@bee157, public boolean java.util.LinkedHashMap.containsValue(java.lang.Object)=[Ljava.lang.Class;@5e0d7c}, replaceAll=public void java.util.LinkedHashMap.replaceAll(java.util.function.BiFunction), remove=freemarker.ext.beans.OverloadedMethods@8d3a99, containsValue=public boolean java.util.LinkedHashMap.containsValue(java.lang.Object), put=public java.lang.Object java.util.HashMap.put(java.lang.Object,java.lang.Object), empty=java.beans.PropertyDescriptor[name=empty; propertyType=boolean; readMethod=public boolean java.util.HashMap.isEmpty()], compute=public java.lang.Object java.util.HashMap.compute(java.lang.Object,java.util.function.BiFunction), hashCode=public int java.util.AbstractMap.hashCode(), putAll=public void java.util.HashMap.putAll(java.util.Map), get=public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object), merge=public java.lang.Object java.util.HashMap.merge(java.lang.Object,java.lang.Object,java.util.function.BiFunction), class=java.beans.PropertyDescriptor[name=class; propertyType=class java.lang.Class; readMethod=public final native java.lang.Class java.lang.Object.getClass()], keySet=public java.util.Set java.util.LinkedHashMap.keySet(), java.lang.Object@1c0f21d=freemarker.ext.beans.OverloadedMethods@d4b988, entrySet=public java.util.Set java.util.LinkedHashMap.entrySet(), java.lang.Object@15be27d=public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object), forEach=public void java.util.LinkedHashMap.forEach(java.util.function.BiConsumer), containsKey=public boolean java.util.HashMap.containsKey(java.lang.Object), isEmpty=public boolean java.util.HashMap.isEmpty(), clear=public void java.util.LinkedHashMap.clear(), computeIfPresent=public java.lang.Object java.util.HashMap.computeIfPresent(java.lang.Object,java.util.function.BiFunction), size=public int java.util.HashMap.size(), equals=public boolean java.util.AbstractMap.equals(java.lang.Object), clone=public java.lang.Object java.util.HashMap.clone(), toString=public java.lang.String java.util.AbstractMap.toString(), putIfAbsent=public java.lang.Object java.util.HashMap.putIfAbsent(java.lang.Object,java.lang.Object)}
[DEBUG] 2017-05-24: 21:05:33 freemarker.log._Log4jLoggerFactory$Log4jLogger.debug(_Log4jLoggerFactory.java:45) :  Key "onkeypress" was not found on instance of java.util.LinkedHashMap. Introspection information for the class is: {getClass=public final native java.lang.Class java.lang.Object.getClass(), getOrDefault=public java.lang.Object java.util.LinkedHashMap.getOrDefault(java.lang.Object,java.lang.Object), computeIfAbsent=public java.lang.Object java.util.HashMap.computeIfAbsent(java.lang.Object,java.util.function.Function), values=public java.util.Collection java.util.LinkedHashMap.values(), replace=freemarker.ext.beans.OverloadedMethods@11d0265, java.lang.Object@3e55b2={public boolean java.util.HashMap.isEmpty()=[Ljava.lang.Class;@c5aa3a, public int java.util.AbstractMap.hashCode()=[Ljava.lang.Class;@74a947, public java.lang.Object java.util.HashMap.put(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@1615a91, public boolean java.util.AbstractMap.equals(java.lang.Object)=[Ljava.lang.Class;@a46ab2, public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object)=[Ljava.lang.Class;@1c389e6, public java.lang.String java.util.AbstractMap.toString()=[Ljava.lang.Class;@a23548, public boolean java.util.HashMap.containsKey(java.lang.Object)=[Ljava.lang.Class;@1be4a9f, public java.util.Set java.util.LinkedHashMap.keySet()=[Ljava.lang.Class;@44c60, public java.lang.Object java.util.HashMap.computeIfAbsent(java.lang.Object,java.util.function.Function)=[Ljava.lang.Class;@10f7dff, public java.lang.Object java.util.HashMap.clone()=[Ljava.lang.Class;@d214e3, public java.lang.Object java.util.LinkedHashMap.getOrDefault(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@1a74254, public java.util.Set java.util.LinkedHashMap.entrySet()=[Ljava.lang.Class;@1c4740c, public void java.util.LinkedHashMap.forEach(java.util.function.BiConsumer)=[Ljava.lang.Class;@1fe0c8e, public java.lang.Object java.util.HashMap.putIfAbsent(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@16f73de, public java.util.Collection java.util.LinkedHashMap.values()=[Ljava.lang.Class;@b3e45, public void java.util.LinkedHashMap.clear()=[Ljava.lang.Class;@a34e5c, public java.lang.Object java.util.HashMap.computeIfPresent(java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1fcb13a, public java.lang.Object java.util.HashMap.compute(java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1a7c258, public final native java.lang.Class java.lang.Object.getClass()=[Ljava.lang.Class;@7397f, public void java.util.HashMap.putAll(java.util.Map)=[Ljava.lang.Class;@59cd, public void java.util.LinkedHashMap.replaceAll(java.util.function.BiFunction)=[Ljava.lang.Class;@994816, public java.lang.Object java.util.HashMap.merge(java.lang.Object,java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1b1e75f, public int java.util.HashMap.size()=[Ljava.lang.Class;@bee157, public boolean java.util.LinkedHashMap.containsValue(java.lang.Object)=[Ljava.lang.Class;@5e0d7c}, replaceAll=public void java.util.LinkedHashMap.replaceAll(java.util.function.BiFunction), remove=freemarker.ext.beans.OverloadedMethods@8d3a99, containsValue=public boolean java.util.LinkedHashMap.containsValue(java.lang.Object), put=public java.lang.Object java.util.HashMap.put(java.lang.Object,java.lang.Object), empty=java.beans.PropertyDescriptor[name=empty; propertyType=boolean; readMethod=public boolean java.util.HashMap.isEmpty()], compute=public java.lang.Object java.util.HashMap.compute(java.lang.Object,java.util.function.BiFunction), hashCode=public int java.util.AbstractMap.hashCode(), putAll=public void java.util.HashMap.putAll(java.util.Map), get=public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object), merge=public java.lang.Object java.util.HashMap.merge(java.lang.Object,java.lang.Object,java.util.function.BiFunction), class=java.beans.PropertyDescriptor[name=class; propertyType=class java.lang.Class; readMethod=public final native java.lang.Class java.lang.Object.getClass()], keySet=public java.util.Set java.util.LinkedHashMap.keySet(), java.lang.Object@1c0f21d=freemarker.ext.beans.OverloadedMethods@d4b988, entrySet=public java.util.Set java.util.LinkedHashMap.entrySet(), java.lang.Object@15be27d=public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object), forEach=public void java.util.LinkedHashMap.forEach(java.util.function.BiConsumer), containsKey=public boolean java.util.HashMap.containsKey(java.lang.Object), isEmpty=public boolean java.util.HashMap.isEmpty(), clear=public void java.util.LinkedHashMap.clear(), computeIfPresent=public java.lang.Object java.util.HashMap.computeIfPresent(java.lang.Object,java.util.function.BiFunction), size=public int java.util.HashMap.size(), equals=public boolean java.util.AbstractMap.equals(java.lang.Object), clone=public java.lang.Object java.util.HashMap.clone(), toString=public java.lang.String java.util.AbstractMap.toString(), putIfAbsent=public java.lang.Object java.util.HashMap.putIfAbsent(java.lang.Object,java.lang.Object)}
[DEBUG] 2017-05-24: 21:05:33 freemarker.log._Log4jLoggerFactory$Log4jLogger.debug(_Log4jLoggerFactory.java:45) :  Key "onkeydown" was not found on instance of java.util.LinkedHashMap. Introspection information for the class is: {getClass=public final native java.lang.Class java.lang.Object.getClass(), getOrDefault=public java.lang.Object java.util.LinkedHashMap.getOrDefault(java.lang.Object,java.lang.Object), computeIfAbsent=public java.lang.Object java.util.HashMap.computeIfAbsent(java.lang.Object,java.util.function.Function), values=public java.util.Collection java.util.LinkedHashMap.values(), replace=freemarker.ext.beans.OverloadedMethods@11d0265, java.lang.Object@3e55b2={public boolean java.util.HashMap.isEmpty()=[Ljava.lang.Class;@c5aa3a, public int java.util.AbstractMap.hashCode()=[Ljava.lang.Class;@74a947, public java.lang.Object java.util.HashMap.put(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@1615a91, public boolean java.util.AbstractMap.equals(java.lang.Object)=[Ljava.lang.Class;@a46ab2, public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object)=[Ljava.lang.Class;@1c389e6, public java.lang.String java.util.AbstractMap.toString()=[Ljava.lang.Class;@a23548, public boolean java.util.HashMap.containsKey(java.lang.Object)=[Ljava.lang.Class;@1be4a9f, public java.util.Set java.util.LinkedHashMap.keySet()=[Ljava.lang.Class;@44c60, public java.lang.Object java.util.HashMap.computeIfAbsent(java.lang.Object,java.util.function.Function)=[Ljava.lang.Class;@10f7dff, public java.lang.Object java.util.HashMap.clone()=[Ljava.lang.Class;@d214e3, public java.lang.Object java.util.LinkedHashMap.getOrDefault(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@1a74254, public java.util.Set java.util.LinkedHashMap.entrySet()=[Ljava.lang.Class;@1c4740c, public void java.util.LinkedHashMap.forEach(java.util.function.BiConsumer)=[Ljava.lang.Class;@1fe0c8e, public java.lang.Object java.util.HashMap.putIfAbsent(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@16f73de, public java.util.Collection java.util.LinkedHashMap.values()=[Ljava.lang.Class;@b3e45, public void java.util.LinkedHashMap.clear()=[Ljava.lang.Class;@a34e5c, public java.lang.Object java.util.HashMap.computeIfPresent(java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1fcb13a, public java.lang.Object java.util.HashMap.compute(java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1a7c258, public final native java.lang.Class java.lang.Object.getClass()=[Ljava.lang.Class;@7397f, public void java.util.HashMap.putAll(java.util.Map)=[Ljava.lang.Class;@59cd, public void java.util.LinkedHashMap.replaceAll(java.util.function.BiFunction)=[Ljava.lang.Class;@994816, public java.lang.Object java.util.HashMap.merge(java.lang.Object,java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1b1e75f, public int java.util.HashMap.size()=[Ljava.lang.Class;@bee157, public boolean java.util.LinkedHashMap.containsValue(java.lang.Object)=[Ljava.lang.Class;@5e0d7c}, replaceAll=public void java.util.LinkedHashMap.replaceAll(java.util.function.BiFunction), remove=freemarker.ext.beans.OverloadedMethods@8d3a99, containsValue=public boolean java.util.LinkedHashMap.containsValue(java.lang.Object), put=public java.lang.Object java.util.HashMap.put(java.lang.Object,java.lang.Object), empty=java.beans.PropertyDescriptor[name=empty; propertyType=boolean; readMethod=public boolean java.util.HashMap.isEmpty()], compute=public java.lang.Object java.util.HashMap.compute(java.lang.Object,java.util.function.BiFunction), hashCode=public int java.util.AbstractMap.hashCode(), putAll=public void java.util.HashMap.putAll(java.util.Map), get=public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object), merge=public java.lang.Object java.util.HashMap.merge(java.lang.Object,java.lang.Object,java.util.function.BiFunction), class=java.beans.PropertyDescriptor[name=class; propertyType=class java.lang.Class; readMethod=public final native java.lang.Class java.lang.Object.getClass()], keySet=public java.util.Set java.util.LinkedHashMap.keySet(), java.lang.Object@1c0f21d=freemarker.ext.beans.OverloadedMethods@d4b988, entrySet=public java.util.Set java.util.LinkedHashMap.entrySet(), java.lang.Object@15be27d=public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object), forEach=public void java.util.LinkedHashMap.forEach(java.util.function.BiConsumer), containsKey=public boolean java.util.HashMap.containsKey(java.lang.Object), isEmpty=public boolean java.util.HashMap.isEmpty(), clear=public void java.util.LinkedHashMap.clear(), computeIfPresent=public java.lang.Object java.util.HashMap.computeIfPresent(java.lang.Object,java.util.function.BiFunction), size=public int java.util.HashMap.size(), equals=public boolean java.util.AbstractMap.equals(java.lang.Object), clone=public java.lang.Object java.util.HashMap.clone(), toString=public java.lang.String java.util.AbstractMap.toString(), putIfAbsent=public java.lang.Object java.util.HashMap.putIfAbsent(java.lang.Object,java.lang.Object)}
[DEBUG] 2017-05-24: 21:05:33 freemarker.log._Log4jLoggerFactory$Log4jLogger.debug(_Log4jLoggerFactory.java:45) :  Key "onkeyup" was not found on instance of java.util.LinkedHashMap. Introspection information for the class is: {getClass=public final native java.lang.Class java.lang.Object.getClass(), getOrDefault=public java.lang.Object java.util.LinkedHashMap.getOrDefault(java.lang.Object,java.lang.Object), computeIfAbsent=public java.lang.Object java.util.HashMap.computeIfAbsent(java.lang.Object,java.util.function.Function), values=public java.util.Collection java.util.LinkedHashMap.values(), replace=freemarker.ext.beans.OverloadedMethods@11d0265, java.lang.Object@3e55b2={public boolean java.util.HashMap.isEmpty()=[Ljava.lang.Class;@c5aa3a, public int java.util.AbstractMap.hashCode()=[Ljava.lang.Class;@74a947, public java.lang.Object java.util.HashMap.put(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@1615a91, public boolean java.util.AbstractMap.equals(java.lang.Object)=[Ljava.lang.Class;@a46ab2, public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object)=[Ljava.lang.Class;@1c389e6, public java.lang.String java.util.AbstractMap.toString()=[Ljava.lang.Class;@a23548, public boolean java.util.HashMap.containsKey(java.lang.Object)=[Ljava.lang.Class;@1be4a9f, public java.util.Set java.util.LinkedHashMap.keySet()=[Ljava.lang.Class;@44c60, public java.lang.Object java.util.HashMap.computeIfAbsent(java.lang.Object,java.util.function.Function)=[Ljava.lang.Class;@10f7dff, public java.lang.Object java.util.HashMap.clone()=[Ljava.lang.Class;@d214e3, public java.lang.Object java.util.LinkedHashMap.getOrDefault(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@1a74254, public java.util.Set java.util.LinkedHashMap.entrySet()=[Ljava.lang.Class;@1c4740c, public void java.util.LinkedHashMap.forEach(java.util.function.BiConsumer)=[Ljava.lang.Class;@1fe0c8e, public java.lang.Object java.util.HashMap.putIfAbsent(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@16f73de, public java.util.Collection java.util.LinkedHashMap.values()=[Ljava.lang.Class;@b3e45, public void java.util.LinkedHashMap.clear()=[Ljava.lang.Class;@a34e5c, public java.lang.Object java.util.HashMap.computeIfPresent(java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1fcb13a, public java.lang.Object java.util.HashMap.compute(java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1a7c258, public final native java.lang.Class java.lang.Object.getClass()=[Ljava.lang.Class;@7397f, public void java.util.HashMap.putAll(java.util.Map)=[Ljava.lang.Class;@59cd, public void java.util.LinkedHashMap.replaceAll(java.util.function.BiFunction)=[Ljava.lang.Class;@994816, public java.lang.Object java.util.HashMap.merge(java.lang.Object,java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1b1e75f, public int java.util.HashMap.size()=[Ljava.lang.Class;@bee157, public boolean java.util.LinkedHashMap.containsValue(java.lang.Object)=[Ljava.lang.Class;@5e0d7c}, replaceAll=public void java.util.LinkedHashMap.replaceAll(java.util.function.BiFunction), remove=freemarker.ext.beans.OverloadedMethods@8d3a99, containsValue=public boolean java.util.LinkedHashMap.containsValue(java.lang.Object), put=public java.lang.Object java.util.HashMap.put(java.lang.Object,java.lang.Object), empty=java.beans.PropertyDescriptor[name=empty; propertyType=boolean; readMethod=public boolean java.util.HashMap.isEmpty()], compute=public java.lang.Object java.util.HashMap.compute(java.lang.Object,java.util.function.BiFunction), hashCode=public int java.util.AbstractMap.hashCode(), putAll=public void java.util.HashMap.putAll(java.util.Map), get=public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object), merge=public java.lang.Object java.util.HashMap.merge(java.lang.Object,java.lang.Object,java.util.function.BiFunction), class=java.beans.PropertyDescriptor[name=class; propertyType=class java.lang.Class; readMethod=public final native java.lang.Class java.lang.Object.getClass()], keySet=public java.util.Set java.util.LinkedHashMap.keySet(), java.lang.Object@1c0f21d=freemarker.ext.beans.OverloadedMethods@d4b988, entrySet=public java.util.Set java.util.LinkedHashMap.entrySet(), java.lang.Object@15be27d=public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object), forEach=public void java.util.LinkedHashMap.forEach(java.util.function.BiConsumer), containsKey=public boolean java.util.HashMap.containsKey(java.lang.Object), isEmpty=public boolean java.util.HashMap.isEmpty(), clear=public void java.util.LinkedHashMap.clear(), computeIfPresent=public java.lang.Object java.util.HashMap.computeIfPresent(java.lang.Object,java.util.function.BiFunction), size=public int java.util.HashMap.size(), equals=public boolean java.util.AbstractMap.equals(java.lang.Object), clone=public java.lang.Object java.util.HashMap.clone(), toString=public java.lang.String java.util.AbstractMap.toString(), putIfAbsent=public java.lang.Object java.util.HashMap.putIfAbsent(java.lang.Object,java.lang.Object)}
[DEBUG] 2017-05-24: 21:05:33 freemarker.log._Log4jLoggerFactory$Log4jLogger.debug(_Log4jLoggerFactory.java:45) :  Key "onselect" was not found on instance of java.util.LinkedHashMap. Introspection information for the class is: {getClass=public final native java.lang.Class java.lang.Object.getClass(), getOrDefault=public java.lang.Object java.util.LinkedHashMap.getOrDefault(java.lang.Object,java.lang.Object), computeIfAbsent=public java.lang.Object java.util.HashMap.computeIfAbsent(java.lang.Object,java.util.function.Function), values=public java.util.Collection java.util.LinkedHashMap.values(), replace=freemarker.ext.beans.OverloadedMethods@11d0265, java.lang.Object@3e55b2={public boolean java.util.HashMap.isEmpty()=[Ljava.lang.Class;@c5aa3a, public int java.util.AbstractMap.hashCode()=[Ljava.lang.Class;@74a947, public java.lang.Object java.util.HashMap.put(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@1615a91, public boolean java.util.AbstractMap.equals(java.lang.Object)=[Ljava.lang.Class;@a46ab2, public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object)=[Ljava.lang.Class;@1c389e6, public java.lang.String java.util.AbstractMap.toString()=[Ljava.lang.Class;@a23548, public boolean java.util.HashMap.containsKey(java.lang.Object)=[Ljava.lang.Class;@1be4a9f, public java.util.Set java.util.LinkedHashMap.keySet()=[Ljava.lang.Class;@44c60, public java.lang.Object java.util.HashMap.computeIfAbsent(java.lang.Object,java.util.function.Function)=[Ljava.lang.Class;@10f7dff, public java.lang.Object java.util.HashMap.clone()=[Ljava.lang.Class;@d214e3, public java.lang.Object java.util.LinkedHashMap.getOrDefault(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@1a74254, public java.util.Set java.util.LinkedHashMap.entrySet()=[Ljava.lang.Class;@1c4740c, public void java.util.LinkedHashMap.forEach(java.util.function.BiConsumer)=[Ljava.lang.Class;@1fe0c8e, public java.lang.Object java.util.HashMap.putIfAbsent(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@16f73de, public java.util.Collection java.util.LinkedHashMap.values()=[Ljava.lang.Class;@b3e45, public void java.util.LinkedHashMap.clear()=[Ljava.lang.Class;@a34e5c, public java.lang.Object java.util.HashMap.computeIfPresent(java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1fcb13a, public java.lang.Object java.util.HashMap.compute(java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1a7c258, public final native java.lang.Class java.lang.Object.getClass()=[Ljava.lang.Class;@7397f, public void java.util.HashMap.putAll(java.util.Map)=[Ljava.lang.Class;@59cd, public void java.util.LinkedHashMap.replaceAll(java.util.function.BiFunction)=[Ljava.lang.Class;@994816, public java.lang.Object java.util.HashMap.merge(java.lang.Object,java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1b1e75f, public int java.util.HashMap.size()=[Ljava.lang.Class;@bee157, public boolean java.util.LinkedHashMap.containsValue(java.lang.Object)=[Ljava.lang.Class;@5e0d7c}, replaceAll=public void java.util.LinkedHashMap.replaceAll(java.util.function.BiFunction), remove=freemarker.ext.beans.OverloadedMethods@8d3a99, containsValue=public boolean java.util.LinkedHashMap.containsValue(java.lang.Object), put=public java.lang.Object java.util.HashMap.put(java.lang.Object,java.lang.Object), empty=java.beans.PropertyDescriptor[name=empty; propertyType=boolean; readMethod=public boolean java.util.HashMap.isEmpty()], compute=public java.lang.Object java.util.HashMap.compute(java.lang.Object,java.util.function.BiFunction), hashCode=public int java.util.AbstractMap.hashCode(), putAll=public void java.util.HashMap.putAll(java.util.Map), get=public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object), merge=public java.lang.Object java.util.HashMap.merge(java.lang.Object,java.lang.Object,java.util.function.BiFunction), class=java.beans.PropertyDescriptor[name=class; propertyType=class java.lang.Class; readMethod=public final native java.lang.Class java.lang.Object.getClass()], keySet=public java.util.Set java.util.LinkedHashMap.keySet(), java.lang.Object@1c0f21d=freemarker.ext.beans.OverloadedMethods@d4b988, entrySet=public java.util.Set java.util.LinkedHashMap.entrySet(), java.lang.Object@15be27d=public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object), forEach=public void java.util.LinkedHashMap.forEach(java.util.function.BiConsumer), containsKey=public boolean java.util.HashMap.containsKey(java.lang.Object), isEmpty=public boolean java.util.HashMap.isEmpty(), clear=public void java.util.LinkedHashMap.clear(), computeIfPresent=public java.lang.Object java.util.HashMap.computeIfPresent(java.lang.Object,java.util.function.BiFunction), size=public int java.util.HashMap.size(), equals=public boolean java.util.AbstractMap.equals(java.lang.Object), clone=public java.lang.Object java.util.HashMap.clone(), toString=public java.lang.String java.util.AbstractMap.toString(), putIfAbsent=public java.lang.Object java.util.HashMap.putIfAbsent(java.lang.Object,java.lang.Object)}
[DEBUG] 2017-05-24: 21:05:33 freemarker.log._Log4jLoggerFactory$Log4jLogger.debug(_Log4jLoggerFactory.java:45) :  Key "onchange" was not found on instance of java.util.LinkedHashMap. Introspection information for the class is: {getClass=public final native java.lang.Class java.lang.Object.getClass(), getOrDefault=public java.lang.Object java.util.LinkedHashMap.getOrDefault(java.lang.Object,java.lang.Object), computeIfAbsent=public java.lang.Object java.util.HashMap.computeIfAbsent(java.lang.Object,java.util.function.Function), values=public java.util.Collection java.util.LinkedHashMap.values(), replace=freemarker.ext.beans.OverloadedMethods@11d0265, java.lang.Object@3e55b2={public boolean java.util.HashMap.isEmpty()=[Ljava.lang.Class;@c5aa3a, public int java.util.AbstractMap.hashCode()=[Ljava.lang.Class;@74a947, public java.lang.Object java.util.HashMap.put(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@1615a91, public boolean java.util.AbstractMap.equals(java.lang.Object)=[Ljava.lang.Class;@a46ab2, public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object)=[Ljava.lang.Class;@1c389e6, public java.lang.String java.util.AbstractMap.toString()=[Ljava.lang.Class;@a23548, public boolean java.util.HashMap.containsKey(java.lang.Object)=[Ljava.lang.Class;@1be4a9f, public java.util.Set java.util.LinkedHashMap.keySet()=[Ljava.lang.Class;@44c60, public java.lang.Object java.util.HashMap.computeIfAbsent(java.lang.Object,java.util.function.Function)=[Ljava.lang.Class;@10f7dff, public java.lang.Object java.util.HashMap.clone()=[Ljava.lang.Class;@d214e3, public java.lang.Object java.util.LinkedHashMap.getOrDefault(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@1a74254, public java.util.Set java.util.LinkedHashMap.entrySet()=[Ljava.lang.Class;@1c4740c, public void java.util.LinkedHashMap.forEach(java.util.function.BiConsumer)=[Ljava.lang.Class;@1fe0c8e, public java.lang.Object java.util.HashMap.putIfAbsent(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@16f73de, public java.util.Collection java.util.LinkedHashMap.values()=[Ljava.lang.Class;@b3e45, public void java.util.LinkedHashMap.clear()=[Ljava.lang.Class;@a34e5c, public java.lang.Object java.util.HashMap.computeIfPresent(java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1fcb13a, public java.lang.Object java.util.HashMap.compute(java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1a7c258, public final native java.lang.Class java.lang.Object.getClass()=[Ljava.lang.Class;@7397f, public void java.util.HashMap.putAll(java.util.Map)=[Ljava.lang.Class;@59cd, public void java.util.LinkedHashMap.replaceAll(java.util.function.BiFunction)=[Ljava.lang.Class;@994816, public java.lang.Object java.util.HashMap.merge(java.lang.Object,java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1b1e75f, public int java.util.HashMap.size()=[Ljava.lang.Class;@bee157, public boolean java.util.LinkedHashMap.containsValue(java.lang.Object)=[Ljava.lang.Class;@5e0d7c}, replaceAll=public void java.util.LinkedHashMap.replaceAll(java.util.function.BiFunction), remove=freemarker.ext.beans.OverloadedMethods@8d3a99, containsValue=public boolean java.util.LinkedHashMap.containsValue(java.lang.Object), put=public java.lang.Object java.util.HashMap.put(java.lang.Object,java.lang.Object), empty=java.beans.PropertyDescriptor[name=empty; propertyType=boolean; readMethod=public boolean java.util.HashMap.isEmpty()], compute=public java.lang.Object java.util.HashMap.compute(java.lang.Object,java.util.function.BiFunction), hashCode=public int java.util.AbstractMap.hashCode(), putAll=public void java.util.HashMap.putAll(java.util.Map), get=public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object), merge=public java.lang.Object java.util.HashMap.merge(java.lang.Object,java.lang.Object,java.util.function.BiFunction), class=java.beans.PropertyDescriptor[name=class; propertyType=class java.lang.Class; readMethod=public final native java.lang.Class java.lang.Object.getClass()], keySet=public java.util.Set java.util.LinkedHashMap.keySet(), java.lang.Object@1c0f21d=freemarker.ext.beans.OverloadedMethods@d4b988, entrySet=public java.util.Set java.util.LinkedHashMap.entrySet(), java.lang.Object@15be27d=public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object), forEach=public void java.util.LinkedHashMap.forEach(java.util.function.BiConsumer), containsKey=public boolean java.util.HashMap.containsKey(java.lang.Object), isEmpty=public boolean java.util.HashMap.isEmpty(), clear=public void java.util.LinkedHashMap.clear(), computeIfPresent=public java.lang.Object java.util.HashMap.computeIfPresent(java.lang.Object,java.util.function.BiFunction), size=public int java.util.HashMap.size(), equals=public boolean java.util.AbstractMap.equals(java.lang.Object), clone=public java.lang.Object java.util.HashMap.clone(), toString=public java.lang.String java.util.AbstractMap.toString(), putIfAbsent=public java.lang.Object java.util.HashMap.putIfAbsent(java.lang.Object,java.lang.Object)}
[DEBUG] 2017-05-24: 21:05:33 freemarker.log._Log4jLoggerFactory$Log4jLogger.debug(_Log4jLoggerFactory.java:45) :  TemplateLoader.findTemplateSource("template/~~~xhtml/common-attributes.ftl"): Found
[DEBUG] 2017-05-24: 21:05:33 freemarker.log._Log4jLoggerFactory$Log4jLogger.debug(_Log4jLoggerFactory.java:45) :  "template/~~~xhtml/common-attributes.ftl"("zh_CN", UTF-8, parsed): using cached since jar:file:/D:/maven/repository/org/apache/struts/struts2-core/2.5.10/struts2-core-2.5.10.jar!/template/simple/common-attributes.ftl hasn't changed.
[DEBUG] 2017-05-24: 21:05:33 freemarker.log._Log4jLoggerFactory$Log4jLogger.debug(_Log4jLoggerFactory.java:45) :  Key "accesskey" was not found on instance of java.util.LinkedHashMap. Introspection information for the class is: {getClass=public final native java.lang.Class java.lang.Object.getClass(), getOrDefault=public java.lang.Object java.util.LinkedHashMap.getOrDefault(java.lang.Object,java.lang.Object), computeIfAbsent=public java.lang.Object java.util.HashMap.computeIfAbsent(java.lang.Object,java.util.function.Function), values=public java.util.Collection java.util.LinkedHashMap.values(), replace=freemarker.ext.beans.OverloadedMethods@11d0265, java.lang.Object@3e55b2={public boolean java.util.HashMap.isEmpty()=[Ljava.lang.Class;@c5aa3a, public int java.util.AbstractMap.hashCode()=[Ljava.lang.Class;@74a947, public java.lang.Object java.util.HashMap.put(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@1615a91, public boolean java.util.AbstractMap.equals(java.lang.Object)=[Ljava.lang.Class;@a46ab2, public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object)=[Ljava.lang.Class;@1c389e6, public java.lang.String java.util.AbstractMap.toString()=[Ljava.lang.Class;@a23548, public boolean java.util.HashMap.containsKey(java.lang.Object)=[Ljava.lang.Class;@1be4a9f, public java.util.Set java.util.LinkedHashMap.keySet()=[Ljava.lang.Class;@44c60, public java.lang.Object java.util.HashMap.computeIfAbsent(java.lang.Object,java.util.function.Function)=[Ljava.lang.Class;@10f7dff, public java.lang.Object java.util.HashMap.clone()=[Ljava.lang.Class;@d214e3, public java.lang.Object java.util.LinkedHashMap.getOrDefault(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@1a74254, public java.util.Set java.util.LinkedHashMap.entrySet()=[Ljava.lang.Class;@1c4740c, public void java.util.LinkedHashMap.forEach(java.util.function.BiConsumer)=[Ljava.lang.Class;@1fe0c8e, public java.lang.Object java.util.HashMap.putIfAbsent(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@16f73de, public java.util.Collection java.util.LinkedHashMap.values()=[Ljava.lang.Class;@b3e45, public void java.util.LinkedHashMap.clear()=[Ljava.lang.Class;@a34e5c, public java.lang.Object java.util.HashMap.computeIfPresent(java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1fcb13a, public java.lang.Object java.util.HashMap.compute(java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1a7c258, public final native java.lang.Class java.lang.Object.getClass()=[Ljava.lang.Class;@7397f, public void java.util.HashMap.putAll(java.util.Map)=[Ljava.lang.Class;@59cd, public void java.util.LinkedHashMap.replaceAll(java.util.function.BiFunction)=[Ljava.lang.Class;@994816, public java.lang.Object java.util.HashMap.merge(java.lang.Object,java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1b1e75f, public int java.util.HashMap.size()=[Ljava.lang.Class;@bee157, public boolean java.util.LinkedHashMap.containsValue(java.lang.Object)=[Ljava.lang.Class;@5e0d7c}, replaceAll=public void java.util.LinkedHashMap.replaceAll(java.util.function.BiFunction), remove=freemarker.ext.beans.OverloadedMethods@8d3a99, containsValue=public boolean java.util.LinkedHashMap.containsValue(java.lang.Object), put=public java.lang.Object java.util.HashMap.put(java.lang.Object,java.lang.Object), empty=java.beans.PropertyDescriptor[name=empty; propertyType=boolean; readMethod=public boolean java.util.HashMap.isEmpty()], compute=public java.lang.Object java.util.HashMap.compute(java.lang.Object,java.util.function.BiFunction), hashCode=public int java.util.AbstractMap.hashCode(), putAll=public void java.util.HashMap.putAll(java.util.Map), get=public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object), merge=public java.lang.Object java.util.HashMap.merge(java.lang.Object,java.lang.Object,java.util.function.BiFunction), class=java.beans.PropertyDescriptor[name=class; propertyType=class java.lang.Class; readMethod=public final native java.lang.Class java.lang.Object.getClass()], keySet=public java.util.Set java.util.LinkedHashMap.keySet(), java.lang.Object@1c0f21d=freemarker.ext.beans.OverloadedMethods@d4b988, entrySet=public java.util.Set java.util.LinkedHashMap.entrySet(), java.lang.Object@15be27d=public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object), forEach=public void java.util.LinkedHashMap.forEach(java.util.function.BiConsumer), containsKey=public boolean java.util.HashMap.containsKey(java.lang.Object), isEmpty=public boolean java.util.HashMap.isEmpty(), clear=public void java.util.LinkedHashMap.clear(), computeIfPresent=public java.lang.Object java.util.HashMap.computeIfPresent(java.lang.Object,java.util.function.BiFunction), size=public int java.util.HashMap.size(), equals=public boolean java.util.AbstractMap.equals(java.lang.Object), clone=public java.lang.Object java.util.HashMap.clone(), toString=public java.lang.String java.util.AbstractMap.toString(), putIfAbsent=public java.lang.Object java.util.HashMap.putIfAbsent(java.lang.Object,java.lang.Object)}
[DEBUG] 2017-05-24: 21:05:33 freemarker.log._Log4jLoggerFactory$Log4jLogger.debug(_Log4jLoggerFactory.java:45) :  TemplateLoader.findTemplateSource("template/~~~xhtml/dynamic-attributes.ftl"): Found
[DEBUG] 2017-05-24: 21:05:33 freemarker.log._Log4jLoggerFactory$Log4jLogger.debug(_Log4jLoggerFactory.java:45) :  "template/~~~xhtml/dynamic-attributes.ftl"("zh_CN", UTF-8, parsed): using cached since jar:file:/D:/maven/repository/org/apache/struts/struts2-core/2.5.10/struts2-core-2.5.10.jar!/template/simple/dynamic-attributes.ftl hasn't changed.
[DEBUG] 2017-05-24: 21:05:33 freemarker.log._Log4jLoggerFactory$Log4jLogger.debug(_Log4jLoggerFactory.java:45) :  TemplateLoader.findTemplateSource("template/~~~xhtml/css.ftl"): Found
[DEBUG] 2017-05-24: 21:05:33 freemarker.log._Log4jLoggerFactory$Log4jLogger.debug(_Log4jLoggerFactory.java:45) :  "template/~~~xhtml/css.ftl"("zh_CN", UTF-8, parsed): using cached since jar:file:/D:/maven/repository/org/apache/struts/struts2-core/2.5.10/struts2-core-2.5.10.jar!/template/simple/css.ftl hasn't changed.
[DEBUG] 2017-05-24: 21:05:33 freemarker.log._Log4jLoggerFactory$Log4jLogger.debug(_Log4jLoggerFactory.java:45) :  Key "cssClass" was not found on instance of java.util.LinkedHashMap. Introspection information for the class is: {getClass=public final native java.lang.Class java.lang.Object.getClass(), getOrDefault=public java.lang.Object java.util.LinkedHashMap.getOrDefault(java.lang.Object,java.lang.Object), computeIfAbsent=public java.lang.Object java.util.HashMap.computeIfAbsent(java.lang.Object,java.util.function.Function), values=public java.util.Collection java.util.LinkedHashMap.values(), replace=freemarker.ext.beans.OverloadedMethods@11d0265, java.lang.Object@3e55b2={public boolean java.util.HashMap.isEmpty()=[Ljava.lang.Class;@c5aa3a, public int java.util.AbstractMap.hashCode()=[Ljava.lang.Class;@74a947, public java.lang.Object java.util.HashMap.put(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@1615a91, public boolean java.util.AbstractMap.equals(java.lang.Object)=[Ljava.lang.Class;@a46ab2, public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object)=[Ljava.lang.Class;@1c389e6, public java.lang.String java.util.AbstractMap.toString()=[Ljava.lang.Class;@a23548, public boolean java.util.HashMap.containsKey(java.lang.Object)=[Ljava.lang.Class;@1be4a9f, public java.util.Set java.util.LinkedHashMap.keySet()=[Ljava.lang.Class;@44c60, public java.lang.Object java.util.HashMap.computeIfAbsent(java.lang.Object,java.util.function.Function)=[Ljava.lang.Class;@10f7dff, public java.lang.Object java.util.HashMap.clone()=[Ljava.lang.Class;@d214e3, public java.lang.Object java.util.LinkedHashMap.getOrDefault(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@1a74254, public java.util.Set java.util.LinkedHashMap.entrySet()=[Ljava.lang.Class;@1c4740c, public void java.util.LinkedHashMap.forEach(java.util.function.BiConsumer)=[Ljava.lang.Class;@1fe0c8e, public java.lang.Object java.util.HashMap.putIfAbsent(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@16f73de, public java.util.Collection java.util.LinkedHashMap.values()=[Ljava.lang.Class;@b3e45, public void java.util.LinkedHashMap.clear()=[Ljava.lang.Class;@a34e5c, public java.lang.Object java.util.HashMap.computeIfPresent(java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1fcb13a, public java.lang.Object java.util.HashMap.compute(java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1a7c258, public final native java.lang.Class java.lang.Object.getClass()=[Ljava.lang.Class;@7397f, public void java.util.HashMap.putAll(java.util.Map)=[Ljava.lang.Class;@59cd, public void java.util.LinkedHashMap.replaceAll(java.util.function.BiFunction)=[Ljava.lang.Class;@994816, public java.lang.Object java.util.HashMap.merge(java.lang.Object,java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1b1e75f, public int java.util.HashMap.size()=[Ljava.lang.Class;@bee157, public boolean java.util.LinkedHashMap.containsValue(java.lang.Object)=[Ljava.lang.Class;@5e0d7c}, replaceAll=public void java.util.LinkedHashMap.replaceAll(java.util.function.BiFunction), remove=freemarker.ext.beans.OverloadedMethods@8d3a99, containsValue=public boolean java.util.LinkedHashMap.containsValue(java.lang.Object), put=public java.lang.Object java.util.HashMap.put(java.lang.Object,java.lang.Object), empty=java.beans.PropertyDescriptor[name=empty; propertyType=boolean; readMethod=public boolean java.util.HashMap.isEmpty()], compute=public java.lang.Object java.util.HashMap.compute(java.lang.Object,java.util.function.BiFunction), hashCode=public int java.util.AbstractMap.hashCode(), putAll=public void java.util.HashMap.putAll(java.util.Map), get=public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object), merge=public java.lang.Object java.util.HashMap.merge(java.lang.Object,java.lang.Object,java.util.function.BiFunction), class=java.beans.PropertyDescriptor[name=class; propertyType=class java.lang.Class; readMethod=public final native java.lang.Class java.lang.Object.getClass()], keySet=public java.util.Set java.util.LinkedHashMap.keySet(), java.lang.Object@1c0f21d=freemarker.ext.beans.OverloadedMethods@d4b988, entrySet=public java.util.Set java.util.LinkedHashMap.entrySet(), java.lang.Object@15be27d=public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object), forEach=public void java.util.LinkedHashMap.forEach(java.util.function.BiConsumer), containsKey=public boolean java.util.HashMap.containsKey(java.lang.Object), isEmpty=public boolean java.util.HashMap.isEmpty(), clear=public void java.util.LinkedHashMap.clear(), computeIfPresent=public java.lang.Object java.util.HashMap.computeIfPresent(java.lang.Object,java.util.function.BiFunction), size=public int java.util.HashMap.size(), equals=public boolean java.util.AbstractMap.equals(java.lang.Object), clone=public java.lang.Object java.util.HashMap.clone(), toString=public java.lang.String java.util.AbstractMap.toString(), putIfAbsent=public java.lang.Object java.util.HashMap.putIfAbsent(java.lang.Object,java.lang.Object)}
[DEBUG] 2017-05-24: 21:05:33 freemarker.log._Log4jLoggerFactory$Log4jLogger.debug(_Log4jLoggerFactory.java:45) :  Key "cssClass" was not found on instance of java.util.LinkedHashMap. Introspection information for the class is: {getClass=public final native java.lang.Class java.lang.Object.getClass(), getOrDefault=public java.lang.Object java.util.LinkedHashMap.getOrDefault(java.lang.Object,java.lang.Object), computeIfAbsent=public java.lang.Object java.util.HashMap.computeIfAbsent(java.lang.Object,java.util.function.Function), values=public java.util.Collection java.util.LinkedHashMap.values(), replace=freemarker.ext.beans.OverloadedMethods@11d0265, java.lang.Object@3e55b2={public boolean java.util.HashMap.isEmpty()=[Ljava.lang.Class;@c5aa3a, public int java.util.AbstractMap.hashCode()=[Ljava.lang.Class;@74a947, public java.lang.Object java.util.HashMap.put(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@1615a91, public boolean java.util.AbstractMap.equals(java.lang.Object)=[Ljava.lang.Class;@a46ab2, public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object)=[Ljava.lang.Class;@1c389e6, public java.lang.String java.util.AbstractMap.toString()=[Ljava.lang.Class;@a23548, public boolean java.util.HashMap.containsKey(java.lang.Object)=[Ljava.lang.Class;@1be4a9f, public java.util.Set java.util.LinkedHashMap.keySet()=[Ljava.lang.Class;@44c60, public java.lang.Object java.util.HashMap.computeIfAbsent(java.lang.Object,java.util.function.Function)=[Ljava.lang.Class;@10f7dff, public java.lang.Object java.util.HashMap.clone()=[Ljava.lang.Class;@d214e3, public java.lang.Object java.util.LinkedHashMap.getOrDefault(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@1a74254, public java.util.Set java.util.LinkedHashMap.entrySet()=[Ljava.lang.Class;@1c4740c, public void java.util.LinkedHashMap.forEach(java.util.function.BiConsumer)=[Ljava.lang.Class;@1fe0c8e, public java.lang.Object java.util.HashMap.putIfAbsent(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@16f73de, public java.util.Collection java.util.LinkedHashMap.values()=[Ljava.lang.Class;@b3e45, public void java.util.LinkedHashMap.clear()=[Ljava.lang.Class;@a34e5c, public java.lang.Object java.util.HashMap.computeIfPresent(java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1fcb13a, public java.lang.Object java.util.HashMap.compute(java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1a7c258, public final native java.lang.Class java.lang.Object.getClass()=[Ljava.lang.Class;@7397f, public void java.util.HashMap.putAll(java.util.Map)=[Ljava.lang.Class;@59cd, public void java.util.LinkedHashMap.replaceAll(java.util.function.BiFunction)=[Ljava.lang.Class;@994816, public java.lang.Object java.util.HashMap.merge(java.lang.Object,java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1b1e75f, public int java.util.HashMap.size()=[Ljava.lang.Class;@bee157, public boolean java.util.LinkedHashMap.containsValue(java.lang.Object)=[Ljava.lang.Class;@5e0d7c}, replaceAll=public void java.util.LinkedHashMap.replaceAll(java.util.function.BiFunction), remove=freemarker.ext.beans.OverloadedMethods@8d3a99, containsValue=public boolean java.util.LinkedHashMap.containsValue(java.lang.Object), put=public java.lang.Object java.util.HashMap.put(java.lang.Object,java.lang.Object), empty=java.beans.PropertyDescriptor[name=empty; propertyType=boolean; readMethod=public boolean java.util.HashMap.isEmpty()], compute=public java.lang.Object java.util.HashMap.compute(java.lang.Object,java.util.function.BiFunction), hashCode=public int java.util.AbstractMap.hashCode(), putAll=public void java.util.HashMap.putAll(java.util.Map), get=public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object), merge=public java.lang.Object java.util.HashMap.merge(java.lang.Object,java.lang.Object,java.util.function.BiFunction), class=java.beans.PropertyDescriptor[name=class; propertyType=class java.lang.Class; readMethod=public final native java.lang.Class java.lang.Object.getClass()], keySet=public java.util.Set java.util.LinkedHashMap.keySet(), java.lang.Object@1c0f21d=freemarker.ext.beans.OverloadedMethods@d4b988, entrySet=public java.util.Set java.util.LinkedHashMap.entrySet(), java.lang.Object@15be27d=public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object), forEach=public void java.util.LinkedHashMap.forEach(java.util.function.BiConsumer), containsKey=public boolean java.util.HashMap.containsKey(java.lang.Object), isEmpty=public boolean java.util.HashMap.isEmpty(), clear=public void java.util.LinkedHashMap.clear(), computeIfPresent=public java.lang.Object java.util.HashMap.computeIfPresent(java.lang.Object,java.util.function.BiFunction), size=public int java.util.HashMap.size(), equals=public boolean java.util.AbstractMap.equals(java.lang.Object), clone=public java.lang.Object java.util.HashMap.clone(), toString=public java.lang.String java.util.AbstractMap.toString(), putIfAbsent=public java.lang.Object java.util.HashMap.putIfAbsent(java.lang.Object,java.lang.Object)}
[DEBUG] 2017-05-24: 21:05:33 freemarker.log._Log4jLoggerFactory$Log4jLogger.debug(_Log4jLoggerFactory.java:45) :  Key "cssClass" was not found on instance of java.util.LinkedHashMap. Introspection information for the class is: {getClass=public final native java.lang.Class java.lang.Object.getClass(), getOrDefault=public java.lang.Object java.util.LinkedHashMap.getOrDefault(java.lang.Object,java.lang.Object), computeIfAbsent=public java.lang.Object java.util.HashMap.computeIfAbsent(java.lang.Object,java.util.function.Function), values=public java.util.Collection java.util.LinkedHashMap.values(), replace=freemarker.ext.beans.OverloadedMethods@11d0265, java.lang.Object@3e55b2={public boolean java.util.HashMap.isEmpty()=[Ljava.lang.Class;@c5aa3a, public int java.util.AbstractMap.hashCode()=[Ljava.lang.Class;@74a947, public java.lang.Object java.util.HashMap.put(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@1615a91, public boolean java.util.AbstractMap.equals(java.lang.Object)=[Ljava.lang.Class;@a46ab2, public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object)=[Ljava.lang.Class;@1c389e6, public java.lang.String java.util.AbstractMap.toString()=[Ljava.lang.Class;@a23548, public boolean java.util.HashMap.containsKey(java.lang.Object)=[Ljava.lang.Class;@1be4a9f, public java.util.Set java.util.LinkedHashMap.keySet()=[Ljava.lang.Class;@44c60, public java.lang.Object java.util.HashMap.computeIfAbsent(java.lang.Object,java.util.function.Function)=[Ljava.lang.Class;@10f7dff, public java.lang.Object java.util.HashMap.clone()=[Ljava.lang.Class;@d214e3, public java.lang.Object java.util.LinkedHashMap.getOrDefault(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@1a74254, public java.util.Set java.util.LinkedHashMap.entrySet()=[Ljava.lang.Class;@1c4740c, public void java.util.LinkedHashMap.forEach(java.util.function.BiConsumer)=[Ljava.lang.Class;@1fe0c8e, public java.lang.Object java.util.HashMap.putIfAbsent(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@16f73de, public java.util.Collection java.util.LinkedHashMap.values()=[Ljava.lang.Class;@b3e45, public void java.util.LinkedHashMap.clear()=[Ljava.lang.Class;@a34e5c, public java.lang.Object java.util.HashMap.computeIfPresent(java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1fcb13a, public java.lang.Object java.util.HashMap.compute(java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1a7c258, public final native java.lang.Class java.lang.Object.getClass()=[Ljava.lang.Class;@7397f, public void java.util.HashMap.putAll(java.util.Map)=[Ljava.lang.Class;@59cd, public void java.util.LinkedHashMap.replaceAll(java.util.function.BiFunction)=[Ljava.lang.Class;@994816, public java.lang.Object java.util.HashMap.merge(java.lang.Object,java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1b1e75f, public int java.util.HashMap.size()=[Ljava.lang.Class;@bee157, public boolean java.util.LinkedHashMap.containsValue(java.lang.Object)=[Ljava.lang.Class;@5e0d7c}, replaceAll=public void java.util.LinkedHashMap.replaceAll(java.util.function.BiFunction), remove=freemarker.ext.beans.OverloadedMethods@8d3a99, containsValue=public boolean java.util.LinkedHashMap.containsValue(java.lang.Object), put=public java.lang.Object java.util.HashMap.put(java.lang.Object,java.lang.Object), empty=java.beans.PropertyDescriptor[name=empty; propertyType=boolean; readMethod=public boolean java.util.HashMap.isEmpty()], compute=public java.lang.Object java.util.HashMap.compute(java.lang.Object,java.util.function.BiFunction), hashCode=public int java.util.AbstractMap.hashCode(), putAll=public void java.util.HashMap.putAll(java.util.Map), get=public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object), merge=public java.lang.Object java.util.HashMap.merge(java.lang.Object,java.lang.Object,java.util.function.BiFunction), class=java.beans.PropertyDescriptor[name=class; propertyType=class java.lang.Class; readMethod=public final native java.lang.Class java.lang.Object.getClass()], keySet=public java.util.Set java.util.LinkedHashMap.keySet(), java.lang.Object@1c0f21d=freemarker.ext.beans.OverloadedMethods@d4b988, entrySet=public java.util.Set java.util.LinkedHashMap.entrySet(), java.lang.Object@15be27d=public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object), forEach=public void java.util.LinkedHashMap.forEach(java.util.function.BiConsumer), containsKey=public boolean java.util.HashMap.containsKey(java.lang.Object), isEmpty=public boolean java.util.HashMap.isEmpty(), clear=public void java.util.LinkedHashMap.clear(), computeIfPresent=public java.lang.Object java.util.HashMap.computeIfPresent(java.lang.Object,java.util.function.BiFunction), size=public int java.util.HashMap.size(), equals=public boolean java.util.AbstractMap.equals(java.lang.Object), clone=public java.lang.Object java.util.HashMap.clone(), toString=public java.lang.String java.util.AbstractMap.toString(), putIfAbsent=public java.lang.Object java.util.HashMap.putIfAbsent(java.lang.Object,java.lang.Object)}
[DEBUG] 2017-05-24: 21:05:33 freemarker.log._Log4jLoggerFactory$Log4jLogger.debug(_Log4jLoggerFactory.java:45) :  Key "cssStyle" was not found on instance of java.util.LinkedHashMap. Introspection information for the class is: {getClass=public final native java.lang.Class java.lang.Object.getClass(), getOrDefault=public java.lang.Object java.util.LinkedHashMap.getOrDefault(java.lang.Object,java.lang.Object), computeIfAbsent=public java.lang.Object java.util.HashMap.computeIfAbsent(java.lang.Object,java.util.function.Function), values=public java.util.Collection java.util.LinkedHashMap.values(), replace=freemarker.ext.beans.OverloadedMethods@11d0265, java.lang.Object@3e55b2={public boolean java.util.HashMap.isEmpty()=[Ljava.lang.Class;@c5aa3a, public int java.util.AbstractMap.hashCode()=[Ljava.lang.Class;@74a947, public java.lang.Object java.util.HashMap.put(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@1615a91, public boolean java.util.AbstractMap.equals(java.lang.Object)=[Ljava.lang.Class;@a46ab2, public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object)=[Ljava.lang.Class;@1c389e6, public java.lang.String java.util.AbstractMap.toString()=[Ljava.lang.Class;@a23548, public boolean java.util.HashMap.containsKey(java.lang.Object)=[Ljava.lang.Class;@1be4a9f, public java.util.Set java.util.LinkedHashMap.keySet()=[Ljava.lang.Class;@44c60, public java.lang.Object java.util.HashMap.computeIfAbsent(java.lang.Object,java.util.function.Function)=[Ljava.lang.Class;@10f7dff, public java.lang.Object java.util.HashMap.clone()=[Ljava.lang.Class;@d214e3, public java.lang.Object java.util.LinkedHashMap.getOrDefault(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@1a74254, public java.util.Set java.util.LinkedHashMap.entrySet()=[Ljava.lang.Class;@1c4740c, public void java.util.LinkedHashMap.forEach(java.util.function.BiConsumer)=[Ljava.lang.Class;@1fe0c8e, public java.lang.Object java.util.HashMap.putIfAbsent(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@16f73de, public java.util.Collection java.util.LinkedHashMap.values()=[Ljava.lang.Class;@b3e45, public void java.util.LinkedHashMap.clear()=[Ljava.lang.Class;@a34e5c, public java.lang.Object java.util.HashMap.computeIfPresent(java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1fcb13a, public java.lang.Object java.util.HashMap.compute(java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1a7c258, public final native java.lang.Class java.lang.Object.getClass()=[Ljava.lang.Class;@7397f, public void java.util.HashMap.putAll(java.util.Map)=[Ljava.lang.Class;@59cd, public void java.util.LinkedHashMap.replaceAll(java.util.function.BiFunction)=[Ljava.lang.Class;@994816, public java.lang.Object java.util.HashMap.merge(java.lang.Object,java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1b1e75f, public int java.util.HashMap.size()=[Ljava.lang.Class;@bee157, public boolean java.util.LinkedHashMap.containsValue(java.lang.Object)=[Ljava.lang.Class;@5e0d7c}, replaceAll=public void java.util.LinkedHashMap.replaceAll(java.util.function.BiFunction), remove=freemarker.ext.beans.OverloadedMethods@8d3a99, containsValue=public boolean java.util.LinkedHashMap.containsValue(java.lang.Object), put=public java.lang.Object java.util.HashMap.put(java.lang.Object,java.lang.Object), empty=java.beans.PropertyDescriptor[name=empty; propertyType=boolean; readMethod=public boolean java.util.HashMap.isEmpty()], compute=public java.lang.Object java.util.HashMap.compute(java.lang.Object,java.util.function.BiFunction), hashCode=public int java.util.AbstractMap.hashCode(), putAll=public void java.util.HashMap.putAll(java.util.Map), get=public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object), merge=public java.lang.Object java.util.HashMap.merge(java.lang.Object,java.lang.Object,java.util.function.BiFunction), class=java.beans.PropertyDescriptor[name=class; propertyType=class java.lang.Class; readMethod=public final native java.lang.Class java.lang.Object.getClass()], keySet=public java.util.Set java.util.LinkedHashMap.keySet(), java.lang.Object@1c0f21d=freemarker.ext.beans.OverloadedMethods@d4b988, entrySet=public java.util.Set java.util.LinkedHashMap.entrySet(), java.lang.Object@15be27d=public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object), forEach=public void java.util.LinkedHashMap.forEach(java.util.function.BiConsumer), containsKey=public boolean java.util.HashMap.containsKey(java.lang.Object), isEmpty=public boolean java.util.HashMap.isEmpty(), clear=public void java.util.LinkedHashMap.clear(), computeIfPresent=public java.lang.Object java.util.HashMap.computeIfPresent(java.lang.Object,java.util.function.BiFunction), size=public int java.util.HashMap.size(), equals=public boolean java.util.AbstractMap.equals(java.lang.Object), clone=public java.lang.Object java.util.HashMap.clone(), toString=public java.lang.String java.util.AbstractMap.toString(), putIfAbsent=public java.lang.Object java.util.HashMap.putIfAbsent(java.lang.Object,java.lang.Object)}
[DEBUG] 2017-05-24: 21:05:33 freemarker.log._Log4jLoggerFactory$Log4jLogger.debug(_Log4jLoggerFactory.java:45) :  TemplateLoader.findTemplateSource("template/~~~xhtml/controlfooter.ftl"): Found
[DEBUG] 2017-05-24: 21:05:33 freemarker.log._Log4jLoggerFactory$Log4jLogger.debug(_Log4jLoggerFactory.java:45) :  "template/~~~xhtml/controlfooter.ftl"("zh_CN", UTF-8, parsed): using cached since jar:file:/D:/maven/repository/org/apache/struts/struts2-core/2.5.10/struts2-core-2.5.10.jar!/template/xhtml/controlfooter.ftl hasn't changed.
[DEBUG] 2017-05-24: 21:05:33 freemarker.log._Log4jLoggerFactory$Log4jLogger.debug(_Log4jLoggerFactory.java:45) :  Key "after" was not found on instance of java.util.LinkedHashMap. Introspection information for the class is: {getClass=public final native java.lang.Class java.lang.Object.getClass(), getOrDefault=public java.lang.Object java.util.LinkedHashMap.getOrDefault(java.lang.Object,java.lang.Object), computeIfAbsent=public java.lang.Object java.util.HashMap.computeIfAbsent(java.lang.Object,java.util.function.Function), values=public java.util.Collection java.util.LinkedHashMap.values(), replace=freemarker.ext.beans.OverloadedMethods@11d0265, java.lang.Object@3e55b2={public boolean java.util.HashMap.isEmpty()=[Ljava.lang.Class;@c5aa3a, public int java.util.AbstractMap.hashCode()=[Ljava.lang.Class;@74a947, public java.lang.Object java.util.HashMap.put(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@1615a91, public boolean java.util.AbstractMap.equals(java.lang.Object)=[Ljava.lang.Class;@a46ab2, public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object)=[Ljava.lang.Class;@1c389e6, public java.lang.String java.util.AbstractMap.toString()=[Ljava.lang.Class;@a23548, public boolean java.util.HashMap.containsKey(java.lang.Object)=[Ljava.lang.Class;@1be4a9f, public java.util.Set java.util.LinkedHashMap.keySet()=[Ljava.lang.Class;@44c60, public java.lang.Object java.util.HashMap.computeIfAbsent(java.lang.Object,java.util.function.Function)=[Ljava.lang.Class;@10f7dff, public java.lang.Object java.util.HashMap.clone()=[Ljava.lang.Class;@d214e3, public java.lang.Object java.util.LinkedHashMap.getOrDefault(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@1a74254, public java.util.Set java.util.LinkedHashMap.entrySet()=[Ljava.lang.Class;@1c4740c, public void java.util.LinkedHashMap.forEach(java.util.function.BiConsumer)=[Ljava.lang.Class;@1fe0c8e, public java.lang.Object java.util.HashMap.putIfAbsent(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@16f73de, public java.util.Collection java.util.LinkedHashMap.values()=[Ljava.lang.Class;@b3e45, public void java.util.LinkedHashMap.clear()=[Ljava.lang.Class;@a34e5c, public java.lang.Object java.util.HashMap.computeIfPresent(java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1fcb13a, public java.lang.Object java.util.HashMap.compute(java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1a7c258, public final native java.lang.Class java.lang.Object.getClass()=[Ljava.lang.Class;@7397f, public void java.util.HashMap.putAll(java.util.Map)=[Ljava.lang.Class;@59cd, public void java.util.LinkedHashMap.replaceAll(java.util.function.BiFunction)=[Ljava.lang.Class;@994816, public java.lang.Object java.util.HashMap.merge(java.lang.Object,java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1b1e75f, public int java.util.HashMap.size()=[Ljava.lang.Class;@bee157, public boolean java.util.LinkedHashMap.containsValue(java.lang.Object)=[Ljava.lang.Class;@5e0d7c}, replaceAll=public void java.util.LinkedHashMap.replaceAll(java.util.function.BiFunction), remove=freemarker.ext.beans.OverloadedMethods@8d3a99, containsValue=public boolean java.util.LinkedHashMap.containsValue(java.lang.Object), put=public java.lang.Object java.util.HashMap.put(java.lang.Object,java.lang.Object), empty=java.beans.PropertyDescriptor[name=empty; propertyType=boolean; readMethod=public boolean java.util.HashMap.isEmpty()], compute=public java.lang.Object java.util.HashMap.compute(java.lang.Object,java.util.function.BiFunction), hashCode=public int java.util.AbstractMap.hashCode(), putAll=public void java.util.HashMap.putAll(java.util.Map), get=public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object), merge=public java.lang.Object java.util.HashMap.merge(java.lang.Object,java.lang.Object,java.util.function.BiFunction), class=java.beans.PropertyDescriptor[name=class; propertyType=class java.lang.Class; readMethod=public final native java.lang.Class java.lang.Object.getClass()], keySet=public java.util.Set java.util.LinkedHashMap.keySet(), java.lang.Object@1c0f21d=freemarker.ext.beans.OverloadedMethods@d4b988, entrySet=public java.util.Set java.util.LinkedHashMap.entrySet(), java.lang.Object@15be27d=public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object), forEach=public void java.util.LinkedHashMap.forEach(java.util.function.BiConsumer), containsKey=public boolean java.util.HashMap.containsKey(java.lang.Object), isEmpty=public boolean java.util.HashMap.isEmpty(), clear=public void java.util.LinkedHashMap.clear(), computeIfPresent=public java.lang.Object java.util.HashMap.computeIfPresent(java.lang.Object,java.util.function.BiFunction), size=public int java.util.HashMap.size(), equals=public boolean java.util.AbstractMap.equals(java.lang.Object), clone=public java.lang.Object java.util.HashMap.clone(), toString=public java.lang.String java.util.AbstractMap.toString(), putIfAbsent=public java.lang.Object java.util.HashMap.putIfAbsent(java.lang.Object,java.lang.Object)}
[DEBUG] 2017-05-24: 21:05:33 freemarker.log._Log4jLoggerFactory$Log4jLogger.debug(_Log4jLoggerFactory.java:45) :  Key "errorposition" was not found on instance of java.util.LinkedHashMap. Introspection information for the class is: {getClass=public final native java.lang.Class java.lang.Object.getClass(), getOrDefault=public java.lang.Object java.util.LinkedHashMap.getOrDefault(java.lang.Object,java.lang.Object), computeIfAbsent=public java.lang.Object java.util.HashMap.computeIfAbsent(java.lang.Object,java.util.function.Function), values=public java.util.Collection java.util.LinkedHashMap.values(), replace=freemarker.ext.beans.OverloadedMethods@11d0265, java.lang.Object@3e55b2={public boolean java.util.HashMap.isEmpty()=[Ljava.lang.Class;@c5aa3a, public int java.util.AbstractMap.hashCode()=[Ljava.lang.Class;@74a947, public java.lang.Object java.util.HashMap.put(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@1615a91, public boolean java.util.AbstractMap.equals(java.lang.Object)=[Ljava.lang.Class;@a46ab2, public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object)=[Ljava.lang.Class;@1c389e6, public java.lang.String java.util.AbstractMap.toString()=[Ljava.lang.Class;@a23548, public boolean java.util.HashMap.containsKey(java.lang.Object)=[Ljava.lang.Class;@1be4a9f, public java.util.Set java.util.LinkedHashMap.keySet()=[Ljava.lang.Class;@44c60, public java.lang.Object java.util.HashMap.computeIfAbsent(java.lang.Object,java.util.function.Function)=[Ljava.lang.Class;@10f7dff, public java.lang.Object java.util.HashMap.clone()=[Ljava.lang.Class;@d214e3, public java.lang.Object java.util.LinkedHashMap.getOrDefault(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@1a74254, public java.util.Set java.util.LinkedHashMap.entrySet()=[Ljava.lang.Class;@1c4740c, public void java.util.LinkedHashMap.forEach(java.util.function.BiConsumer)=[Ljava.lang.Class;@1fe0c8e, public java.lang.Object java.util.HashMap.putIfAbsent(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@16f73de, public java.util.Collection java.util.LinkedHashMap.values()=[Ljava.lang.Class;@b3e45, public void java.util.LinkedHashMap.clear()=[Ljava.lang.Class;@a34e5c, public java.lang.Object java.util.HashMap.computeIfPresent(java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1fcb13a, public java.lang.Object java.util.HashMap.compute(java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1a7c258, public final native java.lang.Class java.lang.Object.getClass()=[Ljava.lang.Class;@7397f, public void java.util.HashMap.putAll(java.util.Map)=[Ljava.lang.Class;@59cd, public void java.util.LinkedHashMap.replaceAll(java.util.function.BiFunction)=[Ljava.lang.Class;@994816, public java.lang.Object java.util.HashMap.merge(java.lang.Object,java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1b1e75f, public int java.util.HashMap.size()=[Ljava.lang.Class;@bee157, public boolean java.util.LinkedHashMap.containsValue(java.lang.Object)=[Ljava.lang.Class;@5e0d7c}, replaceAll=public void java.util.LinkedHashMap.replaceAll(java.util.function.BiFunction), remove=freemarker.ext.beans.OverloadedMethods@8d3a99, containsValue=public boolean java.util.LinkedHashMap.containsValue(java.lang.Object), put=public java.lang.Object java.util.HashMap.put(java.lang.Object,java.lang.Object), empty=java.beans.PropertyDescriptor[name=empty; propertyType=boolean; readMethod=public boolean java.util.HashMap.isEmpty()], compute=public java.lang.Object java.util.HashMap.compute(java.lang.Object,java.util.function.BiFunction), hashCode=public int java.util.AbstractMap.hashCode(), putAll=public void java.util.HashMap.putAll(java.util.Map), get=public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object), merge=public java.lang.Object java.util.HashMap.merge(java.lang.Object,java.lang.Object,java.util.function.BiFunction), class=java.beans.PropertyDescriptor[name=class; propertyType=class java.lang.Class; readMethod=public final native java.lang.Class java.lang.Object.getClass()], keySet=public java.util.Set java.util.LinkedHashMap.keySet(), java.lang.Object@1c0f21d=freemarker.ext.beans.OverloadedMethods@d4b988, entrySet=public java.util.Set java.util.LinkedHashMap.entrySet(), java.lang.Object@15be27d=public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object), forEach=public void java.util.LinkedHashMap.forEach(java.util.function.BiConsumer), containsKey=public boolean java.util.HashMap.containsKey(java.lang.Object), isEmpty=public boolean java.util.HashMap.isEmpty(), clear=public void java.util.LinkedHashMap.clear(), computeIfPresent=public java.lang.Object java.util.HashMap.computeIfPresent(java.lang.Object,java.util.function.BiFunction), size=public int java.util.HashMap.size(), equals=public boolean java.util.AbstractMap.equals(java.lang.Object), clone=public java.lang.Object java.util.HashMap.clone(), toString=public java.lang.String java.util.AbstractMap.toString(), putIfAbsent=public java.lang.Object java.util.HashMap.putIfAbsent(java.lang.Object,java.lang.Object)}
[DEBUG] 2017-05-24: 21:05:33 freemarker.log._Log4jLoggerFactory$Log4jLogger.debug(_Log4jLoggerFactory.java:45) :  Couldn't find template in cache for "template/xhtml/file.ftl"("zh_CN", UTF-8, parsed); will try to load it.
[DEBUG] 2017-05-24: 21:05:33 freemarker.log._Log4jLoggerFactory$Log4jLogger.debug(_Log4jLoggerFactory.java:45) :  TemplateLoader.findTemplateSource("template/xhtml/file.ftl"): Found
[DEBUG] 2017-05-24: 21:05:33 freemarker.log._Log4jLoggerFactory$Log4jLogger.debug(_Log4jLoggerFactory.java:45) :  Loading template for "template/xhtml/file.ftl"("zh_CN", UTF-8, parsed) from "jar:file:/D:/maven/repository/org/apache/struts/struts2-core/2.5.10/struts2-core-2.5.10.jar!/template/xhtml/file.ftl"
[DEBUG] 2017-05-24: 21:05:33 freemarker.log._Log4jLoggerFactory$Log4jLogger.debug(_Log4jLoggerFactory.java:45) :  TemplateLoader.findTemplateSource("template/~~~xhtml/controlheader.ftl"): Found
[DEBUG] 2017-05-24: 21:05:33 freemarker.log._Log4jLoggerFactory$Log4jLogger.debug(_Log4jLoggerFactory.java:45) :  "template/~~~xhtml/controlheader.ftl"("zh_CN", UTF-8, parsed): using cached since jar:file:/D:/maven/repository/org/apache/struts/struts2-core/2.5.10/struts2-core-2.5.10.jar!/template/xhtml/controlheader.ftl hasn't changed.
[DEBUG] 2017-05-24: 21:05:33 freemarker.log._Log4jLoggerFactory$Log4jLogger.debug(_Log4jLoggerFactory.java:45) :  TemplateLoader.findTemplateSource("template/~~~xhtml/controlheader-core.ftl"): Found
[DEBUG] 2017-05-24: 21:05:33 freemarker.log._Log4jLoggerFactory$Log4jLogger.debug(_Log4jLoggerFactory.java:45) :  "template/~~~xhtml/controlheader-core.ftl"("zh_CN", UTF-8, parsed): using cached since jar:file:/D:/maven/repository/org/apache/struts/struts2-core/2.5.10/struts2-core-2.5.10.jar!/template/xhtml/controlheader-core.ftl hasn't changed.
[DEBUG] 2017-05-24: 21:05:33 freemarker.log._Log4jLoggerFactory$Log4jLogger.debug(_Log4jLoggerFactory.java:45) :  Key "errorposition" was not found on instance of java.util.LinkedHashMap. Introspection information for the class is: {getClass=public final native java.lang.Class java.lang.Object.getClass(), getOrDefault=public java.lang.Object java.util.LinkedHashMap.getOrDefault(java.lang.Object,java.lang.Object), computeIfAbsent=public java.lang.Object java.util.HashMap.computeIfAbsent(java.lang.Object,java.util.function.Function), values=public java.util.Collection java.util.LinkedHashMap.values(), replace=freemarker.ext.beans.OverloadedMethods@11d0265, java.lang.Object@3e55b2={public boolean java.util.HashMap.isEmpty()=[Ljava.lang.Class;@c5aa3a, public int java.util.AbstractMap.hashCode()=[Ljava.lang.Class;@74a947, public java.lang.Object java.util.HashMap.put(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@1615a91, public boolean java.util.AbstractMap.equals(java.lang.Object)=[Ljava.lang.Class;@a46ab2, public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object)=[Ljava.lang.Class;@1c389e6, public java.lang.String java.util.AbstractMap.toString()=[Ljava.lang.Class;@a23548, public boolean java.util.HashMap.containsKey(java.lang.Object)=[Ljava.lang.Class;@1be4a9f, public java.util.Set java.util.LinkedHashMap.keySet()=[Ljava.lang.Class;@44c60, public java.lang.Object java.util.HashMap.computeIfAbsent(java.lang.Object,java.util.function.Function)=[Ljava.lang.Class;@10f7dff, public java.lang.Object java.util.HashMap.clone()=[Ljava.lang.Class;@d214e3, public java.lang.Object java.util.LinkedHashMap.getOrDefault(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@1a74254, public java.util.Set java.util.LinkedHashMap.entrySet()=[Ljava.lang.Class;@1c4740c, public void java.util.LinkedHashMap.forEach(java.util.function.BiConsumer)=[Ljava.lang.Class;@1fe0c8e, public java.lang.Object java.util.HashMap.putIfAbsent(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@16f73de, public java.util.Collection java.util.LinkedHashMap.values()=[Ljava.lang.Class;@b3e45, public void java.util.LinkedHashMap.clear()=[Ljava.lang.Class;@a34e5c, public java.lang.Object java.util.HashMap.computeIfPresent(java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1fcb13a, public java.lang.Object java.util.HashMap.compute(java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1a7c258, public final native java.lang.Class java.lang.Object.getClass()=[Ljava.lang.Class;@7397f, public void java.util.HashMap.putAll(java.util.Map)=[Ljava.lang.Class;@59cd, public void java.util.LinkedHashMap.replaceAll(java.util.function.BiFunction)=[Ljava.lang.Class;@994816, public java.lang.Object java.util.HashMap.merge(java.lang.Object,java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1b1e75f, public int java.util.HashMap.size()=[Ljava.lang.Class;@bee157, public boolean java.util.LinkedHashMap.containsValue(java.lang.Object)=[Ljava.lang.Class;@5e0d7c}, replaceAll=public void java.util.LinkedHashMap.replaceAll(java.util.function.BiFunction), remove=freemarker.ext.beans.OverloadedMethods@8d3a99, containsValue=public boolean java.util.LinkedHashMap.containsValue(java.lang.Object), put=public java.lang.Object java.util.HashMap.put(java.lang.Object,java.lang.Object), empty=java.beans.PropertyDescriptor[name=empty; propertyType=boolean; readMethod=public boolean java.util.HashMap.isEmpty()], compute=public java.lang.Object java.util.HashMap.compute(java.lang.Object,java.util.function.BiFunction), hashCode=public int java.util.AbstractMap.hashCode(), putAll=public void java.util.HashMap.putAll(java.util.Map), get=public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object), merge=public java.lang.Object java.util.HashMap.merge(java.lang.Object,java.lang.Object,java.util.function.BiFunction), class=java.beans.PropertyDescriptor[name=class; propertyType=class java.lang.Class; readMethod=public final native java.lang.Class java.lang.Object.getClass()], keySet=public java.util.Set java.util.LinkedHashMap.keySet(), java.lang.Object@1c0f21d=freemarker.ext.beans.OverloadedMethods@d4b988, entrySet=public java.util.Set java.util.LinkedHashMap.entrySet(), java.lang.Object@15be27d=public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object), forEach=public void java.util.LinkedHashMap.forEach(java.util.function.BiConsumer), containsKey=public boolean java.util.HashMap.containsKey(java.lang.Object), isEmpty=public boolean java.util.HashMap.isEmpty(), clear=public void java.util.LinkedHashMap.clear(), computeIfPresent=public java.lang.Object java.util.HashMap.computeIfPresent(java.lang.Object,java.util.function.BiFunction), size=public int java.util.HashMap.size(), equals=public boolean java.util.AbstractMap.equals(java.lang.Object), clone=public java.lang.Object java.util.HashMap.clone(), toString=public java.lang.String java.util.AbstractMap.toString(), putIfAbsent=public java.lang.Object java.util.HashMap.putIfAbsent(java.lang.Object,java.lang.Object)}
[DEBUG] 2017-05-24: 21:05:33 freemarker.log._Log4jLoggerFactory$Log4jLogger.debug(_Log4jLoggerFactory.java:45) :  Key "labelposition" was not found on instance of java.util.LinkedHashMap. Introspection information for the class is: {getClass=public final native java.lang.Class java.lang.Object.getClass(), getOrDefault=public java.lang.Object java.util.LinkedHashMap.getOrDefault(java.lang.Object,java.lang.Object), computeIfAbsent=public java.lang.Object java.util.HashMap.computeIfAbsent(java.lang.Object,java.util.function.Function), values=public java.util.Collection java.util.LinkedHashMap.values(), replace=freemarker.ext.beans.OverloadedMethods@11d0265, java.lang.Object@3e55b2={public boolean java.util.HashMap.isEmpty()=[Ljava.lang.Class;@c5aa3a, public int java.util.AbstractMap.hashCode()=[Ljava.lang.Class;@74a947, public java.lang.Object java.util.HashMap.put(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@1615a91, public boolean java.util.AbstractMap.equals(java.lang.Object)=[Ljava.lang.Class;@a46ab2, public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object)=[Ljava.lang.Class;@1c389e6, public java.lang.String java.util.AbstractMap.toString()=[Ljava.lang.Class;@a23548, public boolean java.util.HashMap.containsKey(java.lang.Object)=[Ljava.lang.Class;@1be4a9f, public java.util.Set java.util.LinkedHashMap.keySet()=[Ljava.lang.Class;@44c60, public java.lang.Object java.util.HashMap.computeIfAbsent(java.lang.Object,java.util.function.Function)=[Ljava.lang.Class;@10f7dff, public java.lang.Object java.util.HashMap.clone()=[Ljava.lang.Class;@d214e3, public java.lang.Object java.util.LinkedHashMap.getOrDefault(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@1a74254, public java.util.Set java.util.LinkedHashMap.entrySet()=[Ljava.lang.Class;@1c4740c, public void java.util.LinkedHashMap.forEach(java.util.function.BiConsumer)=[Ljava.lang.Class;@1fe0c8e, public java.lang.Object java.util.HashMap.putIfAbsent(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@16f73de, public java.util.Collection java.util.LinkedHashMap.values()=[Ljava.lang.Class;@b3e45, public void java.util.LinkedHashMap.clear()=[Ljava.lang.Class;@a34e5c, public java.lang.Object java.util.HashMap.computeIfPresent(java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1fcb13a, public java.lang.Object java.util.HashMap.compute(java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1a7c258, public final native java.lang.Class java.lang.Object.getClass()=[Ljava.lang.Class;@7397f, public void java.util.HashMap.putAll(java.util.Map)=[Ljava.lang.Class;@59cd, public void java.util.LinkedHashMap.replaceAll(java.util.function.BiFunction)=[Ljava.lang.Class;@994816, public java.lang.Object java.util.HashMap.merge(java.lang.Object,java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1b1e75f, public int java.util.HashMap.size()=[Ljava.lang.Class;@bee157, public boolean java.util.LinkedHashMap.containsValue(java.lang.Object)=[Ljava.lang.Class;@5e0d7c}, replaceAll=public void java.util.LinkedHashMap.replaceAll(java.util.function.BiFunction), remove=freemarker.ext.beans.OverloadedMethods@8d3a99, containsValue=public boolean java.util.LinkedHashMap.containsValue(java.lang.Object), put=public java.lang.Object java.util.HashMap.put(java.lang.Object,java.lang.Object), empty=java.beans.PropertyDescriptor[name=empty; propertyType=boolean; readMethod=public boolean java.util.HashMap.isEmpty()], compute=public java.lang.Object java.util.HashMap.compute(java.lang.Object,java.util.function.BiFunction), hashCode=public int java.util.AbstractMap.hashCode(), putAll=public void java.util.HashMap.putAll(java.util.Map), get=public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object), merge=public java.lang.Object java.util.HashMap.merge(java.lang.Object,java.lang.Object,java.util.function.BiFunction), class=java.beans.PropertyDescriptor[name=class; propertyType=class java.lang.Class; readMethod=public final native java.lang.Class java.lang.Object.getClass()], keySet=public java.util.Set java.util.LinkedHashMap.keySet(), java.lang.Object@1c0f21d=freemarker.ext.beans.OverloadedMethods@d4b988, entrySet=public java.util.Set java.util.LinkedHashMap.entrySet(), java.lang.Object@15be27d=public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object), forEach=public void java.util.LinkedHashMap.forEach(java.util.function.BiConsumer), containsKey=public boolean java.util.HashMap.containsKey(java.lang.Object), isEmpty=public boolean java.util.HashMap.isEmpty(), clear=public void java.util.LinkedHashMap.clear(), computeIfPresent=public java.lang.Object java.util.HashMap.computeIfPresent(java.lang.Object,java.util.function.BiFunction), size=public int java.util.HashMap.size(), equals=public boolean java.util.AbstractMap.equals(java.lang.Object), clone=public java.lang.Object java.util.HashMap.clone(), toString=public java.lang.String java.util.AbstractMap.toString(), putIfAbsent=public java.lang.Object java.util.HashMap.putIfAbsent(java.lang.Object,java.lang.Object)}
[DEBUG] 2017-05-24: 21:05:33 freemarker.log._Log4jLoggerFactory$Log4jLogger.debug(_Log4jLoggerFactory.java:45) :  Key "labelposition" was not found on instance of java.util.LinkedHashMap. Introspection information for the class is: {getClass=public final native java.lang.Class java.lang.Object.getClass(), getOrDefault=public java.lang.Object java.util.LinkedHashMap.getOrDefault(java.lang.Object,java.lang.Object), computeIfAbsent=public java.lang.Object java.util.HashMap.computeIfAbsent(java.lang.Object,java.util.function.Function), values=public java.util.Collection java.util.LinkedHashMap.values(), replace=freemarker.ext.beans.OverloadedMethods@11d0265, java.lang.Object@3e55b2={public boolean java.util.HashMap.isEmpty()=[Ljava.lang.Class;@c5aa3a, public int java.util.AbstractMap.hashCode()=[Ljava.lang.Class;@74a947, public java.lang.Object java.util.HashMap.put(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@1615a91, public boolean java.util.AbstractMap.equals(java.lang.Object)=[Ljava.lang.Class;@a46ab2, public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object)=[Ljava.lang.Class;@1c389e6, public java.lang.String java.util.AbstractMap.toString()=[Ljava.lang.Class;@a23548, public boolean java.util.HashMap.containsKey(java.lang.Object)=[Ljava.lang.Class;@1be4a9f, public java.util.Set java.util.LinkedHashMap.keySet()=[Ljava.lang.Class;@44c60, public java.lang.Object java.util.HashMap.computeIfAbsent(java.lang.Object,java.util.function.Function)=[Ljava.lang.Class;@10f7dff, public java.lang.Object java.util.HashMap.clone()=[Ljava.lang.Class;@d214e3, public java.lang.Object java.util.LinkedHashMap.getOrDefault(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@1a74254, public java.util.Set java.util.LinkedHashMap.entrySet()=[Ljava.lang.Class;@1c4740c, public void java.util.LinkedHashMap.forEach(java.util.function.BiConsumer)=[Ljava.lang.Class;@1fe0c8e, public java.lang.Object java.util.HashMap.putIfAbsent(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@16f73de, public java.util.Collection java.util.LinkedHashMap.values()=[Ljava.lang.Class;@b3e45, public void java.util.LinkedHashMap.clear()=[Ljava.lang.Class;@a34e5c, public java.lang.Object java.util.HashMap.computeIfPresent(java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1fcb13a, public java.lang.Object java.util.HashMap.compute(java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1a7c258, public final native java.lang.Class java.lang.Object.getClass()=[Ljava.lang.Class;@7397f, public void java.util.HashMap.putAll(java.util.Map)=[Ljava.lang.Class;@59cd, public void java.util.LinkedHashMap.replaceAll(java.util.function.BiFunction)=[Ljava.lang.Class;@994816, public java.lang.Object java.util.HashMap.merge(java.lang.Object,java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1b1e75f, public int java.util.HashMap.size()=[Ljava.lang.Class;@bee157, public boolean java.util.LinkedHashMap.containsValue(java.lang.Object)=[Ljava.lang.Class;@5e0d7c}, replaceAll=public void java.util.LinkedHashMap.replaceAll(java.util.function.BiFunction), remove=freemarker.ext.beans.OverloadedMethods@8d3a99, containsValue=public boolean java.util.LinkedHashMap.containsValue(java.lang.Object), put=public java.lang.Object java.util.HashMap.put(java.lang.Object,java.lang.Object), empty=java.beans.PropertyDescriptor[name=empty; propertyType=boolean; readMethod=public boolean java.util.HashMap.isEmpty()], compute=public java.lang.Object java.util.HashMap.compute(java.lang.Object,java.util.function.BiFunction), hashCode=public int java.util.AbstractMap.hashCode(), putAll=public void java.util.HashMap.putAll(java.util.Map), get=public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object), merge=public java.lang.Object java.util.HashMap.merge(java.lang.Object,java.lang.Object,java.util.function.BiFunction), class=java.beans.PropertyDescriptor[name=class; propertyType=class java.lang.Class; readMethod=public final native java.lang.Class java.lang.Object.getClass()], keySet=public java.util.Set java.util.LinkedHashMap.keySet(), java.lang.Object@1c0f21d=freemarker.ext.beans.OverloadedMethods@d4b988, entrySet=public java.util.Set java.util.LinkedHashMap.entrySet(), java.lang.Object@15be27d=public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object), forEach=public void java.util.LinkedHashMap.forEach(java.util.function.BiConsumer), containsKey=public boolean java.util.HashMap.containsKey(java.lang.Object), isEmpty=public boolean java.util.HashMap.isEmpty(), clear=public void java.util.LinkedHashMap.clear(), computeIfPresent=public java.lang.Object java.util.HashMap.computeIfPresent(java.lang.Object,java.util.function.BiFunction), size=public int java.util.HashMap.size(), equals=public boolean java.util.AbstractMap.equals(java.lang.Object), clone=public java.lang.Object java.util.HashMap.clone(), toString=public java.lang.String java.util.AbstractMap.toString(), putIfAbsent=public java.lang.Object java.util.HashMap.putIfAbsent(java.lang.Object,java.lang.Object)}
[DEBUG] 2017-05-24: 21:05:33 freemarker.log._Log4jLoggerFactory$Log4jLogger.debug(_Log4jLoggerFactory.java:45) :  Key "labelposition" was not found on instance of java.util.LinkedHashMap. Introspection information for the class is: {getClass=public final native java.lang.Class java.lang.Object.getClass(), getOrDefault=public java.lang.Object java.util.LinkedHashMap.getOrDefault(java.lang.Object,java.lang.Object), computeIfAbsent=public java.lang.Object java.util.HashMap.computeIfAbsent(java.lang.Object,java.util.function.Function), values=public java.util.Collection java.util.LinkedHashMap.values(), replace=freemarker.ext.beans.OverloadedMethods@11d0265, java.lang.Object@3e55b2={public boolean java.util.HashMap.isEmpty()=[Ljava.lang.Class;@c5aa3a, public int java.util.AbstractMap.hashCode()=[Ljava.lang.Class;@74a947, public java.lang.Object java.util.HashMap.put(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@1615a91, public boolean java.util.AbstractMap.equals(java.lang.Object)=[Ljava.lang.Class;@a46ab2, public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object)=[Ljava.lang.Class;@1c389e6, public java.lang.String java.util.AbstractMap.toString()=[Ljava.lang.Class;@a23548, public boolean java.util.HashMap.containsKey(java.lang.Object)=[Ljava.lang.Class;@1be4a9f, public java.util.Set java.util.LinkedHashMap.keySet()=[Ljava.lang.Class;@44c60, public java.lang.Object java.util.HashMap.computeIfAbsent(java.lang.Object,java.util.function.Function)=[Ljava.lang.Class;@10f7dff, public java.lang.Object java.util.HashMap.clone()=[Ljava.lang.Class;@d214e3, public java.lang.Object java.util.LinkedHashMap.getOrDefault(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@1a74254, public java.util.Set java.util.LinkedHashMap.entrySet()=[Ljava.lang.Class;@1c4740c, public void java.util.LinkedHashMap.forEach(java.util.function.BiConsumer)=[Ljava.lang.Class;@1fe0c8e, public java.lang.Object java.util.HashMap.putIfAbsent(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@16f73de, public java.util.Collection java.util.LinkedHashMap.values()=[Ljava.lang.Class;@b3e45, public void java.util.LinkedHashMap.clear()=[Ljava.lang.Class;@a34e5c, public java.lang.Object java.util.HashMap.computeIfPresent(java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1fcb13a, public java.lang.Object java.util.HashMap.compute(java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1a7c258, public final native java.lang.Class java.lang.Object.getClass()=[Ljava.lang.Class;@7397f, public void java.util.HashMap.putAll(java.util.Map)=[Ljava.lang.Class;@59cd, public void java.util.LinkedHashMap.replaceAll(java.util.function.BiFunction)=[Ljava.lang.Class;@994816, public java.lang.Object java.util.HashMap.merge(java.lang.Object,java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1b1e75f, public int java.util.HashMap.size()=[Ljava.lang.Class;@bee157, public boolean java.util.LinkedHashMap.containsValue(java.lang.Object)=[Ljava.lang.Class;@5e0d7c}, replaceAll=public void java.util.LinkedHashMap.replaceAll(java.util.function.BiFunction), remove=freemarker.ext.beans.OverloadedMethods@8d3a99, containsValue=public boolean java.util.LinkedHashMap.containsValue(java.lang.Object), put=public java.lang.Object java.util.HashMap.put(java.lang.Object,java.lang.Object), empty=java.beans.PropertyDescriptor[name=empty; propertyType=boolean; readMethod=public boolean java.util.HashMap.isEmpty()], compute=public java.lang.Object java.util.HashMap.compute(java.lang.Object,java.util.function.BiFunction), hashCode=public int java.util.AbstractMap.hashCode(), putAll=public void java.util.HashMap.putAll(java.util.Map), get=public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object), merge=public java.lang.Object java.util.HashMap.merge(java.lang.Object,java.lang.Object,java.util.function.BiFunction), class=java.beans.PropertyDescriptor[name=class; propertyType=class java.lang.Class; readMethod=public final native java.lang.Class java.lang.Object.getClass()], keySet=public java.util.Set java.util.LinkedHashMap.keySet(), java.lang.Object@1c0f21d=freemarker.ext.beans.OverloadedMethods@d4b988, entrySet=public java.util.Set java.util.LinkedHashMap.entrySet(), java.lang.Object@15be27d=public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object), forEach=public void java.util.LinkedHashMap.forEach(java.util.function.BiConsumer), containsKey=public boolean java.util.HashMap.containsKey(java.lang.Object), isEmpty=public boolean java.util.HashMap.isEmpty(), clear=public void java.util.LinkedHashMap.clear(), computeIfPresent=public java.lang.Object java.util.HashMap.computeIfPresent(java.lang.Object,java.util.function.BiFunction), size=public int java.util.HashMap.size(), equals=public boolean java.util.AbstractMap.equals(java.lang.Object), clone=public java.lang.Object java.util.HashMap.clone(), toString=public java.lang.String java.util.AbstractMap.toString(), putIfAbsent=public java.lang.Object java.util.HashMap.putIfAbsent(java.lang.Object,java.lang.Object)}
[DEBUG] 2017-05-24: 21:05:33 freemarker.log._Log4jLoggerFactory$Log4jLogger.debug(_Log4jLoggerFactory.java:45) :  Key "label" was not found on instance of java.util.LinkedHashMap. Introspection information for the class is: {getClass=public final native java.lang.Class java.lang.Object.getClass(), getOrDefault=public java.lang.Object java.util.LinkedHashMap.getOrDefault(java.lang.Object,java.lang.Object), computeIfAbsent=public java.lang.Object java.util.HashMap.computeIfAbsent(java.lang.Object,java.util.function.Function), values=public java.util.Collection java.util.LinkedHashMap.values(), replace=freemarker.ext.beans.OverloadedMethods@11d0265, java.lang.Object@3e55b2={public boolean java.util.HashMap.isEmpty()=[Ljava.lang.Class;@c5aa3a, public int java.util.AbstractMap.hashCode()=[Ljava.lang.Class;@74a947, public java.lang.Object java.util.HashMap.put(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@1615a91, public boolean java.util.AbstractMap.equals(java.lang.Object)=[Ljava.lang.Class;@a46ab2, public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object)=[Ljava.lang.Class;@1c389e6, public java.lang.String java.util.AbstractMap.toString()=[Ljava.lang.Class;@a23548, public boolean java.util.HashMap.containsKey(java.lang.Object)=[Ljava.lang.Class;@1be4a9f, public java.util.Set java.util.LinkedHashMap.keySet()=[Ljava.lang.Class;@44c60, public java.lang.Object java.util.HashMap.computeIfAbsent(java.lang.Object,java.util.function.Function)=[Ljava.lang.Class;@10f7dff, public java.lang.Object java.util.HashMap.clone()=[Ljava.lang.Class;@d214e3, public java.lang.Object java.util.LinkedHashMap.getOrDefault(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@1a74254, public java.util.Set java.util.LinkedHashMap.entrySet()=[Ljava.lang.Class;@1c4740c, public void java.util.LinkedHashMap.forEach(java.util.function.BiConsumer)=[Ljava.lang.Class;@1fe0c8e, public java.lang.Object java.util.HashMap.putIfAbsent(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@16f73de, public java.util.Collection java.util.LinkedHashMap.values()=[Ljava.lang.Class;@b3e45, public void java.util.LinkedHashMap.clear()=[Ljava.lang.Class;@a34e5c, public java.lang.Object java.util.HashMap.computeIfPresent(java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1fcb13a, public java.lang.Object java.util.HashMap.compute(java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1a7c258, public final native java.lang.Class java.lang.Object.getClass()=[Ljava.lang.Class;@7397f, public void java.util.HashMap.putAll(java.util.Map)=[Ljava.lang.Class;@59cd, public void java.util.LinkedHashMap.replaceAll(java.util.function.BiFunction)=[Ljava.lang.Class;@994816, public java.lang.Object java.util.HashMap.merge(java.lang.Object,java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1b1e75f, public int java.util.HashMap.size()=[Ljava.lang.Class;@bee157, public boolean java.util.LinkedHashMap.containsValue(java.lang.Object)=[Ljava.lang.Class;@5e0d7c}, replaceAll=public void java.util.LinkedHashMap.replaceAll(java.util.function.BiFunction), remove=freemarker.ext.beans.OverloadedMethods@8d3a99, containsValue=public boolean java.util.LinkedHashMap.containsValue(java.lang.Object), put=public java.lang.Object java.util.HashMap.put(java.lang.Object,java.lang.Object), empty=java.beans.PropertyDescriptor[name=empty; propertyType=boolean; readMethod=public boolean java.util.HashMap.isEmpty()], compute=public java.lang.Object java.util.HashMap.compute(java.lang.Object,java.util.function.BiFunction), hashCode=public int java.util.AbstractMap.hashCode(), putAll=public void java.util.HashMap.putAll(java.util.Map), get=public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object), merge=public java.lang.Object java.util.HashMap.merge(java.lang.Object,java.lang.Object,java.util.function.BiFunction), class=java.beans.PropertyDescriptor[name=class; propertyType=class java.lang.Class; readMethod=public final native java.lang.Class java.lang.Object.getClass()], keySet=public java.util.Set java.util.LinkedHashMap.keySet(), java.lang.Object@1c0f21d=freemarker.ext.beans.OverloadedMethods@d4b988, entrySet=public java.util.Set java.util.LinkedHashMap.entrySet(), java.lang.Object@15be27d=public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object), forEach=public void java.util.LinkedHashMap.forEach(java.util.function.BiConsumer), containsKey=public boolean java.util.HashMap.containsKey(java.lang.Object), isEmpty=public boolean java.util.HashMap.isEmpty(), clear=public void java.util.LinkedHashMap.clear(), computeIfPresent=public java.lang.Object java.util.HashMap.computeIfPresent(java.lang.Object,java.util.function.BiFunction), size=public int java.util.HashMap.size(), equals=public boolean java.util.AbstractMap.equals(java.lang.Object), clone=public java.lang.Object java.util.HashMap.clone(), toString=public java.lang.String java.util.AbstractMap.toString(), putIfAbsent=public java.lang.Object java.util.HashMap.putIfAbsent(java.lang.Object,java.lang.Object)}
[DEBUG] 2017-05-24: 21:05:33 freemarker.log._Log4jLoggerFactory$Log4jLogger.debug(_Log4jLoggerFactory.java:45) :  Key "align" was not found on instance of java.util.LinkedHashMap. Introspection information for the class is: {getClass=public final native java.lang.Class java.lang.Object.getClass(), getOrDefault=public java.lang.Object java.util.LinkedHashMap.getOrDefault(java.lang.Object,java.lang.Object), computeIfAbsent=public java.lang.Object java.util.HashMap.computeIfAbsent(java.lang.Object,java.util.function.Function), values=public java.util.Collection java.util.LinkedHashMap.values(), replace=freemarker.ext.beans.OverloadedMethods@11d0265, java.lang.Object@3e55b2={public boolean java.util.HashMap.isEmpty()=[Ljava.lang.Class;@c5aa3a, public int java.util.AbstractMap.hashCode()=[Ljava.lang.Class;@74a947, public java.lang.Object java.util.HashMap.put(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@1615a91, public boolean java.util.AbstractMap.equals(java.lang.Object)=[Ljava.lang.Class;@a46ab2, public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object)=[Ljava.lang.Class;@1c389e6, public java.lang.String java.util.AbstractMap.toString()=[Ljava.lang.Class;@a23548, public boolean java.util.HashMap.containsKey(java.lang.Object)=[Ljava.lang.Class;@1be4a9f, public java.util.Set java.util.LinkedHashMap.keySet()=[Ljava.lang.Class;@44c60, public java.lang.Object java.util.HashMap.computeIfAbsent(java.lang.Object,java.util.function.Function)=[Ljava.lang.Class;@10f7dff, public java.lang.Object java.util.HashMap.clone()=[Ljava.lang.Class;@d214e3, public java.lang.Object java.util.LinkedHashMap.getOrDefault(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@1a74254, public java.util.Set java.util.LinkedHashMap.entrySet()=[Ljava.lang.Class;@1c4740c, public void java.util.LinkedHashMap.forEach(java.util.function.BiConsumer)=[Ljava.lang.Class;@1fe0c8e, public java.lang.Object java.util.HashMap.putIfAbsent(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@16f73de, public java.util.Collection java.util.LinkedHashMap.values()=[Ljava.lang.Class;@b3e45, public void java.util.LinkedHashMap.clear()=[Ljava.lang.Class;@a34e5c, public java.lang.Object java.util.HashMap.computeIfPresent(java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1fcb13a, public java.lang.Object java.util.HashMap.compute(java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1a7c258, public final native java.lang.Class java.lang.Object.getClass()=[Ljava.lang.Class;@7397f, public void java.util.HashMap.putAll(java.util.Map)=[Ljava.lang.Class;@59cd, public void java.util.LinkedHashMap.replaceAll(java.util.function.BiFunction)=[Ljava.lang.Class;@994816, public java.lang.Object java.util.HashMap.merge(java.lang.Object,java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1b1e75f, public int java.util.HashMap.size()=[Ljava.lang.Class;@bee157, public boolean java.util.LinkedHashMap.containsValue(java.lang.Object)=[Ljava.lang.Class;@5e0d7c}, replaceAll=public void java.util.LinkedHashMap.replaceAll(java.util.function.BiFunction), remove=freemarker.ext.beans.OverloadedMethods@8d3a99, containsValue=public boolean java.util.LinkedHashMap.containsValue(java.lang.Object), put=public java.lang.Object java.util.HashMap.put(java.lang.Object,java.lang.Object), empty=java.beans.PropertyDescriptor[name=empty; propertyType=boolean; readMethod=public boolean java.util.HashMap.isEmpty()], compute=public java.lang.Object java.util.HashMap.compute(java.lang.Object,java.util.function.BiFunction), hashCode=public int java.util.AbstractMap.hashCode(), putAll=public void java.util.HashMap.putAll(java.util.Map), get=public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object), merge=public java.lang.Object java.util.HashMap.merge(java.lang.Object,java.lang.Object,java.util.function.BiFunction), class=java.beans.PropertyDescriptor[name=class; propertyType=class java.lang.Class; readMethod=public final native java.lang.Class java.lang.Object.getClass()], keySet=public java.util.Set java.util.LinkedHashMap.keySet(), java.lang.Object@1c0f21d=freemarker.ext.beans.OverloadedMethods@d4b988, entrySet=public java.util.Set java.util.LinkedHashMap.entrySet(), java.lang.Object@15be27d=public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object), forEach=public void java.util.LinkedHashMap.forEach(java.util.function.BiConsumer), containsKey=public boolean java.util.HashMap.containsKey(java.lang.Object), isEmpty=public boolean java.util.HashMap.isEmpty(), clear=public void java.util.LinkedHashMap.clear(), computeIfPresent=public java.lang.Object java.util.HashMap.computeIfPresent(java.lang.Object,java.util.function.BiFunction), size=public int java.util.HashMap.size(), equals=public boolean java.util.AbstractMap.equals(java.lang.Object), clone=public java.lang.Object java.util.HashMap.clone(), toString=public java.lang.String java.util.AbstractMap.toString(), putIfAbsent=public java.lang.Object java.util.HashMap.putIfAbsent(java.lang.Object,java.lang.Object)}
[DEBUG] 2017-05-24: 21:05:33 freemarker.log._Log4jLoggerFactory$Log4jLogger.debug(_Log4jLoggerFactory.java:45) :  Couldn't find template in cache for "template/simple/file.ftl"("zh_CN", UTF-8, parsed); will try to load it.
[DEBUG] 2017-05-24: 21:05:33 freemarker.log._Log4jLoggerFactory$Log4jLogger.debug(_Log4jLoggerFactory.java:45) :  TemplateLoader.findTemplateSource("template/simple/file.ftl"): Found
[DEBUG] 2017-05-24: 21:05:33 freemarker.log._Log4jLoggerFactory$Log4jLogger.debug(_Log4jLoggerFactory.java:45) :  Loading template for "template/simple/file.ftl"("zh_CN", UTF-8, parsed) from "jar:file:/D:/maven/repository/org/apache/struts/struts2-core/2.5.10/struts2-core-2.5.10.jar!/template/simple/file.ftl"
[DEBUG] 2017-05-24: 21:05:33 freemarker.log._Log4jLoggerFactory$Log4jLogger.debug(_Log4jLoggerFactory.java:45) :  Key "disabled" was not found on instance of java.util.LinkedHashMap. Introspection information for the class is: {getClass=public final native java.lang.Class java.lang.Object.getClass(), getOrDefault=public java.lang.Object java.util.LinkedHashMap.getOrDefault(java.lang.Object,java.lang.Object), computeIfAbsent=public java.lang.Object java.util.HashMap.computeIfAbsent(java.lang.Object,java.util.function.Function), values=public java.util.Collection java.util.LinkedHashMap.values(), replace=freemarker.ext.beans.OverloadedMethods@11d0265, java.lang.Object@3e55b2={public boolean java.util.HashMap.isEmpty()=[Ljava.lang.Class;@c5aa3a, public int java.util.AbstractMap.hashCode()=[Ljava.lang.Class;@74a947, public java.lang.Object java.util.HashMap.put(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@1615a91, public boolean java.util.AbstractMap.equals(java.lang.Object)=[Ljava.lang.Class;@a46ab2, public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object)=[Ljava.lang.Class;@1c389e6, public java.lang.String java.util.AbstractMap.toString()=[Ljava.lang.Class;@a23548, public boolean java.util.HashMap.containsKey(java.lang.Object)=[Ljava.lang.Class;@1be4a9f, public java.util.Set java.util.LinkedHashMap.keySet()=[Ljava.lang.Class;@44c60, public java.lang.Object java.util.HashMap.computeIfAbsent(java.lang.Object,java.util.function.Function)=[Ljava.lang.Class;@10f7dff, public java.lang.Object java.util.HashMap.clone()=[Ljava.lang.Class;@d214e3, public java.lang.Object java.util.LinkedHashMap.getOrDefault(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@1a74254, public java.util.Set java.util.LinkedHashMap.entrySet()=[Ljava.lang.Class;@1c4740c, public void java.util.LinkedHashMap.forEach(java.util.function.BiConsumer)=[Ljava.lang.Class;@1fe0c8e, public java.lang.Object java.util.HashMap.putIfAbsent(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@16f73de, public java.util.Collection java.util.LinkedHashMap.values()=[Ljava.lang.Class;@b3e45, public void java.util.LinkedHashMap.clear()=[Ljava.lang.Class;@a34e5c, public java.lang.Object java.util.HashMap.computeIfPresent(java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1fcb13a, public java.lang.Object java.util.HashMap.compute(java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1a7c258, public final native java.lang.Class java.lang.Object.getClass()=[Ljava.lang.Class;@7397f, public void java.util.HashMap.putAll(java.util.Map)=[Ljava.lang.Class;@59cd, public void java.util.LinkedHashMap.replaceAll(java.util.function.BiFunction)=[Ljava.lang.Class;@994816, public java.lang.Object java.util.HashMap.merge(java.lang.Object,java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1b1e75f, public int java.util.HashMap.size()=[Ljava.lang.Class;@bee157, public boolean java.util.LinkedHashMap.containsValue(java.lang.Object)=[Ljava.lang.Class;@5e0d7c}, replaceAll=public void java.util.LinkedHashMap.replaceAll(java.util.function.BiFunction), remove=freemarker.ext.beans.OverloadedMethods@8d3a99, containsValue=public boolean java.util.LinkedHashMap.containsValue(java.lang.Object), put=public java.lang.Object java.util.HashMap.put(java.lang.Object,java.lang.Object), empty=java.beans.PropertyDescriptor[name=empty; propertyType=boolean; readMethod=public boolean java.util.HashMap.isEmpty()], compute=public java.lang.Object java.util.HashMap.compute(java.lang.Object,java.util.function.BiFunction), hashCode=public int java.util.AbstractMap.hashCode(), putAll=public void java.util.HashMap.putAll(java.util.Map), get=public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object), merge=public java.lang.Object java.util.HashMap.merge(java.lang.Object,java.lang.Object,java.util.function.BiFunction), class=java.beans.PropertyDescriptor[name=class; propertyType=class java.lang.Class; readMethod=public final native java.lang.Class java.lang.Object.getClass()], keySet=public java.util.Set java.util.LinkedHashMap.keySet(), java.lang.Object@1c0f21d=freemarker.ext.beans.OverloadedMethods@d4b988, entrySet=public java.util.Set java.util.LinkedHashMap.entrySet(), java.lang.Object@15be27d=public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object), forEach=public void java.util.LinkedHashMap.forEach(java.util.function.BiConsumer), containsKey=public boolean java.util.HashMap.containsKey(java.lang.Object), isEmpty=public boolean java.util.HashMap.isEmpty(), clear=public void java.util.LinkedHashMap.clear(), computeIfPresent=public java.lang.Object java.util.HashMap.computeIfPresent(java.lang.Object,java.util.function.BiFunction), size=public int java.util.HashMap.size(), equals=public boolean java.util.AbstractMap.equals(java.lang.Object), clone=public java.lang.Object java.util.HashMap.clone(), toString=public java.lang.String java.util.AbstractMap.toString(), putIfAbsent=public java.lang.Object java.util.HashMap.putIfAbsent(java.lang.Object,java.lang.Object)}
[DEBUG] 2017-05-24: 21:05:33 freemarker.log._Log4jLoggerFactory$Log4jLogger.debug(_Log4jLoggerFactory.java:45) :  Key "accept" was not found on instance of java.util.LinkedHashMap. Introspection information for the class is: {getClass=public final native java.lang.Class java.lang.Object.getClass(), getOrDefault=public java.lang.Object java.util.LinkedHashMap.getOrDefault(java.lang.Object,java.lang.Object), computeIfAbsent=public java.lang.Object java.util.HashMap.computeIfAbsent(java.lang.Object,java.util.function.Function), values=public java.util.Collection java.util.LinkedHashMap.values(), replace=freemarker.ext.beans.OverloadedMethods@11d0265, java.lang.Object@3e55b2={public boolean java.util.HashMap.isEmpty()=[Ljava.lang.Class;@c5aa3a, public int java.util.AbstractMap.hashCode()=[Ljava.lang.Class;@74a947, public java.lang.Object java.util.HashMap.put(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@1615a91, public boolean java.util.AbstractMap.equals(java.lang.Object)=[Ljava.lang.Class;@a46ab2, public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object)=[Ljava.lang.Class;@1c389e6, public java.lang.String java.util.AbstractMap.toString()=[Ljava.lang.Class;@a23548, public boolean java.util.HashMap.containsKey(java.lang.Object)=[Ljava.lang.Class;@1be4a9f, public java.util.Set java.util.LinkedHashMap.keySet()=[Ljava.lang.Class;@44c60, public java.lang.Object java.util.HashMap.computeIfAbsent(java.lang.Object,java.util.function.Function)=[Ljava.lang.Class;@10f7dff, public java.lang.Object java.util.HashMap.clone()=[Ljava.lang.Class;@d214e3, public java.lang.Object java.util.LinkedHashMap.getOrDefault(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@1a74254, public java.util.Set java.util.LinkedHashMap.entrySet()=[Ljava.lang.Class;@1c4740c, public void java.util.LinkedHashMap.forEach(java.util.function.BiConsumer)=[Ljava.lang.Class;@1fe0c8e, public java.lang.Object java.util.HashMap.putIfAbsent(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@16f73de, public java.util.Collection java.util.LinkedHashMap.values()=[Ljava.lang.Class;@b3e45, public void java.util.LinkedHashMap.clear()=[Ljava.lang.Class;@a34e5c, public java.lang.Object java.util.HashMap.computeIfPresent(java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1fcb13a, public java.lang.Object java.util.HashMap.compute(java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1a7c258, public final native java.lang.Class java.lang.Object.getClass()=[Ljava.lang.Class;@7397f, public void java.util.HashMap.putAll(java.util.Map)=[Ljava.lang.Class;@59cd, public void java.util.LinkedHashMap.replaceAll(java.util.function.BiFunction)=[Ljava.lang.Class;@994816, public java.lang.Object java.util.HashMap.merge(java.lang.Object,java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1b1e75f, public int java.util.HashMap.size()=[Ljava.lang.Class;@bee157, public boolean java.util.LinkedHashMap.containsValue(java.lang.Object)=[Ljava.lang.Class;@5e0d7c}, replaceAll=public void java.util.LinkedHashMap.replaceAll(java.util.function.BiFunction), remove=freemarker.ext.beans.OverloadedMethods@8d3a99, containsValue=public boolean java.util.LinkedHashMap.containsValue(java.lang.Object), put=public java.lang.Object java.util.HashMap.put(java.lang.Object,java.lang.Object), empty=java.beans.PropertyDescriptor[name=empty; propertyType=boolean; readMethod=public boolean java.util.HashMap.isEmpty()], compute=public java.lang.Object java.util.HashMap.compute(java.lang.Object,java.util.function.BiFunction), hashCode=public int java.util.AbstractMap.hashCode(), putAll=public void java.util.HashMap.putAll(java.util.Map), get=public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object), merge=public java.lang.Object java.util.HashMap.merge(java.lang.Object,java.lang.Object,java.util.function.BiFunction), class=java.beans.PropertyDescriptor[name=class; propertyType=class java.lang.Class; readMethod=public final native java.lang.Class java.lang.Object.getClass()], keySet=public java.util.Set java.util.LinkedHashMap.keySet(), java.lang.Object@1c0f21d=freemarker.ext.beans.OverloadedMethods@d4b988, entrySet=public java.util.Set java.util.LinkedHashMap.entrySet(), java.lang.Object@15be27d=public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object), forEach=public void java.util.LinkedHashMap.forEach(java.util.function.BiConsumer), containsKey=public boolean java.util.HashMap.containsKey(java.lang.Object), isEmpty=public boolean java.util.HashMap.isEmpty(), clear=public void java.util.LinkedHashMap.clear(), computeIfPresent=public java.lang.Object java.util.HashMap.computeIfPresent(java.lang.Object,java.util.function.BiFunction), size=public int java.util.HashMap.size(), equals=public boolean java.util.AbstractMap.equals(java.lang.Object), clone=public java.lang.Object java.util.HashMap.clone(), toString=public java.lang.String java.util.AbstractMap.toString(), putIfAbsent=public java.lang.Object java.util.HashMap.putIfAbsent(java.lang.Object,java.lang.Object)}
[DEBUG] 2017-05-24: 21:05:33 freemarker.log._Log4jLoggerFactory$Log4jLogger.debug(_Log4jLoggerFactory.java:45) :  Key "tabindex" was not found on instance of java.util.LinkedHashMap. Introspection information for the class is: {getClass=public final native java.lang.Class java.lang.Object.getClass(), getOrDefault=public java.lang.Object java.util.LinkedHashMap.getOrDefault(java.lang.Object,java.lang.Object), computeIfAbsent=public java.lang.Object java.util.HashMap.computeIfAbsent(java.lang.Object,java.util.function.Function), values=public java.util.Collection java.util.LinkedHashMap.values(), replace=freemarker.ext.beans.OverloadedMethods@11d0265, java.lang.Object@3e55b2={public boolean java.util.HashMap.isEmpty()=[Ljava.lang.Class;@c5aa3a, public int java.util.AbstractMap.hashCode()=[Ljava.lang.Class;@74a947, public java.lang.Object java.util.HashMap.put(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@1615a91, public boolean java.util.AbstractMap.equals(java.lang.Object)=[Ljava.lang.Class;@a46ab2, public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object)=[Ljava.lang.Class;@1c389e6, public java.lang.String java.util.AbstractMap.toString()=[Ljava.lang.Class;@a23548, public boolean java.util.HashMap.containsKey(java.lang.Object)=[Ljava.lang.Class;@1be4a9f, public java.util.Set java.util.LinkedHashMap.keySet()=[Ljava.lang.Class;@44c60, public java.lang.Object java.util.HashMap.computeIfAbsent(java.lang.Object,java.util.function.Function)=[Ljava.lang.Class;@10f7dff, public java.lang.Object java.util.HashMap.clone()=[Ljava.lang.Class;@d214e3, public java.lang.Object java.util.LinkedHashMap.getOrDefault(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@1a74254, public java.util.Set java.util.LinkedHashMap.entrySet()=[Ljava.lang.Class;@1c4740c, public void java.util.LinkedHashMap.forEach(java.util.function.BiConsumer)=[Ljava.lang.Class;@1fe0c8e, public java.lang.Object java.util.HashMap.putIfAbsent(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@16f73de, public java.util.Collection java.util.LinkedHashMap.values()=[Ljava.lang.Class;@b3e45, public void java.util.LinkedHashMap.clear()=[Ljava.lang.Class;@a34e5c, public java.lang.Object java.util.HashMap.computeIfPresent(java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1fcb13a, public java.lang.Object java.util.HashMap.compute(java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1a7c258, public final native java.lang.Class java.lang.Object.getClass()=[Ljava.lang.Class;@7397f, public void java.util.HashMap.putAll(java.util.Map)=[Ljava.lang.Class;@59cd, public void java.util.LinkedHashMap.replaceAll(java.util.function.BiFunction)=[Ljava.lang.Class;@994816, public java.lang.Object java.util.HashMap.merge(java.lang.Object,java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1b1e75f, public int java.util.HashMap.size()=[Ljava.lang.Class;@bee157, public boolean java.util.LinkedHashMap.containsValue(java.lang.Object)=[Ljava.lang.Class;@5e0d7c}, replaceAll=public void java.util.LinkedHashMap.replaceAll(java.util.function.BiFunction), remove=freemarker.ext.beans.OverloadedMethods@8d3a99, containsValue=public boolean java.util.LinkedHashMap.containsValue(java.lang.Object), put=public java.lang.Object java.util.HashMap.put(java.lang.Object,java.lang.Object), empty=java.beans.PropertyDescriptor[name=empty; propertyType=boolean; readMethod=public boolean java.util.HashMap.isEmpty()], compute=public java.lang.Object java.util.HashMap.compute(java.lang.Object,java.util.function.BiFunction), hashCode=public int java.util.AbstractMap.hashCode(), putAll=public void java.util.HashMap.putAll(java.util.Map), get=public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object), merge=public java.lang.Object java.util.HashMap.merge(java.lang.Object,java.lang.Object,java.util.function.BiFunction), class=java.beans.PropertyDescriptor[name=class; propertyType=class java.lang.Class; readMethod=public final native java.lang.Class java.lang.Object.getClass()], keySet=public java.util.Set java.util.LinkedHashMap.keySet(), java.lang.Object@1c0f21d=freemarker.ext.beans.OverloadedMethods@d4b988, entrySet=public java.util.Set java.util.LinkedHashMap.entrySet(), java.lang.Object@15be27d=public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object), forEach=public void java.util.LinkedHashMap.forEach(java.util.function.BiConsumer), containsKey=public boolean java.util.HashMap.containsKey(java.lang.Object), isEmpty=public boolean java.util.HashMap.isEmpty(), clear=public void java.util.LinkedHashMap.clear(), computeIfPresent=public java.lang.Object java.util.HashMap.computeIfPresent(java.lang.Object,java.util.function.BiFunction), size=public int java.util.HashMap.size(), equals=public boolean java.util.AbstractMap.equals(java.lang.Object), clone=public java.lang.Object java.util.HashMap.clone(), toString=public java.lang.String java.util.AbstractMap.toString(), putIfAbsent=public java.lang.Object java.util.HashMap.putIfAbsent(java.lang.Object,java.lang.Object)}
[DEBUG] 2017-05-24: 21:05:33 freemarker.log._Log4jLoggerFactory$Log4jLogger.debug(_Log4jLoggerFactory.java:45) :  TemplateLoader.findTemplateSource("template/~~~xhtml/css.ftl"): Found
[DEBUG] 2017-05-24: 21:05:33 freemarker.log._Log4jLoggerFactory$Log4jLogger.debug(_Log4jLoggerFactory.java:45) :  "template/~~~xhtml/css.ftl"("zh_CN", UTF-8, parsed): using cached since jar:file:/D:/maven/repository/org/apache/struts/struts2-core/2.5.10/struts2-core-2.5.10.jar!/template/simple/css.ftl hasn't changed.
[DEBUG] 2017-05-24: 21:05:33 freemarker.log._Log4jLoggerFactory$Log4jLogger.debug(_Log4jLoggerFactory.java:45) :  Key "cssClass" was not found on instance of java.util.LinkedHashMap. Introspection information for the class is: {getClass=public final native java.lang.Class java.lang.Object.getClass(), getOrDefault=public java.lang.Object java.util.LinkedHashMap.getOrDefault(java.lang.Object,java.lang.Object), computeIfAbsent=public java.lang.Object java.util.HashMap.computeIfAbsent(java.lang.Object,java.util.function.Function), values=public java.util.Collection java.util.LinkedHashMap.values(), replace=freemarker.ext.beans.OverloadedMethods@11d0265, java.lang.Object@3e55b2={public boolean java.util.HashMap.isEmpty()=[Ljava.lang.Class;@c5aa3a, public int java.util.AbstractMap.hashCode()=[Ljava.lang.Class;@74a947, public java.lang.Object java.util.HashMap.put(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@1615a91, public boolean java.util.AbstractMap.equals(java.lang.Object)=[Ljava.lang.Class;@a46ab2, public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object)=[Ljava.lang.Class;@1c389e6, public java.lang.String java.util.AbstractMap.toString()=[Ljava.lang.Class;@a23548, public boolean java.util.HashMap.containsKey(java.lang.Object)=[Ljava.lang.Class;@1be4a9f, public java.util.Set java.util.LinkedHashMap.keySet()=[Ljava.lang.Class;@44c60, public java.lang.Object java.util.HashMap.computeIfAbsent(java.lang.Object,java.util.function.Function)=[Ljava.lang.Class;@10f7dff, public java.lang.Object java.util.HashMap.clone()=[Ljava.lang.Class;@d214e3, public java.lang.Object java.util.LinkedHashMap.getOrDefault(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@1a74254, public java.util.Set java.util.LinkedHashMap.entrySet()=[Ljava.lang.Class;@1c4740c, public void java.util.LinkedHashMap.forEach(java.util.function.BiConsumer)=[Ljava.lang.Class;@1fe0c8e, public java.lang.Object java.util.HashMap.putIfAbsent(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@16f73de, public java.util.Collection java.util.LinkedHashMap.values()=[Ljava.lang.Class;@b3e45, public void java.util.LinkedHashMap.clear()=[Ljava.lang.Class;@a34e5c, public java.lang.Object java.util.HashMap.computeIfPresent(java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1fcb13a, public java.lang.Object java.util.HashMap.compute(java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1a7c258, public final native java.lang.Class java.lang.Object.getClass()=[Ljava.lang.Class;@7397f, public void java.util.HashMap.putAll(java.util.Map)=[Ljava.lang.Class;@59cd, public void java.util.LinkedHashMap.replaceAll(java.util.function.BiFunction)=[Ljava.lang.Class;@994816, public java.lang.Object java.util.HashMap.merge(java.lang.Object,java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1b1e75f, public int java.util.HashMap.size()=[Ljava.lang.Class;@bee157, public boolean java.util.LinkedHashMap.containsValue(java.lang.Object)=[Ljava.lang.Class;@5e0d7c}, replaceAll=public void java.util.LinkedHashMap.replaceAll(java.util.function.BiFunction), remove=freemarker.ext.beans.OverloadedMethods@8d3a99, containsValue=public boolean java.util.LinkedHashMap.containsValue(java.lang.Object), put=public java.lang.Object java.util.HashMap.put(java.lang.Object,java.lang.Object), empty=java.beans.PropertyDescriptor[name=empty; propertyType=boolean; readMethod=public boolean java.util.HashMap.isEmpty()], compute=public java.lang.Object java.util.HashMap.compute(java.lang.Object,java.util.function.BiFunction), hashCode=public int java.util.AbstractMap.hashCode(), putAll=public void java.util.HashMap.putAll(java.util.Map), get=public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object), merge=public java.lang.Object java.util.HashMap.merge(java.lang.Object,java.lang.Object,java.util.function.BiFunction), class=java.beans.PropertyDescriptor[name=class; propertyType=class java.lang.Class; readMethod=public final native java.lang.Class java.lang.Object.getClass()], keySet=public java.util.Set java.util.LinkedHashMap.keySet(), java.lang.Object@1c0f21d=freemarker.ext.beans.OverloadedMethods@d4b988, entrySet=public java.util.Set java.util.LinkedHashMap.entrySet(), java.lang.Object@15be27d=public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object), forEach=public void java.util.LinkedHashMap.forEach(java.util.function.BiConsumer), containsKey=public boolean java.util.HashMap.containsKey(java.lang.Object), isEmpty=public boolean java.util.HashMap.isEmpty(), clear=public void java.util.LinkedHashMap.clear(), computeIfPresent=public java.lang.Object java.util.HashMap.computeIfPresent(java.lang.Object,java.util.function.BiFunction), size=public int java.util.HashMap.size(), equals=public boolean java.util.AbstractMap.equals(java.lang.Object), clone=public java.lang.Object java.util.HashMap.clone(), toString=public java.lang.String java.util.AbstractMap.toString(), putIfAbsent=public java.lang.Object java.util.HashMap.putIfAbsent(java.lang.Object,java.lang.Object)}
[DEBUG] 2017-05-24: 21:05:33 freemarker.log._Log4jLoggerFactory$Log4jLogger.debug(_Log4jLoggerFactory.java:45) :  Key "cssClass" was not found on instance of java.util.LinkedHashMap. Introspection information for the class is: {getClass=public final native java.lang.Class java.lang.Object.getClass(), getOrDefault=public java.lang.Object java.util.LinkedHashMap.getOrDefault(java.lang.Object,java.lang.Object), computeIfAbsent=public java.lang.Object java.util.HashMap.computeIfAbsent(java.lang.Object,java.util.function.Function), values=public java.util.Collection java.util.LinkedHashMap.values(), replace=freemarker.ext.beans.OverloadedMethods@11d0265, java.lang.Object@3e55b2={public boolean java.util.HashMap.isEmpty()=[Ljava.lang.Class;@c5aa3a, public int java.util.AbstractMap.hashCode()=[Ljava.lang.Class;@74a947, public java.lang.Object java.util.HashMap.put(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@1615a91, public boolean java.util.AbstractMap.equals(java.lang.Object)=[Ljava.lang.Class;@a46ab2, public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object)=[Ljava.lang.Class;@1c389e6, public java.lang.String java.util.AbstractMap.toString()=[Ljava.lang.Class;@a23548, public boolean java.util.HashMap.containsKey(java.lang.Object)=[Ljava.lang.Class;@1be4a9f, public java.util.Set java.util.LinkedHashMap.keySet()=[Ljava.lang.Class;@44c60, public java.lang.Object java.util.HashMap.computeIfAbsent(java.lang.Object,java.util.function.Function)=[Ljava.lang.Class;@10f7dff, public java.lang.Object java.util.HashMap.clone()=[Ljava.lang.Class;@d214e3, public java.lang.Object java.util.LinkedHashMap.getOrDefault(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@1a74254, public java.util.Set java.util.LinkedHashMap.entrySet()=[Ljava.lang.Class;@1c4740c, public void java.util.LinkedHashMap.forEach(java.util.function.BiConsumer)=[Ljava.lang.Class;@1fe0c8e, public java.lang.Object java.util.HashMap.putIfAbsent(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@16f73de, public java.util.Collection java.util.LinkedHashMap.values()=[Ljava.lang.Class;@b3e45, public void java.util.LinkedHashMap.clear()=[Ljava.lang.Class;@a34e5c, public java.lang.Object java.util.HashMap.computeIfPresent(java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1fcb13a, public java.lang.Object java.util.HashMap.compute(java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1a7c258, public final native java.lang.Class java.lang.Object.getClass()=[Ljava.lang.Class;@7397f, public void java.util.HashMap.putAll(java.util.Map)=[Ljava.lang.Class;@59cd, public void java.util.LinkedHashMap.replaceAll(java.util.function.BiFunction)=[Ljava.lang.Class;@994816, public java.lang.Object java.util.HashMap.merge(java.lang.Object,java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1b1e75f, public int java.util.HashMap.size()=[Ljava.lang.Class;@bee157, public boolean java.util.LinkedHashMap.containsValue(java.lang.Object)=[Ljava.lang.Class;@5e0d7c}, replaceAll=public void java.util.LinkedHashMap.replaceAll(java.util.function.BiFunction), remove=freemarker.ext.beans.OverloadedMethods@8d3a99, containsValue=public boolean java.util.LinkedHashMap.containsValue(java.lang.Object), put=public java.lang.Object java.util.HashMap.put(java.lang.Object,java.lang.Object), empty=java.beans.PropertyDescriptor[name=empty; propertyType=boolean; readMethod=public boolean java.util.HashMap.isEmpty()], compute=public java.lang.Object java.util.HashMap.compute(java.lang.Object,java.util.function.BiFunction), hashCode=public int java.util.AbstractMap.hashCode(), putAll=public void java.util.HashMap.putAll(java.util.Map), get=public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object), merge=public java.lang.Object java.util.HashMap.merge(java.lang.Object,java.lang.Object,java.util.function.BiFunction), class=java.beans.PropertyDescriptor[name=class; propertyType=class java.lang.Class; readMethod=public final native java.lang.Class java.lang.Object.getClass()], keySet=public java.util.Set java.util.LinkedHashMap.keySet(), java.lang.Object@1c0f21d=freemarker.ext.beans.OverloadedMethods@d4b988, entrySet=public java.util.Set java.util.LinkedHashMap.entrySet(), java.lang.Object@15be27d=public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object), forEach=public void java.util.LinkedHashMap.forEach(java.util.function.BiConsumer), containsKey=public boolean java.util.HashMap.containsKey(java.lang.Object), isEmpty=public boolean java.util.HashMap.isEmpty(), clear=public void java.util.LinkedHashMap.clear(), computeIfPresent=public java.lang.Object java.util.HashMap.computeIfPresent(java.lang.Object,java.util.function.BiFunction), size=public int java.util.HashMap.size(), equals=public boolean java.util.AbstractMap.equals(java.lang.Object), clone=public java.lang.Object java.util.HashMap.clone(), toString=public java.lang.String java.util.AbstractMap.toString(), putIfAbsent=public java.lang.Object java.util.HashMap.putIfAbsent(java.lang.Object,java.lang.Object)}
[DEBUG] 2017-05-24: 21:05:33 freemarker.log._Log4jLoggerFactory$Log4jLogger.debug(_Log4jLoggerFactory.java:45) :  Key "cssClass" was not found on instance of java.util.LinkedHashMap. Introspection information for the class is: {getClass=public final native java.lang.Class java.lang.Object.getClass(), getOrDefault=public java.lang.Object java.util.LinkedHashMap.getOrDefault(java.lang.Object,java.lang.Object), computeIfAbsent=public java.lang.Object java.util.HashMap.computeIfAbsent(java.lang.Object,java.util.function.Function), values=public java.util.Collection java.util.LinkedHashMap.values(), replace=freemarker.ext.beans.OverloadedMethods@11d0265, java.lang.Object@3e55b2={public boolean java.util.HashMap.isEmpty()=[Ljava.lang.Class;@c5aa3a, public int java.util.AbstractMap.hashCode()=[Ljava.lang.Class;@74a947, public java.lang.Object java.util.HashMap.put(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@1615a91, public boolean java.util.AbstractMap.equals(java.lang.Object)=[Ljava.lang.Class;@a46ab2, public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object)=[Ljava.lang.Class;@1c389e6, public java.lang.String java.util.AbstractMap.toString()=[Ljava.lang.Class;@a23548, public boolean java.util.HashMap.containsKey(java.lang.Object)=[Ljava.lang.Class;@1be4a9f, public java.util.Set java.util.LinkedHashMap.keySet()=[Ljava.lang.Class;@44c60, public java.lang.Object java.util.HashMap.computeIfAbsent(java.lang.Object,java.util.function.Function)=[Ljava.lang.Class;@10f7dff, public java.lang.Object java.util.HashMap.clone()=[Ljava.lang.Class;@d214e3, public java.lang.Object java.util.LinkedHashMap.getOrDefault(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@1a74254, public java.util.Set java.util.LinkedHashMap.entrySet()=[Ljava.lang.Class;@1c4740c, public void java.util.LinkedHashMap.forEach(java.util.function.BiConsumer)=[Ljava.lang.Class;@1fe0c8e, public java.lang.Object java.util.HashMap.putIfAbsent(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@16f73de, public java.util.Collection java.util.LinkedHashMap.values()=[Ljava.lang.Class;@b3e45, public void java.util.LinkedHashMap.clear()=[Ljava.lang.Class;@a34e5c, public java.lang.Object java.util.HashMap.computeIfPresent(java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1fcb13a, public java.lang.Object java.util.HashMap.compute(java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1a7c258, public final native java.lang.Class java.lang.Object.getClass()=[Ljava.lang.Class;@7397f, public void java.util.HashMap.putAll(java.util.Map)=[Ljava.lang.Class;@59cd, public void java.util.LinkedHashMap.replaceAll(java.util.function.BiFunction)=[Ljava.lang.Class;@994816, public java.lang.Object java.util.HashMap.merge(java.lang.Object,java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1b1e75f, public int java.util.HashMap.size()=[Ljava.lang.Class;@bee157, public boolean java.util.LinkedHashMap.containsValue(java.lang.Object)=[Ljava.lang.Class;@5e0d7c}, replaceAll=public void java.util.LinkedHashMap.replaceAll(java.util.function.BiFunction), remove=freemarker.ext.beans.OverloadedMethods@8d3a99, containsValue=public boolean java.util.LinkedHashMap.containsValue(java.lang.Object), put=public java.lang.Object java.util.HashMap.put(java.lang.Object,java.lang.Object), empty=java.beans.PropertyDescriptor[name=empty; propertyType=boolean; readMethod=public boolean java.util.HashMap.isEmpty()], compute=public java.lang.Object java.util.HashMap.compute(java.lang.Object,java.util.function.BiFunction), hashCode=public int java.util.AbstractMap.hashCode(), putAll=public void java.util.HashMap.putAll(java.util.Map), get=public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object), merge=public java.lang.Object java.util.HashMap.merge(java.lang.Object,java.lang.Object,java.util.function.BiFunction), class=java.beans.PropertyDescriptor[name=class; propertyType=class java.lang.Class; readMethod=public final native java.lang.Class java.lang.Object.getClass()], keySet=public java.util.Set java.util.LinkedHashMap.keySet(), java.lang.Object@1c0f21d=freemarker.ext.beans.OverloadedMethods@d4b988, entrySet=public java.util.Set java.util.LinkedHashMap.entrySet(), java.lang.Object@15be27d=public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object), forEach=public void java.util.LinkedHashMap.forEach(java.util.function.BiConsumer), containsKey=public boolean java.util.HashMap.containsKey(java.lang.Object), isEmpty=public boolean java.util.HashMap.isEmpty(), clear=public void java.util.LinkedHashMap.clear(), computeIfPresent=public java.lang.Object java.util.HashMap.computeIfPresent(java.lang.Object,java.util.function.BiFunction), size=public int java.util.HashMap.size(), equals=public boolean java.util.AbstractMap.equals(java.lang.Object), clone=public java.lang.Object java.util.HashMap.clone(), toString=public java.lang.String java.util.AbstractMap.toString(), putIfAbsent=public java.lang.Object java.util.HashMap.putIfAbsent(java.lang.Object,java.lang.Object)}
[DEBUG] 2017-05-24: 21:05:33 freemarker.log._Log4jLoggerFactory$Log4jLogger.debug(_Log4jLoggerFactory.java:45) :  Key "cssStyle" was not found on instance of java.util.LinkedHashMap. Introspection information for the class is: {getClass=public final native java.lang.Class java.lang.Object.getClass(), getOrDefault=public java.lang.Object java.util.LinkedHashMap.getOrDefault(java.lang.Object,java.lang.Object), computeIfAbsent=public java.lang.Object java.util.HashMap.computeIfAbsent(java.lang.Object,java.util.function.Function), values=public java.util.Collection java.util.LinkedHashMap.values(), replace=freemarker.ext.beans.OverloadedMethods@11d0265, java.lang.Object@3e55b2={public boolean java.util.HashMap.isEmpty()=[Ljava.lang.Class;@c5aa3a, public int java.util.AbstractMap.hashCode()=[Ljava.lang.Class;@74a947, public java.lang.Object java.util.HashMap.put(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@1615a91, public boolean java.util.AbstractMap.equals(java.lang.Object)=[Ljava.lang.Class;@a46ab2, public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object)=[Ljava.lang.Class;@1c389e6, public java.lang.String java.util.AbstractMap.toString()=[Ljava.lang.Class;@a23548, public boolean java.util.HashMap.containsKey(java.lang.Object)=[Ljava.lang.Class;@1be4a9f, public java.util.Set java.util.LinkedHashMap.keySet()=[Ljava.lang.Class;@44c60, public java.lang.Object java.util.HashMap.computeIfAbsent(java.lang.Object,java.util.function.Function)=[Ljava.lang.Class;@10f7dff, public java.lang.Object java.util.HashMap.clone()=[Ljava.lang.Class;@d214e3, public java.lang.Object java.util.LinkedHashMap.getOrDefault(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@1a74254, public java.util.Set java.util.LinkedHashMap.entrySet()=[Ljava.lang.Class;@1c4740c, public void java.util.LinkedHashMap.forEach(java.util.function.BiConsumer)=[Ljava.lang.Class;@1fe0c8e, public java.lang.Object java.util.HashMap.putIfAbsent(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@16f73de, public java.util.Collection java.util.LinkedHashMap.values()=[Ljava.lang.Class;@b3e45, public void java.util.LinkedHashMap.clear()=[Ljava.lang.Class;@a34e5c, public java.lang.Object java.util.HashMap.computeIfPresent(java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1fcb13a, public java.lang.Object java.util.HashMap.compute(java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1a7c258, public final native java.lang.Class java.lang.Object.getClass()=[Ljava.lang.Class;@7397f, public void java.util.HashMap.putAll(java.util.Map)=[Ljava.lang.Class;@59cd, public void java.util.LinkedHashMap.replaceAll(java.util.function.BiFunction)=[Ljava.lang.Class;@994816, public java.lang.Object java.util.HashMap.merge(java.lang.Object,java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1b1e75f, public int java.util.HashMap.size()=[Ljava.lang.Class;@bee157, public boolean java.util.LinkedHashMap.containsValue(java.lang.Object)=[Ljava.lang.Class;@5e0d7c}, replaceAll=public void java.util.LinkedHashMap.replaceAll(java.util.function.BiFunction), remove=freemarker.ext.beans.OverloadedMethods@8d3a99, containsValue=public boolean java.util.LinkedHashMap.containsValue(java.lang.Object), put=public java.lang.Object java.util.HashMap.put(java.lang.Object,java.lang.Object), empty=java.beans.PropertyDescriptor[name=empty; propertyType=boolean; readMethod=public boolean java.util.HashMap.isEmpty()], compute=public java.lang.Object java.util.HashMap.compute(java.lang.Object,java.util.function.BiFunction), hashCode=public int java.util.AbstractMap.hashCode(), putAll=public void java.util.HashMap.putAll(java.util.Map), get=public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object), merge=public java.lang.Object java.util.HashMap.merge(java.lang.Object,java.lang.Object,java.util.function.BiFunction), class=java.beans.PropertyDescriptor[name=class; propertyType=class java.lang.Class; readMethod=public final native java.lang.Class java.lang.Object.getClass()], keySet=public java.util.Set java.util.LinkedHashMap.keySet(), java.lang.Object@1c0f21d=freemarker.ext.beans.OverloadedMethods@d4b988, entrySet=public java.util.Set java.util.LinkedHashMap.entrySet(), java.lang.Object@15be27d=public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object), forEach=public void java.util.LinkedHashMap.forEach(java.util.function.BiConsumer), containsKey=public boolean java.util.HashMap.containsKey(java.lang.Object), isEmpty=public boolean java.util.HashMap.isEmpty(), clear=public void java.util.LinkedHashMap.clear(), computeIfPresent=public java.lang.Object java.util.HashMap.computeIfPresent(java.lang.Object,java.util.function.BiFunction), size=public int java.util.HashMap.size(), equals=public boolean java.util.AbstractMap.equals(java.lang.Object), clone=public java.lang.Object java.util.HashMap.clone(), toString=public java.lang.String java.util.AbstractMap.toString(), putIfAbsent=public java.lang.Object java.util.HashMap.putIfAbsent(java.lang.Object,java.lang.Object)}
[DEBUG] 2017-05-24: 21:05:33 freemarker.log._Log4jLoggerFactory$Log4jLogger.debug(_Log4jLoggerFactory.java:45) :  Key "title" was not found on instance of java.util.LinkedHashMap. Introspection information for the class is: {getClass=public final native java.lang.Class java.lang.Object.getClass(), getOrDefault=public java.lang.Object java.util.LinkedHashMap.getOrDefault(java.lang.Object,java.lang.Object), computeIfAbsent=public java.lang.Object java.util.HashMap.computeIfAbsent(java.lang.Object,java.util.function.Function), values=public java.util.Collection java.util.LinkedHashMap.values(), replace=freemarker.ext.beans.OverloadedMethods@11d0265, java.lang.Object@3e55b2={public boolean java.util.HashMap.isEmpty()=[Ljava.lang.Class;@c5aa3a, public int java.util.AbstractMap.hashCode()=[Ljava.lang.Class;@74a947, public java.lang.Object java.util.HashMap.put(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@1615a91, public boolean java.util.AbstractMap.equals(java.lang.Object)=[Ljava.lang.Class;@a46ab2, public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object)=[Ljava.lang.Class;@1c389e6, public java.lang.String java.util.AbstractMap.toString()=[Ljava.lang.Class;@a23548, public boolean java.util.HashMap.containsKey(java.lang.Object)=[Ljava.lang.Class;@1be4a9f, public java.util.Set java.util.LinkedHashMap.keySet()=[Ljava.lang.Class;@44c60, public java.lang.Object java.util.HashMap.computeIfAbsent(java.lang.Object,java.util.function.Function)=[Ljava.lang.Class;@10f7dff, public java.lang.Object java.util.HashMap.clone()=[Ljava.lang.Class;@d214e3, public java.lang.Object java.util.LinkedHashMap.getOrDefault(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@1a74254, public java.util.Set java.util.LinkedHashMap.entrySet()=[Ljava.lang.Class;@1c4740c, public void java.util.LinkedHashMap.forEach(java.util.function.BiConsumer)=[Ljava.lang.Class;@1fe0c8e, public java.lang.Object java.util.HashMap.putIfAbsent(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@16f73de, public java.util.Collection java.util.LinkedHashMap.values()=[Ljava.lang.Class;@b3e45, public void java.util.LinkedHashMap.clear()=[Ljava.lang.Class;@a34e5c, public java.lang.Object java.util.HashMap.computeIfPresent(java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1fcb13a, public java.lang.Object java.util.HashMap.compute(java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1a7c258, public final native java.lang.Class java.lang.Object.getClass()=[Ljava.lang.Class;@7397f, public void java.util.HashMap.putAll(java.util.Map)=[Ljava.lang.Class;@59cd, public void java.util.LinkedHashMap.replaceAll(java.util.function.BiFunction)=[Ljava.lang.Class;@994816, public java.lang.Object java.util.HashMap.merge(java.lang.Object,java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1b1e75f, public int java.util.HashMap.size()=[Ljava.lang.Class;@bee157, public boolean java.util.LinkedHashMap.containsValue(java.lang.Object)=[Ljava.lang.Class;@5e0d7c}, replaceAll=public void java.util.LinkedHashMap.replaceAll(java.util.function.BiFunction), remove=freemarker.ext.beans.OverloadedMethods@8d3a99, containsValue=public boolean java.util.LinkedHashMap.containsValue(java.lang.Object), put=public java.lang.Object java.util.HashMap.put(java.lang.Object,java.lang.Object), empty=java.beans.PropertyDescriptor[name=empty; propertyType=boolean; readMethod=public boolean java.util.HashMap.isEmpty()], compute=public java.lang.Object java.util.HashMap.compute(java.lang.Object,java.util.function.BiFunction), hashCode=public int java.util.AbstractMap.hashCode(), putAll=public void java.util.HashMap.putAll(java.util.Map), get=public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object), merge=public java.lang.Object java.util.HashMap.merge(java.lang.Object,java.lang.Object,java.util.function.BiFunction), class=java.beans.PropertyDescriptor[name=class; propertyType=class java.lang.Class; readMethod=public final native java.lang.Class java.lang.Object.getClass()], keySet=public java.util.Set java.util.LinkedHashMap.keySet(), java.lang.Object@1c0f21d=freemarker.ext.beans.OverloadedMethods@d4b988, entrySet=public java.util.Set java.util.LinkedHashMap.entrySet(), java.lang.Object@15be27d=public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object), forEach=public void java.util.LinkedHashMap.forEach(java.util.function.BiConsumer), containsKey=public boolean java.util.HashMap.containsKey(java.lang.Object), isEmpty=public boolean java.util.HashMap.isEmpty(), clear=public void java.util.LinkedHashMap.clear(), computeIfPresent=public java.lang.Object java.util.HashMap.computeIfPresent(java.lang.Object,java.util.function.BiFunction), size=public int java.util.HashMap.size(), equals=public boolean java.util.AbstractMap.equals(java.lang.Object), clone=public java.lang.Object java.util.HashMap.clone(), toString=public java.lang.String java.util.AbstractMap.toString(), putIfAbsent=public java.lang.Object java.util.HashMap.putIfAbsent(java.lang.Object,java.lang.Object)}
[DEBUG] 2017-05-24: 21:05:33 freemarker.log._Log4jLoggerFactory$Log4jLogger.debug(_Log4jLoggerFactory.java:45) :  TemplateLoader.findTemplateSource("template/~~~xhtml/scripting-events.ftl"): Found
[DEBUG] 2017-05-24: 21:05:33 freemarker.log._Log4jLoggerFactory$Log4jLogger.debug(_Log4jLoggerFactory.java:45) :  "template/~~~xhtml/scripting-events.ftl"("zh_CN", UTF-8, parsed): using cached since jar:file:/D:/maven/repository/org/apache/struts/struts2-core/2.5.10/struts2-core-2.5.10.jar!/template/simple/scripting-events.ftl hasn't changed.
[DEBUG] 2017-05-24: 21:05:33 freemarker.log._Log4jLoggerFactory$Log4jLogger.debug(_Log4jLoggerFactory.java:45) :  Key "onclick" was not found on instance of java.util.LinkedHashMap. Introspection information for the class is: {getClass=public final native java.lang.Class java.lang.Object.getClass(), getOrDefault=public java.lang.Object java.util.LinkedHashMap.getOrDefault(java.lang.Object,java.lang.Object), computeIfAbsent=public java.lang.Object java.util.HashMap.computeIfAbsent(java.lang.Object,java.util.function.Function), values=public java.util.Collection java.util.LinkedHashMap.values(), replace=freemarker.ext.beans.OverloadedMethods@11d0265, java.lang.Object@3e55b2={public boolean java.util.HashMap.isEmpty()=[Ljava.lang.Class;@c5aa3a, public int java.util.AbstractMap.hashCode()=[Ljava.lang.Class;@74a947, public java.lang.Object java.util.HashMap.put(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@1615a91, public boolean java.util.AbstractMap.equals(java.lang.Object)=[Ljava.lang.Class;@a46ab2, public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object)=[Ljava.lang.Class;@1c389e6, public java.lang.String java.util.AbstractMap.toString()=[Ljava.lang.Class;@a23548, public boolean java.util.HashMap.containsKey(java.lang.Object)=[Ljava.lang.Class;@1be4a9f, public java.util.Set java.util.LinkedHashMap.keySet()=[Ljava.lang.Class;@44c60, public java.lang.Object java.util.HashMap.computeIfAbsent(java.lang.Object,java.util.function.Function)=[Ljava.lang.Class;@10f7dff, public java.lang.Object java.util.HashMap.clone()=[Ljava.lang.Class;@d214e3, public java.lang.Object java.util.LinkedHashMap.getOrDefault(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@1a74254, public java.util.Set java.util.LinkedHashMap.entrySet()=[Ljava.lang.Class;@1c4740c, public void java.util.LinkedHashMap.forEach(java.util.function.BiConsumer)=[Ljava.lang.Class;@1fe0c8e, public java.lang.Object java.util.HashMap.putIfAbsent(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@16f73de, public java.util.Collection java.util.LinkedHashMap.values()=[Ljava.lang.Class;@b3e45, public void java.util.LinkedHashMap.clear()=[Ljava.lang.Class;@a34e5c, public java.lang.Object java.util.HashMap.computeIfPresent(java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1fcb13a, public java.lang.Object java.util.HashMap.compute(java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1a7c258, public final native java.lang.Class java.lang.Object.getClass()=[Ljava.lang.Class;@7397f, public void java.util.HashMap.putAll(java.util.Map)=[Ljava.lang.Class;@59cd, public void java.util.LinkedHashMap.replaceAll(java.util.function.BiFunction)=[Ljava.lang.Class;@994816, public java.lang.Object java.util.HashMap.merge(java.lang.Object,java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1b1e75f, public int java.util.HashMap.size()=[Ljava.lang.Class;@bee157, public boolean java.util.LinkedHashMap.containsValue(java.lang.Object)=[Ljava.lang.Class;@5e0d7c}, replaceAll=public void java.util.LinkedHashMap.replaceAll(java.util.function.BiFunction), remove=freemarker.ext.beans.OverloadedMethods@8d3a99, containsValue=public boolean java.util.LinkedHashMap.containsValue(java.lang.Object), put=public java.lang.Object java.util.HashMap.put(java.lang.Object,java.lang.Object), empty=java.beans.PropertyDescriptor[name=empty; propertyType=boolean; readMethod=public boolean java.util.HashMap.isEmpty()], compute=public java.lang.Object java.util.HashMap.compute(java.lang.Object,java.util.function.BiFunction), hashCode=public int java.util.AbstractMap.hashCode(), putAll=public void java.util.HashMap.putAll(java.util.Map), get=public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object), merge=public java.lang.Object java.util.HashMap.merge(java.lang.Object,java.lang.Object,java.util.function.BiFunction), class=java.beans.PropertyDescriptor[name=class; propertyType=class java.lang.Class; readMethod=public final native java.lang.Class java.lang.Object.getClass()], keySet=public java.util.Set java.util.LinkedHashMap.keySet(), java.lang.Object@1c0f21d=freemarker.ext.beans.OverloadedMethods@d4b988, entrySet=public java.util.Set java.util.LinkedHashMap.entrySet(), java.lang.Object@15be27d=public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object), forEach=public void java.util.LinkedHashMap.forEach(java.util.function.BiConsumer), containsKey=public boolean java.util.HashMap.containsKey(java.lang.Object), isEmpty=public boolean java.util.HashMap.isEmpty(), clear=public void java.util.LinkedHashMap.clear(), computeIfPresent=public java.lang.Object java.util.HashMap.computeIfPresent(java.lang.Object,java.util.function.BiFunction), size=public int java.util.HashMap.size(), equals=public boolean java.util.AbstractMap.equals(java.lang.Object), clone=public java.lang.Object java.util.HashMap.clone(), toString=public java.lang.String java.util.AbstractMap.toString(), putIfAbsent=public java.lang.Object java.util.HashMap.putIfAbsent(java.lang.Object,java.lang.Object)}
[DEBUG] 2017-05-24: 21:05:33 freemarker.log._Log4jLoggerFactory$Log4jLogger.debug(_Log4jLoggerFactory.java:45) :  Key "ondblclick" was not found on instance of java.util.LinkedHashMap. Introspection information for the class is: {getClass=public final native java.lang.Class java.lang.Object.getClass(), getOrDefault=public java.lang.Object java.util.LinkedHashMap.getOrDefault(java.lang.Object,java.lang.Object), computeIfAbsent=public java.lang.Object java.util.HashMap.computeIfAbsent(java.lang.Object,java.util.function.Function), values=public java.util.Collection java.util.LinkedHashMap.values(), replace=freemarker.ext.beans.OverloadedMethods@11d0265, java.lang.Object@3e55b2={public boolean java.util.HashMap.isEmpty()=[Ljava.lang.Class;@c5aa3a, public int java.util.AbstractMap.hashCode()=[Ljava.lang.Class;@74a947, public java.lang.Object java.util.HashMap.put(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@1615a91, public boolean java.util.AbstractMap.equals(java.lang.Object)=[Ljava.lang.Class;@a46ab2, public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object)=[Ljava.lang.Class;@1c389e6, public java.lang.String java.util.AbstractMap.toString()=[Ljava.lang.Class;@a23548, public boolean java.util.HashMap.containsKey(java.lang.Object)=[Ljava.lang.Class;@1be4a9f, public java.util.Set java.util.LinkedHashMap.keySet()=[Ljava.lang.Class;@44c60, public java.lang.Object java.util.HashMap.computeIfAbsent(java.lang.Object,java.util.function.Function)=[Ljava.lang.Class;@10f7dff, public java.lang.Object java.util.HashMap.clone()=[Ljava.lang.Class;@d214e3, public java.lang.Object java.util.LinkedHashMap.getOrDefault(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@1a74254, public java.util.Set java.util.LinkedHashMap.entrySet()=[Ljava.lang.Class;@1c4740c, public void java.util.LinkedHashMap.forEach(java.util.function.BiConsumer)=[Ljava.lang.Class;@1fe0c8e, public java.lang.Object java.util.HashMap.putIfAbsent(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@16f73de, public java.util.Collection java.util.LinkedHashMap.values()=[Ljava.lang.Class;@b3e45, public void java.util.LinkedHashMap.clear()=[Ljava.lang.Class;@a34e5c, public java.lang.Object java.util.HashMap.computeIfPresent(java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1fcb13a, public java.lang.Object java.util.HashMap.compute(java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1a7c258, public final native java.lang.Class java.lang.Object.getClass()=[Ljava.lang.Class;@7397f, public void java.util.HashMap.putAll(java.util.Map)=[Ljava.lang.Class;@59cd, public void java.util.LinkedHashMap.replaceAll(java.util.function.BiFunction)=[Ljava.lang.Class;@994816, public java.lang.Object java.util.HashMap.merge(java.lang.Object,java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1b1e75f, public int java.util.HashMap.size()=[Ljava.lang.Class;@bee157, public boolean java.util.LinkedHashMap.containsValue(java.lang.Object)=[Ljava.lang.Class;@5e0d7c}, replaceAll=public void java.util.LinkedHashMap.replaceAll(java.util.function.BiFunction), remove=freemarker.ext.beans.OverloadedMethods@8d3a99, containsValue=public boolean java.util.LinkedHashMap.containsValue(java.lang.Object), put=public java.lang.Object java.util.HashMap.put(java.lang.Object,java.lang.Object), empty=java.beans.PropertyDescriptor[name=empty; propertyType=boolean; readMethod=public boolean java.util.HashMap.isEmpty()], compute=public java.lang.Object java.util.HashMap.compute(java.lang.Object,java.util.function.BiFunction), hashCode=public int java.util.AbstractMap.hashCode(), putAll=public void java.util.HashMap.putAll(java.util.Map), get=public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object), merge=public java.lang.Object java.util.HashMap.merge(java.lang.Object,java.lang.Object,java.util.function.BiFunction), class=java.beans.PropertyDescriptor[name=class; propertyType=class java.lang.Class; readMethod=public final native java.lang.Class java.lang.Object.getClass()], keySet=public java.util.Set java.util.LinkedHashMap.keySet(), java.lang.Object@1c0f21d=freemarker.ext.beans.OverloadedMethods@d4b988, entrySet=public java.util.Set java.util.LinkedHashMap.entrySet(), java.lang.Object@15be27d=public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object), forEach=public void java.util.LinkedHashMap.forEach(java.util.function.BiConsumer), containsKey=public boolean java.util.HashMap.containsKey(java.lang.Object), isEmpty=public boolean java.util.HashMap.isEmpty(), clear=public void java.util.LinkedHashMap.clear(), computeIfPresent=public java.lang.Object java.util.HashMap.computeIfPresent(java.lang.Object,java.util.function.BiFunction), size=public int java.util.HashMap.size(), equals=public boolean java.util.AbstractMap.equals(java.lang.Object), clone=public java.lang.Object java.util.HashMap.clone(), toString=public java.lang.String java.util.AbstractMap.toString(), putIfAbsent=public java.lang.Object java.util.HashMap.putIfAbsent(java.lang.Object,java.lang.Object)}
[DEBUG] 2017-05-24: 21:05:33 freemarker.log._Log4jLoggerFactory$Log4jLogger.debug(_Log4jLoggerFactory.java:45) :  Key "onmousedown" was not found on instance of java.util.LinkedHashMap. Introspection information for the class is: {getClass=public final native java.lang.Class java.lang.Object.getClass(), getOrDefault=public java.lang.Object java.util.LinkedHashMap.getOrDefault(java.lang.Object,java.lang.Object), computeIfAbsent=public java.lang.Object java.util.HashMap.computeIfAbsent(java.lang.Object,java.util.function.Function), values=public java.util.Collection java.util.LinkedHashMap.values(), replace=freemarker.ext.beans.OverloadedMethods@11d0265, java.lang.Object@3e55b2={public boolean java.util.HashMap.isEmpty()=[Ljava.lang.Class;@c5aa3a, public int java.util.AbstractMap.hashCode()=[Ljava.lang.Class;@74a947, public java.lang.Object java.util.HashMap.put(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@1615a91, public boolean java.util.AbstractMap.equals(java.lang.Object)=[Ljava.lang.Class;@a46ab2, public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object)=[Ljava.lang.Class;@1c389e6, public java.lang.String java.util.AbstractMap.toString()=[Ljava.lang.Class;@a23548, public boolean java.util.HashMap.containsKey(java.lang.Object)=[Ljava.lang.Class;@1be4a9f, public java.util.Set java.util.LinkedHashMap.keySet()=[Ljava.lang.Class;@44c60, public java.lang.Object java.util.HashMap.computeIfAbsent(java.lang.Object,java.util.function.Function)=[Ljava.lang.Class;@10f7dff, public java.lang.Object java.util.HashMap.clone()=[Ljava.lang.Class;@d214e3, public java.lang.Object java.util.LinkedHashMap.getOrDefault(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@1a74254, public java.util.Set java.util.LinkedHashMap.entrySet()=[Ljava.lang.Class;@1c4740c, public void java.util.LinkedHashMap.forEach(java.util.function.BiConsumer)=[Ljava.lang.Class;@1fe0c8e, public java.lang.Object java.util.HashMap.putIfAbsent(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@16f73de, public java.util.Collection java.util.LinkedHashMap.values()=[Ljava.lang.Class;@b3e45, public void java.util.LinkedHashMap.clear()=[Ljava.lang.Class;@a34e5c, public java.lang.Object java.util.HashMap.computeIfPresent(java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1fcb13a, public java.lang.Object java.util.HashMap.compute(java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1a7c258, public final native java.lang.Class java.lang.Object.getClass()=[Ljava.lang.Class;@7397f, public void java.util.HashMap.putAll(java.util.Map)=[Ljava.lang.Class;@59cd, public void java.util.LinkedHashMap.replaceAll(java.util.function.BiFunction)=[Ljava.lang.Class;@994816, public java.lang.Object java.util.HashMap.merge(java.lang.Object,java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1b1e75f, public int java.util.HashMap.size()=[Ljava.lang.Class;@bee157, public boolean java.util.LinkedHashMap.containsValue(java.lang.Object)=[Ljava.lang.Class;@5e0d7c}, replaceAll=public void java.util.LinkedHashMap.replaceAll(java.util.function.BiFunction), remove=freemarker.ext.beans.OverloadedMethods@8d3a99, containsValue=public boolean java.util.LinkedHashMap.containsValue(java.lang.Object), put=public java.lang.Object java.util.HashMap.put(java.lang.Object,java.lang.Object), empty=java.beans.PropertyDescriptor[name=empty; propertyType=boolean; readMethod=public boolean java.util.HashMap.isEmpty()], compute=public java.lang.Object java.util.HashMap.compute(java.lang.Object,java.util.function.BiFunction), hashCode=public int java.util.AbstractMap.hashCode(), putAll=public void java.util.HashMap.putAll(java.util.Map), get=public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object), merge=public java.lang.Object java.util.HashMap.merge(java.lang.Object,java.lang.Object,java.util.function.BiFunction), class=java.beans.PropertyDescriptor[name=class; propertyType=class java.lang.Class; readMethod=public final native java.lang.Class java.lang.Object.getClass()], keySet=public java.util.Set java.util.LinkedHashMap.keySet(), java.lang.Object@1c0f21d=freemarker.ext.beans.OverloadedMethods@d4b988, entrySet=public java.util.Set java.util.LinkedHashMap.entrySet(), java.lang.Object@15be27d=public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object), forEach=public void java.util.LinkedHashMap.forEach(java.util.function.BiConsumer), containsKey=public boolean java.util.HashMap.containsKey(java.lang.Object), isEmpty=public boolean java.util.HashMap.isEmpty(), clear=public void java.util.LinkedHashMap.clear(), computeIfPresent=public java.lang.Object java.util.HashMap.computeIfPresent(java.lang.Object,java.util.function.BiFunction), size=public int java.util.HashMap.size(), equals=public boolean java.util.AbstractMap.equals(java.lang.Object), clone=public java.lang.Object java.util.HashMap.clone(), toString=public java.lang.String java.util.AbstractMap.toString(), putIfAbsent=public java.lang.Object java.util.HashMap.putIfAbsent(java.lang.Object,java.lang.Object)}
[DEBUG] 2017-05-24: 21:05:33 freemarker.log._Log4jLoggerFactory$Log4jLogger.debug(_Log4jLoggerFactory.java:45) :  Key "onmouseup" was not found on instance of java.util.LinkedHashMap. Introspection information for the class is: {getClass=public final native java.lang.Class java.lang.Object.getClass(), getOrDefault=public java.lang.Object java.util.LinkedHashMap.getOrDefault(java.lang.Object,java.lang.Object), computeIfAbsent=public java.lang.Object java.util.HashMap.computeIfAbsent(java.lang.Object,java.util.function.Function), values=public java.util.Collection java.util.LinkedHashMap.values(), replace=freemarker.ext.beans.OverloadedMethods@11d0265, java.lang.Object@3e55b2={public boolean java.util.HashMap.isEmpty()=[Ljava.lang.Class;@c5aa3a, public int java.util.AbstractMap.hashCode()=[Ljava.lang.Class;@74a947, public java.lang.Object java.util.HashMap.put(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@1615a91, public boolean java.util.AbstractMap.equals(java.lang.Object)=[Ljava.lang.Class;@a46ab2, public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object)=[Ljava.lang.Class;@1c389e6, public java.lang.String java.util.AbstractMap.toString()=[Ljava.lang.Class;@a23548, public boolean java.util.HashMap.containsKey(java.lang.Object)=[Ljava.lang.Class;@1be4a9f, public java.util.Set java.util.LinkedHashMap.keySet()=[Ljava.lang.Class;@44c60, public java.lang.Object java.util.HashMap.computeIfAbsent(java.lang.Object,java.util.function.Function)=[Ljava.lang.Class;@10f7dff, public java.lang.Object java.util.HashMap.clone()=[Ljava.lang.Class;@d214e3, public java.lang.Object java.util.LinkedHashMap.getOrDefault(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@1a74254, public java.util.Set java.util.LinkedHashMap.entrySet()=[Ljava.lang.Class;@1c4740c, public void java.util.LinkedHashMap.forEach(java.util.function.BiConsumer)=[Ljava.lang.Class;@1fe0c8e, public java.lang.Object java.util.HashMap.putIfAbsent(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@16f73de, public java.util.Collection java.util.LinkedHashMap.values()=[Ljava.lang.Class;@b3e45, public void java.util.LinkedHashMap.clear()=[Ljava.lang.Class;@a34e5c, public java.lang.Object java.util.HashMap.computeIfPresent(java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1fcb13a, public java.lang.Object java.util.HashMap.compute(java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1a7c258, public final native java.lang.Class java.lang.Object.getClass()=[Ljava.lang.Class;@7397f, public void java.util.HashMap.putAll(java.util.Map)=[Ljava.lang.Class;@59cd, public void java.util.LinkedHashMap.replaceAll(java.util.function.BiFunction)=[Ljava.lang.Class;@994816, public java.lang.Object java.util.HashMap.merge(java.lang.Object,java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1b1e75f, public int java.util.HashMap.size()=[Ljava.lang.Class;@bee157, public boolean java.util.LinkedHashMap.containsValue(java.lang.Object)=[Ljava.lang.Class;@5e0d7c}, replaceAll=public void java.util.LinkedHashMap.replaceAll(java.util.function.BiFunction), remove=freemarker.ext.beans.OverloadedMethods@8d3a99, containsValue=public boolean java.util.LinkedHashMap.containsValue(java.lang.Object), put=public java.lang.Object java.util.HashMap.put(java.lang.Object,java.lang.Object), empty=java.beans.PropertyDescriptor[name=empty; propertyType=boolean; readMethod=public boolean java.util.HashMap.isEmpty()], compute=public java.lang.Object java.util.HashMap.compute(java.lang.Object,java.util.function.BiFunction), hashCode=public int java.util.AbstractMap.hashCode(), putAll=public void java.util.HashMap.putAll(java.util.Map), get=public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object), merge=public java.lang.Object java.util.HashMap.merge(java.lang.Object,java.lang.Object,java.util.function.BiFunction), class=java.beans.PropertyDescriptor[name=class; propertyType=class java.lang.Class; readMethod=public final native java.lang.Class java.lang.Object.getClass()], keySet=public java.util.Set java.util.LinkedHashMap.keySet(), java.lang.Object@1c0f21d=freemarker.ext.beans.OverloadedMethods@d4b988, entrySet=public java.util.Set java.util.LinkedHashMap.entrySet(), java.lang.Object@15be27d=public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object), forEach=public void java.util.LinkedHashMap.forEach(java.util.function.BiConsumer), containsKey=public boolean java.util.HashMap.containsKey(java.lang.Object), isEmpty=public boolean java.util.HashMap.isEmpty(), clear=public void java.util.LinkedHashMap.clear(), computeIfPresent=public java.lang.Object java.util.HashMap.computeIfPresent(java.lang.Object,java.util.function.BiFunction), size=public int java.util.HashMap.size(), equals=public boolean java.util.AbstractMap.equals(java.lang.Object), clone=public java.lang.Object java.util.HashMap.clone(), toString=public java.lang.String java.util.AbstractMap.toString(), putIfAbsent=public java.lang.Object java.util.HashMap.putIfAbsent(java.lang.Object,java.lang.Object)}
[DEBUG] 2017-05-24: 21:05:33 freemarker.log._Log4jLoggerFactory$Log4jLogger.debug(_Log4jLoggerFactory.java:45) :  Key "onmouseover" was not found on instance of java.util.LinkedHashMap. Introspection information for the class is: {getClass=public final native java.lang.Class java.lang.Object.getClass(), getOrDefault=public java.lang.Object java.util.LinkedHashMap.getOrDefault(java.lang.Object,java.lang.Object), computeIfAbsent=public java.lang.Object java.util.HashMap.computeIfAbsent(java.lang.Object,java.util.function.Function), values=public java.util.Collection java.util.LinkedHashMap.values(), replace=freemarker.ext.beans.OverloadedMethods@11d0265, java.lang.Object@3e55b2={public boolean java.util.HashMap.isEmpty()=[Ljava.lang.Class;@c5aa3a, public int java.util.AbstractMap.hashCode()=[Ljava.lang.Class;@74a947, public java.lang.Object java.util.HashMap.put(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@1615a91, public boolean java.util.AbstractMap.equals(java.lang.Object)=[Ljava.lang.Class;@a46ab2, public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object)=[Ljava.lang.Class;@1c389e6, public java.lang.String java.util.AbstractMap.toString()=[Ljava.lang.Class;@a23548, public boolean java.util.HashMap.containsKey(java.lang.Object)=[Ljava.lang.Class;@1be4a9f, public java.util.Set java.util.LinkedHashMap.keySet()=[Ljava.lang.Class;@44c60, public java.lang.Object java.util.HashMap.computeIfAbsent(java.lang.Object,java.util.function.Function)=[Ljava.lang.Class;@10f7dff, public java.lang.Object java.util.HashMap.clone()=[Ljava.lang.Class;@d214e3, public java.lang.Object java.util.LinkedHashMap.getOrDefault(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@1a74254, public java.util.Set java.util.LinkedHashMap.entrySet()=[Ljava.lang.Class;@1c4740c, public void java.util.LinkedHashMap.forEach(java.util.function.BiConsumer)=[Ljava.lang.Class;@1fe0c8e, public java.lang.Object java.util.HashMap.putIfAbsent(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@16f73de, public java.util.Collection java.util.LinkedHashMap.values()=[Ljava.lang.Class;@b3e45, public void java.util.LinkedHashMap.clear()=[Ljava.lang.Class;@a34e5c, public java.lang.Object java.util.HashMap.computeIfPresent(java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1fcb13a, public java.lang.Object java.util.HashMap.compute(java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1a7c258, public final native java.lang.Class java.lang.Object.getClass()=[Ljava.lang.Class;@7397f, public void java.util.HashMap.putAll(java.util.Map)=[Ljava.lang.Class;@59cd, public void java.util.LinkedHashMap.replaceAll(java.util.function.BiFunction)=[Ljava.lang.Class;@994816, public java.lang.Object java.util.HashMap.merge(java.lang.Object,java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1b1e75f, public int java.util.HashMap.size()=[Ljava.lang.Class;@bee157, public boolean java.util.LinkedHashMap.containsValue(java.lang.Object)=[Ljava.lang.Class;@5e0d7c}, replaceAll=public void java.util.LinkedHashMap.replaceAll(java.util.function.BiFunction), remove=freemarker.ext.beans.OverloadedMethods@8d3a99, containsValue=public boolean java.util.LinkedHashMap.containsValue(java.lang.Object), put=public java.lang.Object java.util.HashMap.put(java.lang.Object,java.lang.Object), empty=java.beans.PropertyDescriptor[name=empty; propertyType=boolean; readMethod=public boolean java.util.HashMap.isEmpty()], compute=public java.lang.Object java.util.HashMap.compute(java.lang.Object,java.util.function.BiFunction), hashCode=public int java.util.AbstractMap.hashCode(), putAll=public void java.util.HashMap.putAll(java.util.Map), get=public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object), merge=public java.lang.Object java.util.HashMap.merge(java.lang.Object,java.lang.Object,java.util.function.BiFunction), class=java.beans.PropertyDescriptor[name=class; propertyType=class java.lang.Class; readMethod=public final native java.lang.Class java.lang.Object.getClass()], keySet=public java.util.Set java.util.LinkedHashMap.keySet(), java.lang.Object@1c0f21d=freemarker.ext.beans.OverloadedMethods@d4b988, entrySet=public java.util.Set java.util.LinkedHashMap.entrySet(), java.lang.Object@15be27d=public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object), forEach=public void java.util.LinkedHashMap.forEach(java.util.function.BiConsumer), containsKey=public boolean java.util.HashMap.containsKey(java.lang.Object), isEmpty=public boolean java.util.HashMap.isEmpty(), clear=public void java.util.LinkedHashMap.clear(), computeIfPresent=public java.lang.Object java.util.HashMap.computeIfPresent(java.lang.Object,java.util.function.BiFunction), size=public int java.util.HashMap.size(), equals=public boolean java.util.AbstractMap.equals(java.lang.Object), clone=public java.lang.Object java.util.HashMap.clone(), toString=public java.lang.String java.util.AbstractMap.toString(), putIfAbsent=public java.lang.Object java.util.HashMap.putIfAbsent(java.lang.Object,java.lang.Object)}
[DEBUG] 2017-05-24: 21:05:33 freemarker.log._Log4jLoggerFactory$Log4jLogger.debug(_Log4jLoggerFactory.java:45) :  Key "onmousemove" was not found on instance of java.util.LinkedHashMap. Introspection information for the class is: {getClass=public final native java.lang.Class java.lang.Object.getClass(), getOrDefault=public java.lang.Object java.util.LinkedHashMap.getOrDefault(java.lang.Object,java.lang.Object), computeIfAbsent=public java.lang.Object java.util.HashMap.computeIfAbsent(java.lang.Object,java.util.function.Function), values=public java.util.Collection java.util.LinkedHashMap.values(), replace=freemarker.ext.beans.OverloadedMethods@11d0265, java.lang.Object@3e55b2={public boolean java.util.HashMap.isEmpty()=[Ljava.lang.Class;@c5aa3a, public int java.util.AbstractMap.hashCode()=[Ljava.lang.Class;@74a947, public java.lang.Object java.util.HashMap.put(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@1615a91, public boolean java.util.AbstractMap.equals(java.lang.Object)=[Ljava.lang.Class;@a46ab2, public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object)=[Ljava.lang.Class;@1c389e6, public java.lang.String java.util.AbstractMap.toString()=[Ljava.lang.Class;@a23548, public boolean java.util.HashMap.containsKey(java.lang.Object)=[Ljava.lang.Class;@1be4a9f, public java.util.Set java.util.LinkedHashMap.keySet()=[Ljava.lang.Class;@44c60, public java.lang.Object java.util.HashMap.computeIfAbsent(java.lang.Object,java.util.function.Function)=[Ljava.lang.Class;@10f7dff, public java.lang.Object java.util.HashMap.clone()=[Ljava.lang.Class;@d214e3, public java.lang.Object java.util.LinkedHashMap.getOrDefault(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@1a74254, public java.util.Set java.util.LinkedHashMap.entrySet()=[Ljava.lang.Class;@1c4740c, public void java.util.LinkedHashMap.forEach(java.util.function.BiConsumer)=[Ljava.lang.Class;@1fe0c8e, public java.lang.Object java.util.HashMap.putIfAbsent(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@16f73de, public java.util.Collection java.util.LinkedHashMap.values()=[Ljava.lang.Class;@b3e45, public void java.util.LinkedHashMap.clear()=[Ljava.lang.Class;@a34e5c, public java.lang.Object java.util.HashMap.computeIfPresent(java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1fcb13a, public java.lang.Object java.util.HashMap.compute(java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1a7c258, public final native java.lang.Class java.lang.Object.getClass()=[Ljava.lang.Class;@7397f, public void java.util.HashMap.putAll(java.util.Map)=[Ljava.lang.Class;@59cd, public void java.util.LinkedHashMap.replaceAll(java.util.function.BiFunction)=[Ljava.lang.Class;@994816, public java.lang.Object java.util.HashMap.merge(java.lang.Object,java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1b1e75f, public int java.util.HashMap.size()=[Ljava.lang.Class;@bee157, public boolean java.util.LinkedHashMap.containsValue(java.lang.Object)=[Ljava.lang.Class;@5e0d7c}, replaceAll=public void java.util.LinkedHashMap.replaceAll(java.util.function.BiFunction), remove=freemarker.ext.beans.OverloadedMethods@8d3a99, containsValue=public boolean java.util.LinkedHashMap.containsValue(java.lang.Object), put=public java.lang.Object java.util.HashMap.put(java.lang.Object,java.lang.Object), empty=java.beans.PropertyDescriptor[name=empty; propertyType=boolean; readMethod=public boolean java.util.HashMap.isEmpty()], compute=public java.lang.Object java.util.HashMap.compute(java.lang.Object,java.util.function.BiFunction), hashCode=public int java.util.AbstractMap.hashCode(), putAll=public void java.util.HashMap.putAll(java.util.Map), get=public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object), merge=public java.lang.Object java.util.HashMap.merge(java.lang.Object,java.lang.Object,java.util.function.BiFunction), class=java.beans.PropertyDescriptor[name=class; propertyType=class java.lang.Class; readMethod=public final native java.lang.Class java.lang.Object.getClass()], keySet=public java.util.Set java.util.LinkedHashMap.keySet(), java.lang.Object@1c0f21d=freemarker.ext.beans.OverloadedMethods@d4b988, entrySet=public java.util.Set java.util.LinkedHashMap.entrySet(), java.lang.Object@15be27d=public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object), forEach=public void java.util.LinkedHashMap.forEach(java.util.function.BiConsumer), containsKey=public boolean java.util.HashMap.containsKey(java.lang.Object), isEmpty=public boolean java.util.HashMap.isEmpty(), clear=public void java.util.LinkedHashMap.clear(), computeIfPresent=public java.lang.Object java.util.HashMap.computeIfPresent(java.lang.Object,java.util.function.BiFunction), size=public int java.util.HashMap.size(), equals=public boolean java.util.AbstractMap.equals(java.lang.Object), clone=public java.lang.Object java.util.HashMap.clone(), toString=public java.lang.String java.util.AbstractMap.toString(), putIfAbsent=public java.lang.Object java.util.HashMap.putIfAbsent(java.lang.Object,java.lang.Object)}
[DEBUG] 2017-05-24: 21:05:33 freemarker.log._Log4jLoggerFactory$Log4jLogger.debug(_Log4jLoggerFactory.java:45) :  Key "onmouseout" was not found on instance of java.util.LinkedHashMap. Introspection information for the class is: {getClass=public final native java.lang.Class java.lang.Object.getClass(), getOrDefault=public java.lang.Object java.util.LinkedHashMap.getOrDefault(java.lang.Object,java.lang.Object), computeIfAbsent=public java.lang.Object java.util.HashMap.computeIfAbsent(java.lang.Object,java.util.function.Function), values=public java.util.Collection java.util.LinkedHashMap.values(), replace=freemarker.ext.beans.OverloadedMethods@11d0265, java.lang.Object@3e55b2={public boolean java.util.HashMap.isEmpty()=[Ljava.lang.Class;@c5aa3a, public int java.util.AbstractMap.hashCode()=[Ljava.lang.Class;@74a947, public java.lang.Object java.util.HashMap.put(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@1615a91, public boolean java.util.AbstractMap.equals(java.lang.Object)=[Ljava.lang.Class;@a46ab2, public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object)=[Ljava.lang.Class;@1c389e6, public java.lang.String java.util.AbstractMap.toString()=[Ljava.lang.Class;@a23548, public boolean java.util.HashMap.containsKey(java.lang.Object)=[Ljava.lang.Class;@1be4a9f, public java.util.Set java.util.LinkedHashMap.keySet()=[Ljava.lang.Class;@44c60, public java.lang.Object java.util.HashMap.computeIfAbsent(java.lang.Object,java.util.function.Function)=[Ljava.lang.Class;@10f7dff, public java.lang.Object java.util.HashMap.clone()=[Ljava.lang.Class;@d214e3, public java.lang.Object java.util.LinkedHashMap.getOrDefault(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@1a74254, public java.util.Set java.util.LinkedHashMap.entrySet()=[Ljava.lang.Class;@1c4740c, public void java.util.LinkedHashMap.forEach(java.util.function.BiConsumer)=[Ljava.lang.Class;@1fe0c8e, public java.lang.Object java.util.HashMap.putIfAbsent(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@16f73de, public java.util.Collection java.util.LinkedHashMap.values()=[Ljava.lang.Class;@b3e45, public void java.util.LinkedHashMap.clear()=[Ljava.lang.Class;@a34e5c, public java.lang.Object java.util.HashMap.computeIfPresent(java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1fcb13a, public java.lang.Object java.util.HashMap.compute(java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1a7c258, public final native java.lang.Class java.lang.Object.getClass()=[Ljava.lang.Class;@7397f, public void java.util.HashMap.putAll(java.util.Map)=[Ljava.lang.Class;@59cd, public void java.util.LinkedHashMap.replaceAll(java.util.function.BiFunction)=[Ljava.lang.Class;@994816, public java.lang.Object java.util.HashMap.merge(java.lang.Object,java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1b1e75f, public int java.util.HashMap.size()=[Ljava.lang.Class;@bee157, public boolean java.util.LinkedHashMap.containsValue(java.lang.Object)=[Ljava.lang.Class;@5e0d7c}, replaceAll=public void java.util.LinkedHashMap.replaceAll(java.util.function.BiFunction), remove=freemarker.ext.beans.OverloadedMethods@8d3a99, containsValue=public boolean java.util.LinkedHashMap.containsValue(java.lang.Object), put=public java.lang.Object java.util.HashMap.put(java.lang.Object,java.lang.Object), empty=java.beans.PropertyDescriptor[name=empty; propertyType=boolean; readMethod=public boolean java.util.HashMap.isEmpty()], compute=public java.lang.Object java.util.HashMap.compute(java.lang.Object,java.util.function.BiFunction), hashCode=public int java.util.AbstractMap.hashCode(), putAll=public void java.util.HashMap.putAll(java.util.Map), get=public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object), merge=public java.lang.Object java.util.HashMap.merge(java.lang.Object,java.lang.Object,java.util.function.BiFunction), class=java.beans.PropertyDescriptor[name=class; propertyType=class java.lang.Class; readMethod=public final native java.lang.Class java.lang.Object.getClass()], keySet=public java.util.Set java.util.LinkedHashMap.keySet(), java.lang.Object@1c0f21d=freemarker.ext.beans.OverloadedMethods@d4b988, entrySet=public java.util.Set java.util.LinkedHashMap.entrySet(), java.lang.Object@15be27d=public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object), forEach=public void java.util.LinkedHashMap.forEach(java.util.function.BiConsumer), containsKey=public boolean java.util.HashMap.containsKey(java.lang.Object), isEmpty=public boolean java.util.HashMap.isEmpty(), clear=public void java.util.LinkedHashMap.clear(), computeIfPresent=public java.lang.Object java.util.HashMap.computeIfPresent(java.lang.Object,java.util.function.BiFunction), size=public int java.util.HashMap.size(), equals=public boolean java.util.AbstractMap.equals(java.lang.Object), clone=public java.lang.Object java.util.HashMap.clone(), toString=public java.lang.String java.util.AbstractMap.toString(), putIfAbsent=public java.lang.Object java.util.HashMap.putIfAbsent(java.lang.Object,java.lang.Object)}
[DEBUG] 2017-05-24: 21:05:33 freemarker.log._Log4jLoggerFactory$Log4jLogger.debug(_Log4jLoggerFactory.java:45) :  Key "onfocus" was not found on instance of java.util.LinkedHashMap. Introspection information for the class is: {getClass=public final native java.lang.Class java.lang.Object.getClass(), getOrDefault=public java.lang.Object java.util.LinkedHashMap.getOrDefault(java.lang.Object,java.lang.Object), computeIfAbsent=public java.lang.Object java.util.HashMap.computeIfAbsent(java.lang.Object,java.util.function.Function), values=public java.util.Collection java.util.LinkedHashMap.values(), replace=freemarker.ext.beans.OverloadedMethods@11d0265, java.lang.Object@3e55b2={public boolean java.util.HashMap.isEmpty()=[Ljava.lang.Class;@c5aa3a, public int java.util.AbstractMap.hashCode()=[Ljava.lang.Class;@74a947, public java.lang.Object java.util.HashMap.put(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@1615a91, public boolean java.util.AbstractMap.equals(java.lang.Object)=[Ljava.lang.Class;@a46ab2, public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object)=[Ljava.lang.Class;@1c389e6, public java.lang.String java.util.AbstractMap.toString()=[Ljava.lang.Class;@a23548, public boolean java.util.HashMap.containsKey(java.lang.Object)=[Ljava.lang.Class;@1be4a9f, public java.util.Set java.util.LinkedHashMap.keySet()=[Ljava.lang.Class;@44c60, public java.lang.Object java.util.HashMap.computeIfAbsent(java.lang.Object,java.util.function.Function)=[Ljava.lang.Class;@10f7dff, public java.lang.Object java.util.HashMap.clone()=[Ljava.lang.Class;@d214e3, public java.lang.Object java.util.LinkedHashMap.getOrDefault(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@1a74254, public java.util.Set java.util.LinkedHashMap.entrySet()=[Ljava.lang.Class;@1c4740c, public void java.util.LinkedHashMap.forEach(java.util.function.BiConsumer)=[Ljava.lang.Class;@1fe0c8e, public java.lang.Object java.util.HashMap.putIfAbsent(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@16f73de, public java.util.Collection java.util.LinkedHashMap.values()=[Ljava.lang.Class;@b3e45, public void java.util.LinkedHashMap.clear()=[Ljava.lang.Class;@a34e5c, public java.lang.Object java.util.HashMap.computeIfPresent(java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1fcb13a, public java.lang.Object java.util.HashMap.compute(java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1a7c258, public final native java.lang.Class java.lang.Object.getClass()=[Ljava.lang.Class;@7397f, public void java.util.HashMap.putAll(java.util.Map)=[Ljava.lang.Class;@59cd, public void java.util.LinkedHashMap.replaceAll(java.util.function.BiFunction)=[Ljava.lang.Class;@994816, public java.lang.Object java.util.HashMap.merge(java.lang.Object,java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1b1e75f, public int java.util.HashMap.size()=[Ljava.lang.Class;@bee157, public boolean java.util.LinkedHashMap.containsValue(java.lang.Object)=[Ljava.lang.Class;@5e0d7c}, replaceAll=public void java.util.LinkedHashMap.replaceAll(java.util.function.BiFunction), remove=freemarker.ext.beans.OverloadedMethods@8d3a99, containsValue=public boolean java.util.LinkedHashMap.containsValue(java.lang.Object), put=public java.lang.Object java.util.HashMap.put(java.lang.Object,java.lang.Object), empty=java.beans.PropertyDescriptor[name=empty; propertyType=boolean; readMethod=public boolean java.util.HashMap.isEmpty()], compute=public java.lang.Object java.util.HashMap.compute(java.lang.Object,java.util.function.BiFunction), hashCode=public int java.util.AbstractMap.hashCode(), putAll=public void java.util.HashMap.putAll(java.util.Map), get=public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object), merge=public java.lang.Object java.util.HashMap.merge(java.lang.Object,java.lang.Object,java.util.function.BiFunction), class=java.beans.PropertyDescriptor[name=class; propertyType=class java.lang.Class; readMethod=public final native java.lang.Class java.lang.Object.getClass()], keySet=public java.util.Set java.util.LinkedHashMap.keySet(), java.lang.Object@1c0f21d=freemarker.ext.beans.OverloadedMethods@d4b988, entrySet=public java.util.Set java.util.LinkedHashMap.entrySet(), java.lang.Object@15be27d=public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object), forEach=public void java.util.LinkedHashMap.forEach(java.util.function.BiConsumer), containsKey=public boolean java.util.HashMap.containsKey(java.lang.Object), isEmpty=public boolean java.util.HashMap.isEmpty(), clear=public void java.util.LinkedHashMap.clear(), computeIfPresent=public java.lang.Object java.util.HashMap.computeIfPresent(java.lang.Object,java.util.function.BiFunction), size=public int java.util.HashMap.size(), equals=public boolean java.util.AbstractMap.equals(java.lang.Object), clone=public java.lang.Object java.util.HashMap.clone(), toString=public java.lang.String java.util.AbstractMap.toString(), putIfAbsent=public java.lang.Object java.util.HashMap.putIfAbsent(java.lang.Object,java.lang.Object)}
[DEBUG] 2017-05-24: 21:05:33 freemarker.log._Log4jLoggerFactory$Log4jLogger.debug(_Log4jLoggerFactory.java:45) :  Key "onblur" was not found on instance of java.util.LinkedHashMap. Introspection information for the class is: {getClass=public final native java.lang.Class java.lang.Object.getClass(), getOrDefault=public java.lang.Object java.util.LinkedHashMap.getOrDefault(java.lang.Object,java.lang.Object), computeIfAbsent=public java.lang.Object java.util.HashMap.computeIfAbsent(java.lang.Object,java.util.function.Function), values=public java.util.Collection java.util.LinkedHashMap.values(), replace=freemarker.ext.beans.OverloadedMethods@11d0265, java.lang.Object@3e55b2={public boolean java.util.HashMap.isEmpty()=[Ljava.lang.Class;@c5aa3a, public int java.util.AbstractMap.hashCode()=[Ljava.lang.Class;@74a947, public java.lang.Object java.util.HashMap.put(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@1615a91, public boolean java.util.AbstractMap.equals(java.lang.Object)=[Ljava.lang.Class;@a46ab2, public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object)=[Ljava.lang.Class;@1c389e6, public java.lang.String java.util.AbstractMap.toString()=[Ljava.lang.Class;@a23548, public boolean java.util.HashMap.containsKey(java.lang.Object)=[Ljava.lang.Class;@1be4a9f, public java.util.Set java.util.LinkedHashMap.keySet()=[Ljava.lang.Class;@44c60, public java.lang.Object java.util.HashMap.computeIfAbsent(java.lang.Object,java.util.function.Function)=[Ljava.lang.Class;@10f7dff, public java.lang.Object java.util.HashMap.clone()=[Ljava.lang.Class;@d214e3, public java.lang.Object java.util.LinkedHashMap.getOrDefault(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@1a74254, public java.util.Set java.util.LinkedHashMap.entrySet()=[Ljava.lang.Class;@1c4740c, public void java.util.LinkedHashMap.forEach(java.util.function.BiConsumer)=[Ljava.lang.Class;@1fe0c8e, public java.lang.Object java.util.HashMap.putIfAbsent(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@16f73de, public java.util.Collection java.util.LinkedHashMap.values()=[Ljava.lang.Class;@b3e45, public void java.util.LinkedHashMap.clear()=[Ljava.lang.Class;@a34e5c, public java.lang.Object java.util.HashMap.computeIfPresent(java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1fcb13a, public java.lang.Object java.util.HashMap.compute(java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1a7c258, public final native java.lang.Class java.lang.Object.getClass()=[Ljava.lang.Class;@7397f, public void java.util.HashMap.putAll(java.util.Map)=[Ljava.lang.Class;@59cd, public void java.util.LinkedHashMap.replaceAll(java.util.function.BiFunction)=[Ljava.lang.Class;@994816, public java.lang.Object java.util.HashMap.merge(java.lang.Object,java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1b1e75f, public int java.util.HashMap.size()=[Ljava.lang.Class;@bee157, public boolean java.util.LinkedHashMap.containsValue(java.lang.Object)=[Ljava.lang.Class;@5e0d7c}, replaceAll=public void java.util.LinkedHashMap.replaceAll(java.util.function.BiFunction), remove=freemarker.ext.beans.OverloadedMethods@8d3a99, containsValue=public boolean java.util.LinkedHashMap.containsValue(java.lang.Object), put=public java.lang.Object java.util.HashMap.put(java.lang.Object,java.lang.Object), empty=java.beans.PropertyDescriptor[name=empty; propertyType=boolean; readMethod=public boolean java.util.HashMap.isEmpty()], compute=public java.lang.Object java.util.HashMap.compute(java.lang.Object,java.util.function.BiFunction), hashCode=public int java.util.AbstractMap.hashCode(), putAll=public void java.util.HashMap.putAll(java.util.Map), get=public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object), merge=public java.lang.Object java.util.HashMap.merge(java.lang.Object,java.lang.Object,java.util.function.BiFunction), class=java.beans.PropertyDescriptor[name=class; propertyType=class java.lang.Class; readMethod=public final native java.lang.Class java.lang.Object.getClass()], keySet=public java.util.Set java.util.LinkedHashMap.keySet(), java.lang.Object@1c0f21d=freemarker.ext.beans.OverloadedMethods@d4b988, entrySet=public java.util.Set java.util.LinkedHashMap.entrySet(), java.lang.Object@15be27d=public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object), forEach=public void java.util.LinkedHashMap.forEach(java.util.function.BiConsumer), containsKey=public boolean java.util.HashMap.containsKey(java.lang.Object), isEmpty=public boolean java.util.HashMap.isEmpty(), clear=public void java.util.LinkedHashMap.clear(), computeIfPresent=public java.lang.Object java.util.HashMap.computeIfPresent(java.lang.Object,java.util.function.BiFunction), size=public int java.util.HashMap.size(), equals=public boolean java.util.AbstractMap.equals(java.lang.Object), clone=public java.lang.Object java.util.HashMap.clone(), toString=public java.lang.String java.util.AbstractMap.toString(), putIfAbsent=public java.lang.Object java.util.HashMap.putIfAbsent(java.lang.Object,java.lang.Object)}
[DEBUG] 2017-05-24: 21:05:33 freemarker.log._Log4jLoggerFactory$Log4jLogger.debug(_Log4jLoggerFactory.java:45) :  Key "onkeypress" was not found on instance of java.util.LinkedHashMap. Introspection information for the class is: {getClass=public final native java.lang.Class java.lang.Object.getClass(), getOrDefault=public java.lang.Object java.util.LinkedHashMap.getOrDefault(java.lang.Object,java.lang.Object), computeIfAbsent=public java.lang.Object java.util.HashMap.computeIfAbsent(java.lang.Object,java.util.function.Function), values=public java.util.Collection java.util.LinkedHashMap.values(), replace=freemarker.ext.beans.OverloadedMethods@11d0265, java.lang.Object@3e55b2={public boolean java.util.HashMap.isEmpty()=[Ljava.lang.Class;@c5aa3a, public int java.util.AbstractMap.hashCode()=[Ljava.lang.Class;@74a947, public java.lang.Object java.util.HashMap.put(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@1615a91, public boolean java.util.AbstractMap.equals(java.lang.Object)=[Ljava.lang.Class;@a46ab2, public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object)=[Ljava.lang.Class;@1c389e6, public java.lang.String java.util.AbstractMap.toString()=[Ljava.lang.Class;@a23548, public boolean java.util.HashMap.containsKey(java.lang.Object)=[Ljava.lang.Class;@1be4a9f, public java.util.Set java.util.LinkedHashMap.keySet()=[Ljava.lang.Class;@44c60, public java.lang.Object java.util.HashMap.computeIfAbsent(java.lang.Object,java.util.function.Function)=[Ljava.lang.Class;@10f7dff, public java.lang.Object java.util.HashMap.clone()=[Ljava.lang.Class;@d214e3, public java.lang.Object java.util.LinkedHashMap.getOrDefault(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@1a74254, public java.util.Set java.util.LinkedHashMap.entrySet()=[Ljava.lang.Class;@1c4740c, public void java.util.LinkedHashMap.forEach(java.util.function.BiConsumer)=[Ljava.lang.Class;@1fe0c8e, public java.lang.Object java.util.HashMap.putIfAbsent(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@16f73de, public java.util.Collection java.util.LinkedHashMap.values()=[Ljava.lang.Class;@b3e45, public void java.util.LinkedHashMap.clear()=[Ljava.lang.Class;@a34e5c, public java.lang.Object java.util.HashMap.computeIfPresent(java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1fcb13a, public java.lang.Object java.util.HashMap.compute(java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1a7c258, public final native java.lang.Class java.lang.Object.getClass()=[Ljava.lang.Class;@7397f, public void java.util.HashMap.putAll(java.util.Map)=[Ljava.lang.Class;@59cd, public void java.util.LinkedHashMap.replaceAll(java.util.function.BiFunction)=[Ljava.lang.Class;@994816, public java.lang.Object java.util.HashMap.merge(java.lang.Object,java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1b1e75f, public int java.util.HashMap.size()=[Ljava.lang.Class;@bee157, public boolean java.util.LinkedHashMap.containsValue(java.lang.Object)=[Ljava.lang.Class;@5e0d7c}, replaceAll=public void java.util.LinkedHashMap.replaceAll(java.util.function.BiFunction), remove=freemarker.ext.beans.OverloadedMethods@8d3a99, containsValue=public boolean java.util.LinkedHashMap.containsValue(java.lang.Object), put=public java.lang.Object java.util.HashMap.put(java.lang.Object,java.lang.Object), empty=java.beans.PropertyDescriptor[name=empty; propertyType=boolean; readMethod=public boolean java.util.HashMap.isEmpty()], compute=public java.lang.Object java.util.HashMap.compute(java.lang.Object,java.util.function.BiFunction), hashCode=public int java.util.AbstractMap.hashCode(), putAll=public void java.util.HashMap.putAll(java.util.Map), get=public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object), merge=public java.lang.Object java.util.HashMap.merge(java.lang.Object,java.lang.Object,java.util.function.BiFunction), class=java.beans.PropertyDescriptor[name=class; propertyType=class java.lang.Class; readMethod=public final native java.lang.Class java.lang.Object.getClass()], keySet=public java.util.Set java.util.LinkedHashMap.keySet(), java.lang.Object@1c0f21d=freemarker.ext.beans.OverloadedMethods@d4b988, entrySet=public java.util.Set java.util.LinkedHashMap.entrySet(), java.lang.Object@15be27d=public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object), forEach=public void java.util.LinkedHashMap.forEach(java.util.function.BiConsumer), containsKey=public boolean java.util.HashMap.containsKey(java.lang.Object), isEmpty=public boolean java.util.HashMap.isEmpty(), clear=public void java.util.LinkedHashMap.clear(), computeIfPresent=public java.lang.Object java.util.HashMap.computeIfPresent(java.lang.Object,java.util.function.BiFunction), size=public int java.util.HashMap.size(), equals=public boolean java.util.AbstractMap.equals(java.lang.Object), clone=public java.lang.Object java.util.HashMap.clone(), toString=public java.lang.String java.util.AbstractMap.toString(), putIfAbsent=public java.lang.Object java.util.HashMap.putIfAbsent(java.lang.Object,java.lang.Object)}
[DEBUG] 2017-05-24: 21:05:33 freemarker.log._Log4jLoggerFactory$Log4jLogger.debug(_Log4jLoggerFactory.java:45) :  Key "onkeydown" was not found on instance of java.util.LinkedHashMap. Introspection information for the class is: {getClass=public final native java.lang.Class java.lang.Object.getClass(), getOrDefault=public java.lang.Object java.util.LinkedHashMap.getOrDefault(java.lang.Object,java.lang.Object), computeIfAbsent=public java.lang.Object java.util.HashMap.computeIfAbsent(java.lang.Object,java.util.function.Function), values=public java.util.Collection java.util.LinkedHashMap.values(), replace=freemarker.ext.beans.OverloadedMethods@11d0265, java.lang.Object@3e55b2={public boolean java.util.HashMap.isEmpty()=[Ljava.lang.Class;@c5aa3a, public int java.util.AbstractMap.hashCode()=[Ljava.lang.Class;@74a947, public java.lang.Object java.util.HashMap.put(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@1615a91, public boolean java.util.AbstractMap.equals(java.lang.Object)=[Ljava.lang.Class;@a46ab2, public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object)=[Ljava.lang.Class;@1c389e6, public java.lang.String java.util.AbstractMap.toString()=[Ljava.lang.Class;@a23548, public boolean java.util.HashMap.containsKey(java.lang.Object)=[Ljava.lang.Class;@1be4a9f, public java.util.Set java.util.LinkedHashMap.keySet()=[Ljava.lang.Class;@44c60, public java.lang.Object java.util.HashMap.computeIfAbsent(java.lang.Object,java.util.function.Function)=[Ljava.lang.Class;@10f7dff, public java.lang.Object java.util.HashMap.clone()=[Ljava.lang.Class;@d214e3, public java.lang.Object java.util.LinkedHashMap.getOrDefault(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@1a74254, public java.util.Set java.util.LinkedHashMap.entrySet()=[Ljava.lang.Class;@1c4740c, public void java.util.LinkedHashMap.forEach(java.util.function.BiConsumer)=[Ljava.lang.Class;@1fe0c8e, public java.lang.Object java.util.HashMap.putIfAbsent(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@16f73de, public java.util.Collection java.util.LinkedHashMap.values()=[Ljava.lang.Class;@b3e45, public void java.util.LinkedHashMap.clear()=[Ljava.lang.Class;@a34e5c, public java.lang.Object java.util.HashMap.computeIfPresent(java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1fcb13a, public java.lang.Object java.util.HashMap.compute(java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1a7c258, public final native java.lang.Class java.lang.Object.getClass()=[Ljava.lang.Class;@7397f, public void java.util.HashMap.putAll(java.util.Map)=[Ljava.lang.Class;@59cd, public void java.util.LinkedHashMap.replaceAll(java.util.function.BiFunction)=[Ljava.lang.Class;@994816, public java.lang.Object java.util.HashMap.merge(java.lang.Object,java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1b1e75f, public int java.util.HashMap.size()=[Ljava.lang.Class;@bee157, public boolean java.util.LinkedHashMap.containsValue(java.lang.Object)=[Ljava.lang.Class;@5e0d7c}, replaceAll=public void java.util.LinkedHashMap.replaceAll(java.util.function.BiFunction), remove=freemarker.ext.beans.OverloadedMethods@8d3a99, containsValue=public boolean java.util.LinkedHashMap.containsValue(java.lang.Object), put=public java.lang.Object java.util.HashMap.put(java.lang.Object,java.lang.Object), empty=java.beans.PropertyDescriptor[name=empty; propertyType=boolean; readMethod=public boolean java.util.HashMap.isEmpty()], compute=public java.lang.Object java.util.HashMap.compute(java.lang.Object,java.util.function.BiFunction), hashCode=public int java.util.AbstractMap.hashCode(), putAll=public void java.util.HashMap.putAll(java.util.Map), get=public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object), merge=public java.lang.Object java.util.HashMap.merge(java.lang.Object,java.lang.Object,java.util.function.BiFunction), class=java.beans.PropertyDescriptor[name=class; propertyType=class java.lang.Class; readMethod=public final native java.lang.Class java.lang.Object.getClass()], keySet=public java.util.Set java.util.LinkedHashMap.keySet(), java.lang.Object@1c0f21d=freemarker.ext.beans.OverloadedMethods@d4b988, entrySet=public java.util.Set java.util.LinkedHashMap.entrySet(), java.lang.Object@15be27d=public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object), forEach=public void java.util.LinkedHashMap.forEach(java.util.function.BiConsumer), containsKey=public boolean java.util.HashMap.containsKey(java.lang.Object), isEmpty=public boolean java.util.HashMap.isEmpty(), clear=public void java.util.LinkedHashMap.clear(), computeIfPresent=public java.lang.Object java.util.HashMap.computeIfPresent(java.lang.Object,java.util.function.BiFunction), size=public int java.util.HashMap.size(), equals=public boolean java.util.AbstractMap.equals(java.lang.Object), clone=public java.lang.Object java.util.HashMap.clone(), toString=public java.lang.String java.util.AbstractMap.toString(), putIfAbsent=public java.lang.Object java.util.HashMap.putIfAbsent(java.lang.Object,java.lang.Object)}
[DEBUG] 2017-05-24: 21:05:33 freemarker.log._Log4jLoggerFactory$Log4jLogger.debug(_Log4jLoggerFactory.java:45) :  Key "onkeyup" was not found on instance of java.util.LinkedHashMap. Introspection information for the class is: {getClass=public final native java.lang.Class java.lang.Object.getClass(), getOrDefault=public java.lang.Object java.util.LinkedHashMap.getOrDefault(java.lang.Object,java.lang.Object), computeIfAbsent=public java.lang.Object java.util.HashMap.computeIfAbsent(java.lang.Object,java.util.function.Function), values=public java.util.Collection java.util.LinkedHashMap.values(), replace=freemarker.ext.beans.OverloadedMethods@11d0265, java.lang.Object@3e55b2={public boolean java.util.HashMap.isEmpty()=[Ljava.lang.Class;@c5aa3a, public int java.util.AbstractMap.hashCode()=[Ljava.lang.Class;@74a947, public java.lang.Object java.util.HashMap.put(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@1615a91, public boolean java.util.AbstractMap.equals(java.lang.Object)=[Ljava.lang.Class;@a46ab2, public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object)=[Ljava.lang.Class;@1c389e6, public java.lang.String java.util.AbstractMap.toString()=[Ljava.lang.Class;@a23548, public boolean java.util.HashMap.containsKey(java.lang.Object)=[Ljava.lang.Class;@1be4a9f, public java.util.Set java.util.LinkedHashMap.keySet()=[Ljava.lang.Class;@44c60, public java.lang.Object java.util.HashMap.computeIfAbsent(java.lang.Object,java.util.function.Function)=[Ljava.lang.Class;@10f7dff, public java.lang.Object java.util.HashMap.clone()=[Ljava.lang.Class;@d214e3, public java.lang.Object java.util.LinkedHashMap.getOrDefault(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@1a74254, public java.util.Set java.util.LinkedHashMap.entrySet()=[Ljava.lang.Class;@1c4740c, public void java.util.LinkedHashMap.forEach(java.util.function.BiConsumer)=[Ljava.lang.Class;@1fe0c8e, public java.lang.Object java.util.HashMap.putIfAbsent(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@16f73de, public java.util.Collection java.util.LinkedHashMap.values()=[Ljava.lang.Class;@b3e45, public void java.util.LinkedHashMap.clear()=[Ljava.lang.Class;@a34e5c, public java.lang.Object java.util.HashMap.computeIfPresent(java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1fcb13a, public java.lang.Object java.util.HashMap.compute(java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1a7c258, public final native java.lang.Class java.lang.Object.getClass()=[Ljava.lang.Class;@7397f, public void java.util.HashMap.putAll(java.util.Map)=[Ljava.lang.Class;@59cd, public void java.util.LinkedHashMap.replaceAll(java.util.function.BiFunction)=[Ljava.lang.Class;@994816, public java.lang.Object java.util.HashMap.merge(java.lang.Object,java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1b1e75f, public int java.util.HashMap.size()=[Ljava.lang.Class;@bee157, public boolean java.util.LinkedHashMap.containsValue(java.lang.Object)=[Ljava.lang.Class;@5e0d7c}, replaceAll=public void java.util.LinkedHashMap.replaceAll(java.util.function.BiFunction), remove=freemarker.ext.beans.OverloadedMethods@8d3a99, containsValue=public boolean java.util.LinkedHashMap.containsValue(java.lang.Object), put=public java.lang.Object java.util.HashMap.put(java.lang.Object,java.lang.Object), empty=java.beans.PropertyDescriptor[name=empty; propertyType=boolean; readMethod=public boolean java.util.HashMap.isEmpty()], compute=public java.lang.Object java.util.HashMap.compute(java.lang.Object,java.util.function.BiFunction), hashCode=public int java.util.AbstractMap.hashCode(), putAll=public void java.util.HashMap.putAll(java.util.Map), get=public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object), merge=public java.lang.Object java.util.HashMap.merge(java.lang.Object,java.lang.Object,java.util.function.BiFunction), class=java.beans.PropertyDescriptor[name=class; propertyType=class java.lang.Class; readMethod=public final native java.lang.Class java.lang.Object.getClass()], keySet=public java.util.Set java.util.LinkedHashMap.keySet(), java.lang.Object@1c0f21d=freemarker.ext.beans.OverloadedMethods@d4b988, entrySet=public java.util.Set java.util.LinkedHashMap.entrySet(), java.lang.Object@15be27d=public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object), forEach=public void java.util.LinkedHashMap.forEach(java.util.function.BiConsumer), containsKey=public boolean java.util.HashMap.containsKey(java.lang.Object), isEmpty=public boolean java.util.HashMap.isEmpty(), clear=public void java.util.LinkedHashMap.clear(), computeIfPresent=public java.lang.Object java.util.HashMap.computeIfPresent(java.lang.Object,java.util.function.BiFunction), size=public int java.util.HashMap.size(), equals=public boolean java.util.AbstractMap.equals(java.lang.Object), clone=public java.lang.Object java.util.HashMap.clone(), toString=public java.lang.String java.util.AbstractMap.toString(), putIfAbsent=public java.lang.Object java.util.HashMap.putIfAbsent(java.lang.Object,java.lang.Object)}
[DEBUG] 2017-05-24: 21:05:33 freemarker.log._Log4jLoggerFactory$Log4jLogger.debug(_Log4jLoggerFactory.java:45) :  Key "onselect" was not found on instance of java.util.LinkedHashMap. Introspection information for the class is: {getClass=public final native java.lang.Class java.lang.Object.getClass(), getOrDefault=public java.lang.Object java.util.LinkedHashMap.getOrDefault(java.lang.Object,java.lang.Object), computeIfAbsent=public java.lang.Object java.util.HashMap.computeIfAbsent(java.lang.Object,java.util.function.Function), values=public java.util.Collection java.util.LinkedHashMap.values(), replace=freemarker.ext.beans.OverloadedMethods@11d0265, java.lang.Object@3e55b2={public boolean java.util.HashMap.isEmpty()=[Ljava.lang.Class;@c5aa3a, public int java.util.AbstractMap.hashCode()=[Ljava.lang.Class;@74a947, public java.lang.Object java.util.HashMap.put(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@1615a91, public boolean java.util.AbstractMap.equals(java.lang.Object)=[Ljava.lang.Class;@a46ab2, public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object)=[Ljava.lang.Class;@1c389e6, public java.lang.String java.util.AbstractMap.toString()=[Ljava.lang.Class;@a23548, public boolean java.util.HashMap.containsKey(java.lang.Object)=[Ljava.lang.Class;@1be4a9f, public java.util.Set java.util.LinkedHashMap.keySet()=[Ljava.lang.Class;@44c60, public java.lang.Object java.util.HashMap.computeIfAbsent(java.lang.Object,java.util.function.Function)=[Ljava.lang.Class;@10f7dff, public java.lang.Object java.util.HashMap.clone()=[Ljava.lang.Class;@d214e3, public java.lang.Object java.util.LinkedHashMap.getOrDefault(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@1a74254, public java.util.Set java.util.LinkedHashMap.entrySet()=[Ljava.lang.Class;@1c4740c, public void java.util.LinkedHashMap.forEach(java.util.function.BiConsumer)=[Ljava.lang.Class;@1fe0c8e, public java.lang.Object java.util.HashMap.putIfAbsent(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@16f73de, public java.util.Collection java.util.LinkedHashMap.values()=[Ljava.lang.Class;@b3e45, public void java.util.LinkedHashMap.clear()=[Ljava.lang.Class;@a34e5c, public java.lang.Object java.util.HashMap.computeIfPresent(java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1fcb13a, public java.lang.Object java.util.HashMap.compute(java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1a7c258, public final native java.lang.Class java.lang.Object.getClass()=[Ljava.lang.Class;@7397f, public void java.util.HashMap.putAll(java.util.Map)=[Ljava.lang.Class;@59cd, public void java.util.LinkedHashMap.replaceAll(java.util.function.BiFunction)=[Ljava.lang.Class;@994816, public java.lang.Object java.util.HashMap.merge(java.lang.Object,java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1b1e75f, public int java.util.HashMap.size()=[Ljava.lang.Class;@bee157, public boolean java.util.LinkedHashMap.containsValue(java.lang.Object)=[Ljava.lang.Class;@5e0d7c}, replaceAll=public void java.util.LinkedHashMap.replaceAll(java.util.function.BiFunction), remove=freemarker.ext.beans.OverloadedMethods@8d3a99, containsValue=public boolean java.util.LinkedHashMap.containsValue(java.lang.Object), put=public java.lang.Object java.util.HashMap.put(java.lang.Object,java.lang.Object), empty=java.beans.PropertyDescriptor[name=empty; propertyType=boolean; readMethod=public boolean java.util.HashMap.isEmpty()], compute=public java.lang.Object java.util.HashMap.compute(java.lang.Object,java.util.function.BiFunction), hashCode=public int java.util.AbstractMap.hashCode(), putAll=public void java.util.HashMap.putAll(java.util.Map), get=public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object), merge=public java.lang.Object java.util.HashMap.merge(java.lang.Object,java.lang.Object,java.util.function.BiFunction), class=java.beans.PropertyDescriptor[name=class; propertyType=class java.lang.Class; readMethod=public final native java.lang.Class java.lang.Object.getClass()], keySet=public java.util.Set java.util.LinkedHashMap.keySet(), java.lang.Object@1c0f21d=freemarker.ext.beans.OverloadedMethods@d4b988, entrySet=public java.util.Set java.util.LinkedHashMap.entrySet(), java.lang.Object@15be27d=public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object), forEach=public void java.util.LinkedHashMap.forEach(java.util.function.BiConsumer), containsKey=public boolean java.util.HashMap.containsKey(java.lang.Object), isEmpty=public boolean java.util.HashMap.isEmpty(), clear=public void java.util.LinkedHashMap.clear(), computeIfPresent=public java.lang.Object java.util.HashMap.computeIfPresent(java.lang.Object,java.util.function.BiFunction), size=public int java.util.HashMap.size(), equals=public boolean java.util.AbstractMap.equals(java.lang.Object), clone=public java.lang.Object java.util.HashMap.clone(), toString=public java.lang.String java.util.AbstractMap.toString(), putIfAbsent=public java.lang.Object java.util.HashMap.putIfAbsent(java.lang.Object,java.lang.Object)}
[DEBUG] 2017-05-24: 21:05:33 freemarker.log._Log4jLoggerFactory$Log4jLogger.debug(_Log4jLoggerFactory.java:45) :  Key "onchange" was not found on instance of java.util.LinkedHashMap. Introspection information for the class is: {getClass=public final native java.lang.Class java.lang.Object.getClass(), getOrDefault=public java.lang.Object java.util.LinkedHashMap.getOrDefault(java.lang.Object,java.lang.Object), computeIfAbsent=public java.lang.Object java.util.HashMap.computeIfAbsent(java.lang.Object,java.util.function.Function), values=public java.util.Collection java.util.LinkedHashMap.values(), replace=freemarker.ext.beans.OverloadedMethods@11d0265, java.lang.Object@3e55b2={public boolean java.util.HashMap.isEmpty()=[Ljava.lang.Class;@c5aa3a, public int java.util.AbstractMap.hashCode()=[Ljava.lang.Class;@74a947, public java.lang.Object java.util.HashMap.put(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@1615a91, public boolean java.util.AbstractMap.equals(java.lang.Object)=[Ljava.lang.Class;@a46ab2, public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object)=[Ljava.lang.Class;@1c389e6, public java.lang.String java.util.AbstractMap.toString()=[Ljava.lang.Class;@a23548, public boolean java.util.HashMap.containsKey(java.lang.Object)=[Ljava.lang.Class;@1be4a9f, public java.util.Set java.util.LinkedHashMap.keySet()=[Ljava.lang.Class;@44c60, public java.lang.Object java.util.HashMap.computeIfAbsent(java.lang.Object,java.util.function.Function)=[Ljava.lang.Class;@10f7dff, public java.lang.Object java.util.HashMap.clone()=[Ljava.lang.Class;@d214e3, public java.lang.Object java.util.LinkedHashMap.getOrDefault(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@1a74254, public java.util.Set java.util.LinkedHashMap.entrySet()=[Ljava.lang.Class;@1c4740c, public void java.util.LinkedHashMap.forEach(java.util.function.BiConsumer)=[Ljava.lang.Class;@1fe0c8e, public java.lang.Object java.util.HashMap.putIfAbsent(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@16f73de, public java.util.Collection java.util.LinkedHashMap.values()=[Ljava.lang.Class;@b3e45, public void java.util.LinkedHashMap.clear()=[Ljava.lang.Class;@a34e5c, public java.lang.Object java.util.HashMap.computeIfPresent(java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1fcb13a, public java.lang.Object java.util.HashMap.compute(java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1a7c258, public final native java.lang.Class java.lang.Object.getClass()=[Ljava.lang.Class;@7397f, public void java.util.HashMap.putAll(java.util.Map)=[Ljava.lang.Class;@59cd, public void java.util.LinkedHashMap.replaceAll(java.util.function.BiFunction)=[Ljava.lang.Class;@994816, public java.lang.Object java.util.HashMap.merge(java.lang.Object,java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1b1e75f, public int java.util.HashMap.size()=[Ljava.lang.Class;@bee157, public boolean java.util.LinkedHashMap.containsValue(java.lang.Object)=[Ljava.lang.Class;@5e0d7c}, replaceAll=public void java.util.LinkedHashMap.replaceAll(java.util.function.BiFunction), remove=freemarker.ext.beans.OverloadedMethods@8d3a99, containsValue=public boolean java.util.LinkedHashMap.containsValue(java.lang.Object), put=public java.lang.Object java.util.HashMap.put(java.lang.Object,java.lang.Object), empty=java.beans.PropertyDescriptor[name=empty; propertyType=boolean; readMethod=public boolean java.util.HashMap.isEmpty()], compute=public java.lang.Object java.util.HashMap.compute(java.lang.Object,java.util.function.BiFunction), hashCode=public int java.util.AbstractMap.hashCode(), putAll=public void java.util.HashMap.putAll(java.util.Map), get=public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object), merge=public java.lang.Object java.util.HashMap.merge(java.lang.Object,java.lang.Object,java.util.function.BiFunction), class=java.beans.PropertyDescriptor[name=class; propertyType=class java.lang.Class; readMethod=public final native java.lang.Class java.lang.Object.getClass()], keySet=public java.util.Set java.util.LinkedHashMap.keySet(), java.lang.Object@1c0f21d=freemarker.ext.beans.OverloadedMethods@d4b988, entrySet=public java.util.Set java.util.LinkedHashMap.entrySet(), java.lang.Object@15be27d=public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object), forEach=public void java.util.LinkedHashMap.forEach(java.util.function.BiConsumer), containsKey=public boolean java.util.HashMap.containsKey(java.lang.Object), isEmpty=public boolean java.util.HashMap.isEmpty(), clear=public void java.util.LinkedHashMap.clear(), computeIfPresent=public java.lang.Object java.util.HashMap.computeIfPresent(java.lang.Object,java.util.function.BiFunction), size=public int java.util.HashMap.size(), equals=public boolean java.util.AbstractMap.equals(java.lang.Object), clone=public java.lang.Object java.util.HashMap.clone(), toString=public java.lang.String java.util.AbstractMap.toString(), putIfAbsent=public java.lang.Object java.util.HashMap.putIfAbsent(java.lang.Object,java.lang.Object)}
[DEBUG] 2017-05-24: 21:05:33 freemarker.log._Log4jLoggerFactory$Log4jLogger.debug(_Log4jLoggerFactory.java:45) :  TemplateLoader.findTemplateSource("template/~~~xhtml/common-attributes.ftl"): Found
[DEBUG] 2017-05-24: 21:05:33 freemarker.log._Log4jLoggerFactory$Log4jLogger.debug(_Log4jLoggerFactory.java:45) :  "template/~~~xhtml/common-attributes.ftl"("zh_CN", UTF-8, parsed): using cached since jar:file:/D:/maven/repository/org/apache/struts/struts2-core/2.5.10/struts2-core-2.5.10.jar!/template/simple/common-attributes.ftl hasn't changed.
[DEBUG] 2017-05-24: 21:05:33 freemarker.log._Log4jLoggerFactory$Log4jLogger.debug(_Log4jLoggerFactory.java:45) :  Key "accesskey" was not found on instance of java.util.LinkedHashMap. Introspection information for the class is: {getClass=public final native java.lang.Class java.lang.Object.getClass(), getOrDefault=public java.lang.Object java.util.LinkedHashMap.getOrDefault(java.lang.Object,java.lang.Object), computeIfAbsent=public java.lang.Object java.util.HashMap.computeIfAbsent(java.lang.Object,java.util.function.Function), values=public java.util.Collection java.util.LinkedHashMap.values(), replace=freemarker.ext.beans.OverloadedMethods@11d0265, java.lang.Object@3e55b2={public boolean java.util.HashMap.isEmpty()=[Ljava.lang.Class;@c5aa3a, public int java.util.AbstractMap.hashCode()=[Ljava.lang.Class;@74a947, public java.lang.Object java.util.HashMap.put(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@1615a91, public boolean java.util.AbstractMap.equals(java.lang.Object)=[Ljava.lang.Class;@a46ab2, public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object)=[Ljava.lang.Class;@1c389e6, public java.lang.String java.util.AbstractMap.toString()=[Ljava.lang.Class;@a23548, public boolean java.util.HashMap.containsKey(java.lang.Object)=[Ljava.lang.Class;@1be4a9f, public java.util.Set java.util.LinkedHashMap.keySet()=[Ljava.lang.Class;@44c60, public java.lang.Object java.util.HashMap.computeIfAbsent(java.lang.Object,java.util.function.Function)=[Ljava.lang.Class;@10f7dff, public java.lang.Object java.util.HashMap.clone()=[Ljava.lang.Class;@d214e3, public java.lang.Object java.util.LinkedHashMap.getOrDefault(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@1a74254, public java.util.Set java.util.LinkedHashMap.entrySet()=[Ljava.lang.Class;@1c4740c, public void java.util.LinkedHashMap.forEach(java.util.function.BiConsumer)=[Ljava.lang.Class;@1fe0c8e, public java.lang.Object java.util.HashMap.putIfAbsent(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@16f73de, public java.util.Collection java.util.LinkedHashMap.values()=[Ljava.lang.Class;@b3e45, public void java.util.LinkedHashMap.clear()=[Ljava.lang.Class;@a34e5c, public java.lang.Object java.util.HashMap.computeIfPresent(java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1fcb13a, public java.lang.Object java.util.HashMap.compute(java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1a7c258, public final native java.lang.Class java.lang.Object.getClass()=[Ljava.lang.Class;@7397f, public void java.util.HashMap.putAll(java.util.Map)=[Ljava.lang.Class;@59cd, public void java.util.LinkedHashMap.replaceAll(java.util.function.BiFunction)=[Ljava.lang.Class;@994816, public java.lang.Object java.util.HashMap.merge(java.lang.Object,java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1b1e75f, public int java.util.HashMap.size()=[Ljava.lang.Class;@bee157, public boolean java.util.LinkedHashMap.containsValue(java.lang.Object)=[Ljava.lang.Class;@5e0d7c}, replaceAll=public void java.util.LinkedHashMap.replaceAll(java.util.function.BiFunction), remove=freemarker.ext.beans.OverloadedMethods@8d3a99, containsValue=public boolean java.util.LinkedHashMap.containsValue(java.lang.Object), put=public java.lang.Object java.util.HashMap.put(java.lang.Object,java.lang.Object), empty=java.beans.PropertyDescriptor[name=empty; propertyType=boolean; readMethod=public boolean java.util.HashMap.isEmpty()], compute=public java.lang.Object java.util.HashMap.compute(java.lang.Object,java.util.function.BiFunction), hashCode=public int java.util.AbstractMap.hashCode(), putAll=public void java.util.HashMap.putAll(java.util.Map), get=public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object), merge=public java.lang.Object java.util.HashMap.merge(java.lang.Object,java.lang.Object,java.util.function.BiFunction), class=java.beans.PropertyDescriptor[name=class; propertyType=class java.lang.Class; readMethod=public final native java.lang.Class java.lang.Object.getClass()], keySet=public java.util.Set java.util.LinkedHashMap.keySet(), java.lang.Object@1c0f21d=freemarker.ext.beans.OverloadedMethods@d4b988, entrySet=public java.util.Set java.util.LinkedHashMap.entrySet(), java.lang.Object@15be27d=public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object), forEach=public void java.util.LinkedHashMap.forEach(java.util.function.BiConsumer), containsKey=public boolean java.util.HashMap.containsKey(java.lang.Object), isEmpty=public boolean java.util.HashMap.isEmpty(), clear=public void java.util.LinkedHashMap.clear(), computeIfPresent=public java.lang.Object java.util.HashMap.computeIfPresent(java.lang.Object,java.util.function.BiFunction), size=public int java.util.HashMap.size(), equals=public boolean java.util.AbstractMap.equals(java.lang.Object), clone=public java.lang.Object java.util.HashMap.clone(), toString=public java.lang.String java.util.AbstractMap.toString(), putIfAbsent=public java.lang.Object java.util.HashMap.putIfAbsent(java.lang.Object,java.lang.Object)}
[DEBUG] 2017-05-24: 21:05:33 freemarker.log._Log4jLoggerFactory$Log4jLogger.debug(_Log4jLoggerFactory.java:45) :  TemplateLoader.findTemplateSource("template/~~~xhtml/dynamic-attributes.ftl"): Found
[DEBUG] 2017-05-24: 21:05:33 freemarker.log._Log4jLoggerFactory$Log4jLogger.debug(_Log4jLoggerFactory.java:45) :  "template/~~~xhtml/dynamic-attributes.ftl"("zh_CN", UTF-8, parsed): using cached since jar:file:/D:/maven/repository/org/apache/struts/struts2-core/2.5.10/struts2-core-2.5.10.jar!/template/simple/dynamic-attributes.ftl hasn't changed.
[DEBUG] 2017-05-24: 21:05:33 freemarker.log._Log4jLoggerFactory$Log4jLogger.debug(_Log4jLoggerFactory.java:45) :  TemplateLoader.findTemplateSource("template/~~~xhtml/controlfooter.ftl"): Found
[DEBUG] 2017-05-24: 21:05:33 freemarker.log._Log4jLoggerFactory$Log4jLogger.debug(_Log4jLoggerFactory.java:45) :  "template/~~~xhtml/controlfooter.ftl"("zh_CN", UTF-8, parsed): using cached since jar:file:/D:/maven/repository/org/apache/struts/struts2-core/2.5.10/struts2-core-2.5.10.jar!/template/xhtml/controlfooter.ftl hasn't changed.
[DEBUG] 2017-05-24: 21:05:33 freemarker.log._Log4jLoggerFactory$Log4jLogger.debug(_Log4jLoggerFactory.java:45) :  Key "after" was not found on instance of java.util.LinkedHashMap. Introspection information for the class is: {getClass=public final native java.lang.Class java.lang.Object.getClass(), getOrDefault=public java.lang.Object java.util.LinkedHashMap.getOrDefault(java.lang.Object,java.lang.Object), computeIfAbsent=public java.lang.Object java.util.HashMap.computeIfAbsent(java.lang.Object,java.util.function.Function), values=public java.util.Collection java.util.LinkedHashMap.values(), replace=freemarker.ext.beans.OverloadedMethods@11d0265, java.lang.Object@3e55b2={public boolean java.util.HashMap.isEmpty()=[Ljava.lang.Class;@c5aa3a, public int java.util.AbstractMap.hashCode()=[Ljava.lang.Class;@74a947, public java.lang.Object java.util.HashMap.put(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@1615a91, public boolean java.util.AbstractMap.equals(java.lang.Object)=[Ljava.lang.Class;@a46ab2, public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object)=[Ljava.lang.Class;@1c389e6, public java.lang.String java.util.AbstractMap.toString()=[Ljava.lang.Class;@a23548, public boolean java.util.HashMap.containsKey(java.lang.Object)=[Ljava.lang.Class;@1be4a9f, public java.util.Set java.util.LinkedHashMap.keySet()=[Ljava.lang.Class;@44c60, public java.lang.Object java.util.HashMap.computeIfAbsent(java.lang.Object,java.util.function.Function)=[Ljava.lang.Class;@10f7dff, public java.lang.Object java.util.HashMap.clone()=[Ljava.lang.Class;@d214e3, public java.lang.Object java.util.LinkedHashMap.getOrDefault(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@1a74254, public java.util.Set java.util.LinkedHashMap.entrySet()=[Ljava.lang.Class;@1c4740c, public void java.util.LinkedHashMap.forEach(java.util.function.BiConsumer)=[Ljava.lang.Class;@1fe0c8e, public java.lang.Object java.util.HashMap.putIfAbsent(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@16f73de, public java.util.Collection java.util.LinkedHashMap.values()=[Ljava.lang.Class;@b3e45, public void java.util.LinkedHashMap.clear()=[Ljava.lang.Class;@a34e5c, public java.lang.Object java.util.HashMap.computeIfPresent(java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1fcb13a, public java.lang.Object java.util.HashMap.compute(java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1a7c258, public final native java.lang.Class java.lang.Object.getClass()=[Ljava.lang.Class;@7397f, public void java.util.HashMap.putAll(java.util.Map)=[Ljava.lang.Class;@59cd, public void java.util.LinkedHashMap.replaceAll(java.util.function.BiFunction)=[Ljava.lang.Class;@994816, public java.lang.Object java.util.HashMap.merge(java.lang.Object,java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1b1e75f, public int java.util.HashMap.size()=[Ljava.lang.Class;@bee157, public boolean java.util.LinkedHashMap.containsValue(java.lang.Object)=[Ljava.lang.Class;@5e0d7c}, replaceAll=public void java.util.LinkedHashMap.replaceAll(java.util.function.BiFunction), remove=freemarker.ext.beans.OverloadedMethods@8d3a99, containsValue=public boolean java.util.LinkedHashMap.containsValue(java.lang.Object), put=public java.lang.Object java.util.HashMap.put(java.lang.Object,java.lang.Object), empty=java.beans.PropertyDescriptor[name=empty; propertyType=boolean; readMethod=public boolean java.util.HashMap.isEmpty()], compute=public java.lang.Object java.util.HashMap.compute(java.lang.Object,java.util.function.BiFunction), hashCode=public int java.util.AbstractMap.hashCode(), putAll=public void java.util.HashMap.putAll(java.util.Map), get=public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object), merge=public java.lang.Object java.util.HashMap.merge(java.lang.Object,java.lang.Object,java.util.function.BiFunction), class=java.beans.PropertyDescriptor[name=class; propertyType=class java.lang.Class; readMethod=public final native java.lang.Class java.lang.Object.getClass()], keySet=public java.util.Set java.util.LinkedHashMap.keySet(), java.lang.Object@1c0f21d=freemarker.ext.beans.OverloadedMethods@d4b988, entrySet=public java.util.Set java.util.LinkedHashMap.entrySet(), java.lang.Object@15be27d=public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object), forEach=public void java.util.LinkedHashMap.forEach(java.util.function.BiConsumer), containsKey=public boolean java.util.HashMap.containsKey(java.lang.Object), isEmpty=public boolean java.util.HashMap.isEmpty(), clear=public void java.util.LinkedHashMap.clear(), computeIfPresent=public java.lang.Object java.util.HashMap.computeIfPresent(java.lang.Object,java.util.function.BiFunction), size=public int java.util.HashMap.size(), equals=public boolean java.util.AbstractMap.equals(java.lang.Object), clone=public java.lang.Object java.util.HashMap.clone(), toString=public java.lang.String java.util.AbstractMap.toString(), putIfAbsent=public java.lang.Object java.util.HashMap.putIfAbsent(java.lang.Object,java.lang.Object)}
[DEBUG] 2017-05-24: 21:05:33 freemarker.log._Log4jLoggerFactory$Log4jLogger.debug(_Log4jLoggerFactory.java:45) :  Key "errorposition" was not found on instance of java.util.LinkedHashMap. Introspection information for the class is: {getClass=public final native java.lang.Class java.lang.Object.getClass(), getOrDefault=public java.lang.Object java.util.LinkedHashMap.getOrDefault(java.lang.Object,java.lang.Object), computeIfAbsent=public java.lang.Object java.util.HashMap.computeIfAbsent(java.lang.Object,java.util.function.Function), values=public java.util.Collection java.util.LinkedHashMap.values(), replace=freemarker.ext.beans.OverloadedMethods@11d0265, java.lang.Object@3e55b2={public boolean java.util.HashMap.isEmpty()=[Ljava.lang.Class;@c5aa3a, public int java.util.AbstractMap.hashCode()=[Ljava.lang.Class;@74a947, public java.lang.Object java.util.HashMap.put(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@1615a91, public boolean java.util.AbstractMap.equals(java.lang.Object)=[Ljava.lang.Class;@a46ab2, public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object)=[Ljava.lang.Class;@1c389e6, public java.lang.String java.util.AbstractMap.toString()=[Ljava.lang.Class;@a23548, public boolean java.util.HashMap.containsKey(java.lang.Object)=[Ljava.lang.Class;@1be4a9f, public java.util.Set java.util.LinkedHashMap.keySet()=[Ljava.lang.Class;@44c60, public java.lang.Object java.util.HashMap.computeIfAbsent(java.lang.Object,java.util.function.Function)=[Ljava.lang.Class;@10f7dff, public java.lang.Object java.util.HashMap.clone()=[Ljava.lang.Class;@d214e3, public java.lang.Object java.util.LinkedHashMap.getOrDefault(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@1a74254, public java.util.Set java.util.LinkedHashMap.entrySet()=[Ljava.lang.Class;@1c4740c, public void java.util.LinkedHashMap.forEach(java.util.function.BiConsumer)=[Ljava.lang.Class;@1fe0c8e, public java.lang.Object java.util.HashMap.putIfAbsent(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@16f73de, public java.util.Collection java.util.LinkedHashMap.values()=[Ljava.lang.Class;@b3e45, public void java.util.LinkedHashMap.clear()=[Ljava.lang.Class;@a34e5c, public java.lang.Object java.util.HashMap.computeIfPresent(java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1fcb13a, public java.lang.Object java.util.HashMap.compute(java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1a7c258, public final native java.lang.Class java.lang.Object.getClass()=[Ljava.lang.Class;@7397f, public void java.util.HashMap.putAll(java.util.Map)=[Ljava.lang.Class;@59cd, public void java.util.LinkedHashMap.replaceAll(java.util.function.BiFunction)=[Ljava.lang.Class;@994816, public java.lang.Object java.util.HashMap.merge(java.lang.Object,java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1b1e75f, public int java.util.HashMap.size()=[Ljava.lang.Class;@bee157, public boolean java.util.LinkedHashMap.containsValue(java.lang.Object)=[Ljava.lang.Class;@5e0d7c}, replaceAll=public void java.util.LinkedHashMap.replaceAll(java.util.function.BiFunction), remove=freemarker.ext.beans.OverloadedMethods@8d3a99, containsValue=public boolean java.util.LinkedHashMap.containsValue(java.lang.Object), put=public java.lang.Object java.util.HashMap.put(java.lang.Object,java.lang.Object), empty=java.beans.PropertyDescriptor[name=empty; propertyType=boolean; readMethod=public boolean java.util.HashMap.isEmpty()], compute=public java.lang.Object java.util.HashMap.compute(java.lang.Object,java.util.function.BiFunction), hashCode=public int java.util.AbstractMap.hashCode(), putAll=public void java.util.HashMap.putAll(java.util.Map), get=public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object), merge=public java.lang.Object java.util.HashMap.merge(java.lang.Object,java.lang.Object,java.util.function.BiFunction), class=java.beans.PropertyDescriptor[name=class; propertyType=class java.lang.Class; readMethod=public final native java.lang.Class java.lang.Object.getClass()], keySet=public java.util.Set java.util.LinkedHashMap.keySet(), java.lang.Object@1c0f21d=freemarker.ext.beans.OverloadedMethods@d4b988, entrySet=public java.util.Set java.util.LinkedHashMap.entrySet(), java.lang.Object@15be27d=public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object), forEach=public void java.util.LinkedHashMap.forEach(java.util.function.BiConsumer), containsKey=public boolean java.util.HashMap.containsKey(java.lang.Object), isEmpty=public boolean java.util.HashMap.isEmpty(), clear=public void java.util.LinkedHashMap.clear(), computeIfPresent=public java.lang.Object java.util.HashMap.computeIfPresent(java.lang.Object,java.util.function.BiFunction), size=public int java.util.HashMap.size(), equals=public boolean java.util.AbstractMap.equals(java.lang.Object), clone=public java.lang.Object java.util.HashMap.clone(), toString=public java.lang.String java.util.AbstractMap.toString(), putIfAbsent=public java.lang.Object java.util.HashMap.putIfAbsent(java.lang.Object,java.lang.Object)}
[DEBUG] 2017-05-24: 21:05:33 freemarker.log._Log4jLoggerFactory$Log4jLogger.debug(_Log4jLoggerFactory.java:45) :  Couldn't find template in cache for "template/xhtml/submit.ftl"("zh_CN", UTF-8, parsed); will try to load it.
[DEBUG] 2017-05-24: 21:05:33 freemarker.log._Log4jLoggerFactory$Log4jLogger.debug(_Log4jLoggerFactory.java:45) :  TemplateLoader.findTemplateSource("template/xhtml/submit.ftl"): Found
[DEBUG] 2017-05-24: 21:05:33 freemarker.log._Log4jLoggerFactory$Log4jLogger.debug(_Log4jLoggerFactory.java:45) :  Loading template for "template/xhtml/submit.ftl"("zh_CN", UTF-8, parsed) from "jar:file:/D:/maven/repository/org/apache/struts/struts2-core/2.5.10/struts2-core-2.5.10.jar!/template/xhtml/submit.ftl"
[DEBUG] 2017-05-24: 21:05:33 freemarker.log._Log4jLoggerFactory$Log4jLogger.debug(_Log4jLoggerFactory.java:45) :  Couldn't find template in cache for "template/simple/submit.ftl"("zh_CN", UTF-8, parsed); will try to load it.
[DEBUG] 2017-05-24: 21:05:33 freemarker.log._Log4jLoggerFactory$Log4jLogger.debug(_Log4jLoggerFactory.java:45) :  TemplateLoader.findTemplateSource("template/simple/submit.ftl"): Found
[DEBUG] 2017-05-24: 21:05:33 freemarker.log._Log4jLoggerFactory$Log4jLogger.debug(_Log4jLoggerFactory.java:45) :  Loading template for "template/simple/submit.ftl"("zh_CN", UTF-8, parsed) from "jar:file:/D:/maven/repository/org/apache/struts/struts2-core/2.5.10/struts2-core-2.5.10.jar!/template/simple/submit.ftl"
[DEBUG] 2017-05-24: 21:05:33 freemarker.log._Log4jLoggerFactory$Log4jLogger.debug(_Log4jLoggerFactory.java:45) :  Key "name" was not found on instance of java.util.LinkedHashMap. Introspection information for the class is: {getClass=public final native java.lang.Class java.lang.Object.getClass(), getOrDefault=public java.lang.Object java.util.LinkedHashMap.getOrDefault(java.lang.Object,java.lang.Object), computeIfAbsent=public java.lang.Object java.util.HashMap.computeIfAbsent(java.lang.Object,java.util.function.Function), values=public java.util.Collection java.util.LinkedHashMap.values(), replace=freemarker.ext.beans.OverloadedMethods@11d0265, java.lang.Object@3e55b2={public boolean java.util.HashMap.isEmpty()=[Ljava.lang.Class;@c5aa3a, public int java.util.AbstractMap.hashCode()=[Ljava.lang.Class;@74a947, public java.lang.Object java.util.HashMap.put(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@1615a91, public boolean java.util.AbstractMap.equals(java.lang.Object)=[Ljava.lang.Class;@a46ab2, public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object)=[Ljava.lang.Class;@1c389e6, public java.lang.String java.util.AbstractMap.toString()=[Ljava.lang.Class;@a23548, public boolean java.util.HashMap.containsKey(java.lang.Object)=[Ljava.lang.Class;@1be4a9f, public java.util.Set java.util.LinkedHashMap.keySet()=[Ljava.lang.Class;@44c60, public java.lang.Object java.util.HashMap.computeIfAbsent(java.lang.Object,java.util.function.Function)=[Ljava.lang.Class;@10f7dff, public java.lang.Object java.util.HashMap.clone()=[Ljava.lang.Class;@d214e3, public java.lang.Object java.util.LinkedHashMap.getOrDefault(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@1a74254, public java.util.Set java.util.LinkedHashMap.entrySet()=[Ljava.lang.Class;@1c4740c, public void java.util.LinkedHashMap.forEach(java.util.function.BiConsumer)=[Ljava.lang.Class;@1fe0c8e, public java.lang.Object java.util.HashMap.putIfAbsent(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@16f73de, public java.util.Collection java.util.LinkedHashMap.values()=[Ljava.lang.Class;@b3e45, public void java.util.LinkedHashMap.clear()=[Ljava.lang.Class;@a34e5c, public java.lang.Object java.util.HashMap.computeIfPresent(java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1fcb13a, public java.lang.Object java.util.HashMap.compute(java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1a7c258, public final native java.lang.Class java.lang.Object.getClass()=[Ljava.lang.Class;@7397f, public void java.util.HashMap.putAll(java.util.Map)=[Ljava.lang.Class;@59cd, public void java.util.LinkedHashMap.replaceAll(java.util.function.BiFunction)=[Ljava.lang.Class;@994816, public java.lang.Object java.util.HashMap.merge(java.lang.Object,java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1b1e75f, public int java.util.HashMap.size()=[Ljava.lang.Class;@bee157, public boolean java.util.LinkedHashMap.containsValue(java.lang.Object)=[Ljava.lang.Class;@5e0d7c}, replaceAll=public void java.util.LinkedHashMap.replaceAll(java.util.function.BiFunction), remove=freemarker.ext.beans.OverloadedMethods@8d3a99, containsValue=public boolean java.util.LinkedHashMap.containsValue(java.lang.Object), put=public java.lang.Object java.util.HashMap.put(java.lang.Object,java.lang.Object), empty=java.beans.PropertyDescriptor[name=empty; propertyType=boolean; readMethod=public boolean java.util.HashMap.isEmpty()], compute=public java.lang.Object java.util.HashMap.compute(java.lang.Object,java.util.function.BiFunction), hashCode=public int java.util.AbstractMap.hashCode(), putAll=public void java.util.HashMap.putAll(java.util.Map), get=public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object), merge=public java.lang.Object java.util.HashMap.merge(java.lang.Object,java.lang.Object,java.util.function.BiFunction), class=java.beans.PropertyDescriptor[name=class; propertyType=class java.lang.Class; readMethod=public final native java.lang.Class java.lang.Object.getClass()], keySet=public java.util.Set java.util.LinkedHashMap.keySet(), java.lang.Object@1c0f21d=freemarker.ext.beans.OverloadedMethods@d4b988, entrySet=public java.util.Set java.util.LinkedHashMap.entrySet(), java.lang.Object@15be27d=public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object), forEach=public void java.util.LinkedHashMap.forEach(java.util.function.BiConsumer), containsKey=public boolean java.util.HashMap.containsKey(java.lang.Object), isEmpty=public boolean java.util.HashMap.isEmpty(), clear=public void java.util.LinkedHashMap.clear(), computeIfPresent=public java.lang.Object java.util.HashMap.computeIfPresent(java.lang.Object,java.util.function.BiFunction), size=public int java.util.HashMap.size(), equals=public boolean java.util.AbstractMap.equals(java.lang.Object), clone=public java.lang.Object java.util.HashMap.clone(), toString=public java.lang.String java.util.AbstractMap.toString(), putIfAbsent=public java.lang.Object java.util.HashMap.putIfAbsent(java.lang.Object,java.lang.Object)}
[DEBUG] 2017-05-24: 21:05:33 freemarker.log._Log4jLoggerFactory$Log4jLogger.debug(_Log4jLoggerFactory.java:45) :  Key "disabled" was not found on instance of java.util.LinkedHashMap. Introspection information for the class is: {getClass=public final native java.lang.Class java.lang.Object.getClass(), getOrDefault=public java.lang.Object java.util.LinkedHashMap.getOrDefault(java.lang.Object,java.lang.Object), computeIfAbsent=public java.lang.Object java.util.HashMap.computeIfAbsent(java.lang.Object,java.util.function.Function), values=public java.util.Collection java.util.LinkedHashMap.values(), replace=freemarker.ext.beans.OverloadedMethods@11d0265, java.lang.Object@3e55b2={public boolean java.util.HashMap.isEmpty()=[Ljava.lang.Class;@c5aa3a, public int java.util.AbstractMap.hashCode()=[Ljava.lang.Class;@74a947, public java.lang.Object java.util.HashMap.put(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@1615a91, public boolean java.util.AbstractMap.equals(java.lang.Object)=[Ljava.lang.Class;@a46ab2, public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object)=[Ljava.lang.Class;@1c389e6, public java.lang.String java.util.AbstractMap.toString()=[Ljava.lang.Class;@a23548, public boolean java.util.HashMap.containsKey(java.lang.Object)=[Ljava.lang.Class;@1be4a9f, public java.util.Set java.util.LinkedHashMap.keySet()=[Ljava.lang.Class;@44c60, public java.lang.Object java.util.HashMap.computeIfAbsent(java.lang.Object,java.util.function.Function)=[Ljava.lang.Class;@10f7dff, public java.lang.Object java.util.HashMap.clone()=[Ljava.lang.Class;@d214e3, public java.lang.Object java.util.LinkedHashMap.getOrDefault(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@1a74254, public java.util.Set java.util.LinkedHashMap.entrySet()=[Ljava.lang.Class;@1c4740c, public void java.util.LinkedHashMap.forEach(java.util.function.BiConsumer)=[Ljava.lang.Class;@1fe0c8e, public java.lang.Object java.util.HashMap.putIfAbsent(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@16f73de, public java.util.Collection java.util.LinkedHashMap.values()=[Ljava.lang.Class;@b3e45, public void java.util.LinkedHashMap.clear()=[Ljava.lang.Class;@a34e5c, public java.lang.Object java.util.HashMap.computeIfPresent(java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1fcb13a, public java.lang.Object java.util.HashMap.compute(java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1a7c258, public final native java.lang.Class java.lang.Object.getClass()=[Ljava.lang.Class;@7397f, public void java.util.HashMap.putAll(java.util.Map)=[Ljava.lang.Class;@59cd, public void java.util.LinkedHashMap.replaceAll(java.util.function.BiFunction)=[Ljava.lang.Class;@994816, public java.lang.Object java.util.HashMap.merge(java.lang.Object,java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1b1e75f, public int java.util.HashMap.size()=[Ljava.lang.Class;@bee157, public boolean java.util.LinkedHashMap.containsValue(java.lang.Object)=[Ljava.lang.Class;@5e0d7c}, replaceAll=public void java.util.LinkedHashMap.replaceAll(java.util.function.BiFunction), remove=freemarker.ext.beans.OverloadedMethods@8d3a99, containsValue=public boolean java.util.LinkedHashMap.containsValue(java.lang.Object), put=public java.lang.Object java.util.HashMap.put(java.lang.Object,java.lang.Object), empty=java.beans.PropertyDescriptor[name=empty; propertyType=boolean; readMethod=public boolean java.util.HashMap.isEmpty()], compute=public java.lang.Object java.util.HashMap.compute(java.lang.Object,java.util.function.BiFunction), hashCode=public int java.util.AbstractMap.hashCode(), putAll=public void java.util.HashMap.putAll(java.util.Map), get=public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object), merge=public java.lang.Object java.util.HashMap.merge(java.lang.Object,java.lang.Object,java.util.function.BiFunction), class=java.beans.PropertyDescriptor[name=class; propertyType=class java.lang.Class; readMethod=public final native java.lang.Class java.lang.Object.getClass()], keySet=public java.util.Set java.util.LinkedHashMap.keySet(), java.lang.Object@1c0f21d=freemarker.ext.beans.OverloadedMethods@d4b988, entrySet=public java.util.Set java.util.LinkedHashMap.entrySet(), java.lang.Object@15be27d=public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object), forEach=public void java.util.LinkedHashMap.forEach(java.util.function.BiConsumer), containsKey=public boolean java.util.HashMap.containsKey(java.lang.Object), isEmpty=public boolean java.util.HashMap.isEmpty(), clear=public void java.util.LinkedHashMap.clear(), computeIfPresent=public java.lang.Object java.util.HashMap.computeIfPresent(java.lang.Object,java.util.function.BiFunction), size=public int java.util.HashMap.size(), equals=public boolean java.util.AbstractMap.equals(java.lang.Object), clone=public java.lang.Object java.util.HashMap.clone(), toString=public java.lang.String java.util.AbstractMap.toString(), putIfAbsent=public java.lang.Object java.util.HashMap.putIfAbsent(java.lang.Object,java.lang.Object)}
[DEBUG] 2017-05-24: 21:05:33 freemarker.log._Log4jLoggerFactory$Log4jLogger.debug(_Log4jLoggerFactory.java:45) :  Key "cssClass" was not found on instance of java.util.LinkedHashMap. Introspection information for the class is: {getClass=public final native java.lang.Class java.lang.Object.getClass(), getOrDefault=public java.lang.Object java.util.LinkedHashMap.getOrDefault(java.lang.Object,java.lang.Object), computeIfAbsent=public java.lang.Object java.util.HashMap.computeIfAbsent(java.lang.Object,java.util.function.Function), values=public java.util.Collection java.util.LinkedHashMap.values(), replace=freemarker.ext.beans.OverloadedMethods@11d0265, java.lang.Object@3e55b2={public boolean java.util.HashMap.isEmpty()=[Ljava.lang.Class;@c5aa3a, public int java.util.AbstractMap.hashCode()=[Ljava.lang.Class;@74a947, public java.lang.Object java.util.HashMap.put(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@1615a91, public boolean java.util.AbstractMap.equals(java.lang.Object)=[Ljava.lang.Class;@a46ab2, public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object)=[Ljava.lang.Class;@1c389e6, public java.lang.String java.util.AbstractMap.toString()=[Ljava.lang.Class;@a23548, public boolean java.util.HashMap.containsKey(java.lang.Object)=[Ljava.lang.Class;@1be4a9f, public java.util.Set java.util.LinkedHashMap.keySet()=[Ljava.lang.Class;@44c60, public java.lang.Object java.util.HashMap.computeIfAbsent(java.lang.Object,java.util.function.Function)=[Ljava.lang.Class;@10f7dff, public java.lang.Object java.util.HashMap.clone()=[Ljava.lang.Class;@d214e3, public java.lang.Object java.util.LinkedHashMap.getOrDefault(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@1a74254, public java.util.Set java.util.LinkedHashMap.entrySet()=[Ljava.lang.Class;@1c4740c, public void java.util.LinkedHashMap.forEach(java.util.function.BiConsumer)=[Ljava.lang.Class;@1fe0c8e, public java.lang.Object java.util.HashMap.putIfAbsent(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@16f73de, public java.util.Collection java.util.LinkedHashMap.values()=[Ljava.lang.Class;@b3e45, public void java.util.LinkedHashMap.clear()=[Ljava.lang.Class;@a34e5c, public java.lang.Object java.util.HashMap.computeIfPresent(java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1fcb13a, public java.lang.Object java.util.HashMap.compute(java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1a7c258, public final native java.lang.Class java.lang.Object.getClass()=[Ljava.lang.Class;@7397f, public void java.util.HashMap.putAll(java.util.Map)=[Ljava.lang.Class;@59cd, public void java.util.LinkedHashMap.replaceAll(java.util.function.BiFunction)=[Ljava.lang.Class;@994816, public java.lang.Object java.util.HashMap.merge(java.lang.Object,java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1b1e75f, public int java.util.HashMap.size()=[Ljava.lang.Class;@bee157, public boolean java.util.LinkedHashMap.containsValue(java.lang.Object)=[Ljava.lang.Class;@5e0d7c}, replaceAll=public void java.util.LinkedHashMap.replaceAll(java.util.function.BiFunction), remove=freemarker.ext.beans.OverloadedMethods@8d3a99, containsValue=public boolean java.util.LinkedHashMap.containsValue(java.lang.Object), put=public java.lang.Object java.util.HashMap.put(java.lang.Object,java.lang.Object), empty=java.beans.PropertyDescriptor[name=empty; propertyType=boolean; readMethod=public boolean java.util.HashMap.isEmpty()], compute=public java.lang.Object java.util.HashMap.compute(java.lang.Object,java.util.function.BiFunction), hashCode=public int java.util.AbstractMap.hashCode(), putAll=public void java.util.HashMap.putAll(java.util.Map), get=public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object), merge=public java.lang.Object java.util.HashMap.merge(java.lang.Object,java.lang.Object,java.util.function.BiFunction), class=java.beans.PropertyDescriptor[name=class; propertyType=class java.lang.Class; readMethod=public final native java.lang.Class java.lang.Object.getClass()], keySet=public java.util.Set java.util.LinkedHashMap.keySet(), java.lang.Object@1c0f21d=freemarker.ext.beans.OverloadedMethods@d4b988, entrySet=public java.util.Set java.util.LinkedHashMap.entrySet(), java.lang.Object@15be27d=public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object), forEach=public void java.util.LinkedHashMap.forEach(java.util.function.BiConsumer), containsKey=public boolean java.util.HashMap.containsKey(java.lang.Object), isEmpty=public boolean java.util.HashMap.isEmpty(), clear=public void java.util.LinkedHashMap.clear(), computeIfPresent=public java.lang.Object java.util.HashMap.computeIfPresent(java.lang.Object,java.util.function.BiFunction), size=public int java.util.HashMap.size(), equals=public boolean java.util.AbstractMap.equals(java.lang.Object), clone=public java.lang.Object java.util.HashMap.clone(), toString=public java.lang.String java.util.AbstractMap.toString(), putIfAbsent=public java.lang.Object java.util.HashMap.putIfAbsent(java.lang.Object,java.lang.Object)}
[DEBUG] 2017-05-24: 21:05:33 freemarker.log._Log4jLoggerFactory$Log4jLogger.debug(_Log4jLoggerFactory.java:45) :  Key "cssStyle" was not found on instance of java.util.LinkedHashMap. Introspection information for the class is: {getClass=public final native java.lang.Class java.lang.Object.getClass(), getOrDefault=public java.lang.Object java.util.LinkedHashMap.getOrDefault(java.lang.Object,java.lang.Object), computeIfAbsent=public java.lang.Object java.util.HashMap.computeIfAbsent(java.lang.Object,java.util.function.Function), values=public java.util.Collection java.util.LinkedHashMap.values(), replace=freemarker.ext.beans.OverloadedMethods@11d0265, java.lang.Object@3e55b2={public boolean java.util.HashMap.isEmpty()=[Ljava.lang.Class;@c5aa3a, public int java.util.AbstractMap.hashCode()=[Ljava.lang.Class;@74a947, public java.lang.Object java.util.HashMap.put(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@1615a91, public boolean java.util.AbstractMap.equals(java.lang.Object)=[Ljava.lang.Class;@a46ab2, public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object)=[Ljava.lang.Class;@1c389e6, public java.lang.String java.util.AbstractMap.toString()=[Ljava.lang.Class;@a23548, public boolean java.util.HashMap.containsKey(java.lang.Object)=[Ljava.lang.Class;@1be4a9f, public java.util.Set java.util.LinkedHashMap.keySet()=[Ljava.lang.Class;@44c60, public java.lang.Object java.util.HashMap.computeIfAbsent(java.lang.Object,java.util.function.Function)=[Ljava.lang.Class;@10f7dff, public java.lang.Object java.util.HashMap.clone()=[Ljava.lang.Class;@d214e3, public java.lang.Object java.util.LinkedHashMap.getOrDefault(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@1a74254, public java.util.Set java.util.LinkedHashMap.entrySet()=[Ljava.lang.Class;@1c4740c, public void java.util.LinkedHashMap.forEach(java.util.function.BiConsumer)=[Ljava.lang.Class;@1fe0c8e, public java.lang.Object java.util.HashMap.putIfAbsent(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@16f73de, public java.util.Collection java.util.LinkedHashMap.values()=[Ljava.lang.Class;@b3e45, public void java.util.LinkedHashMap.clear()=[Ljava.lang.Class;@a34e5c, public java.lang.Object java.util.HashMap.computeIfPresent(java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1fcb13a, public java.lang.Object java.util.HashMap.compute(java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1a7c258, public final native java.lang.Class java.lang.Object.getClass()=[Ljava.lang.Class;@7397f, public void java.util.HashMap.putAll(java.util.Map)=[Ljava.lang.Class;@59cd, public void java.util.LinkedHashMap.replaceAll(java.util.function.BiFunction)=[Ljava.lang.Class;@994816, public java.lang.Object java.util.HashMap.merge(java.lang.Object,java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1b1e75f, public int java.util.HashMap.size()=[Ljava.lang.Class;@bee157, public boolean java.util.LinkedHashMap.containsValue(java.lang.Object)=[Ljava.lang.Class;@5e0d7c}, replaceAll=public void java.util.LinkedHashMap.replaceAll(java.util.function.BiFunction), remove=freemarker.ext.beans.OverloadedMethods@8d3a99, containsValue=public boolean java.util.LinkedHashMap.containsValue(java.lang.Object), put=public java.lang.Object java.util.HashMap.put(java.lang.Object,java.lang.Object), empty=java.beans.PropertyDescriptor[name=empty; propertyType=boolean; readMethod=public boolean java.util.HashMap.isEmpty()], compute=public java.lang.Object java.util.HashMap.compute(java.lang.Object,java.util.function.BiFunction), hashCode=public int java.util.AbstractMap.hashCode(), putAll=public void java.util.HashMap.putAll(java.util.Map), get=public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object), merge=public java.lang.Object java.util.HashMap.merge(java.lang.Object,java.lang.Object,java.util.function.BiFunction), class=java.beans.PropertyDescriptor[name=class; propertyType=class java.lang.Class; readMethod=public final native java.lang.Class java.lang.Object.getClass()], keySet=public java.util.Set java.util.LinkedHashMap.keySet(), java.lang.Object@1c0f21d=freemarker.ext.beans.OverloadedMethods@d4b988, entrySet=public java.util.Set java.util.LinkedHashMap.entrySet(), java.lang.Object@15be27d=public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object), forEach=public void java.util.LinkedHashMap.forEach(java.util.function.BiConsumer), containsKey=public boolean java.util.HashMap.containsKey(java.lang.Object), isEmpty=public boolean java.util.HashMap.isEmpty(), clear=public void java.util.LinkedHashMap.clear(), computeIfPresent=public java.lang.Object java.util.HashMap.computeIfPresent(java.lang.Object,java.util.function.BiFunction), size=public int java.util.HashMap.size(), equals=public boolean java.util.AbstractMap.equals(java.lang.Object), clone=public java.lang.Object java.util.HashMap.clone(), toString=public java.lang.String java.util.AbstractMap.toString(), putIfAbsent=public java.lang.Object java.util.HashMap.putIfAbsent(java.lang.Object,java.lang.Object)}
[DEBUG] 2017-05-24: 21:05:33 freemarker.log._Log4jLoggerFactory$Log4jLogger.debug(_Log4jLoggerFactory.java:45) :  Key "title" was not found on instance of java.util.LinkedHashMap. Introspection information for the class is: {getClass=public final native java.lang.Class java.lang.Object.getClass(), getOrDefault=public java.lang.Object java.util.LinkedHashMap.getOrDefault(java.lang.Object,java.lang.Object), computeIfAbsent=public java.lang.Object java.util.HashMap.computeIfAbsent(java.lang.Object,java.util.function.Function), values=public java.util.Collection java.util.LinkedHashMap.values(), replace=freemarker.ext.beans.OverloadedMethods@11d0265, java.lang.Object@3e55b2={public boolean java.util.HashMap.isEmpty()=[Ljava.lang.Class;@c5aa3a, public int java.util.AbstractMap.hashCode()=[Ljava.lang.Class;@74a947, public java.lang.Object java.util.HashMap.put(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@1615a91, public boolean java.util.AbstractMap.equals(java.lang.Object)=[Ljava.lang.Class;@a46ab2, public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object)=[Ljava.lang.Class;@1c389e6, public java.lang.String java.util.AbstractMap.toString()=[Ljava.lang.Class;@a23548, public boolean java.util.HashMap.containsKey(java.lang.Object)=[Ljava.lang.Class;@1be4a9f, public java.util.Set java.util.LinkedHashMap.keySet()=[Ljava.lang.Class;@44c60, public java.lang.Object java.util.HashMap.computeIfAbsent(java.lang.Object,java.util.function.Function)=[Ljava.lang.Class;@10f7dff, public java.lang.Object java.util.HashMap.clone()=[Ljava.lang.Class;@d214e3, public java.lang.Object java.util.LinkedHashMap.getOrDefault(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@1a74254, public java.util.Set java.util.LinkedHashMap.entrySet()=[Ljava.lang.Class;@1c4740c, public void java.util.LinkedHashMap.forEach(java.util.function.BiConsumer)=[Ljava.lang.Class;@1fe0c8e, public java.lang.Object java.util.HashMap.putIfAbsent(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@16f73de, public java.util.Collection java.util.LinkedHashMap.values()=[Ljava.lang.Class;@b3e45, public void java.util.LinkedHashMap.clear()=[Ljava.lang.Class;@a34e5c, public java.lang.Object java.util.HashMap.computeIfPresent(java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1fcb13a, public java.lang.Object java.util.HashMap.compute(java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1a7c258, public final native java.lang.Class java.lang.Object.getClass()=[Ljava.lang.Class;@7397f, public void java.util.HashMap.putAll(java.util.Map)=[Ljava.lang.Class;@59cd, public void java.util.LinkedHashMap.replaceAll(java.util.function.BiFunction)=[Ljava.lang.Class;@994816, public java.lang.Object java.util.HashMap.merge(java.lang.Object,java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1b1e75f, public int java.util.HashMap.size()=[Ljava.lang.Class;@bee157, public boolean java.util.LinkedHashMap.containsValue(java.lang.Object)=[Ljava.lang.Class;@5e0d7c}, replaceAll=public void java.util.LinkedHashMap.replaceAll(java.util.function.BiFunction), remove=freemarker.ext.beans.OverloadedMethods@8d3a99, containsValue=public boolean java.util.LinkedHashMap.containsValue(java.lang.Object), put=public java.lang.Object java.util.HashMap.put(java.lang.Object,java.lang.Object), empty=java.beans.PropertyDescriptor[name=empty; propertyType=boolean; readMethod=public boolean java.util.HashMap.isEmpty()], compute=public java.lang.Object java.util.HashMap.compute(java.lang.Object,java.util.function.BiFunction), hashCode=public int java.util.AbstractMap.hashCode(), putAll=public void java.util.HashMap.putAll(java.util.Map), get=public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object), merge=public java.lang.Object java.util.HashMap.merge(java.lang.Object,java.lang.Object,java.util.function.BiFunction), class=java.beans.PropertyDescriptor[name=class; propertyType=class java.lang.Class; readMethod=public final native java.lang.Class java.lang.Object.getClass()], keySet=public java.util.Set java.util.LinkedHashMap.keySet(), java.lang.Object@1c0f21d=freemarker.ext.beans.OverloadedMethods@d4b988, entrySet=public java.util.Set java.util.LinkedHashMap.entrySet(), java.lang.Object@15be27d=public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object), forEach=public void java.util.LinkedHashMap.forEach(java.util.function.BiConsumer), containsKey=public boolean java.util.HashMap.containsKey(java.lang.Object), isEmpty=public boolean java.util.HashMap.isEmpty(), clear=public void java.util.LinkedHashMap.clear(), computeIfPresent=public java.lang.Object java.util.HashMap.computeIfPresent(java.lang.Object,java.util.function.BiFunction), size=public int java.util.HashMap.size(), equals=public boolean java.util.AbstractMap.equals(java.lang.Object), clone=public java.lang.Object java.util.HashMap.clone(), toString=public java.lang.String java.util.AbstractMap.toString(), putIfAbsent=public java.lang.Object java.util.HashMap.putIfAbsent(java.lang.Object,java.lang.Object)}
[DEBUG] 2017-05-24: 21:05:33 freemarker.log._Log4jLoggerFactory$Log4jLogger.debug(_Log4jLoggerFactory.java:45) :  Key "tabindex" was not found on instance of java.util.LinkedHashMap. Introspection information for the class is: {getClass=public final native java.lang.Class java.lang.Object.getClass(), getOrDefault=public java.lang.Object java.util.LinkedHashMap.getOrDefault(java.lang.Object,java.lang.Object), computeIfAbsent=public java.lang.Object java.util.HashMap.computeIfAbsent(java.lang.Object,java.util.function.Function), values=public java.util.Collection java.util.LinkedHashMap.values(), replace=freemarker.ext.beans.OverloadedMethods@11d0265, java.lang.Object@3e55b2={public boolean java.util.HashMap.isEmpty()=[Ljava.lang.Class;@c5aa3a, public int java.util.AbstractMap.hashCode()=[Ljava.lang.Class;@74a947, public java.lang.Object java.util.HashMap.put(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@1615a91, public boolean java.util.AbstractMap.equals(java.lang.Object)=[Ljava.lang.Class;@a46ab2, public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object)=[Ljava.lang.Class;@1c389e6, public java.lang.String java.util.AbstractMap.toString()=[Ljava.lang.Class;@a23548, public boolean java.util.HashMap.containsKey(java.lang.Object)=[Ljava.lang.Class;@1be4a9f, public java.util.Set java.util.LinkedHashMap.keySet()=[Ljava.lang.Class;@44c60, public java.lang.Object java.util.HashMap.computeIfAbsent(java.lang.Object,java.util.function.Function)=[Ljava.lang.Class;@10f7dff, public java.lang.Object java.util.HashMap.clone()=[Ljava.lang.Class;@d214e3, public java.lang.Object java.util.LinkedHashMap.getOrDefault(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@1a74254, public java.util.Set java.util.LinkedHashMap.entrySet()=[Ljava.lang.Class;@1c4740c, public void java.util.LinkedHashMap.forEach(java.util.function.BiConsumer)=[Ljava.lang.Class;@1fe0c8e, public java.lang.Object java.util.HashMap.putIfAbsent(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@16f73de, public java.util.Collection java.util.LinkedHashMap.values()=[Ljava.lang.Class;@b3e45, public void java.util.LinkedHashMap.clear()=[Ljava.lang.Class;@a34e5c, public java.lang.Object java.util.HashMap.computeIfPresent(java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1fcb13a, public java.lang.Object java.util.HashMap.compute(java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1a7c258, public final native java.lang.Class java.lang.Object.getClass()=[Ljava.lang.Class;@7397f, public void java.util.HashMap.putAll(java.util.Map)=[Ljava.lang.Class;@59cd, public void java.util.LinkedHashMap.replaceAll(java.util.function.BiFunction)=[Ljava.lang.Class;@994816, public java.lang.Object java.util.HashMap.merge(java.lang.Object,java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1b1e75f, public int java.util.HashMap.size()=[Ljava.lang.Class;@bee157, public boolean java.util.LinkedHashMap.containsValue(java.lang.Object)=[Ljava.lang.Class;@5e0d7c}, replaceAll=public void java.util.LinkedHashMap.replaceAll(java.util.function.BiFunction), remove=freemarker.ext.beans.OverloadedMethods@8d3a99, containsValue=public boolean java.util.LinkedHashMap.containsValue(java.lang.Object), put=public java.lang.Object java.util.HashMap.put(java.lang.Object,java.lang.Object), empty=java.beans.PropertyDescriptor[name=empty; propertyType=boolean; readMethod=public boolean java.util.HashMap.isEmpty()], compute=public java.lang.Object java.util.HashMap.compute(java.lang.Object,java.util.function.BiFunction), hashCode=public int java.util.AbstractMap.hashCode(), putAll=public void java.util.HashMap.putAll(java.util.Map), get=public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object), merge=public java.lang.Object java.util.HashMap.merge(java.lang.Object,java.lang.Object,java.util.function.BiFunction), class=java.beans.PropertyDescriptor[name=class; propertyType=class java.lang.Class; readMethod=public final native java.lang.Class java.lang.Object.getClass()], keySet=public java.util.Set java.util.LinkedHashMap.keySet(), java.lang.Object@1c0f21d=freemarker.ext.beans.OverloadedMethods@d4b988, entrySet=public java.util.Set java.util.LinkedHashMap.entrySet(), java.lang.Object@15be27d=public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object), forEach=public void java.util.LinkedHashMap.forEach(java.util.function.BiConsumer), containsKey=public boolean java.util.HashMap.containsKey(java.lang.Object), isEmpty=public boolean java.util.HashMap.isEmpty(), clear=public void java.util.LinkedHashMap.clear(), computeIfPresent=public java.lang.Object java.util.HashMap.computeIfPresent(java.lang.Object,java.util.function.BiFunction), size=public int java.util.HashMap.size(), equals=public boolean java.util.AbstractMap.equals(java.lang.Object), clone=public java.lang.Object java.util.HashMap.clone(), toString=public java.lang.String java.util.AbstractMap.toString(), putIfAbsent=public java.lang.Object java.util.HashMap.putIfAbsent(java.lang.Object,java.lang.Object)}
[DEBUG] 2017-05-24: 21:05:33 freemarker.log._Log4jLoggerFactory$Log4jLogger.debug(_Log4jLoggerFactory.java:45) :  TemplateLoader.findTemplateSource("template/~~~xhtml/scripting-events.ftl"): Found
[DEBUG] 2017-05-24: 21:05:33 freemarker.log._Log4jLoggerFactory$Log4jLogger.debug(_Log4jLoggerFactory.java:45) :  "template/~~~xhtml/scripting-events.ftl"("zh_CN", UTF-8, parsed): using cached since jar:file:/D:/maven/repository/org/apache/struts/struts2-core/2.5.10/struts2-core-2.5.10.jar!/template/simple/scripting-events.ftl hasn't changed.
[DEBUG] 2017-05-24: 21:05:33 freemarker.log._Log4jLoggerFactory$Log4jLogger.debug(_Log4jLoggerFactory.java:45) :  Key "onclick" was not found on instance of java.util.LinkedHashMap. Introspection information for the class is: {getClass=public final native java.lang.Class java.lang.Object.getClass(), getOrDefault=public java.lang.Object java.util.LinkedHashMap.getOrDefault(java.lang.Object,java.lang.Object), computeIfAbsent=public java.lang.Object java.util.HashMap.computeIfAbsent(java.lang.Object,java.util.function.Function), values=public java.util.Collection java.util.LinkedHashMap.values(), replace=freemarker.ext.beans.OverloadedMethods@11d0265, java.lang.Object@3e55b2={public boolean java.util.HashMap.isEmpty()=[Ljava.lang.Class;@c5aa3a, public int java.util.AbstractMap.hashCode()=[Ljava.lang.Class;@74a947, public java.lang.Object java.util.HashMap.put(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@1615a91, public boolean java.util.AbstractMap.equals(java.lang.Object)=[Ljava.lang.Class;@a46ab2, public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object)=[Ljava.lang.Class;@1c389e6, public java.lang.String java.util.AbstractMap.toString()=[Ljava.lang.Class;@a23548, public boolean java.util.HashMap.containsKey(java.lang.Object)=[Ljava.lang.Class;@1be4a9f, public java.util.Set java.util.LinkedHashMap.keySet()=[Ljava.lang.Class;@44c60, public java.lang.Object java.util.HashMap.computeIfAbsent(java.lang.Object,java.util.function.Function)=[Ljava.lang.Class;@10f7dff, public java.lang.Object java.util.HashMap.clone()=[Ljava.lang.Class;@d214e3, public java.lang.Object java.util.LinkedHashMap.getOrDefault(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@1a74254, public java.util.Set java.util.LinkedHashMap.entrySet()=[Ljava.lang.Class;@1c4740c, public void java.util.LinkedHashMap.forEach(java.util.function.BiConsumer)=[Ljava.lang.Class;@1fe0c8e, public java.lang.Object java.util.HashMap.putIfAbsent(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@16f73de, public java.util.Collection java.util.LinkedHashMap.values()=[Ljava.lang.Class;@b3e45, public void java.util.LinkedHashMap.clear()=[Ljava.lang.Class;@a34e5c, public java.lang.Object java.util.HashMap.computeIfPresent(java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1fcb13a, public java.lang.Object java.util.HashMap.compute(java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1a7c258, public final native java.lang.Class java.lang.Object.getClass()=[Ljava.lang.Class;@7397f, public void java.util.HashMap.putAll(java.util.Map)=[Ljava.lang.Class;@59cd, public void java.util.LinkedHashMap.replaceAll(java.util.function.BiFunction)=[Ljava.lang.Class;@994816, public java.lang.Object java.util.HashMap.merge(java.lang.Object,java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1b1e75f, public int java.util.HashMap.size()=[Ljava.lang.Class;@bee157, public boolean java.util.LinkedHashMap.containsValue(java.lang.Object)=[Ljava.lang.Class;@5e0d7c}, replaceAll=public void java.util.LinkedHashMap.replaceAll(java.util.function.BiFunction), remove=freemarker.ext.beans.OverloadedMethods@8d3a99, containsValue=public boolean java.util.LinkedHashMap.containsValue(java.lang.Object), put=public java.lang.Object java.util.HashMap.put(java.lang.Object,java.lang.Object), empty=java.beans.PropertyDescriptor[name=empty; propertyType=boolean; readMethod=public boolean java.util.HashMap.isEmpty()], compute=public java.lang.Object java.util.HashMap.compute(java.lang.Object,java.util.function.BiFunction), hashCode=public int java.util.AbstractMap.hashCode(), putAll=public void java.util.HashMap.putAll(java.util.Map), get=public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object), merge=public java.lang.Object java.util.HashMap.merge(java.lang.Object,java.lang.Object,java.util.function.BiFunction), class=java.beans.PropertyDescriptor[name=class; propertyType=class java.lang.Class; readMethod=public final native java.lang.Class java.lang.Object.getClass()], keySet=public java.util.Set java.util.LinkedHashMap.keySet(), java.lang.Object@1c0f21d=freemarker.ext.beans.OverloadedMethods@d4b988, entrySet=public java.util.Set java.util.LinkedHashMap.entrySet(), java.lang.Object@15be27d=public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object), forEach=public void java.util.LinkedHashMap.forEach(java.util.function.BiConsumer), containsKey=public boolean java.util.HashMap.containsKey(java.lang.Object), isEmpty=public boolean java.util.HashMap.isEmpty(), clear=public void java.util.LinkedHashMap.clear(), computeIfPresent=public java.lang.Object java.util.HashMap.computeIfPresent(java.lang.Object,java.util.function.BiFunction), size=public int java.util.HashMap.size(), equals=public boolean java.util.AbstractMap.equals(java.lang.Object), clone=public java.lang.Object java.util.HashMap.clone(), toString=public java.lang.String java.util.AbstractMap.toString(), putIfAbsent=public java.lang.Object java.util.HashMap.putIfAbsent(java.lang.Object,java.lang.Object)}
[DEBUG] 2017-05-24: 21:05:33 freemarker.log._Log4jLoggerFactory$Log4jLogger.debug(_Log4jLoggerFactory.java:45) :  Key "ondblclick" was not found on instance of java.util.LinkedHashMap. Introspection information for the class is: {getClass=public final native java.lang.Class java.lang.Object.getClass(), getOrDefault=public java.lang.Object java.util.LinkedHashMap.getOrDefault(java.lang.Object,java.lang.Object), computeIfAbsent=public java.lang.Object java.util.HashMap.computeIfAbsent(java.lang.Object,java.util.function.Function), values=public java.util.Collection java.util.LinkedHashMap.values(), replace=freemarker.ext.beans.OverloadedMethods@11d0265, java.lang.Object@3e55b2={public boolean java.util.HashMap.isEmpty()=[Ljava.lang.Class;@c5aa3a, public int java.util.AbstractMap.hashCode()=[Ljava.lang.Class;@74a947, public java.lang.Object java.util.HashMap.put(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@1615a91, public boolean java.util.AbstractMap.equals(java.lang.Object)=[Ljava.lang.Class;@a46ab2, public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object)=[Ljava.lang.Class;@1c389e6, public java.lang.String java.util.AbstractMap.toString()=[Ljava.lang.Class;@a23548, public boolean java.util.HashMap.containsKey(java.lang.Object)=[Ljava.lang.Class;@1be4a9f, public java.util.Set java.util.LinkedHashMap.keySet()=[Ljava.lang.Class;@44c60, public java.lang.Object java.util.HashMap.computeIfAbsent(java.lang.Object,java.util.function.Function)=[Ljava.lang.Class;@10f7dff, public java.lang.Object java.util.HashMap.clone()=[Ljava.lang.Class;@d214e3, public java.lang.Object java.util.LinkedHashMap.getOrDefault(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@1a74254, public java.util.Set java.util.LinkedHashMap.entrySet()=[Ljava.lang.Class;@1c4740c, public void java.util.LinkedHashMap.forEach(java.util.function.BiConsumer)=[Ljava.lang.Class;@1fe0c8e, public java.lang.Object java.util.HashMap.putIfAbsent(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@16f73de, public java.util.Collection java.util.LinkedHashMap.values()=[Ljava.lang.Class;@b3e45, public void java.util.LinkedHashMap.clear()=[Ljava.lang.Class;@a34e5c, public java.lang.Object java.util.HashMap.computeIfPresent(java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1fcb13a, public java.lang.Object java.util.HashMap.compute(java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1a7c258, public final native java.lang.Class java.lang.Object.getClass()=[Ljava.lang.Class;@7397f, public void java.util.HashMap.putAll(java.util.Map)=[Ljava.lang.Class;@59cd, public void java.util.LinkedHashMap.replaceAll(java.util.function.BiFunction)=[Ljava.lang.Class;@994816, public java.lang.Object java.util.HashMap.merge(java.lang.Object,java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1b1e75f, public int java.util.HashMap.size()=[Ljava.lang.Class;@bee157, public boolean java.util.LinkedHashMap.containsValue(java.lang.Object)=[Ljava.lang.Class;@5e0d7c}, replaceAll=public void java.util.LinkedHashMap.replaceAll(java.util.function.BiFunction), remove=freemarker.ext.beans.OverloadedMethods@8d3a99, containsValue=public boolean java.util.LinkedHashMap.containsValue(java.lang.Object), put=public java.lang.Object java.util.HashMap.put(java.lang.Object,java.lang.Object), empty=java.beans.PropertyDescriptor[name=empty; propertyType=boolean; readMethod=public boolean java.util.HashMap.isEmpty()], compute=public java.lang.Object java.util.HashMap.compute(java.lang.Object,java.util.function.BiFunction), hashCode=public int java.util.AbstractMap.hashCode(), putAll=public void java.util.HashMap.putAll(java.util.Map), get=public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object), merge=public java.lang.Object java.util.HashMap.merge(java.lang.Object,java.lang.Object,java.util.function.BiFunction), class=java.beans.PropertyDescriptor[name=class; propertyType=class java.lang.Class; readMethod=public final native java.lang.Class java.lang.Object.getClass()], keySet=public java.util.Set java.util.LinkedHashMap.keySet(), java.lang.Object@1c0f21d=freemarker.ext.beans.OverloadedMethods@d4b988, entrySet=public java.util.Set java.util.LinkedHashMap.entrySet(), java.lang.Object@15be27d=public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object), forEach=public void java.util.LinkedHashMap.forEach(java.util.function.BiConsumer), containsKey=public boolean java.util.HashMap.containsKey(java.lang.Object), isEmpty=public boolean java.util.HashMap.isEmpty(), clear=public void java.util.LinkedHashMap.clear(), computeIfPresent=public java.lang.Object java.util.HashMap.computeIfPresent(java.lang.Object,java.util.function.BiFunction), size=public int java.util.HashMap.size(), equals=public boolean java.util.AbstractMap.equals(java.lang.Object), clone=public java.lang.Object java.util.HashMap.clone(), toString=public java.lang.String java.util.AbstractMap.toString(), putIfAbsent=public java.lang.Object java.util.HashMap.putIfAbsent(java.lang.Object,java.lang.Object)}
[DEBUG] 2017-05-24: 21:05:33 freemarker.log._Log4jLoggerFactory$Log4jLogger.debug(_Log4jLoggerFactory.java:45) :  Key "onmousedown" was not found on instance of java.util.LinkedHashMap. Introspection information for the class is: {getClass=public final native java.lang.Class java.lang.Object.getClass(), getOrDefault=public java.lang.Object java.util.LinkedHashMap.getOrDefault(java.lang.Object,java.lang.Object), computeIfAbsent=public java.lang.Object java.util.HashMap.computeIfAbsent(java.lang.Object,java.util.function.Function), values=public java.util.Collection java.util.LinkedHashMap.values(), replace=freemarker.ext.beans.OverloadedMethods@11d0265, java.lang.Object@3e55b2={public boolean java.util.HashMap.isEmpty()=[Ljava.lang.Class;@c5aa3a, public int java.util.AbstractMap.hashCode()=[Ljava.lang.Class;@74a947, public java.lang.Object java.util.HashMap.put(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@1615a91, public boolean java.util.AbstractMap.equals(java.lang.Object)=[Ljava.lang.Class;@a46ab2, public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object)=[Ljava.lang.Class;@1c389e6, public java.lang.String java.util.AbstractMap.toString()=[Ljava.lang.Class;@a23548, public boolean java.util.HashMap.containsKey(java.lang.Object)=[Ljava.lang.Class;@1be4a9f, public java.util.Set java.util.LinkedHashMap.keySet()=[Ljava.lang.Class;@44c60, public java.lang.Object java.util.HashMap.computeIfAbsent(java.lang.Object,java.util.function.Function)=[Ljava.lang.Class;@10f7dff, public java.lang.Object java.util.HashMap.clone()=[Ljava.lang.Class;@d214e3, public java.lang.Object java.util.LinkedHashMap.getOrDefault(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@1a74254, public java.util.Set java.util.LinkedHashMap.entrySet()=[Ljava.lang.Class;@1c4740c, public void java.util.LinkedHashMap.forEach(java.util.function.BiConsumer)=[Ljava.lang.Class;@1fe0c8e, public java.lang.Object java.util.HashMap.putIfAbsent(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@16f73de, public java.util.Collection java.util.LinkedHashMap.values()=[Ljava.lang.Class;@b3e45, public void java.util.LinkedHashMap.clear()=[Ljava.lang.Class;@a34e5c, public java.lang.Object java.util.HashMap.computeIfPresent(java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1fcb13a, public java.lang.Object java.util.HashMap.compute(java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1a7c258, public final native java.lang.Class java.lang.Object.getClass()=[Ljava.lang.Class;@7397f, public void java.util.HashMap.putAll(java.util.Map)=[Ljava.lang.Class;@59cd, public void java.util.LinkedHashMap.replaceAll(java.util.function.BiFunction)=[Ljava.lang.Class;@994816, public java.lang.Object java.util.HashMap.merge(java.lang.Object,java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1b1e75f, public int java.util.HashMap.size()=[Ljava.lang.Class;@bee157, public boolean java.util.LinkedHashMap.containsValue(java.lang.Object)=[Ljava.lang.Class;@5e0d7c}, replaceAll=public void java.util.LinkedHashMap.replaceAll(java.util.function.BiFunction), remove=freemarker.ext.beans.OverloadedMethods@8d3a99, containsValue=public boolean java.util.LinkedHashMap.containsValue(java.lang.Object), put=public java.lang.Object java.util.HashMap.put(java.lang.Object,java.lang.Object), empty=java.beans.PropertyDescriptor[name=empty; propertyType=boolean; readMethod=public boolean java.util.HashMap.isEmpty()], compute=public java.lang.Object java.util.HashMap.compute(java.lang.Object,java.util.function.BiFunction), hashCode=public int java.util.AbstractMap.hashCode(), putAll=public void java.util.HashMap.putAll(java.util.Map), get=public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object), merge=public java.lang.Object java.util.HashMap.merge(java.lang.Object,java.lang.Object,java.util.function.BiFunction), class=java.beans.PropertyDescriptor[name=class; propertyType=class java.lang.Class; readMethod=public final native java.lang.Class java.lang.Object.getClass()], keySet=public java.util.Set java.util.LinkedHashMap.keySet(), java.lang.Object@1c0f21d=freemarker.ext.beans.OverloadedMethods@d4b988, entrySet=public java.util.Set java.util.LinkedHashMap.entrySet(), java.lang.Object@15be27d=public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object), forEach=public void java.util.LinkedHashMap.forEach(java.util.function.BiConsumer), containsKey=public boolean java.util.HashMap.containsKey(java.lang.Object), isEmpty=public boolean java.util.HashMap.isEmpty(), clear=public void java.util.LinkedHashMap.clear(), computeIfPresent=public java.lang.Object java.util.HashMap.computeIfPresent(java.lang.Object,java.util.function.BiFunction), size=public int java.util.HashMap.size(), equals=public boolean java.util.AbstractMap.equals(java.lang.Object), clone=public java.lang.Object java.util.HashMap.clone(), toString=public java.lang.String java.util.AbstractMap.toString(), putIfAbsent=public java.lang.Object java.util.HashMap.putIfAbsent(java.lang.Object,java.lang.Object)}
[DEBUG] 2017-05-24: 21:05:33 freemarker.log._Log4jLoggerFactory$Log4jLogger.debug(_Log4jLoggerFactory.java:45) :  Key "onmouseup" was not found on instance of java.util.LinkedHashMap. Introspection information for the class is: {getClass=public final native java.lang.Class java.lang.Object.getClass(), getOrDefault=public java.lang.Object java.util.LinkedHashMap.getOrDefault(java.lang.Object,java.lang.Object), computeIfAbsent=public java.lang.Object java.util.HashMap.computeIfAbsent(java.lang.Object,java.util.function.Function), values=public java.util.Collection java.util.LinkedHashMap.values(), replace=freemarker.ext.beans.OverloadedMethods@11d0265, java.lang.Object@3e55b2={public boolean java.util.HashMap.isEmpty()=[Ljava.lang.Class;@c5aa3a, public int java.util.AbstractMap.hashCode()=[Ljava.lang.Class;@74a947, public java.lang.Object java.util.HashMap.put(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@1615a91, public boolean java.util.AbstractMap.equals(java.lang.Object)=[Ljava.lang.Class;@a46ab2, public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object)=[Ljava.lang.Class;@1c389e6, public java.lang.String java.util.AbstractMap.toString()=[Ljava.lang.Class;@a23548, public boolean java.util.HashMap.containsKey(java.lang.Object)=[Ljava.lang.Class;@1be4a9f, public java.util.Set java.util.LinkedHashMap.keySet()=[Ljava.lang.Class;@44c60, public java.lang.Object java.util.HashMap.computeIfAbsent(java.lang.Object,java.util.function.Function)=[Ljava.lang.Class;@10f7dff, public java.lang.Object java.util.HashMap.clone()=[Ljava.lang.Class;@d214e3, public java.lang.Object java.util.LinkedHashMap.getOrDefault(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@1a74254, public java.util.Set java.util.LinkedHashMap.entrySet()=[Ljava.lang.Class;@1c4740c, public void java.util.LinkedHashMap.forEach(java.util.function.BiConsumer)=[Ljava.lang.Class;@1fe0c8e, public java.lang.Object java.util.HashMap.putIfAbsent(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@16f73de, public java.util.Collection java.util.LinkedHashMap.values()=[Ljava.lang.Class;@b3e45, public void java.util.LinkedHashMap.clear()=[Ljava.lang.Class;@a34e5c, public java.lang.Object java.util.HashMap.computeIfPresent(java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1fcb13a, public java.lang.Object java.util.HashMap.compute(java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1a7c258, public final native java.lang.Class java.lang.Object.getClass()=[Ljava.lang.Class;@7397f, public void java.util.HashMap.putAll(java.util.Map)=[Ljava.lang.Class;@59cd, public void java.util.LinkedHashMap.replaceAll(java.util.function.BiFunction)=[Ljava.lang.Class;@994816, public java.lang.Object java.util.HashMap.merge(java.lang.Object,java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1b1e75f, public int java.util.HashMap.size()=[Ljava.lang.Class;@bee157, public boolean java.util.LinkedHashMap.containsValue(java.lang.Object)=[Ljava.lang.Class;@5e0d7c}, replaceAll=public void java.util.LinkedHashMap.replaceAll(java.util.function.BiFunction), remove=freemarker.ext.beans.OverloadedMethods@8d3a99, containsValue=public boolean java.util.LinkedHashMap.containsValue(java.lang.Object), put=public java.lang.Object java.util.HashMap.put(java.lang.Object,java.lang.Object), empty=java.beans.PropertyDescriptor[name=empty; propertyType=boolean; readMethod=public boolean java.util.HashMap.isEmpty()], compute=public java.lang.Object java.util.HashMap.compute(java.lang.Object,java.util.function.BiFunction), hashCode=public int java.util.AbstractMap.hashCode(), putAll=public void java.util.HashMap.putAll(java.util.Map), get=public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object), merge=public java.lang.Object java.util.HashMap.merge(java.lang.Object,java.lang.Object,java.util.function.BiFunction), class=java.beans.PropertyDescriptor[name=class; propertyType=class java.lang.Class; readMethod=public final native java.lang.Class java.lang.Object.getClass()], keySet=public java.util.Set java.util.LinkedHashMap.keySet(), java.lang.Object@1c0f21d=freemarker.ext.beans.OverloadedMethods@d4b988, entrySet=public java.util.Set java.util.LinkedHashMap.entrySet(), java.lang.Object@15be27d=public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object), forEach=public void java.util.LinkedHashMap.forEach(java.util.function.BiConsumer), containsKey=public boolean java.util.HashMap.containsKey(java.lang.Object), isEmpty=public boolean java.util.HashMap.isEmpty(), clear=public void java.util.LinkedHashMap.clear(), computeIfPresent=public java.lang.Object java.util.HashMap.computeIfPresent(java.lang.Object,java.util.function.BiFunction), size=public int java.util.HashMap.size(), equals=public boolean java.util.AbstractMap.equals(java.lang.Object), clone=public java.lang.Object java.util.HashMap.clone(), toString=public java.lang.String java.util.AbstractMap.toString(), putIfAbsent=public java.lang.Object java.util.HashMap.putIfAbsent(java.lang.Object,java.lang.Object)}
[DEBUG] 2017-05-24: 21:05:33 freemarker.log._Log4jLoggerFactory$Log4jLogger.debug(_Log4jLoggerFactory.java:45) :  Key "onmouseover" was not found on instance of java.util.LinkedHashMap. Introspection information for the class is: {getClass=public final native java.lang.Class java.lang.Object.getClass(), getOrDefault=public java.lang.Object java.util.LinkedHashMap.getOrDefault(java.lang.Object,java.lang.Object), computeIfAbsent=public java.lang.Object java.util.HashMap.computeIfAbsent(java.lang.Object,java.util.function.Function), values=public java.util.Collection java.util.LinkedHashMap.values(), replace=freemarker.ext.beans.OverloadedMethods@11d0265, java.lang.Object@3e55b2={public boolean java.util.HashMap.isEmpty()=[Ljava.lang.Class;@c5aa3a, public int java.util.AbstractMap.hashCode()=[Ljava.lang.Class;@74a947, public java.lang.Object java.util.HashMap.put(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@1615a91, public boolean java.util.AbstractMap.equals(java.lang.Object)=[Ljava.lang.Class;@a46ab2, public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object)=[Ljava.lang.Class;@1c389e6, public java.lang.String java.util.AbstractMap.toString()=[Ljava.lang.Class;@a23548, public boolean java.util.HashMap.containsKey(java.lang.Object)=[Ljava.lang.Class;@1be4a9f, public java.util.Set java.util.LinkedHashMap.keySet()=[Ljava.lang.Class;@44c60, public java.lang.Object java.util.HashMap.computeIfAbsent(java.lang.Object,java.util.function.Function)=[Ljava.lang.Class;@10f7dff, public java.lang.Object java.util.HashMap.clone()=[Ljava.lang.Class;@d214e3, public java.lang.Object java.util.LinkedHashMap.getOrDefault(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@1a74254, public java.util.Set java.util.LinkedHashMap.entrySet()=[Ljava.lang.Class;@1c4740c, public void java.util.LinkedHashMap.forEach(java.util.function.BiConsumer)=[Ljava.lang.Class;@1fe0c8e, public java.lang.Object java.util.HashMap.putIfAbsent(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@16f73de, public java.util.Collection java.util.LinkedHashMap.values()=[Ljava.lang.Class;@b3e45, public void java.util.LinkedHashMap.clear()=[Ljava.lang.Class;@a34e5c, public java.lang.Object java.util.HashMap.computeIfPresent(java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1fcb13a, public java.lang.Object java.util.HashMap.compute(java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1a7c258, public final native java.lang.Class java.lang.Object.getClass()=[Ljava.lang.Class;@7397f, public void java.util.HashMap.putAll(java.util.Map)=[Ljava.lang.Class;@59cd, public void java.util.LinkedHashMap.replaceAll(java.util.function.BiFunction)=[Ljava.lang.Class;@994816, public java.lang.Object java.util.HashMap.merge(java.lang.Object,java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1b1e75f, public int java.util.HashMap.size()=[Ljava.lang.Class;@bee157, public boolean java.util.LinkedHashMap.containsValue(java.lang.Object)=[Ljava.lang.Class;@5e0d7c}, replaceAll=public void java.util.LinkedHashMap.replaceAll(java.util.function.BiFunction), remove=freemarker.ext.beans.OverloadedMethods@8d3a99, containsValue=public boolean java.util.LinkedHashMap.containsValue(java.lang.Object), put=public java.lang.Object java.util.HashMap.put(java.lang.Object,java.lang.Object), empty=java.beans.PropertyDescriptor[name=empty; propertyType=boolean; readMethod=public boolean java.util.HashMap.isEmpty()], compute=public java.lang.Object java.util.HashMap.compute(java.lang.Object,java.util.function.BiFunction), hashCode=public int java.util.AbstractMap.hashCode(), putAll=public void java.util.HashMap.putAll(java.util.Map), get=public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object), merge=public java.lang.Object java.util.HashMap.merge(java.lang.Object,java.lang.Object,java.util.function.BiFunction), class=java.beans.PropertyDescriptor[name=class; propertyType=class java.lang.Class; readMethod=public final native java.lang.Class java.lang.Object.getClass()], keySet=public java.util.Set java.util.LinkedHashMap.keySet(), java.lang.Object@1c0f21d=freemarker.ext.beans.OverloadedMethods@d4b988, entrySet=public java.util.Set java.util.LinkedHashMap.entrySet(), java.lang.Object@15be27d=public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object), forEach=public void java.util.LinkedHashMap.forEach(java.util.function.BiConsumer), containsKey=public boolean java.util.HashMap.containsKey(java.lang.Object), isEmpty=public boolean java.util.HashMap.isEmpty(), clear=public void java.util.LinkedHashMap.clear(), computeIfPresent=public java.lang.Object java.util.HashMap.computeIfPresent(java.lang.Object,java.util.function.BiFunction), size=public int java.util.HashMap.size(), equals=public boolean java.util.AbstractMap.equals(java.lang.Object), clone=public java.lang.Object java.util.HashMap.clone(), toString=public java.lang.String java.util.AbstractMap.toString(), putIfAbsent=public java.lang.Object java.util.HashMap.putIfAbsent(java.lang.Object,java.lang.Object)}
[DEBUG] 2017-05-24: 21:05:33 freemarker.log._Log4jLoggerFactory$Log4jLogger.debug(_Log4jLoggerFactory.java:45) :  Key "onmousemove" was not found on instance of java.util.LinkedHashMap. Introspection information for the class is: {getClass=public final native java.lang.Class java.lang.Object.getClass(), getOrDefault=public java.lang.Object java.util.LinkedHashMap.getOrDefault(java.lang.Object,java.lang.Object), computeIfAbsent=public java.lang.Object java.util.HashMap.computeIfAbsent(java.lang.Object,java.util.function.Function), values=public java.util.Collection java.util.LinkedHashMap.values(), replace=freemarker.ext.beans.OverloadedMethods@11d0265, java.lang.Object@3e55b2={public boolean java.util.HashMap.isEmpty()=[Ljava.lang.Class;@c5aa3a, public int java.util.AbstractMap.hashCode()=[Ljava.lang.Class;@74a947, public java.lang.Object java.util.HashMap.put(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@1615a91, public boolean java.util.AbstractMap.equals(java.lang.Object)=[Ljava.lang.Class;@a46ab2, public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object)=[Ljava.lang.Class;@1c389e6, public java.lang.String java.util.AbstractMap.toString()=[Ljava.lang.Class;@a23548, public boolean java.util.HashMap.containsKey(java.lang.Object)=[Ljava.lang.Class;@1be4a9f, public java.util.Set java.util.LinkedHashMap.keySet()=[Ljava.lang.Class;@44c60, public java.lang.Object java.util.HashMap.computeIfAbsent(java.lang.Object,java.util.function.Function)=[Ljava.lang.Class;@10f7dff, public java.lang.Object java.util.HashMap.clone()=[Ljava.lang.Class;@d214e3, public java.lang.Object java.util.LinkedHashMap.getOrDefault(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@1a74254, public java.util.Set java.util.LinkedHashMap.entrySet()=[Ljava.lang.Class;@1c4740c, public void java.util.LinkedHashMap.forEach(java.util.function.BiConsumer)=[Ljava.lang.Class;@1fe0c8e, public java.lang.Object java.util.HashMap.putIfAbsent(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@16f73de, public java.util.Collection java.util.LinkedHashMap.values()=[Ljava.lang.Class;@b3e45, public void java.util.LinkedHashMap.clear()=[Ljava.lang.Class;@a34e5c, public java.lang.Object java.util.HashMap.computeIfPresent(java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1fcb13a, public java.lang.Object java.util.HashMap.compute(java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1a7c258, public final native java.lang.Class java.lang.Object.getClass()=[Ljava.lang.Class;@7397f, public void java.util.HashMap.putAll(java.util.Map)=[Ljava.lang.Class;@59cd, public void java.util.LinkedHashMap.replaceAll(java.util.function.BiFunction)=[Ljava.lang.Class;@994816, public java.lang.Object java.util.HashMap.merge(java.lang.Object,java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1b1e75f, public int java.util.HashMap.size()=[Ljava.lang.Class;@bee157, public boolean java.util.LinkedHashMap.containsValue(java.lang.Object)=[Ljava.lang.Class;@5e0d7c}, replaceAll=public void java.util.LinkedHashMap.replaceAll(java.util.function.BiFunction), remove=freemarker.ext.beans.OverloadedMethods@8d3a99, containsValue=public boolean java.util.LinkedHashMap.containsValue(java.lang.Object), put=public java.lang.Object java.util.HashMap.put(java.lang.Object,java.lang.Object), empty=java.beans.PropertyDescriptor[name=empty; propertyType=boolean; readMethod=public boolean java.util.HashMap.isEmpty()], compute=public java.lang.Object java.util.HashMap.compute(java.lang.Object,java.util.function.BiFunction), hashCode=public int java.util.AbstractMap.hashCode(), putAll=public void java.util.HashMap.putAll(java.util.Map), get=public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object), merge=public java.lang.Object java.util.HashMap.merge(java.lang.Object,java.lang.Object,java.util.function.BiFunction), class=java.beans.PropertyDescriptor[name=class; propertyType=class java.lang.Class; readMethod=public final native java.lang.Class java.lang.Object.getClass()], keySet=public java.util.Set java.util.LinkedHashMap.keySet(), java.lang.Object@1c0f21d=freemarker.ext.beans.OverloadedMethods@d4b988, entrySet=public java.util.Set java.util.LinkedHashMap.entrySet(), java.lang.Object@15be27d=public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object), forEach=public void java.util.LinkedHashMap.forEach(java.util.function.BiConsumer), containsKey=public boolean java.util.HashMap.containsKey(java.lang.Object), isEmpty=public boolean java.util.HashMap.isEmpty(), clear=public void java.util.LinkedHashMap.clear(), computeIfPresent=public java.lang.Object java.util.HashMap.computeIfPresent(java.lang.Object,java.util.function.BiFunction), size=public int java.util.HashMap.size(), equals=public boolean java.util.AbstractMap.equals(java.lang.Object), clone=public java.lang.Object java.util.HashMap.clone(), toString=public java.lang.String java.util.AbstractMap.toString(), putIfAbsent=public java.lang.Object java.util.HashMap.putIfAbsent(java.lang.Object,java.lang.Object)}
[DEBUG] 2017-05-24: 21:05:33 freemarker.log._Log4jLoggerFactory$Log4jLogger.debug(_Log4jLoggerFactory.java:45) :  Key "onmouseout" was not found on instance of java.util.LinkedHashMap. Introspection information for the class is: {getClass=public final native java.lang.Class java.lang.Object.getClass(), getOrDefault=public java.lang.Object java.util.LinkedHashMap.getOrDefault(java.lang.Object,java.lang.Object), computeIfAbsent=public java.lang.Object java.util.HashMap.computeIfAbsent(java.lang.Object,java.util.function.Function), values=public java.util.Collection java.util.LinkedHashMap.values(), replace=freemarker.ext.beans.OverloadedMethods@11d0265, java.lang.Object@3e55b2={public boolean java.util.HashMap.isEmpty()=[Ljava.lang.Class;@c5aa3a, public int java.util.AbstractMap.hashCode()=[Ljava.lang.Class;@74a947, public java.lang.Object java.util.HashMap.put(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@1615a91, public boolean java.util.AbstractMap.equals(java.lang.Object)=[Ljava.lang.Class;@a46ab2, public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object)=[Ljava.lang.Class;@1c389e6, public java.lang.String java.util.AbstractMap.toString()=[Ljava.lang.Class;@a23548, public boolean java.util.HashMap.containsKey(java.lang.Object)=[Ljava.lang.Class;@1be4a9f, public java.util.Set java.util.LinkedHashMap.keySet()=[Ljava.lang.Class;@44c60, public java.lang.Object java.util.HashMap.computeIfAbsent(java.lang.Object,java.util.function.Function)=[Ljava.lang.Class;@10f7dff, public java.lang.Object java.util.HashMap.clone()=[Ljava.lang.Class;@d214e3, public java.lang.Object java.util.LinkedHashMap.getOrDefault(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@1a74254, public java.util.Set java.util.LinkedHashMap.entrySet()=[Ljava.lang.Class;@1c4740c, public void java.util.LinkedHashMap.forEach(java.util.function.BiConsumer)=[Ljava.lang.Class;@1fe0c8e, public java.lang.Object java.util.HashMap.putIfAbsent(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@16f73de, public java.util.Collection java.util.LinkedHashMap.values()=[Ljava.lang.Class;@b3e45, public void java.util.LinkedHashMap.clear()=[Ljava.lang.Class;@a34e5c, public java.lang.Object java.util.HashMap.computeIfPresent(java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1fcb13a, public java.lang.Object java.util.HashMap.compute(java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1a7c258, public final native java.lang.Class java.lang.Object.getClass()=[Ljava.lang.Class;@7397f, public void java.util.HashMap.putAll(java.util.Map)=[Ljava.lang.Class;@59cd, public void java.util.LinkedHashMap.replaceAll(java.util.function.BiFunction)=[Ljava.lang.Class;@994816, public java.lang.Object java.util.HashMap.merge(java.lang.Object,java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1b1e75f, public int java.util.HashMap.size()=[Ljava.lang.Class;@bee157, public boolean java.util.LinkedHashMap.containsValue(java.lang.Object)=[Ljava.lang.Class;@5e0d7c}, replaceAll=public void java.util.LinkedHashMap.replaceAll(java.util.function.BiFunction), remove=freemarker.ext.beans.OverloadedMethods@8d3a99, containsValue=public boolean java.util.LinkedHashMap.containsValue(java.lang.Object), put=public java.lang.Object java.util.HashMap.put(java.lang.Object,java.lang.Object), empty=java.beans.PropertyDescriptor[name=empty; propertyType=boolean; readMethod=public boolean java.util.HashMap.isEmpty()], compute=public java.lang.Object java.util.HashMap.compute(java.lang.Object,java.util.function.BiFunction), hashCode=public int java.util.AbstractMap.hashCode(), putAll=public void java.util.HashMap.putAll(java.util.Map), get=public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object), merge=public java.lang.Object java.util.HashMap.merge(java.lang.Object,java.lang.Object,java.util.function.BiFunction), class=java.beans.PropertyDescriptor[name=class; propertyType=class java.lang.Class; readMethod=public final native java.lang.Class java.lang.Object.getClass()], keySet=public java.util.Set java.util.LinkedHashMap.keySet(), java.lang.Object@1c0f21d=freemarker.ext.beans.OverloadedMethods@d4b988, entrySet=public java.util.Set java.util.LinkedHashMap.entrySet(), java.lang.Object@15be27d=public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object), forEach=public void java.util.LinkedHashMap.forEach(java.util.function.BiConsumer), containsKey=public boolean java.util.HashMap.containsKey(java.lang.Object), isEmpty=public boolean java.util.HashMap.isEmpty(), clear=public void java.util.LinkedHashMap.clear(), computeIfPresent=public java.lang.Object java.util.HashMap.computeIfPresent(java.lang.Object,java.util.function.BiFunction), size=public int java.util.HashMap.size(), equals=public boolean java.util.AbstractMap.equals(java.lang.Object), clone=public java.lang.Object java.util.HashMap.clone(), toString=public java.lang.String java.util.AbstractMap.toString(), putIfAbsent=public java.lang.Object java.util.HashMap.putIfAbsent(java.lang.Object,java.lang.Object)}
[DEBUG] 2017-05-24: 21:05:33 freemarker.log._Log4jLoggerFactory$Log4jLogger.debug(_Log4jLoggerFactory.java:45) :  Key "onfocus" was not found on instance of java.util.LinkedHashMap. Introspection information for the class is: {getClass=public final native java.lang.Class java.lang.Object.getClass(), getOrDefault=public java.lang.Object java.util.LinkedHashMap.getOrDefault(java.lang.Object,java.lang.Object), computeIfAbsent=public java.lang.Object java.util.HashMap.computeIfAbsent(java.lang.Object,java.util.function.Function), values=public java.util.Collection java.util.LinkedHashMap.values(), replace=freemarker.ext.beans.OverloadedMethods@11d0265, java.lang.Object@3e55b2={public boolean java.util.HashMap.isEmpty()=[Ljava.lang.Class;@c5aa3a, public int java.util.AbstractMap.hashCode()=[Ljava.lang.Class;@74a947, public java.lang.Object java.util.HashMap.put(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@1615a91, public boolean java.util.AbstractMap.equals(java.lang.Object)=[Ljava.lang.Class;@a46ab2, public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object)=[Ljava.lang.Class;@1c389e6, public java.lang.String java.util.AbstractMap.toString()=[Ljava.lang.Class;@a23548, public boolean java.util.HashMap.containsKey(java.lang.Object)=[Ljava.lang.Class;@1be4a9f, public java.util.Set java.util.LinkedHashMap.keySet()=[Ljava.lang.Class;@44c60, public java.lang.Object java.util.HashMap.computeIfAbsent(java.lang.Object,java.util.function.Function)=[Ljava.lang.Class;@10f7dff, public java.lang.Object java.util.HashMap.clone()=[Ljava.lang.Class;@d214e3, public java.lang.Object java.util.LinkedHashMap.getOrDefault(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@1a74254, public java.util.Set java.util.LinkedHashMap.entrySet()=[Ljava.lang.Class;@1c4740c, public void java.util.LinkedHashMap.forEach(java.util.function.BiConsumer)=[Ljava.lang.Class;@1fe0c8e, public java.lang.Object java.util.HashMap.putIfAbsent(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@16f73de, public java.util.Collection java.util.LinkedHashMap.values()=[Ljava.lang.Class;@b3e45, public void java.util.LinkedHashMap.clear()=[Ljava.lang.Class;@a34e5c, public java.lang.Object java.util.HashMap.computeIfPresent(java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1fcb13a, public java.lang.Object java.util.HashMap.compute(java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1a7c258, public final native java.lang.Class java.lang.Object.getClass()=[Ljava.lang.Class;@7397f, public void java.util.HashMap.putAll(java.util.Map)=[Ljava.lang.Class;@59cd, public void java.util.LinkedHashMap.replaceAll(java.util.function.BiFunction)=[Ljava.lang.Class;@994816, public java.lang.Object java.util.HashMap.merge(java.lang.Object,java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1b1e75f, public int java.util.HashMap.size()=[Ljava.lang.Class;@bee157, public boolean java.util.LinkedHashMap.containsValue(java.lang.Object)=[Ljava.lang.Class;@5e0d7c}, replaceAll=public void java.util.LinkedHashMap.replaceAll(java.util.function.BiFunction), remove=freemarker.ext.beans.OverloadedMethods@8d3a99, containsValue=public boolean java.util.LinkedHashMap.containsValue(java.lang.Object), put=public java.lang.Object java.util.HashMap.put(java.lang.Object,java.lang.Object), empty=java.beans.PropertyDescriptor[name=empty; propertyType=boolean; readMethod=public boolean java.util.HashMap.isEmpty()], compute=public java.lang.Object java.util.HashMap.compute(java.lang.Object,java.util.function.BiFunction), hashCode=public int java.util.AbstractMap.hashCode(), putAll=public void java.util.HashMap.putAll(java.util.Map), get=public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object), merge=public java.lang.Object java.util.HashMap.merge(java.lang.Object,java.lang.Object,java.util.function.BiFunction), class=java.beans.PropertyDescriptor[name=class; propertyType=class java.lang.Class; readMethod=public final native java.lang.Class java.lang.Object.getClass()], keySet=public java.util.Set java.util.LinkedHashMap.keySet(), java.lang.Object@1c0f21d=freemarker.ext.beans.OverloadedMethods@d4b988, entrySet=public java.util.Set java.util.LinkedHashMap.entrySet(), java.lang.Object@15be27d=public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object), forEach=public void java.util.LinkedHashMap.forEach(java.util.function.BiConsumer), containsKey=public boolean java.util.HashMap.containsKey(java.lang.Object), isEmpty=public boolean java.util.HashMap.isEmpty(), clear=public void java.util.LinkedHashMap.clear(), computeIfPresent=public java.lang.Object java.util.HashMap.computeIfPresent(java.lang.Object,java.util.function.BiFunction), size=public int java.util.HashMap.size(), equals=public boolean java.util.AbstractMap.equals(java.lang.Object), clone=public java.lang.Object java.util.HashMap.clone(), toString=public java.lang.String java.util.AbstractMap.toString(), putIfAbsent=public java.lang.Object java.util.HashMap.putIfAbsent(java.lang.Object,java.lang.Object)}
[DEBUG] 2017-05-24: 21:05:33 freemarker.log._Log4jLoggerFactory$Log4jLogger.debug(_Log4jLoggerFactory.java:45) :  Key "onblur" was not found on instance of java.util.LinkedHashMap. Introspection information for the class is: {getClass=public final native java.lang.Class java.lang.Object.getClass(), getOrDefault=public java.lang.Object java.util.LinkedHashMap.getOrDefault(java.lang.Object,java.lang.Object), computeIfAbsent=public java.lang.Object java.util.HashMap.computeIfAbsent(java.lang.Object,java.util.function.Function), values=public java.util.Collection java.util.LinkedHashMap.values(), replace=freemarker.ext.beans.OverloadedMethods@11d0265, java.lang.Object@3e55b2={public boolean java.util.HashMap.isEmpty()=[Ljava.lang.Class;@c5aa3a, public int java.util.AbstractMap.hashCode()=[Ljava.lang.Class;@74a947, public java.lang.Object java.util.HashMap.put(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@1615a91, public boolean java.util.AbstractMap.equals(java.lang.Object)=[Ljava.lang.Class;@a46ab2, public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object)=[Ljava.lang.Class;@1c389e6, public java.lang.String java.util.AbstractMap.toString()=[Ljava.lang.Class;@a23548, public boolean java.util.HashMap.containsKey(java.lang.Object)=[Ljava.lang.Class;@1be4a9f, public java.util.Set java.util.LinkedHashMap.keySet()=[Ljava.lang.Class;@44c60, public java.lang.Object java.util.HashMap.computeIfAbsent(java.lang.Object,java.util.function.Function)=[Ljava.lang.Class;@10f7dff, public java.lang.Object java.util.HashMap.clone()=[Ljava.lang.Class;@d214e3, public java.lang.Object java.util.LinkedHashMap.getOrDefault(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@1a74254, public java.util.Set java.util.LinkedHashMap.entrySet()=[Ljava.lang.Class;@1c4740c, public void java.util.LinkedHashMap.forEach(java.util.function.BiConsumer)=[Ljava.lang.Class;@1fe0c8e, public java.lang.Object java.util.HashMap.putIfAbsent(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@16f73de, public java.util.Collection java.util.LinkedHashMap.values()=[Ljava.lang.Class;@b3e45, public void java.util.LinkedHashMap.clear()=[Ljava.lang.Class;@a34e5c, public java.lang.Object java.util.HashMap.computeIfPresent(java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1fcb13a, public java.lang.Object java.util.HashMap.compute(java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1a7c258, public final native java.lang.Class java.lang.Object.getClass()=[Ljava.lang.Class;@7397f, public void java.util.HashMap.putAll(java.util.Map)=[Ljava.lang.Class;@59cd, public void java.util.LinkedHashMap.replaceAll(java.util.function.BiFunction)=[Ljava.lang.Class;@994816, public java.lang.Object java.util.HashMap.merge(java.lang.Object,java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1b1e75f, public int java.util.HashMap.size()=[Ljava.lang.Class;@bee157, public boolean java.util.LinkedHashMap.containsValue(java.lang.Object)=[Ljava.lang.Class;@5e0d7c}, replaceAll=public void java.util.LinkedHashMap.replaceAll(java.util.function.BiFunction), remove=freemarker.ext.beans.OverloadedMethods@8d3a99, containsValue=public boolean java.util.LinkedHashMap.containsValue(java.lang.Object), put=public java.lang.Object java.util.HashMap.put(java.lang.Object,java.lang.Object), empty=java.beans.PropertyDescriptor[name=empty; propertyType=boolean; readMethod=public boolean java.util.HashMap.isEmpty()], compute=public java.lang.Object java.util.HashMap.compute(java.lang.Object,java.util.function.BiFunction), hashCode=public int java.util.AbstractMap.hashCode(), putAll=public void java.util.HashMap.putAll(java.util.Map), get=public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object), merge=public java.lang.Object java.util.HashMap.merge(java.lang.Object,java.lang.Object,java.util.function.BiFunction), class=java.beans.PropertyDescriptor[name=class; propertyType=class java.lang.Class; readMethod=public final native java.lang.Class java.lang.Object.getClass()], keySet=public java.util.Set java.util.LinkedHashMap.keySet(), java.lang.Object@1c0f21d=freemarker.ext.beans.OverloadedMethods@d4b988, entrySet=public java.util.Set java.util.LinkedHashMap.entrySet(), java.lang.Object@15be27d=public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object), forEach=public void java.util.LinkedHashMap.forEach(java.util.function.BiConsumer), containsKey=public boolean java.util.HashMap.containsKey(java.lang.Object), isEmpty=public boolean java.util.HashMap.isEmpty(), clear=public void java.util.LinkedHashMap.clear(), computeIfPresent=public java.lang.Object java.util.HashMap.computeIfPresent(java.lang.Object,java.util.function.BiFunction), size=public int java.util.HashMap.size(), equals=public boolean java.util.AbstractMap.equals(java.lang.Object), clone=public java.lang.Object java.util.HashMap.clone(), toString=public java.lang.String java.util.AbstractMap.toString(), putIfAbsent=public java.lang.Object java.util.HashMap.putIfAbsent(java.lang.Object,java.lang.Object)}
[DEBUG] 2017-05-24: 21:05:33 freemarker.log._Log4jLoggerFactory$Log4jLogger.debug(_Log4jLoggerFactory.java:45) :  Key "onkeypress" was not found on instance of java.util.LinkedHashMap. Introspection information for the class is: {getClass=public final native java.lang.Class java.lang.Object.getClass(), getOrDefault=public java.lang.Object java.util.LinkedHashMap.getOrDefault(java.lang.Object,java.lang.Object), computeIfAbsent=public java.lang.Object java.util.HashMap.computeIfAbsent(java.lang.Object,java.util.function.Function), values=public java.util.Collection java.util.LinkedHashMap.values(), replace=freemarker.ext.beans.OverloadedMethods@11d0265, java.lang.Object@3e55b2={public boolean java.util.HashMap.isEmpty()=[Ljava.lang.Class;@c5aa3a, public int java.util.AbstractMap.hashCode()=[Ljava.lang.Class;@74a947, public java.lang.Object java.util.HashMap.put(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@1615a91, public boolean java.util.AbstractMap.equals(java.lang.Object)=[Ljava.lang.Class;@a46ab2, public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object)=[Ljava.lang.Class;@1c389e6, public java.lang.String java.util.AbstractMap.toString()=[Ljava.lang.Class;@a23548, public boolean java.util.HashMap.containsKey(java.lang.Object)=[Ljava.lang.Class;@1be4a9f, public java.util.Set java.util.LinkedHashMap.keySet()=[Ljava.lang.Class;@44c60, public java.lang.Object java.util.HashMap.computeIfAbsent(java.lang.Object,java.util.function.Function)=[Ljava.lang.Class;@10f7dff, public java.lang.Object java.util.HashMap.clone()=[Ljava.lang.Class;@d214e3, public java.lang.Object java.util.LinkedHashMap.getOrDefault(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@1a74254, public java.util.Set java.util.LinkedHashMap.entrySet()=[Ljava.lang.Class;@1c4740c, public void java.util.LinkedHashMap.forEach(java.util.function.BiConsumer)=[Ljava.lang.Class;@1fe0c8e, public java.lang.Object java.util.HashMap.putIfAbsent(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@16f73de, public java.util.Collection java.util.LinkedHashMap.values()=[Ljava.lang.Class;@b3e45, public void java.util.LinkedHashMap.clear()=[Ljava.lang.Class;@a34e5c, public java.lang.Object java.util.HashMap.computeIfPresent(java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1fcb13a, public java.lang.Object java.util.HashMap.compute(java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1a7c258, public final native java.lang.Class java.lang.Object.getClass()=[Ljava.lang.Class;@7397f, public void java.util.HashMap.putAll(java.util.Map)=[Ljava.lang.Class;@59cd, public void java.util.LinkedHashMap.replaceAll(java.util.function.BiFunction)=[Ljava.lang.Class;@994816, public java.lang.Object java.util.HashMap.merge(java.lang.Object,java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1b1e75f, public int java.util.HashMap.size()=[Ljava.lang.Class;@bee157, public boolean java.util.LinkedHashMap.containsValue(java.lang.Object)=[Ljava.lang.Class;@5e0d7c}, replaceAll=public void java.util.LinkedHashMap.replaceAll(java.util.function.BiFunction), remove=freemarker.ext.beans.OverloadedMethods@8d3a99, containsValue=public boolean java.util.LinkedHashMap.containsValue(java.lang.Object), put=public java.lang.Object java.util.HashMap.put(java.lang.Object,java.lang.Object), empty=java.beans.PropertyDescriptor[name=empty; propertyType=boolean; readMethod=public boolean java.util.HashMap.isEmpty()], compute=public java.lang.Object java.util.HashMap.compute(java.lang.Object,java.util.function.BiFunction), hashCode=public int java.util.AbstractMap.hashCode(), putAll=public void java.util.HashMap.putAll(java.util.Map), get=public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object), merge=public java.lang.Object java.util.HashMap.merge(java.lang.Object,java.lang.Object,java.util.function.BiFunction), class=java.beans.PropertyDescriptor[name=class; propertyType=class java.lang.Class; readMethod=public final native java.lang.Class java.lang.Object.getClass()], keySet=public java.util.Set java.util.LinkedHashMap.keySet(), java.lang.Object@1c0f21d=freemarker.ext.beans.OverloadedMethods@d4b988, entrySet=public java.util.Set java.util.LinkedHashMap.entrySet(), java.lang.Object@15be27d=public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object), forEach=public void java.util.LinkedHashMap.forEach(java.util.function.BiConsumer), containsKey=public boolean java.util.HashMap.containsKey(java.lang.Object), isEmpty=public boolean java.util.HashMap.isEmpty(), clear=public void java.util.LinkedHashMap.clear(), computeIfPresent=public java.lang.Object java.util.HashMap.computeIfPresent(java.lang.Object,java.util.function.BiFunction), size=public int java.util.HashMap.size(), equals=public boolean java.util.AbstractMap.equals(java.lang.Object), clone=public java.lang.Object java.util.HashMap.clone(), toString=public java.lang.String java.util.AbstractMap.toString(), putIfAbsent=public java.lang.Object java.util.HashMap.putIfAbsent(java.lang.Object,java.lang.Object)}
[DEBUG] 2017-05-24: 21:05:33 freemarker.log._Log4jLoggerFactory$Log4jLogger.debug(_Log4jLoggerFactory.java:45) :  Key "onkeydown" was not found on instance of java.util.LinkedHashMap. Introspection information for the class is: {getClass=public final native java.lang.Class java.lang.Object.getClass(), getOrDefault=public java.lang.Object java.util.LinkedHashMap.getOrDefault(java.lang.Object,java.lang.Object), computeIfAbsent=public java.lang.Object java.util.HashMap.computeIfAbsent(java.lang.Object,java.util.function.Function), values=public java.util.Collection java.util.LinkedHashMap.values(), replace=freemarker.ext.beans.OverloadedMethods@11d0265, java.lang.Object@3e55b2={public boolean java.util.HashMap.isEmpty()=[Ljava.lang.Class;@c5aa3a, public int java.util.AbstractMap.hashCode()=[Ljava.lang.Class;@74a947, public java.lang.Object java.util.HashMap.put(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@1615a91, public boolean java.util.AbstractMap.equals(java.lang.Object)=[Ljava.lang.Class;@a46ab2, public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object)=[Ljava.lang.Class;@1c389e6, public java.lang.String java.util.AbstractMap.toString()=[Ljava.lang.Class;@a23548, public boolean java.util.HashMap.containsKey(java.lang.Object)=[Ljava.lang.Class;@1be4a9f, public java.util.Set java.util.LinkedHashMap.keySet()=[Ljava.lang.Class;@44c60, public java.lang.Object java.util.HashMap.computeIfAbsent(java.lang.Object,java.util.function.Function)=[Ljava.lang.Class;@10f7dff, public java.lang.Object java.util.HashMap.clone()=[Ljava.lang.Class;@d214e3, public java.lang.Object java.util.LinkedHashMap.getOrDefault(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@1a74254, public java.util.Set java.util.LinkedHashMap.entrySet()=[Ljava.lang.Class;@1c4740c, public void java.util.LinkedHashMap.forEach(java.util.function.BiConsumer)=[Ljava.lang.Class;@1fe0c8e, public java.lang.Object java.util.HashMap.putIfAbsent(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@16f73de, public java.util.Collection java.util.LinkedHashMap.values()=[Ljava.lang.Class;@b3e45, public void java.util.LinkedHashMap.clear()=[Ljava.lang.Class;@a34e5c, public java.lang.Object java.util.HashMap.computeIfPresent(java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1fcb13a, public java.lang.Object java.util.HashMap.compute(java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1a7c258, public final native java.lang.Class java.lang.Object.getClass()=[Ljava.lang.Class;@7397f, public void java.util.HashMap.putAll(java.util.Map)=[Ljava.lang.Class;@59cd, public void java.util.LinkedHashMap.replaceAll(java.util.function.BiFunction)=[Ljava.lang.Class;@994816, public java.lang.Object java.util.HashMap.merge(java.lang.Object,java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1b1e75f, public int java.util.HashMap.size()=[Ljava.lang.Class;@bee157, public boolean java.util.LinkedHashMap.containsValue(java.lang.Object)=[Ljava.lang.Class;@5e0d7c}, replaceAll=public void java.util.LinkedHashMap.replaceAll(java.util.function.BiFunction), remove=freemarker.ext.beans.OverloadedMethods@8d3a99, containsValue=public boolean java.util.LinkedHashMap.containsValue(java.lang.Object), put=public java.lang.Object java.util.HashMap.put(java.lang.Object,java.lang.Object), empty=java.beans.PropertyDescriptor[name=empty; propertyType=boolean; readMethod=public boolean java.util.HashMap.isEmpty()], compute=public java.lang.Object java.util.HashMap.compute(java.lang.Object,java.util.function.BiFunction), hashCode=public int java.util.AbstractMap.hashCode(), putAll=public void java.util.HashMap.putAll(java.util.Map), get=public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object), merge=public java.lang.Object java.util.HashMap.merge(java.lang.Object,java.lang.Object,java.util.function.BiFunction), class=java.beans.PropertyDescriptor[name=class; propertyType=class java.lang.Class; readMethod=public final native java.lang.Class java.lang.Object.getClass()], keySet=public java.util.Set java.util.LinkedHashMap.keySet(), java.lang.Object@1c0f21d=freemarker.ext.beans.OverloadedMethods@d4b988, entrySet=public java.util.Set java.util.LinkedHashMap.entrySet(), java.lang.Object@15be27d=public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object), forEach=public void java.util.LinkedHashMap.forEach(java.util.function.BiConsumer), containsKey=public boolean java.util.HashMap.containsKey(java.lang.Object), isEmpty=public boolean java.util.HashMap.isEmpty(), clear=public void java.util.LinkedHashMap.clear(), computeIfPresent=public java.lang.Object java.util.HashMap.computeIfPresent(java.lang.Object,java.util.function.BiFunction), size=public int java.util.HashMap.size(), equals=public boolean java.util.AbstractMap.equals(java.lang.Object), clone=public java.lang.Object java.util.HashMap.clone(), toString=public java.lang.String java.util.AbstractMap.toString(), putIfAbsent=public java.lang.Object java.util.HashMap.putIfAbsent(java.lang.Object,java.lang.Object)}
[DEBUG] 2017-05-24: 21:05:33 freemarker.log._Log4jLoggerFactory$Log4jLogger.debug(_Log4jLoggerFactory.java:45) :  Key "onkeyup" was not found on instance of java.util.LinkedHashMap. Introspection information for the class is: {getClass=public final native java.lang.Class java.lang.Object.getClass(), getOrDefault=public java.lang.Object java.util.LinkedHashMap.getOrDefault(java.lang.Object,java.lang.Object), computeIfAbsent=public java.lang.Object java.util.HashMap.computeIfAbsent(java.lang.Object,java.util.function.Function), values=public java.util.Collection java.util.LinkedHashMap.values(), replace=freemarker.ext.beans.OverloadedMethods@11d0265, java.lang.Object@3e55b2={public boolean java.util.HashMap.isEmpty()=[Ljava.lang.Class;@c5aa3a, public int java.util.AbstractMap.hashCode()=[Ljava.lang.Class;@74a947, public java.lang.Object java.util.HashMap.put(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@1615a91, public boolean java.util.AbstractMap.equals(java.lang.Object)=[Ljava.lang.Class;@a46ab2, public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object)=[Ljava.lang.Class;@1c389e6, public java.lang.String java.util.AbstractMap.toString()=[Ljava.lang.Class;@a23548, public boolean java.util.HashMap.containsKey(java.lang.Object)=[Ljava.lang.Class;@1be4a9f, public java.util.Set java.util.LinkedHashMap.keySet()=[Ljava.lang.Class;@44c60, public java.lang.Object java.util.HashMap.computeIfAbsent(java.lang.Object,java.util.function.Function)=[Ljava.lang.Class;@10f7dff, public java.lang.Object java.util.HashMap.clone()=[Ljava.lang.Class;@d214e3, public java.lang.Object java.util.LinkedHashMap.getOrDefault(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@1a74254, public java.util.Set java.util.LinkedHashMap.entrySet()=[Ljava.lang.Class;@1c4740c, public void java.util.LinkedHashMap.forEach(java.util.function.BiConsumer)=[Ljava.lang.Class;@1fe0c8e, public java.lang.Object java.util.HashMap.putIfAbsent(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@16f73de, public java.util.Collection java.util.LinkedHashMap.values()=[Ljava.lang.Class;@b3e45, public void java.util.LinkedHashMap.clear()=[Ljava.lang.Class;@a34e5c, public java.lang.Object java.util.HashMap.computeIfPresent(java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1fcb13a, public java.lang.Object java.util.HashMap.compute(java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1a7c258, public final native java.lang.Class java.lang.Object.getClass()=[Ljava.lang.Class;@7397f, public void java.util.HashMap.putAll(java.util.Map)=[Ljava.lang.Class;@59cd, public void java.util.LinkedHashMap.replaceAll(java.util.function.BiFunction)=[Ljava.lang.Class;@994816, public java.lang.Object java.util.HashMap.merge(java.lang.Object,java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1b1e75f, public int java.util.HashMap.size()=[Ljava.lang.Class;@bee157, public boolean java.util.LinkedHashMap.containsValue(java.lang.Object)=[Ljava.lang.Class;@5e0d7c}, replaceAll=public void java.util.LinkedHashMap.replaceAll(java.util.function.BiFunction), remove=freemarker.ext.beans.OverloadedMethods@8d3a99, containsValue=public boolean java.util.LinkedHashMap.containsValue(java.lang.Object), put=public java.lang.Object java.util.HashMap.put(java.lang.Object,java.lang.Object), empty=java.beans.PropertyDescriptor[name=empty; propertyType=boolean; readMethod=public boolean java.util.HashMap.isEmpty()], compute=public java.lang.Object java.util.HashMap.compute(java.lang.Object,java.util.function.BiFunction), hashCode=public int java.util.AbstractMap.hashCode(), putAll=public void java.util.HashMap.putAll(java.util.Map), get=public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object), merge=public java.lang.Object java.util.HashMap.merge(java.lang.Object,java.lang.Object,java.util.function.BiFunction), class=java.beans.PropertyDescriptor[name=class; propertyType=class java.lang.Class; readMethod=public final native java.lang.Class java.lang.Object.getClass()], keySet=public java.util.Set java.util.LinkedHashMap.keySet(), java.lang.Object@1c0f21d=freemarker.ext.beans.OverloadedMethods@d4b988, entrySet=public java.util.Set java.util.LinkedHashMap.entrySet(), java.lang.Object@15be27d=public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object), forEach=public void java.util.LinkedHashMap.forEach(java.util.function.BiConsumer), containsKey=public boolean java.util.HashMap.containsKey(java.lang.Object), isEmpty=public boolean java.util.HashMap.isEmpty(), clear=public void java.util.LinkedHashMap.clear(), computeIfPresent=public java.lang.Object java.util.HashMap.computeIfPresent(java.lang.Object,java.util.function.BiFunction), size=public int java.util.HashMap.size(), equals=public boolean java.util.AbstractMap.equals(java.lang.Object), clone=public java.lang.Object java.util.HashMap.clone(), toString=public java.lang.String java.util.AbstractMap.toString(), putIfAbsent=public java.lang.Object java.util.HashMap.putIfAbsent(java.lang.Object,java.lang.Object)}
[DEBUG] 2017-05-24: 21:05:33 freemarker.log._Log4jLoggerFactory$Log4jLogger.debug(_Log4jLoggerFactory.java:45) :  Key "onselect" was not found on instance of java.util.LinkedHashMap. Introspection information for the class is: {getClass=public final native java.lang.Class java.lang.Object.getClass(), getOrDefault=public java.lang.Object java.util.LinkedHashMap.getOrDefault(java.lang.Object,java.lang.Object), computeIfAbsent=public java.lang.Object java.util.HashMap.computeIfAbsent(java.lang.Object,java.util.function.Function), values=public java.util.Collection java.util.LinkedHashMap.values(), replace=freemarker.ext.beans.OverloadedMethods@11d0265, java.lang.Object@3e55b2={public boolean java.util.HashMap.isEmpty()=[Ljava.lang.Class;@c5aa3a, public int java.util.AbstractMap.hashCode()=[Ljava.lang.Class;@74a947, public java.lang.Object java.util.HashMap.put(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@1615a91, public boolean java.util.AbstractMap.equals(java.lang.Object)=[Ljava.lang.Class;@a46ab2, public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object)=[Ljava.lang.Class;@1c389e6, public java.lang.String java.util.AbstractMap.toString()=[Ljava.lang.Class;@a23548, public boolean java.util.HashMap.containsKey(java.lang.Object)=[Ljava.lang.Class;@1be4a9f, public java.util.Set java.util.LinkedHashMap.keySet()=[Ljava.lang.Class;@44c60, public java.lang.Object java.util.HashMap.computeIfAbsent(java.lang.Object,java.util.function.Function)=[Ljava.lang.Class;@10f7dff, public java.lang.Object java.util.HashMap.clone()=[Ljava.lang.Class;@d214e3, public java.lang.Object java.util.LinkedHashMap.getOrDefault(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@1a74254, public java.util.Set java.util.LinkedHashMap.entrySet()=[Ljava.lang.Class;@1c4740c, public void java.util.LinkedHashMap.forEach(java.util.function.BiConsumer)=[Ljava.lang.Class;@1fe0c8e, public java.lang.Object java.util.HashMap.putIfAbsent(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@16f73de, public java.util.Collection java.util.LinkedHashMap.values()=[Ljava.lang.Class;@b3e45, public void java.util.LinkedHashMap.clear()=[Ljava.lang.Class;@a34e5c, public java.lang.Object java.util.HashMap.computeIfPresent(java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1fcb13a, public java.lang.Object java.util.HashMap.compute(java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1a7c258, public final native java.lang.Class java.lang.Object.getClass()=[Ljava.lang.Class;@7397f, public void java.util.HashMap.putAll(java.util.Map)=[Ljava.lang.Class;@59cd, public void java.util.LinkedHashMap.replaceAll(java.util.function.BiFunction)=[Ljava.lang.Class;@994816, public java.lang.Object java.util.HashMap.merge(java.lang.Object,java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1b1e75f, public int java.util.HashMap.size()=[Ljava.lang.Class;@bee157, public boolean java.util.LinkedHashMap.containsValue(java.lang.Object)=[Ljava.lang.Class;@5e0d7c}, replaceAll=public void java.util.LinkedHashMap.replaceAll(java.util.function.BiFunction), remove=freemarker.ext.beans.OverloadedMethods@8d3a99, containsValue=public boolean java.util.LinkedHashMap.containsValue(java.lang.Object), put=public java.lang.Object java.util.HashMap.put(java.lang.Object,java.lang.Object), empty=java.beans.PropertyDescriptor[name=empty; propertyType=boolean; readMethod=public boolean java.util.HashMap.isEmpty()], compute=public java.lang.Object java.util.HashMap.compute(java.lang.Object,java.util.function.BiFunction), hashCode=public int java.util.AbstractMap.hashCode(), putAll=public void java.util.HashMap.putAll(java.util.Map), get=public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object), merge=public java.lang.Object java.util.HashMap.merge(java.lang.Object,java.lang.Object,java.util.function.BiFunction), class=java.beans.PropertyDescriptor[name=class; propertyType=class java.lang.Class; readMethod=public final native java.lang.Class java.lang.Object.getClass()], keySet=public java.util.Set java.util.LinkedHashMap.keySet(), java.lang.Object@1c0f21d=freemarker.ext.beans.OverloadedMethods@d4b988, entrySet=public java.util.Set java.util.LinkedHashMap.entrySet(), java.lang.Object@15be27d=public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object), forEach=public void java.util.LinkedHashMap.forEach(java.util.function.BiConsumer), containsKey=public boolean java.util.HashMap.containsKey(java.lang.Object), isEmpty=public boolean java.util.HashMap.isEmpty(), clear=public void java.util.LinkedHashMap.clear(), computeIfPresent=public java.lang.Object java.util.HashMap.computeIfPresent(java.lang.Object,java.util.function.BiFunction), size=public int java.util.HashMap.size(), equals=public boolean java.util.AbstractMap.equals(java.lang.Object), clone=public java.lang.Object java.util.HashMap.clone(), toString=public java.lang.String java.util.AbstractMap.toString(), putIfAbsent=public java.lang.Object java.util.HashMap.putIfAbsent(java.lang.Object,java.lang.Object)}
[DEBUG] 2017-05-24: 21:05:33 freemarker.log._Log4jLoggerFactory$Log4jLogger.debug(_Log4jLoggerFactory.java:45) :  Key "onchange" was not found on instance of java.util.LinkedHashMap. Introspection information for the class is: {getClass=public final native java.lang.Class java.lang.Object.getClass(), getOrDefault=public java.lang.Object java.util.LinkedHashMap.getOrDefault(java.lang.Object,java.lang.Object), computeIfAbsent=public java.lang.Object java.util.HashMap.computeIfAbsent(java.lang.Object,java.util.function.Function), values=public java.util.Collection java.util.LinkedHashMap.values(), replace=freemarker.ext.beans.OverloadedMethods@11d0265, java.lang.Object@3e55b2={public boolean java.util.HashMap.isEmpty()=[Ljava.lang.Class;@c5aa3a, public int java.util.AbstractMap.hashCode()=[Ljava.lang.Class;@74a947, public java.lang.Object java.util.HashMap.put(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@1615a91, public boolean java.util.AbstractMap.equals(java.lang.Object)=[Ljava.lang.Class;@a46ab2, public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object)=[Ljava.lang.Class;@1c389e6, public java.lang.String java.util.AbstractMap.toString()=[Ljava.lang.Class;@a23548, public boolean java.util.HashMap.containsKey(java.lang.Object)=[Ljava.lang.Class;@1be4a9f, public java.util.Set java.util.LinkedHashMap.keySet()=[Ljava.lang.Class;@44c60, public java.lang.Object java.util.HashMap.computeIfAbsent(java.lang.Object,java.util.function.Function)=[Ljava.lang.Class;@10f7dff, public java.lang.Object java.util.HashMap.clone()=[Ljava.lang.Class;@d214e3, public java.lang.Object java.util.LinkedHashMap.getOrDefault(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@1a74254, public java.util.Set java.util.LinkedHashMap.entrySet()=[Ljava.lang.Class;@1c4740c, public void java.util.LinkedHashMap.forEach(java.util.function.BiConsumer)=[Ljava.lang.Class;@1fe0c8e, public java.lang.Object java.util.HashMap.putIfAbsent(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@16f73de, public java.util.Collection java.util.LinkedHashMap.values()=[Ljava.lang.Class;@b3e45, public void java.util.LinkedHashMap.clear()=[Ljava.lang.Class;@a34e5c, public java.lang.Object java.util.HashMap.computeIfPresent(java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1fcb13a, public java.lang.Object java.util.HashMap.compute(java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1a7c258, public final native java.lang.Class java.lang.Object.getClass()=[Ljava.lang.Class;@7397f, public void java.util.HashMap.putAll(java.util.Map)=[Ljava.lang.Class;@59cd, public void java.util.LinkedHashMap.replaceAll(java.util.function.BiFunction)=[Ljava.lang.Class;@994816, public java.lang.Object java.util.HashMap.merge(java.lang.Object,java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1b1e75f, public int java.util.HashMap.size()=[Ljava.lang.Class;@bee157, public boolean java.util.LinkedHashMap.containsValue(java.lang.Object)=[Ljava.lang.Class;@5e0d7c}, replaceAll=public void java.util.LinkedHashMap.replaceAll(java.util.function.BiFunction), remove=freemarker.ext.beans.OverloadedMethods@8d3a99, containsValue=public boolean java.util.LinkedHashMap.containsValue(java.lang.Object), put=public java.lang.Object java.util.HashMap.put(java.lang.Object,java.lang.Object), empty=java.beans.PropertyDescriptor[name=empty; propertyType=boolean; readMethod=public boolean java.util.HashMap.isEmpty()], compute=public java.lang.Object java.util.HashMap.compute(java.lang.Object,java.util.function.BiFunction), hashCode=public int java.util.AbstractMap.hashCode(), putAll=public void java.util.HashMap.putAll(java.util.Map), get=public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object), merge=public java.lang.Object java.util.HashMap.merge(java.lang.Object,java.lang.Object,java.util.function.BiFunction), class=java.beans.PropertyDescriptor[name=class; propertyType=class java.lang.Class; readMethod=public final native java.lang.Class java.lang.Object.getClass()], keySet=public java.util.Set java.util.LinkedHashMap.keySet(), java.lang.Object@1c0f21d=freemarker.ext.beans.OverloadedMethods@d4b988, entrySet=public java.util.Set java.util.LinkedHashMap.entrySet(), java.lang.Object@15be27d=public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object), forEach=public void java.util.LinkedHashMap.forEach(java.util.function.BiConsumer), containsKey=public boolean java.util.HashMap.containsKey(java.lang.Object), isEmpty=public boolean java.util.HashMap.isEmpty(), clear=public void java.util.LinkedHashMap.clear(), computeIfPresent=public java.lang.Object java.util.HashMap.computeIfPresent(java.lang.Object,java.util.function.BiFunction), size=public int java.util.HashMap.size(), equals=public boolean java.util.AbstractMap.equals(java.lang.Object), clone=public java.lang.Object java.util.HashMap.clone(), toString=public java.lang.String java.util.AbstractMap.toString(), putIfAbsent=public java.lang.Object java.util.HashMap.putIfAbsent(java.lang.Object,java.lang.Object)}
[DEBUG] 2017-05-24: 21:05:33 freemarker.log._Log4jLoggerFactory$Log4jLogger.debug(_Log4jLoggerFactory.java:45) :  TemplateLoader.findTemplateSource("template/~~~xhtml/common-attributes.ftl"): Found
[DEBUG] 2017-05-24: 21:05:33 freemarker.log._Log4jLoggerFactory$Log4jLogger.debug(_Log4jLoggerFactory.java:45) :  "template/~~~xhtml/common-attributes.ftl"("zh_CN", UTF-8, parsed): using cached since jar:file:/D:/maven/repository/org/apache/struts/struts2-core/2.5.10/struts2-core-2.5.10.jar!/template/simple/common-attributes.ftl hasn't changed.
[DEBUG] 2017-05-24: 21:05:33 freemarker.log._Log4jLoggerFactory$Log4jLogger.debug(_Log4jLoggerFactory.java:45) :  Key "accesskey" was not found on instance of java.util.LinkedHashMap. Introspection information for the class is: {getClass=public final native java.lang.Class java.lang.Object.getClass(), getOrDefault=public java.lang.Object java.util.LinkedHashMap.getOrDefault(java.lang.Object,java.lang.Object), computeIfAbsent=public java.lang.Object java.util.HashMap.computeIfAbsent(java.lang.Object,java.util.function.Function), values=public java.util.Collection java.util.LinkedHashMap.values(), replace=freemarker.ext.beans.OverloadedMethods@11d0265, java.lang.Object@3e55b2={public boolean java.util.HashMap.isEmpty()=[Ljava.lang.Class;@c5aa3a, public int java.util.AbstractMap.hashCode()=[Ljava.lang.Class;@74a947, public java.lang.Object java.util.HashMap.put(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@1615a91, public boolean java.util.AbstractMap.equals(java.lang.Object)=[Ljava.lang.Class;@a46ab2, public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object)=[Ljava.lang.Class;@1c389e6, public java.lang.String java.util.AbstractMap.toString()=[Ljava.lang.Class;@a23548, public boolean java.util.HashMap.containsKey(java.lang.Object)=[Ljava.lang.Class;@1be4a9f, public java.util.Set java.util.LinkedHashMap.keySet()=[Ljava.lang.Class;@44c60, public java.lang.Object java.util.HashMap.computeIfAbsent(java.lang.Object,java.util.function.Function)=[Ljava.lang.Class;@10f7dff, public java.lang.Object java.util.HashMap.clone()=[Ljava.lang.Class;@d214e3, public java.lang.Object java.util.LinkedHashMap.getOrDefault(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@1a74254, public java.util.Set java.util.LinkedHashMap.entrySet()=[Ljava.lang.Class;@1c4740c, public void java.util.LinkedHashMap.forEach(java.util.function.BiConsumer)=[Ljava.lang.Class;@1fe0c8e, public java.lang.Object java.util.HashMap.putIfAbsent(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@16f73de, public java.util.Collection java.util.LinkedHashMap.values()=[Ljava.lang.Class;@b3e45, public void java.util.LinkedHashMap.clear()=[Ljava.lang.Class;@a34e5c, public java.lang.Object java.util.HashMap.computeIfPresent(java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1fcb13a, public java.lang.Object java.util.HashMap.compute(java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1a7c258, public final native java.lang.Class java.lang.Object.getClass()=[Ljava.lang.Class;@7397f, public void java.util.HashMap.putAll(java.util.Map)=[Ljava.lang.Class;@59cd, public void java.util.LinkedHashMap.replaceAll(java.util.function.BiFunction)=[Ljava.lang.Class;@994816, public java.lang.Object java.util.HashMap.merge(java.lang.Object,java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1b1e75f, public int java.util.HashMap.size()=[Ljava.lang.Class;@bee157, public boolean java.util.LinkedHashMap.containsValue(java.lang.Object)=[Ljava.lang.Class;@5e0d7c}, replaceAll=public void java.util.LinkedHashMap.replaceAll(java.util.function.BiFunction), remove=freemarker.ext.beans.OverloadedMethods@8d3a99, containsValue=public boolean java.util.LinkedHashMap.containsValue(java.lang.Object), put=public java.lang.Object java.util.HashMap.put(java.lang.Object,java.lang.Object), empty=java.beans.PropertyDescriptor[name=empty; propertyType=boolean; readMethod=public boolean java.util.HashMap.isEmpty()], compute=public java.lang.Object java.util.HashMap.compute(java.lang.Object,java.util.function.BiFunction), hashCode=public int java.util.AbstractMap.hashCode(), putAll=public void java.util.HashMap.putAll(java.util.Map), get=public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object), merge=public java.lang.Object java.util.HashMap.merge(java.lang.Object,java.lang.Object,java.util.function.BiFunction), class=java.beans.PropertyDescriptor[name=class; propertyType=class java.lang.Class; readMethod=public final native java.lang.Class java.lang.Object.getClass()], keySet=public java.util.Set java.util.LinkedHashMap.keySet(), java.lang.Object@1c0f21d=freemarker.ext.beans.OverloadedMethods@d4b988, entrySet=public java.util.Set java.util.LinkedHashMap.entrySet(), java.lang.Object@15be27d=public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object), forEach=public void java.util.LinkedHashMap.forEach(java.util.function.BiConsumer), containsKey=public boolean java.util.HashMap.containsKey(java.lang.Object), isEmpty=public boolean java.util.HashMap.isEmpty(), clear=public void java.util.LinkedHashMap.clear(), computeIfPresent=public java.lang.Object java.util.HashMap.computeIfPresent(java.lang.Object,java.util.function.BiFunction), size=public int java.util.HashMap.size(), equals=public boolean java.util.AbstractMap.equals(java.lang.Object), clone=public java.lang.Object java.util.HashMap.clone(), toString=public java.lang.String java.util.AbstractMap.toString(), putIfAbsent=public java.lang.Object java.util.HashMap.putIfAbsent(java.lang.Object,java.lang.Object)}
[DEBUG] 2017-05-24: 21:05:33 freemarker.log._Log4jLoggerFactory$Log4jLogger.debug(_Log4jLoggerFactory.java:45) :  TemplateLoader.findTemplateSource("template/~~~xhtml/dynamic-attributes.ftl"): Found
[DEBUG] 2017-05-24: 21:05:33 freemarker.log._Log4jLoggerFactory$Log4jLogger.debug(_Log4jLoggerFactory.java:45) :  "template/~~~xhtml/dynamic-attributes.ftl"("zh_CN", UTF-8, parsed): using cached since jar:file:/D:/maven/repository/org/apache/struts/struts2-core/2.5.10/struts2-core-2.5.10.jar!/template/simple/dynamic-attributes.ftl hasn't changed.
[DEBUG] 2017-05-24: 21:05:33 freemarker.log._Log4jLoggerFactory$Log4jLogger.debug(_Log4jLoggerFactory.java:45) :  Couldn't find template in cache for "template/xhtml/submit-close.ftl"("zh_CN", UTF-8, parsed); will try to load it.
[DEBUG] 2017-05-24: 21:05:33 freemarker.log._Log4jLoggerFactory$Log4jLogger.debug(_Log4jLoggerFactory.java:45) :  TemplateLoader.findTemplateSource("template/xhtml/submit-close.ftl"): Found
[DEBUG] 2017-05-24: 21:05:33 freemarker.log._Log4jLoggerFactory$Log4jLogger.debug(_Log4jLoggerFactory.java:45) :  Loading template for "template/xhtml/submit-close.ftl"("zh_CN", UTF-8, parsed) from "jar:file:/D:/maven/repository/org/apache/struts/struts2-core/2.5.10/struts2-core-2.5.10.jar!/template/xhtml/submit-close.ftl"
[DEBUG] 2017-05-24: 21:05:33 freemarker.log._Log4jLoggerFactory$Log4jLogger.debug(_Log4jLoggerFactory.java:45) :  Couldn't find template in cache for "template/simple/submit-close.ftl"("zh_CN", UTF-8, parsed); will try to load it.
[DEBUG] 2017-05-24: 21:05:33 freemarker.log._Log4jLoggerFactory$Log4jLogger.debug(_Log4jLoggerFactory.java:45) :  TemplateLoader.findTemplateSource("template/simple/submit-close.ftl"): Found
[DEBUG] 2017-05-24: 21:05:33 freemarker.log._Log4jLoggerFactory$Log4jLogger.debug(_Log4jLoggerFactory.java:45) :  Loading template for "template/simple/submit-close.ftl"("zh_CN", UTF-8, parsed) from "jar:file:/D:/maven/repository/org/apache/struts/struts2-core/2.5.10/struts2-core-2.5.10.jar!/template/simple/submit-close.ftl"
[DEBUG] 2017-05-24: 21:05:33 freemarker.log._Log4jLoggerFactory$Log4jLogger.debug(_Log4jLoggerFactory.java:45) :  TemplateLoader.findTemplateSource("template/~~~xhtml/controlfooter.ftl"): Found
[DEBUG] 2017-05-24: 21:05:33 freemarker.log._Log4jLoggerFactory$Log4jLogger.debug(_Log4jLoggerFactory.java:45) :  "template/~~~xhtml/controlfooter.ftl"("zh_CN", UTF-8, parsed): using cached since jar:file:/D:/maven/repository/org/apache/struts/struts2-core/2.5.10/struts2-core-2.5.10.jar!/template/xhtml/controlfooter.ftl hasn't changed.
[DEBUG] 2017-05-24: 21:05:33 freemarker.log._Log4jLoggerFactory$Log4jLogger.debug(_Log4jLoggerFactory.java:45) :  Key "after" was not found on instance of java.util.LinkedHashMap. Introspection information for the class is: {getClass=public final native java.lang.Class java.lang.Object.getClass(), getOrDefault=public java.lang.Object java.util.LinkedHashMap.getOrDefault(java.lang.Object,java.lang.Object), computeIfAbsent=public java.lang.Object java.util.HashMap.computeIfAbsent(java.lang.Object,java.util.function.Function), values=public java.util.Collection java.util.LinkedHashMap.values(), replace=freemarker.ext.beans.OverloadedMethods@11d0265, java.lang.Object@3e55b2={public boolean java.util.HashMap.isEmpty()=[Ljava.lang.Class;@c5aa3a, public int java.util.AbstractMap.hashCode()=[Ljava.lang.Class;@74a947, public java.lang.Object java.util.HashMap.put(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@1615a91, public boolean java.util.AbstractMap.equals(java.lang.Object)=[Ljava.lang.Class;@a46ab2, public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object)=[Ljava.lang.Class;@1c389e6, public java.lang.String java.util.AbstractMap.toString()=[Ljava.lang.Class;@a23548, public boolean java.util.HashMap.containsKey(java.lang.Object)=[Ljava.lang.Class;@1be4a9f, public java.util.Set java.util.LinkedHashMap.keySet()=[Ljava.lang.Class;@44c60, public java.lang.Object java.util.HashMap.computeIfAbsent(java.lang.Object,java.util.function.Function)=[Ljava.lang.Class;@10f7dff, public java.lang.Object java.util.HashMap.clone()=[Ljava.lang.Class;@d214e3, public java.lang.Object java.util.LinkedHashMap.getOrDefault(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@1a74254, public java.util.Set java.util.LinkedHashMap.entrySet()=[Ljava.lang.Class;@1c4740c, public void java.util.LinkedHashMap.forEach(java.util.function.BiConsumer)=[Ljava.lang.Class;@1fe0c8e, public java.lang.Object java.util.HashMap.putIfAbsent(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@16f73de, public java.util.Collection java.util.LinkedHashMap.values()=[Ljava.lang.Class;@b3e45, public void java.util.LinkedHashMap.clear()=[Ljava.lang.Class;@a34e5c, public java.lang.Object java.util.HashMap.computeIfPresent(java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1fcb13a, public java.lang.Object java.util.HashMap.compute(java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1a7c258, public final native java.lang.Class java.lang.Object.getClass()=[Ljava.lang.Class;@7397f, public void java.util.HashMap.putAll(java.util.Map)=[Ljava.lang.Class;@59cd, public void java.util.LinkedHashMap.replaceAll(java.util.function.BiFunction)=[Ljava.lang.Class;@994816, public java.lang.Object java.util.HashMap.merge(java.lang.Object,java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1b1e75f, public int java.util.HashMap.size()=[Ljava.lang.Class;@bee157, public boolean java.util.LinkedHashMap.containsValue(java.lang.Object)=[Ljava.lang.Class;@5e0d7c}, replaceAll=public void java.util.LinkedHashMap.replaceAll(java.util.function.BiFunction), remove=freemarker.ext.beans.OverloadedMethods@8d3a99, containsValue=public boolean java.util.LinkedHashMap.containsValue(java.lang.Object), put=public java.lang.Object java.util.HashMap.put(java.lang.Object,java.lang.Object), empty=java.beans.PropertyDescriptor[name=empty; propertyType=boolean; readMethod=public boolean java.util.HashMap.isEmpty()], compute=public java.lang.Object java.util.HashMap.compute(java.lang.Object,java.util.function.BiFunction), hashCode=public int java.util.AbstractMap.hashCode(), putAll=public void java.util.HashMap.putAll(java.util.Map), get=public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object), merge=public java.lang.Object java.util.HashMap.merge(java.lang.Object,java.lang.Object,java.util.function.BiFunction), class=java.beans.PropertyDescriptor[name=class; propertyType=class java.lang.Class; readMethod=public final native java.lang.Class java.lang.Object.getClass()], keySet=public java.util.Set java.util.LinkedHashMap.keySet(), java.lang.Object@1c0f21d=freemarker.ext.beans.OverloadedMethods@d4b988, entrySet=public java.util.Set java.util.LinkedHashMap.entrySet(), java.lang.Object@15be27d=public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object), forEach=public void java.util.LinkedHashMap.forEach(java.util.function.BiConsumer), containsKey=public boolean java.util.HashMap.containsKey(java.lang.Object), isEmpty=public boolean java.util.HashMap.isEmpty(), clear=public void java.util.LinkedHashMap.clear(), computeIfPresent=public java.lang.Object java.util.HashMap.computeIfPresent(java.lang.Object,java.util.function.BiFunction), size=public int java.util.HashMap.size(), equals=public boolean java.util.AbstractMap.equals(java.lang.Object), clone=public java.lang.Object java.util.HashMap.clone(), toString=public java.lang.String java.util.AbstractMap.toString(), putIfAbsent=public java.lang.Object java.util.HashMap.putIfAbsent(java.lang.Object,java.lang.Object)}
[DEBUG] 2017-05-24: 21:05:33 freemarker.log._Log4jLoggerFactory$Log4jLogger.debug(_Log4jLoggerFactory.java:45) :  Key "errorposition" was not found on instance of java.util.LinkedHashMap. Introspection information for the class is: {getClass=public final native java.lang.Class java.lang.Object.getClass(), getOrDefault=public java.lang.Object java.util.LinkedHashMap.getOrDefault(java.lang.Object,java.lang.Object), computeIfAbsent=public java.lang.Object java.util.HashMap.computeIfAbsent(java.lang.Object,java.util.function.Function), values=public java.util.Collection java.util.LinkedHashMap.values(), replace=freemarker.ext.beans.OverloadedMethods@11d0265, java.lang.Object@3e55b2={public boolean java.util.HashMap.isEmpty()=[Ljava.lang.Class;@c5aa3a, public int java.util.AbstractMap.hashCode()=[Ljava.lang.Class;@74a947, public java.lang.Object java.util.HashMap.put(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@1615a91, public boolean java.util.AbstractMap.equals(java.lang.Object)=[Ljava.lang.Class;@a46ab2, public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object)=[Ljava.lang.Class;@1c389e6, public java.lang.String java.util.AbstractMap.toString()=[Ljava.lang.Class;@a23548, public boolean java.util.HashMap.containsKey(java.lang.Object)=[Ljava.lang.Class;@1be4a9f, public java.util.Set java.util.LinkedHashMap.keySet()=[Ljava.lang.Class;@44c60, public java.lang.Object java.util.HashMap.computeIfAbsent(java.lang.Object,java.util.function.Function)=[Ljava.lang.Class;@10f7dff, public java.lang.Object java.util.HashMap.clone()=[Ljava.lang.Class;@d214e3, public java.lang.Object java.util.LinkedHashMap.getOrDefault(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@1a74254, public java.util.Set java.util.LinkedHashMap.entrySet()=[Ljava.lang.Class;@1c4740c, public void java.util.LinkedHashMap.forEach(java.util.function.BiConsumer)=[Ljava.lang.Class;@1fe0c8e, public java.lang.Object java.util.HashMap.putIfAbsent(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@16f73de, public java.util.Collection java.util.LinkedHashMap.values()=[Ljava.lang.Class;@b3e45, public void java.util.LinkedHashMap.clear()=[Ljava.lang.Class;@a34e5c, public java.lang.Object java.util.HashMap.computeIfPresent(java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1fcb13a, public java.lang.Object java.util.HashMap.compute(java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1a7c258, public final native java.lang.Class java.lang.Object.getClass()=[Ljava.lang.Class;@7397f, public void java.util.HashMap.putAll(java.util.Map)=[Ljava.lang.Class;@59cd, public void java.util.LinkedHashMap.replaceAll(java.util.function.BiFunction)=[Ljava.lang.Class;@994816, public java.lang.Object java.util.HashMap.merge(java.lang.Object,java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1b1e75f, public int java.util.HashMap.size()=[Ljava.lang.Class;@bee157, public boolean java.util.LinkedHashMap.containsValue(java.lang.Object)=[Ljava.lang.Class;@5e0d7c}, replaceAll=public void java.util.LinkedHashMap.replaceAll(java.util.function.BiFunction), remove=freemarker.ext.beans.OverloadedMethods@8d3a99, containsValue=public boolean java.util.LinkedHashMap.containsValue(java.lang.Object), put=public java.lang.Object java.util.HashMap.put(java.lang.Object,java.lang.Object), empty=java.beans.PropertyDescriptor[name=empty; propertyType=boolean; readMethod=public boolean java.util.HashMap.isEmpty()], compute=public java.lang.Object java.util.HashMap.compute(java.lang.Object,java.util.function.BiFunction), hashCode=public int java.util.AbstractMap.hashCode(), putAll=public void java.util.HashMap.putAll(java.util.Map), get=public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object), merge=public java.lang.Object java.util.HashMap.merge(java.lang.Object,java.lang.Object,java.util.function.BiFunction), class=java.beans.PropertyDescriptor[name=class; propertyType=class java.lang.Class; readMethod=public final native java.lang.Class java.lang.Object.getClass()], keySet=public java.util.Set java.util.LinkedHashMap.keySet(), java.lang.Object@1c0f21d=freemarker.ext.beans.OverloadedMethods@d4b988, entrySet=public java.util.Set java.util.LinkedHashMap.entrySet(), java.lang.Object@15be27d=public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object), forEach=public void java.util.LinkedHashMap.forEach(java.util.function.BiConsumer), containsKey=public boolean java.util.HashMap.containsKey(java.lang.Object), isEmpty=public boolean java.util.HashMap.isEmpty(), clear=public void java.util.LinkedHashMap.clear(), computeIfPresent=public java.lang.Object java.util.HashMap.computeIfPresent(java.lang.Object,java.util.function.BiFunction), size=public int java.util.HashMap.size(), equals=public boolean java.util.AbstractMap.equals(java.lang.Object), clone=public java.lang.Object java.util.HashMap.clone(), toString=public java.lang.String java.util.AbstractMap.toString(), putIfAbsent=public java.lang.Object java.util.HashMap.putIfAbsent(java.lang.Object,java.lang.Object)}
[DEBUG] 2017-05-24: 21:05:33 freemarker.log._Log4jLoggerFactory$Log4jLogger.debug(_Log4jLoggerFactory.java:45) :  Couldn't find template in cache for "template/xhtml/form-close.ftl"("zh_CN", UTF-8, parsed); will try to load it.
[DEBUG] 2017-05-24: 21:05:33 freemarker.log._Log4jLoggerFactory$Log4jLogger.debug(_Log4jLoggerFactory.java:45) :  TemplateLoader.findTemplateSource("template/xhtml/form-close.ftl"): Found
[DEBUG] 2017-05-24: 21:05:33 freemarker.log._Log4jLoggerFactory$Log4jLogger.debug(_Log4jLoggerFactory.java:45) :  Loading template for "template/xhtml/form-close.ftl"("zh_CN", UTF-8, parsed) from "jar:file:/D:/maven/repository/org/apache/struts/struts2-core/2.5.10/struts2-core-2.5.10.jar!/template/xhtml/form-close.ftl"
[DEBUG] 2017-05-24: 21:05:33 freemarker.log._Log4jLoggerFactory$Log4jLogger.debug(_Log4jLoggerFactory.java:45) :  Couldn't find template in cache for "template/~~~xhtml/control-close.ftl"("zh_CN", UTF-8, parsed); will try to load it.
[DEBUG] 2017-05-24: 21:05:33 freemarker.log._Log4jLoggerFactory$Log4jLogger.debug(_Log4jLoggerFactory.java:45) :  TemplateLoader.findTemplateSource("template/~~~xhtml/control-close.ftl"): Found
[DEBUG] 2017-05-24: 21:05:33 freemarker.log._Log4jLoggerFactory$Log4jLogger.debug(_Log4jLoggerFactory.java:45) :  Loading template for "template/~~~xhtml/control-close.ftl"("zh_CN", UTF-8, parsed) from "jar:file:/D:/maven/repository/org/apache/struts/struts2-core/2.5.10/struts2-core-2.5.10.jar!/template/xhtml/control-close.ftl"
[DEBUG] 2017-05-24: 21:05:33 freemarker.log._Log4jLoggerFactory$Log4jLogger.debug(_Log4jLoggerFactory.java:45) :  Couldn't find template in cache for "template/simple/form-close.ftl"("zh_CN", UTF-8, parsed); will try to load it.
[DEBUG] 2017-05-24: 21:05:33 freemarker.log._Log4jLoggerFactory$Log4jLogger.debug(_Log4jLoggerFactory.java:45) :  TemplateLoader.findTemplateSource("template/simple/form-close.ftl"): Found
[DEBUG] 2017-05-24: 21:05:33 freemarker.log._Log4jLoggerFactory$Log4jLogger.debug(_Log4jLoggerFactory.java:45) :  Loading template for "template/simple/form-close.ftl"("zh_CN", UTF-8, parsed) from "jar:file:/D:/maven/repository/org/apache/struts/struts2-core/2.5.10/struts2-core-2.5.10.jar!/template/simple/form-close.ftl"
[DEBUG] 2017-05-24: 21:05:33 freemarker.log._Log4jLoggerFactory$Log4jLogger.debug(_Log4jLoggerFactory.java:45) :  Key "customOnsubmitEnabled" was not found on instance of java.util.LinkedHashMap. Introspection information for the class is: {getClass=public final native java.lang.Class java.lang.Object.getClass(), getOrDefault=public java.lang.Object java.util.LinkedHashMap.getOrDefault(java.lang.Object,java.lang.Object), computeIfAbsent=public java.lang.Object java.util.HashMap.computeIfAbsent(java.lang.Object,java.util.function.Function), values=public java.util.Collection java.util.LinkedHashMap.values(), replace=freemarker.ext.beans.OverloadedMethods@11d0265, java.lang.Object@3e55b2={public boolean java.util.HashMap.isEmpty()=[Ljava.lang.Class;@c5aa3a, public int java.util.AbstractMap.hashCode()=[Ljava.lang.Class;@74a947, public java.lang.Object java.util.HashMap.put(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@1615a91, public boolean java.util.AbstractMap.equals(java.lang.Object)=[Ljava.lang.Class;@a46ab2, public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object)=[Ljava.lang.Class;@1c389e6, public java.lang.String java.util.AbstractMap.toString()=[Ljava.lang.Class;@a23548, public boolean java.util.HashMap.containsKey(java.lang.Object)=[Ljava.lang.Class;@1be4a9f, public java.util.Set java.util.LinkedHashMap.keySet()=[Ljava.lang.Class;@44c60, public java.lang.Object java.util.HashMap.computeIfAbsent(java.lang.Object,java.util.function.Function)=[Ljava.lang.Class;@10f7dff, public java.lang.Object java.util.HashMap.clone()=[Ljava.lang.Class;@d214e3, public java.lang.Object java.util.LinkedHashMap.getOrDefault(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@1a74254, public java.util.Set java.util.LinkedHashMap.entrySet()=[Ljava.lang.Class;@1c4740c, public void java.util.LinkedHashMap.forEach(java.util.function.BiConsumer)=[Ljava.lang.Class;@1fe0c8e, public java.lang.Object java.util.HashMap.putIfAbsent(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@16f73de, public java.util.Collection java.util.LinkedHashMap.values()=[Ljava.lang.Class;@b3e45, public void java.util.LinkedHashMap.clear()=[Ljava.lang.Class;@a34e5c, public java.lang.Object java.util.HashMap.computeIfPresent(java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1fcb13a, public java.lang.Object java.util.HashMap.compute(java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1a7c258, public final native java.lang.Class java.lang.Object.getClass()=[Ljava.lang.Class;@7397f, public void java.util.HashMap.putAll(java.util.Map)=[Ljava.lang.Class;@59cd, public void java.util.LinkedHashMap.replaceAll(java.util.function.BiFunction)=[Ljava.lang.Class;@994816, public java.lang.Object java.util.HashMap.merge(java.lang.Object,java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1b1e75f, public int java.util.HashMap.size()=[Ljava.lang.Class;@bee157, public boolean java.util.LinkedHashMap.containsValue(java.lang.Object)=[Ljava.lang.Class;@5e0d7c}, replaceAll=public void java.util.LinkedHashMap.replaceAll(java.util.function.BiFunction), remove=freemarker.ext.beans.OverloadedMethods@8d3a99, containsValue=public boolean java.util.LinkedHashMap.containsValue(java.lang.Object), put=public java.lang.Object java.util.HashMap.put(java.lang.Object,java.lang.Object), empty=java.beans.PropertyDescriptor[name=empty; propertyType=boolean; readMethod=public boolean java.util.HashMap.isEmpty()], compute=public java.lang.Object java.util.HashMap.compute(java.lang.Object,java.util.function.BiFunction), hashCode=public int java.util.AbstractMap.hashCode(), putAll=public void java.util.HashMap.putAll(java.util.Map), get=public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object), merge=public java.lang.Object java.util.HashMap.merge(java.lang.Object,java.lang.Object,java.util.function.BiFunction), class=java.beans.PropertyDescriptor[name=class; propertyType=class java.lang.Class; readMethod=public final native java.lang.Class java.lang.Object.getClass()], keySet=public java.util.Set java.util.LinkedHashMap.keySet(), java.lang.Object@1c0f21d=freemarker.ext.beans.OverloadedMethods@d4b988, entrySet=public java.util.Set java.util.LinkedHashMap.entrySet(), java.lang.Object@15be27d=public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object), forEach=public void java.util.LinkedHashMap.forEach(java.util.function.BiConsumer), containsKey=public boolean java.util.HashMap.containsKey(java.lang.Object), isEmpty=public boolean java.util.HashMap.isEmpty(), clear=public void java.util.LinkedHashMap.clear(), computeIfPresent=public java.lang.Object java.util.HashMap.computeIfPresent(java.lang.Object,java.util.function.BiFunction), size=public int java.util.HashMap.size(), equals=public boolean java.util.AbstractMap.equals(java.lang.Object), clone=public java.lang.Object java.util.HashMap.clone(), toString=public java.lang.String java.util.AbstractMap.toString(), putIfAbsent=public java.lang.Object java.util.HashMap.putIfAbsent(java.lang.Object,java.lang.Object)}
[DEBUG] 2017-05-24: 21:05:33 freemarker.log._Log4jLoggerFactory$Log4jLogger.debug(_Log4jLoggerFactory.java:45) :  Couldn't find template in cache for "template/~~~xhtml/form-close-tooltips.ftl"("zh_CN", UTF-8, parsed); will try to load it.
[DEBUG] 2017-05-24: 21:05:33 freemarker.log._Log4jLoggerFactory$Log4jLogger.debug(_Log4jLoggerFactory.java:45) :  TemplateLoader.findTemplateSource("template/~~~xhtml/form-close-tooltips.ftl"): Found
[DEBUG] 2017-05-24: 21:05:33 freemarker.log._Log4jLoggerFactory$Log4jLogger.debug(_Log4jLoggerFactory.java:45) :  Loading template for "template/~~~xhtml/form-close-tooltips.ftl"("zh_CN", UTF-8, parsed) from "jar:file:/D:/maven/repository/org/apache/struts/struts2-core/2.5.10/struts2-core-2.5.10.jar!/template/simple/form-close-tooltips.ftl"
[DEBUG] 2017-05-24: 21:05:33 freemarker.log._Log4jLoggerFactory$Log4jLogger.debug(_Log4jLoggerFactory.java:45) :  Key "hasTooltip" was not found on instance of java.util.LinkedHashMap. Introspection information for the class is: {getClass=public final native java.lang.Class java.lang.Object.getClass(), getOrDefault=public java.lang.Object java.util.LinkedHashMap.getOrDefault(java.lang.Object,java.lang.Object), computeIfAbsent=public java.lang.Object java.util.HashMap.computeIfAbsent(java.lang.Object,java.util.function.Function), values=public java.util.Collection java.util.LinkedHashMap.values(), replace=freemarker.ext.beans.OverloadedMethods@11d0265, java.lang.Object@3e55b2={public boolean java.util.HashMap.isEmpty()=[Ljava.lang.Class;@c5aa3a, public int java.util.AbstractMap.hashCode()=[Ljava.lang.Class;@74a947, public java.lang.Object java.util.HashMap.put(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@1615a91, public boolean java.util.AbstractMap.equals(java.lang.Object)=[Ljava.lang.Class;@a46ab2, public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object)=[Ljava.lang.Class;@1c389e6, public java.lang.String java.util.AbstractMap.toString()=[Ljava.lang.Class;@a23548, public boolean java.util.HashMap.containsKey(java.lang.Object)=[Ljava.lang.Class;@1be4a9f, public java.util.Set java.util.LinkedHashMap.keySet()=[Ljava.lang.Class;@44c60, public java.lang.Object java.util.HashMap.computeIfAbsent(java.lang.Object,java.util.function.Function)=[Ljava.lang.Class;@10f7dff, public java.lang.Object java.util.HashMap.clone()=[Ljava.lang.Class;@d214e3, public java.lang.Object java.util.LinkedHashMap.getOrDefault(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@1a74254, public java.util.Set java.util.LinkedHashMap.entrySet()=[Ljava.lang.Class;@1c4740c, public void java.util.LinkedHashMap.forEach(java.util.function.BiConsumer)=[Ljava.lang.Class;@1fe0c8e, public java.lang.Object java.util.HashMap.putIfAbsent(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@16f73de, public java.util.Collection java.util.LinkedHashMap.values()=[Ljava.lang.Class;@b3e45, public void java.util.LinkedHashMap.clear()=[Ljava.lang.Class;@a34e5c, public java.lang.Object java.util.HashMap.computeIfPresent(java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1fcb13a, public java.lang.Object java.util.HashMap.compute(java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1a7c258, public final native java.lang.Class java.lang.Object.getClass()=[Ljava.lang.Class;@7397f, public void java.util.HashMap.putAll(java.util.Map)=[Ljava.lang.Class;@59cd, public void java.util.LinkedHashMap.replaceAll(java.util.function.BiFunction)=[Ljava.lang.Class;@994816, public java.lang.Object java.util.HashMap.merge(java.lang.Object,java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1b1e75f, public int java.util.HashMap.size()=[Ljava.lang.Class;@bee157, public boolean java.util.LinkedHashMap.containsValue(java.lang.Object)=[Ljava.lang.Class;@5e0d7c}, replaceAll=public void java.util.LinkedHashMap.replaceAll(java.util.function.BiFunction), remove=freemarker.ext.beans.OverloadedMethods@8d3a99, containsValue=public boolean java.util.LinkedHashMap.containsValue(java.lang.Object), put=public java.lang.Object java.util.HashMap.put(java.lang.Object,java.lang.Object), empty=java.beans.PropertyDescriptor[name=empty; propertyType=boolean; readMethod=public boolean java.util.HashMap.isEmpty()], compute=public java.lang.Object java.util.HashMap.compute(java.lang.Object,java.util.function.BiFunction), hashCode=public int java.util.AbstractMap.hashCode(), putAll=public void java.util.HashMap.putAll(java.util.Map), get=public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object), merge=public java.lang.Object java.util.HashMap.merge(java.lang.Object,java.lang.Object,java.util.function.BiFunction), class=java.beans.PropertyDescriptor[name=class; propertyType=class java.lang.Class; readMethod=public final native java.lang.Class java.lang.Object.getClass()], keySet=public java.util.Set java.util.LinkedHashMap.keySet(), java.lang.Object@1c0f21d=freemarker.ext.beans.OverloadedMethods@d4b988, entrySet=public java.util.Set java.util.LinkedHashMap.entrySet(), java.lang.Object@15be27d=public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object), forEach=public void java.util.LinkedHashMap.forEach(java.util.function.BiConsumer), containsKey=public boolean java.util.HashMap.containsKey(java.lang.Object), isEmpty=public boolean java.util.HashMap.isEmpty(), clear=public void java.util.LinkedHashMap.clear(), computeIfPresent=public java.lang.Object java.util.HashMap.computeIfPresent(java.lang.Object,java.util.function.BiFunction), size=public int java.util.HashMap.size(), equals=public boolean java.util.AbstractMap.equals(java.lang.Object), clone=public java.lang.Object java.util.HashMap.clone(), toString=public java.lang.String java.util.AbstractMap.toString(), putIfAbsent=public java.lang.Object java.util.HashMap.putIfAbsent(java.lang.Object,java.lang.Object)}
[DEBUG] 2017-05-24: 21:05:33 freemarker.log._Log4jLoggerFactory$Log4jLogger.debug(_Log4jLoggerFactory.java:45) :  Couldn't find template in cache for "template/~~~xhtml/form-close-validate.ftl"("zh_CN", UTF-8, parsed); will try to load it.
[DEBUG] 2017-05-24: 21:05:33 freemarker.log._Log4jLoggerFactory$Log4jLogger.debug(_Log4jLoggerFactory.java:45) :  TemplateLoader.findTemplateSource("template/~~~xhtml/form-close-validate.ftl"): Found
[DEBUG] 2017-05-24: 21:05:33 freemarker.log._Log4jLoggerFactory$Log4jLogger.debug(_Log4jLoggerFactory.java:45) :  Loading template for "template/~~~xhtml/form-close-validate.ftl"("zh_CN", UTF-8, parsed) from "jar:file:/D:/maven/repository/org/apache/struts/struts2-core/2.5.10/struts2-core-2.5.10.jar!/template/xhtml/form-close-validate.ftl"
[DEBUG] 2017-05-24: 21:05:33 freemarker.log._Log4jLoggerFactory$Log4jLogger.debug(_Log4jLoggerFactory.java:45) :  Key "validate" was not found on instance of java.util.LinkedHashMap. Introspection information for the class is: {getClass=public final native java.lang.Class java.lang.Object.getClass(), getOrDefault=public java.lang.Object java.util.LinkedHashMap.getOrDefault(java.lang.Object,java.lang.Object), computeIfAbsent=public java.lang.Object java.util.HashMap.computeIfAbsent(java.lang.Object,java.util.function.Function), values=public java.util.Collection java.util.LinkedHashMap.values(), replace=freemarker.ext.beans.OverloadedMethods@11d0265, java.lang.Object@3e55b2={public boolean java.util.HashMap.isEmpty()=[Ljava.lang.Class;@c5aa3a, public int java.util.AbstractMap.hashCode()=[Ljava.lang.Class;@74a947, public java.lang.Object java.util.HashMap.put(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@1615a91, public boolean java.util.AbstractMap.equals(java.lang.Object)=[Ljava.lang.Class;@a46ab2, public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object)=[Ljava.lang.Class;@1c389e6, public java.lang.String java.util.AbstractMap.toString()=[Ljava.lang.Class;@a23548, public boolean java.util.HashMap.containsKey(java.lang.Object)=[Ljava.lang.Class;@1be4a9f, public java.util.Set java.util.LinkedHashMap.keySet()=[Ljava.lang.Class;@44c60, public java.lang.Object java.util.HashMap.computeIfAbsent(java.lang.Object,java.util.function.Function)=[Ljava.lang.Class;@10f7dff, public java.lang.Object java.util.HashMap.clone()=[Ljava.lang.Class;@d214e3, public java.lang.Object java.util.LinkedHashMap.getOrDefault(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@1a74254, public java.util.Set java.util.LinkedHashMap.entrySet()=[Ljava.lang.Class;@1c4740c, public void java.util.LinkedHashMap.forEach(java.util.function.BiConsumer)=[Ljava.lang.Class;@1fe0c8e, public java.lang.Object java.util.HashMap.putIfAbsent(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@16f73de, public java.util.Collection java.util.LinkedHashMap.values()=[Ljava.lang.Class;@b3e45, public void java.util.LinkedHashMap.clear()=[Ljava.lang.Class;@a34e5c, public java.lang.Object java.util.HashMap.computeIfPresent(java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1fcb13a, public java.lang.Object java.util.HashMap.compute(java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1a7c258, public final native java.lang.Class java.lang.Object.getClass()=[Ljava.lang.Class;@7397f, public void java.util.HashMap.putAll(java.util.Map)=[Ljava.lang.Class;@59cd, public void java.util.LinkedHashMap.replaceAll(java.util.function.BiFunction)=[Ljava.lang.Class;@994816, public java.lang.Object java.util.HashMap.merge(java.lang.Object,java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1b1e75f, public int java.util.HashMap.size()=[Ljava.lang.Class;@bee157, public boolean java.util.LinkedHashMap.containsValue(java.lang.Object)=[Ljava.lang.Class;@5e0d7c}, replaceAll=public void java.util.LinkedHashMap.replaceAll(java.util.function.BiFunction), remove=freemarker.ext.beans.OverloadedMethods@8d3a99, containsValue=public boolean java.util.LinkedHashMap.containsValue(java.lang.Object), put=public java.lang.Object java.util.HashMap.put(java.lang.Object,java.lang.Object), empty=java.beans.PropertyDescriptor[name=empty; propertyType=boolean; readMethod=public boolean java.util.HashMap.isEmpty()], compute=public java.lang.Object java.util.HashMap.compute(java.lang.Object,java.util.function.BiFunction), hashCode=public int java.util.AbstractMap.hashCode(), putAll=public void java.util.HashMap.putAll(java.util.Map), get=public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object), merge=public java.lang.Object java.util.HashMap.merge(java.lang.Object,java.lang.Object,java.util.function.BiFunction), class=java.beans.PropertyDescriptor[name=class; propertyType=class java.lang.Class; readMethod=public final native java.lang.Class java.lang.Object.getClass()], keySet=public java.util.Set java.util.LinkedHashMap.keySet(), java.lang.Object@1c0f21d=freemarker.ext.beans.OverloadedMethods@d4b988, entrySet=public java.util.Set java.util.LinkedHashMap.entrySet(), java.lang.Object@15be27d=public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object), forEach=public void java.util.LinkedHashMap.forEach(java.util.function.BiConsumer), containsKey=public boolean java.util.HashMap.containsKey(java.lang.Object), isEmpty=public boolean java.util.HashMap.isEmpty(), clear=public void java.util.LinkedHashMap.clear(), computeIfPresent=public java.lang.Object java.util.HashMap.computeIfPresent(java.lang.Object,java.util.function.BiFunction), size=public int java.util.HashMap.size(), equals=public boolean java.util.AbstractMap.equals(java.lang.Object), clone=public java.lang.Object java.util.HashMap.clone(), toString=public java.lang.String java.util.AbstractMap.toString(), putIfAbsent=public java.lang.Object java.util.HashMap.putIfAbsent(java.lang.Object,java.lang.Object)}
[DEBUG] 2017-05-24: 21:05:33 freemarker.log._Log4jLoggerFactory$Log4jLogger.debug(_Log4jLoggerFactory.java:45) :  Key "focusElement" was not found on instance of java.util.LinkedHashMap. Introspection information for the class is: {getClass=public final native java.lang.Class java.lang.Object.getClass(), getOrDefault=public java.lang.Object java.util.LinkedHashMap.getOrDefault(java.lang.Object,java.lang.Object), computeIfAbsent=public java.lang.Object java.util.HashMap.computeIfAbsent(java.lang.Object,java.util.function.Function), values=public java.util.Collection java.util.LinkedHashMap.values(), replace=freemarker.ext.beans.OverloadedMethods@11d0265, java.lang.Object@3e55b2={public boolean java.util.HashMap.isEmpty()=[Ljava.lang.Class;@c5aa3a, public int java.util.AbstractMap.hashCode()=[Ljava.lang.Class;@74a947, public java.lang.Object java.util.HashMap.put(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@1615a91, public boolean java.util.AbstractMap.equals(java.lang.Object)=[Ljava.lang.Class;@a46ab2, public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object)=[Ljava.lang.Class;@1c389e6, public java.lang.String java.util.AbstractMap.toString()=[Ljava.lang.Class;@a23548, public boolean java.util.HashMap.containsKey(java.lang.Object)=[Ljava.lang.Class;@1be4a9f, public java.util.Set java.util.LinkedHashMap.keySet()=[Ljava.lang.Class;@44c60, public java.lang.Object java.util.HashMap.computeIfAbsent(java.lang.Object,java.util.function.Function)=[Ljava.lang.Class;@10f7dff, public java.lang.Object java.util.HashMap.clone()=[Ljava.lang.Class;@d214e3, public java.lang.Object java.util.LinkedHashMap.getOrDefault(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@1a74254, public java.util.Set java.util.LinkedHashMap.entrySet()=[Ljava.lang.Class;@1c4740c, public void java.util.LinkedHashMap.forEach(java.util.function.BiConsumer)=[Ljava.lang.Class;@1fe0c8e, public java.lang.Object java.util.HashMap.putIfAbsent(java.lang.Object,java.lang.Object)=[Ljava.lang.Class;@16f73de, public java.util.Collection java.util.LinkedHashMap.values()=[Ljava.lang.Class;@b3e45, public void java.util.LinkedHashMap.clear()=[Ljava.lang.Class;@a34e5c, public java.lang.Object java.util.HashMap.computeIfPresent(java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1fcb13a, public java.lang.Object java.util.HashMap.compute(java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1a7c258, public final native java.lang.Class java.lang.Object.getClass()=[Ljava.lang.Class;@7397f, public void java.util.HashMap.putAll(java.util.Map)=[Ljava.lang.Class;@59cd, public void java.util.LinkedHashMap.replaceAll(java.util.function.BiFunction)=[Ljava.lang.Class;@994816, public java.lang.Object java.util.HashMap.merge(java.lang.Object,java.lang.Object,java.util.function.BiFunction)=[Ljava.lang.Class;@1b1e75f, public int java.util.HashMap.size()=[Ljava.lang.Class;@bee157, public boolean java.util.LinkedHashMap.containsValue(java.lang.Object)=[Ljava.lang.Class;@5e0d7c}, replaceAll=public void java.util.LinkedHashMap.replaceAll(java.util.function.BiFunction), remove=freemarker.ext.beans.OverloadedMethods@8d3a99, containsValue=public boolean java.util.LinkedHashMap.containsValue(java.lang.Object), put=public java.lang.Object java.util.HashMap.put(java.lang.Object,java.lang.Object), empty=java.beans.PropertyDescriptor[name=empty; propertyType=boolean; readMethod=public boolean java.util.HashMap.isEmpty()], compute=public java.lang.Object java.util.HashMap.compute(java.lang.Object,java.util.function.BiFunction), hashCode=public int java.util.AbstractMap.hashCode(), putAll=public void java.util.HashMap.putAll(java.util.Map), get=public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object), merge=public java.lang.Object java.util.HashMap.merge(java.lang.Object,java.lang.Object,java.util.function.BiFunction), class=java.beans.PropertyDescriptor[name=class; propertyType=class java.lang.Class; readMethod=public final native java.lang.Class java.lang.Object.getClass()], keySet=public java.util.Set java.util.LinkedHashMap.keySet(), java.lang.Object@1c0f21d=freemarker.ext.beans.OverloadedMethods@d4b988, entrySet=public java.util.Set java.util.LinkedHashMap.entrySet(), java.lang.Object@15be27d=public java.lang.Object java.util.LinkedHashMap.get(java.lang.Object), forEach=public void java.util.LinkedHashMap.forEach(java.util.function.BiConsumer), containsKey=public boolean java.util.HashMap.containsKey(java.lang.Object), isEmpty=public boolean java.util.HashMap.isEmpty(), clear=public void java.util.LinkedHashMap.clear(), computeIfPresent=public java.lang.Object java.util.HashMap.computeIfPresent(java.lang.Object,java.util.function.BiFunction), size=public int java.util.HashMap.size(), equals=public boolean java.util.AbstractMap.equals(java.lang.Object), clone=public java.lang.Object java.util.HashMap.clone(), toString=public java.lang.String java.util.AbstractMap.toString(), putIfAbsent=public java.lang.Object java.util.HashMap.putIfAbsent(java.lang.Object,java.lang.Object)}
[INFO] 2017-05-24: 21:06:13 org.springframework.context.support.AbstractApplicationContext.doClose(AbstractApplicationContext.java:982) :  Closing Root WebApplicationContext: startup date [Wed May 24 21:05:12 CST 2017]; root of context hierarchy
[DEBUG] 2017-05-24: 21:06:13 org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:251) :  Returning cached instance of singleton bean 'lifecycleProcessor'
[DEBUG] 2017-05-24: 21:06:13 org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.destroySingletons(DefaultSingletonBeanRegistry.java:512) :  Destroying singletons in org.springframework.beans.factory.support.DefaultListableBeanFactory@9e5e75: defining beans [userAction,userDao,userService,org.springframework.context.annotation.internalConfigurationAnnotationProcessor,org.springframework.context.annotation.internalAutowiredAnnotationProcessor,org.springframework.context.annotation.internalRequiredAnnotationProcessor,org.springframework.context.annotation.internalCommonAnnotationProcessor,org.springframework.context.annotation.internalPersistenceAnnotationProcessor,org.springframework.context.event.internalEventListenerProcessor,org.springframework.context.event.internalEventListenerFactory,org.springframework.context.support.PropertySourcesPlaceholderConfigurer#0,dataSource,sessionFactory,transactionManager,org.springframework.transaction.config.internalTransactionalEventListenerFactory,org.springframework.aop.config.internalAutoProxyCreator,org.springframework.transaction.annotation.AnnotationTransactionAttributeSource#0,org.springframework.transaction.interceptor.TransactionInterceptor#0,org.springframework.transaction.config.internalTransactionAdvisor,org.springframework.context.annotation.ConfigurationClassPostProcessor.importAwareProcessor,org.springframework.context.annotation.ConfigurationClassPostProcessor.enhancedConfigurationProcessor]; root of factory hierarchy
[DEBUG] 2017-05-24: 21:06:13 org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.destroyBean(DefaultSingletonBeanRegistry.java:568) :  Retrieved dependent beans for bean 'sessionFactory': [userDao, transactionManager]
[DEBUG] 2017-05-24: 21:06:13 org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.destroyBean(DefaultSingletonBeanRegistry.java:568) :  Retrieved dependent beans for bean 'userDao': [userService]
[DEBUG] 2017-05-24: 21:06:13 org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.destroyBean(DefaultSingletonBeanRegistry.java:568) :  Retrieved dependent beans for bean 'userService': [userAction]
[DEBUG] 2017-05-24: 21:06:13 org.springframework.beans.factory.support.DisposableBeanAdapter.destroy(DisposableBeanAdapter.java:259) :  Invoking destroy() on bean with name 'sessionFactory'
[DEBUG] 2017-05-24: 21:06:13 org.hibernate.internal.SessionFactoryImpl.close(SessionFactoryImpl.java:1339) :  HHH000031: Closing
[DEBUG] 2017-05-24: 21:06:13 org.hibernate.boot.registry.internal.BootstrapServiceRegistryImpl.deRegisterChild(BootstrapServiceRegistryImpl.java:308) :  Implicitly destroying Boot-strap registry on de-registration of all child ServiceRegistries
[DEBUG] 2017-05-24: 21:06:13 org.hibernate.service.internal.AbstractServiceRegistryImpl.deRegisterChild(AbstractServiceRegistryImpl.java:406) :  Implicitly destroying ServiceRegistry on de-registration of all child ServiceRegistries
[INFO] 2017-05-24: 21:06:22 org.springframework.web.context.ContextLoader.initWebApplicationContext(ContextLoader.java:305) :  Root WebApplicationContext: initialization started
[DEBUG] 2017-05-24: 21:06:22 org.springframework.core.env.MutablePropertySources.addLast(MutablePropertySources.java:109) :  Adding [servletConfigInitParams] PropertySource with lowest search precedence
[DEBUG] 2017-05-24: 21:06:22 org.springframework.core.env.MutablePropertySources.addLast(MutablePropertySources.java:109) :  Adding [servletContextInitParams] PropertySource with lowest search precedence
[DEBUG] 2017-05-24: 21:06:22 org.springframework.core.env.MutablePropertySources.addLast(MutablePropertySources.java:109) :  Adding [jndiProperties] PropertySource with lowest search precedence
[DEBUG] 2017-05-24: 21:06:22 org.springframework.core.env.MutablePropertySources.addLast(MutablePropertySources.java:109) :  Adding [systemProperties] PropertySource with lowest search precedence
[DEBUG] 2017-05-24: 21:06:22 org.springframework.core.env.MutablePropertySources.addLast(MutablePropertySources.java:109) :  Adding [systemEnvironment] PropertySource with lowest search precedence
[DEBUG] 2017-05-24: 21:06:22 org.springframework.core.env.AbstractEnvironment.<init>(AbstractEnvironment.java:124) :  Initialized StandardServletEnvironment with PropertySources [servletConfigInitParams,servletContextInitParams,jndiProperties,systemProperties,systemEnvironment]
[DEBUG] 2017-05-24: 21:06:22 org.springframework.core.env.MutablePropertySources.replace(MutablePropertySources.java:174) :  Replacing [servletContextInitParams] PropertySource with [servletContextInitParams]
[INFO] 2017-05-24: 21:06:22 org.springframework.context.support.AbstractApplicationContext.prepareRefresh(AbstractApplicationContext.java:581) :  Refreshing Root WebApplicationContext: startup date [Wed May 24 21:06:22 CST 2017]; root of context hierarchy
[DEBUG] 2017-05-24: 21:06:22 org.springframework.core.env.MutablePropertySources.addLast(MutablePropertySources.java:109) :  Adding [systemProperties] PropertySource with lowest search precedence
[DEBUG] 2017-05-24: 21:06:22 org.springframework.core.env.MutablePropertySources.addLast(MutablePropertySources.java:109) :  Adding [systemEnvironment] PropertySource with lowest search precedence
[DEBUG] 2017-05-24: 21:06:22 org.springframework.core.env.AbstractEnvironment.<init>(AbstractEnvironment.java:124) :  Initialized StandardEnvironment with PropertySources [systemProperties,systemEnvironment]
[INFO] 2017-05-24: 21:06:22 org.springframework.beans.factory.xml.XmlBeanDefinitionReader.loadBeanDefinitions(XmlBeanDefinitionReader.java:317) :  Loading XML bean definitions from class path resource [spring-core.xml]
[DEBUG] 2017-05-24: 21:06:22 org.springframework.beans.factory.xml.DefaultDocumentLoader.loadDocument(DefaultDocumentLoader.java:73) :  Using JAXP provider [com.sun.org.apache.xerces.internal.jaxp.DocumentBuilderFactoryImpl]
[DEBUG] 2017-05-24: 21:06:22 org.springframework.beans.factory.xml.PluggableSchemaResolver.getSchemaMappings(PluggableSchemaResolver.java:141) :  Loading schema mappings from [META-INF/spring.schemas]
[DEBUG] 2017-05-24: 21:06:22 org.springframework.beans.factory.xml.PluggableSchemaResolver.getSchemaMappings(PluggableSchemaResolver.java:147) :  Loaded schema mappings: {http://www.springframework.org/schema/tx/spring-tx-2.5.xsd=org/springframework/transaction/config/spring-tx-2.5.xsd, http://www.springframework.org/schema/tx/spring-tx-4.3.xsd=org/springframework/transaction/config/spring-tx-4.3.xsd, http://www.springframework.org/schema/cache/spring-cache-4.2.xsd=org/springframework/cache/config/spring-cache-4.2.xsd, http://www.springframework.org/schema/aop/spring-aop-4.1.xsd=org/springframework/aop/config/spring-aop-4.1.xsd, http://www.springframework.org/schema/context/spring-context-3.1.xsd=org/springframework/context/config/spring-context-3.1.xsd, http://www.springframework.org/schema/jdbc/spring-jdbc-4.1.xsd=org/springframework/jdbc/config/spring-jdbc-4.1.xsd, http://www.springframework.org/schema/util/spring-util-3.0.xsd=org/springframework/beans/factory/xml/spring-util-3.0.xsd, http://www.springframework.org/schema/tool/spring-tool.xsd=org/springframework/beans/factory/xml/spring-tool-4.3.xsd, http://www.springframework.org/schema/aop/spring-aop-3.2.xsd=org/springframework/aop/config/spring-aop-3.2.xsd, http://www.springframework.org/schema/lang/spring-lang-4.1.xsd=org/springframework/scripting/config/spring-lang-4.1.xsd, http://www.springframework.org/schema/context/spring-context-4.0.xsd=org/springframework/context/config/spring-context-4.0.xsd, http://www.springframework.org/schema/beans/spring-beans-4.2.xsd=org/springframework/beans/factory/xml/spring-beans-4.2.xsd, http://www.springframework.org/schema/tool/spring-tool-4.1.xsd=org/springframework/beans/factory/xml/spring-tool-4.1.xsd, http://www.springframework.org/schema/lang/spring-lang-3.2.xsd=org/springframework/scripting/config/spring-lang-3.2.xsd, http://www.springframework.org/schema/cache/spring-cache-3.2.xsd=org/springframework/cache/config/spring-cache-3.2.xsd, http://www.springframework.org/schema/jee/spring-jee-4.1.xsd=org/springframework/ejb/config/spring-jee-4.1.xsd, http://www.springframework.org/schema/jdbc/spring-jdbc-3.1.xsd=org/springframework/jdbc/config/spring-jdbc-3.1.xsd, http://www.springframework.org/schema/util/spring-util-2.0.xsd=org/springframework/beans/factory/xml/spring-util-2.0.xsd, http://www.springframework.org/schema/task/spring-task-4.2.xsd=org/springframework/scheduling/config/spring-task-4.2.xsd, http://www.springframework.org/schema/tool/spring-tool-3.2.xsd=org/springframework/beans/factory/xml/spring-tool-3.2.xsd, http://www.springframework.org/schema/context/spring-context.xsd=org/springframework/context/config/spring-context-4.3.xsd, http://www.springframework.org/schema/tx/spring-tx-4.2.xsd=org/springframework/transaction/config/spring-tx-4.2.xsd, http://www.springframework.org/schema/cache/spring-cache-4.1.xsd=org/springframework/cache/config/spring-cache-4.1.xsd, http://www.springframework.org/schema/aop/spring-aop-4.0.xsd=org/springframework/aop/config/spring-aop-4.0.xsd, http://www.springframework.org/schema/jee/spring-jee-3.2.xsd=org/springframework/ejb/config/spring-jee-3.2.xsd, http://www.springframework.org/schema/context/spring-context-3.0.xsd=org/springframework/context/config/spring-context-3.0.xsd, http://www.springframework.org/schema/jdbc/spring-jdbc-4.0.xsd=org/springframework/jdbc/config/spring-jdbc-4.0.xsd, http://www.springframework.org/schema/util/spring-util-4.3.xsd=org/springframework/beans/factory/xml/spring-util-4.3.xsd, http://www.springframework.org/schema/util/spring-util-2.5.xsd=org/springframework/beans/factory/xml/spring-util-2.5.xsd, http://www.springframework.org/schema/beans/spring-beans-3.2.xsd=org/springframework/beans/factory/xml/spring-beans-3.2.xsd, http://www.springframework.org/schema/aop/spring-aop-3.1.xsd=org/springframework/aop/config/spring-aop-3.1.xsd, http://www.springframework.org/schema/lang/spring-lang-4.0.xsd=org/springframework/scripting/config/spring-lang-4.0.xsd, http://www.springframework.org/schema/beans/spring-beans-4.1.xsd=org/springframework/beans/factory/xml/spring-beans-4.1.xsd, http://www.springframework.org/schema/tool/spring-tool-4.0.xsd=org/springframework/beans/factory/xml/spring-tool-4.0.xsd, http://www.springframework.org/schema/lang/spring-lang-3.1.xsd=org/springframework/scripting/config/spring-lang-3.1.xsd, http://www.springframework.org/schema/tx/spring-tx-3.2.xsd=org/springframework/transaction/config/spring-tx-3.2.xsd, http://www.springframework.org/schema/cache/spring-cache-3.1.xsd=org/springframework/cache/config/spring-cache-3.1.xsd, http://www.springframework.org/schema/jee/spring-jee-4.0.xsd=org/springframework/ejb/config/spring-jee-4.0.xsd, http://www.springframework.org/schema/jdbc/spring-jdbc-3.0.xsd=org/springframework/jdbc/config/spring-jdbc-3.0.xsd, http://www.springframework.org/schema/task/spring-task-4.1.xsd=org/springframework/scheduling/config/spring-task-4.1.xsd, http://www.springframework.org/schema/tool/spring-tool-3.1.xsd=org/springframework/beans/factory/xml/spring-tool-3.1.xsd, http://www.springframework.org/schema/jdbc/spring-jdbc.xsd=org/springframework/jdbc/config/spring-jdbc-4.3.xsd, http://www.springframework.org/schema/tx/spring-tx-4.1.xsd=org/springframework/transaction/config/spring-tx-4.1.xsd, http://www.springframework.org/schema/cache/spring-cache-4.0.xsd=org/springframework/cache/config/spring-cache-4.0.xsd, http://www.springframework.org/schema/jee/spring-jee-3.1.xsd=org/springframework/ejb/config/spring-jee-3.1.xsd, http://www.springframework.org/schema/util/spring-util-4.2.xsd=org/springframework/beans/factory/xml/spring-util-4.2.xsd, http://www.springframework.org/schema/task/spring-task-3.2.xsd=org/springframework/scheduling/config/spring-task-3.2.xsd, http://www.springframework.org/schema/beans/spring-beans-3.1.xsd=org/springframework/beans/factory/xml/spring-beans-3.1.xsd, http://www.springframework.org/schema/util/spring-util.xsd=org/springframework/beans/factory/xml/spring-util-4.3.xsd, http://www.springframework.org/schema/aop/spring-aop-3.0.xsd=org/springframework/aop/config/spring-aop-3.0.xsd, http://www.springframework.org/schema/beans/spring-beans-4.0.xsd=org/springframework/beans/factory/xml/spring-beans-4.0.xsd, http://www.springframework.org/schema/beans/spring-beans.xsd=org/springframework/beans/factory/xml/spring-beans-4.3.xsd, http://www.springframework.org/schema/lang/spring-lang-3.0.xsd=org/springframework/scripting/config/spring-lang-3.0.xsd, http://www.springframework.org/schema/tx/spring-tx-3.1.xsd=org/springframework/transaction/config/spring-tx-3.1.xsd, http://www.springframework.org/schema/context/spring-context-2.5.xsd=org/springframework/context/config/spring-context-2.5.xsd, http://www.springframework.org/schema/context/spring-context-4.3.xsd=org/springframework/context/config/spring-context-4.3.xsd, http://www.springframework.org/schema/task/spring-task-4.0.xsd=org/springframework/scheduling/config/spring-task-4.0.xsd, http://www.springframework.org/schema/tool/spring-tool-3.0.xsd=org/springframework/beans/factory/xml/spring-tool-3.0.xsd, http://www.springframework.org/schema/tx/spring-tx-4.0.xsd=org/springframework/transaction/config/spring-tx-4.0.xsd, http://www.springframework.org/schema/aop/spring-aop-2.0.xsd=org/springframework/aop/config/spring-aop-2.0.xsd, http://www.springframework.org/schema/jee/spring-jee-3.0.xsd=org/springframework/ejb/config/spring-jee-3.0.xsd, http://www.springframework.org/schema/util/spring-util-4.1.xsd=org/springframework/beans/factory/xml/spring-util-4.1.xsd, http://www.springframework.org/schema/task/spring-task-3.1.xsd=org/springframework/scheduling/config/spring-task-3.1.xsd, http://www.springframework.org/schema/beans/spring-beans-3.0.xsd=org/springframework/beans/factory/xml/spring-beans-3.0.xsd, http://www.springframework.org/schema/jee/spring-jee.xsd=org/springframework/ejb/config/spring-jee-4.3.xsd, http://www.springframework.org/schema/aop/spring-aop-2.5.xsd=org/springframework/aop/config/spring-aop-2.5.xsd, http://www.springframework.org/schema/aop/spring-aop-4.3.xsd=org/springframework/aop/config/spring-aop-4.3.xsd, http://www.springframework.org/schema/lang/spring-lang-2.0.xsd=org/springframework/scripting/config/spring-lang-2.0.xsd, http://www.springframework.org/schema/jdbc/spring-jdbc-4.3.xsd=org/springframework/jdbc/config/spring-jdbc-4.3.xsd, http://www.springframework.org/schema/util/spring-util-3.2.xsd=org/springframework/beans/factory/xml/spring-util-3.2.xsd, http://www.springframework.org/schema/task/spring-task.xsd=org/springframework/scheduling/config/spring-task-4.3.xsd, http://www.springframework.org/schema/tool/spring-tool-2.0.xsd=org/springframework/beans/factory/xml/spring-tool-2.0.xsd, http://www.springframework.org/schema/tx/spring-tx-3.0.xsd=org/springframework/transaction/config/spring-tx-3.0.xsd, http://www.springframework.org/schema/lang/spring-lang-2.5.xsd=org/springframework/scripting/config/spring-lang-2.5.xsd, http://www.springframework.org/schema/lang/spring-lang-4.3.xsd=org/springframework/scripting/config/spring-lang-4.3.xsd, http://www.springframework.org/schema/context/spring-context-4.2.xsd=org/springframework/context/config/spring-context-4.2.xsd, http://www.springframework.org/schema/jee/spring-jee-2.0.xsd=org/springframework/ejb/config/spring-jee-2.0.xsd, http://www.springframework.org/schema/tool/spring-tool-4.3.xsd=org/springframework/beans/factory/xml/spring-tool-4.3.xsd, http://www.springframework.org/schema/tool/spring-tool-2.5.xsd=org/springframework/beans/factory/xml/spring-tool-2.5.xsd, http://www.springframework.org/schema/jee/spring-jee-4.3.xsd=org/springframework/ejb/config/spring-jee-4.3.xsd, http://www.springframework.org/schema/jee/spring-jee-2.5.xsd=org/springframework/ejb/config/spring-jee-2.5.xsd, http://www.springframework.org/schema/util/spring-util-4.0.xsd=org/springframework/beans/factory/xml/spring-util-4.0.xsd, http://www.springframework.org/schema/task/spring-task-3.0.xsd=org/springframework/scheduling/config/spring-task-3.0.xsd, http://www.springframework.org/schema/cache/spring-cache-4.3.xsd=org/springframework/cache/config/spring-cache-4.3.xsd, http://www.springframework.org/schema/aop/spring-aop-4.2.xsd=org/springframework/aop/config/spring-aop-4.2.xsd, http://www.springframework.org/schema/lang/spring-lang.xsd=org/springframework/scripting/config/spring-lang-4.3.xsd, http://www.springframework.org/schema/context/spring-context-3.2.xsd=org/springframework/context/config/spring-context-3.2.xsd, http://www.springframework.org/schema/jdbc/spring-jdbc-4.2.xsd=org/springframework/jdbc/config/spring-jdbc-4.2.xsd, http://www.springframework.org/schema/util/spring-util-3.1.xsd=org/springframework/beans/factory/xml/spring-util-3.1.xsd, http://www.springframework.org/schema/beans/spring-beans-2.0.xsd=org/springframework/beans/factory/xml/spring-beans-2.0.xsd, http://www.springframework.org/schema/cache/spring-cache.xsd=org/springframework/cache/config/spring-cache-4.3.xsd, http://www.springframework.org/schema/tx/spring-tx.xsd=org/springframework/transaction/config/spring-tx-4.3.xsd, http://www.springframework.org/schema/lang/spring-lang-4.2.xsd=org/springframework/scripting/config/spring-lang-4.2.xsd, http://www.springframework.org/schema/context/spring-context-4.1.xsd=org/springframework/context/config/spring-context-4.1.xsd, http://www.springframework.org/schema/beans/spring-beans-4.3.xsd=org/springframework/beans/factory/xml/spring-beans-4.3.xsd, http://www.springframework.org/schema/beans/spring-beans-2.5.xsd=org/springframework/beans/factory/xml/spring-beans-2.5.xsd, http://www.springframework.org/schema/tool/spring-tool-4.2.xsd=org/springframework/beans/factory/xml/spring-tool-4.2.xsd, http://www.springframework.org/schema/tx/spring-tx-2.0.xsd=org/springframework/transaction/config/spring-tx-2.0.xsd, http://www.springframework.org/schema/jee/spring-jee-4.2.xsd=org/springframework/ejb/config/spring-jee-4.2.xsd, http://www.springframework.org/schema/jdbc/spring-jdbc-3.2.xsd=org/springframework/jdbc/config/spring-jdbc-3.2.xsd, http://www.springframework.org/schema/task/spring-task-4.3.xsd=org/springframework/scheduling/config/spring-task-4.3.xsd, http://www.springframework.org/schema/aop/spring-aop.xsd=org/springframework/aop/config/spring-aop-4.3.xsd}
[DEBUG] 2017-05-24: 21:06:22 org.springframework.beans.factory.xml.PluggableSchemaResolver.resolveEntity(PluggableSchemaResolver.java:119) :  Found XML schema [http://www.springframework.org/schema/beans/spring-beans.xsd] in classpath: org/springframework/beans/factory/xml/spring-beans-4.3.xsd
[DEBUG] 2017-05-24: 21:06:22 org.springframework.beans.factory.xml.PluggableSchemaResolver.resolveEntity(PluggableSchemaResolver.java:119) :  Found XML schema [http://www.springframework.org/schema/context/spring-context.xsd] in classpath: org/springframework/context/config/spring-context-4.3.xsd
[DEBUG] 2017-05-24: 21:06:22 org.springframework.beans.factory.xml.PluggableSchemaResolver.resolveEntity(PluggableSchemaResolver.java:119) :  Found XML schema [http://www.springframework.org/schema/tool/spring-tool-4.3.xsd] in classpath: org/springframework/beans/factory/xml/spring-tool-4.3.xsd
[DEBUG] 2017-05-24: 21:06:22 org.springframework.beans.factory.xml.PluggableSchemaResolver.resolveEntity(PluggableSchemaResolver.java:119) :  Found XML schema [http://www.springframework.org/schema/tx/spring-tx.xsd] in classpath: org/springframework/transaction/config/spring-tx-4.3.xsd
[DEBUG] 2017-05-24: 21:06:22 org.springframework.beans.factory.xml.DefaultBeanDefinitionDocumentReader.registerBeanDefinitions(DefaultBeanDefinitionDocumentReader.java:92) :  Loading bean definitions
[DEBUG] 2017-05-24: 21:06:22 org.springframework.beans.factory.xml.DefaultNamespaceHandlerResolver.getHandlerMappings(DefaultNamespaceHandlerResolver.java:157) :  Loaded NamespaceHandler mappings: {http://www.springframework.org/schema/p=org.springframework.beans.factory.xml.SimplePropertyNamespaceHandler, http://www.springframework.org/schema/util=org.springframework.beans.factory.xml.UtilNamespaceHandler, http://www.springframework.org/schema/jee=org.springframework.ejb.config.JeeNamespaceHandler, http://www.springframework.org/schema/aop=org.springframework.aop.config.AopNamespaceHandler, http://www.springframework.org/schema/jdbc=org.springframework.jdbc.config.JdbcNamespaceHandler, http://www.springframework.org/schema/cache=org.springframework.cache.config.CacheNamespaceHandler, http://www.springframework.org/schema/c=org.springframework.beans.factory.xml.SimpleConstructorNamespaceHandler, http://www.springframework.org/schema/tx=org.springframework.transaction.config.TxNamespaceHandler, http://www.springframework.org/schema/task=org.springframework.scheduling.config.TaskNamespaceHandler, http://www.springframework.org/schema/lang=org.springframework.scripting.config.LangNamespaceHandler, http://www.springframework.org/schema/context=org.springframework.context.config.ContextNamespaceHandler}
[DEBUG] 2017-05-24: 21:06:22 org.springframework.core.env.MutablePropertySources.addLast(MutablePropertySources.java:109) :  Adding [systemProperties] PropertySource with lowest search precedence
[DEBUG] 2017-05-24: 21:06:22 org.springframework.core.env.MutablePropertySources.addLast(MutablePropertySources.java:109) :  Adding [systemEnvironment] PropertySource with lowest search precedence
[DEBUG] 2017-05-24: 21:06:22 org.springframework.core.env.AbstractEnvironment.<init>(AbstractEnvironment.java:124) :  Initialized StandardEnvironment with PropertySources [systemProperties,systemEnvironment]
[DEBUG] 2017-05-24: 21:06:22 org.springframework.context.annotation.ClassPathScanningCandidateComponentProvider.registerDefaultFilters(ClassPathScanningCandidateComponentProvider.java:244) :  JSR-250 'javax.annotation.ManagedBean' found and supported for component scanning
[DEBUG] 2017-05-24: 21:06:22 org.springframework.context.annotation.ClassPathScanningCandidateComponentProvider.registerDefaultFilters(ClassPathScanningCandidateComponentProvider.java:252) :  JSR-330 'javax.inject.Named' annotation found and supported for component scanning
[DEBUG] 2017-05-24: 21:06:22 org.springframework.core.io.support.PathMatchingResourcePatternResolver.findAllClassPathResources(PathMatchingResourcePatternResolver.java:317) :  Resolved classpath location [com/ittx/usermanager/] to resources [URL [file:/D:/projects/workspace_mavens/ssh/ssh-usermanager_annotaion/target/classes/com/ittx/usermanager/]]
[DEBUG] 2017-05-24: 21:06:22 org.springframework.core.io.support.PathMatchingResourcePatternResolver.doFindMatchingFileSystemResources(PathMatchingResourcePatternResolver.java:711) :  Looking for matching resources in directory tree [D:\projects\workspace_mavens\ssh\ssh-usermanager_annotaion\target\classes\com\ittx\usermanager]
[DEBUG] 2017-05-24: 21:06:22 org.springframework.core.io.support.PathMatchingResourcePatternResolver.doRetrieveMatchingFiles(PathMatchingResourcePatternResolver.java:773) :  Searching directory [D:\projects\workspace_mavens\ssh\ssh-usermanager_annotaion\target\classes\com\ittx\usermanager] for files matching pattern [D:/projects/workspace_mavens/ssh/ssh-usermanager_annotaion/target/classes/com/ittx/usermanager/**/*.class]
[DEBUG] 2017-05-24: 21:06:22 org.springframework.core.io.support.PathMatchingResourcePatternResolver.doRetrieveMatchingFiles(PathMatchingResourcePatternResolver.java:773) :  Searching directory [D:\projects\workspace_mavens\ssh\ssh-usermanager_annotaion\target\classes\com\ittx\usermanager\action] for files matching pattern [D:/projects/workspace_mavens/ssh/ssh-usermanager_annotaion/target/classes/com/ittx/usermanager/**/*.class]
[DEBUG] 2017-05-24: 21:06:22 org.springframework.core.io.support.PathMatchingResourcePatternResolver.doRetrieveMatchingFiles(PathMatchingResourcePatternResolver.java:773) :  Searching directory [D:\projects\workspace_mavens\ssh\ssh-usermanager_annotaion\target\classes\com\ittx\usermanager\dao] for files matching pattern [D:/projects/workspace_mavens/ssh/ssh-usermanager_annotaion/target/classes/com/ittx/usermanager/**/*.class]
[DEBUG] 2017-05-24: 21:06:22 org.springframework.core.io.support.PathMatchingResourcePatternResolver.doRetrieveMatchingFiles(PathMatchingResourcePatternResolver.java:773) :  Searching directory [D:\projects\workspace_mavens\ssh\ssh-usermanager_annotaion\target\classes\com\ittx\usermanager\dao\impl] for files matching pattern [D:/projects/workspace_mavens/ssh/ssh-usermanager_annotaion/target/classes/com/ittx/usermanager/**/*.class]
[DEBUG] 2017-05-24: 21:06:22 org.springframework.core.io.support.PathMatchingResourcePatternResolver.doRetrieveMatchingFiles(PathMatchingResourcePatternResolver.java:773) :  Searching directory [D:\projects\workspace_mavens\ssh\ssh-usermanager_annotaion\target\classes\com\ittx\usermanager\model] for files matching pattern [D:/projects/workspace_mavens/ssh/ssh-usermanager_annotaion/target/classes/com/ittx/usermanager/**/*.class]
[DEBUG] 2017-05-24: 21:06:22 org.springframework.core.io.support.PathMatchingResourcePatternResolver.doRetrieveMatchingFiles(PathMatchingResourcePatternResolver.java:773) :  Searching directory [D:\projects\workspace_mavens\ssh\ssh-usermanager_annotaion\target\classes\com\ittx\usermanager\service] for files matching pattern [D:/projects/workspace_mavens/ssh/ssh-usermanager_annotaion/target/classes/com/ittx/usermanager/**/*.class]
[DEBUG] 2017-05-24: 21:06:22 org.springframework.core.io.support.PathMatchingResourcePatternResolver.doRetrieveMatchingFiles(PathMatchingResourcePatternResolver.java:773) :  Searching directory [D:\projects\workspace_mavens\ssh\ssh-usermanager_annotaion\target\classes\com\ittx\usermanager\service\impl] for files matching pattern [D:/projects/workspace_mavens/ssh/ssh-usermanager_annotaion/target/classes/com/ittx/usermanager/**/*.class]
[DEBUG] 2017-05-24: 21:06:22 org.springframework.core.io.support.PathMatchingResourcePatternResolver.doRetrieveMatchingFiles(PathMatchingResourcePatternResolver.java:773) :  Searching directory [D:\projects\workspace_mavens\ssh\ssh-usermanager_annotaion\target\classes\com\ittx\usermanager\util] for files matching pattern [D:/projects/workspace_mavens/ssh/ssh-usermanager_annotaion/target/classes/com/ittx/usermanager/**/*.class]
[DEBUG] 2017-05-24: 21:06:22 org.springframework.core.io.support.PathMatchingResourcePatternResolver.findPathMatchingResources(PathMatchingResourcePatternResolver.java:483) :  Resolved location pattern [classpath*:com/ittx/usermanager/**/*.class] to resources [file [D:\projects\workspace_mavens\ssh\ssh-usermanager_annotaion\target\classes\com\ittx\usermanager\action\BaseAction.class], file [D:\projects\workspace_mavens\ssh\ssh-usermanager_annotaion\target\classes\com\ittx\usermanager\action\LoginAction.class], file [D:\projects\workspace_mavens\ssh\ssh-usermanager_annotaion\target\classes\com\ittx\usermanager\action\UserAction.class], file [D:\projects\workspace_mavens\ssh\ssh-usermanager_annotaion\target\classes\com\ittx\usermanager\dao\impl\UserDaoImpl$1.class], file [D:\projects\workspace_mavens\ssh\ssh-usermanager_annotaion\target\classes\com\ittx\usermanager\dao\impl\UserDaoImpl$2.class], file [D:\projects\workspace_mavens\ssh\ssh-usermanager_annotaion\target\classes\com\ittx\usermanager\dao\impl\UserDaoImpl.class], file [D:\projects\workspace_mavens\ssh\ssh-usermanager_annotaion\target\classes\com\ittx\usermanager\dao\UserDao.class], file [D:\projects\workspace_mavens\ssh\ssh-usermanager_annotaion\target\classes\com\ittx\usermanager\model\User.class], file [D:\projects\workspace_mavens\ssh\ssh-usermanager_annotaion\target\classes\com\ittx\usermanager\service\impl\UserServiceImpl.class], file [D:\projects\workspace_mavens\ssh\ssh-usermanager_annotaion\target\classes\com\ittx\usermanager\service\UserService.class], file [D:\projects\workspace_mavens\ssh\ssh-usermanager_annotaion\target\classes\com\ittx\usermanager\util\ConnectDB.class], file [D:\projects\workspace_mavens\ssh\ssh-usermanager_annotaion\target\classes\com\ittx\usermanager\util\DBConnection.class], file [D:\projects\workspace_mavens\ssh\ssh-usermanager_annotaion\target\classes\com\ittx\usermanager\util\EncodeFilter.class], file [D:\projects\workspace_mavens\ssh\ssh-usermanager_annotaion\target\classes\com\ittx\usermanager\util\HibernateUtil.class], file [D:\projects\workspace_mavens\ssh\ssh-usermanager_annotaion\target\classes\com\ittx\usermanager\util\LoginFilter.class], file [D:\projects\workspace_mavens\ssh\ssh-usermanager_annotaion\target\classes\com\ittx\usermanager\util\MyHibernateDaoSupport.class], file [D:\projects\workspace_mavens\ssh\ssh-usermanager_annotaion\target\classes\com\ittx\usermanager\util\Pager.class], file [D:\projects\workspace_mavens\ssh\ssh-usermanager_annotaion\target\classes\com\ittx\usermanager\util\PagerUtil.class]]
[DEBUG] 2017-05-24: 21:06:22 org.springframework.context.annotation.ClassPathScanningCandidateComponentProvider.findCandidateComponents(ClassPathScanningCandidateComponentProvider.java:286) :  Identified candidate component class: file [D:\projects\workspace_mavens\ssh\ssh-usermanager_annotaion\target\classes\com\ittx\usermanager\action\UserAction.class]
[DEBUG] 2017-05-24: 21:06:22 org.springframework.context.annotation.ClassPathScanningCandidateComponentProvider.findCandidateComponents(ClassPathScanningCandidateComponentProvider.java:286) :  Identified candidate component class: file [D:\projects\workspace_mavens\ssh\ssh-usermanager_annotaion\target\classes\com\ittx\usermanager\dao\impl\UserDaoImpl.class]
[DEBUG] 2017-05-24: 21:06:22 org.springframework.context.annotation.ClassPathScanningCandidateComponentProvider.findCandidateComponents(ClassPathScanningCandidateComponentProvider.java:286) :  Identified candidate component class: file [D:\projects\workspace_mavens\ssh\ssh-usermanager_annotaion\target\classes\com\ittx\usermanager\service\impl\UserServiceImpl.class]
[DEBUG] 2017-05-24: 21:06:22 org.springframework.beans.factory.support.AbstractBeanDefinitionReader.loadBeanDefinitions(AbstractBeanDefinitionReader.java:224) :  Loaded 19 bean definitions from location pattern [classpath:spring-core.xml]
[DEBUG] 2017-05-24: 21:06:22 org.springframework.context.support.AbstractApplicationContext.obtainFreshBeanFactory(AbstractApplicationContext.java:615) :  Bean factory for Root WebApplicationContext: org.springframework.beans.factory.support.DefaultListableBeanFactory@61d059: defining beans [userAction,userDao,userService,org.springframework.context.annotation.internalConfigurationAnnotationProcessor,org.springframework.context.annotation.internalAutowiredAnnotationProcessor,org.springframework.context.annotation.internalRequiredAnnotationProcessor,org.springframework.context.annotation.internalCommonAnnotationProcessor,org.springframework.context.annotation.internalPersistenceAnnotationProcessor,org.springframework.context.event.internalEventListenerProcessor,org.springframework.context.event.internalEventListenerFactory,org.springframework.context.support.PropertySourcesPlaceholderConfigurer#0,dataSource,sessionFactory,transactionManager,org.springframework.transaction.config.internalTransactionalEventListenerFactory,org.springframework.aop.config.internalAutoProxyCreator,org.springframework.transaction.annotation.AnnotationTransactionAttributeSource#0,org.springframework.transaction.interceptor.TransactionInterceptor#0,org.springframework.transaction.config.internalTransactionAdvisor]; root of factory hierarchy
[DEBUG] 2017-05-24: 21:06:22 org.springframework.beans.factory.support.AbstractBeanFactory.registerScope(AbstractBeanFactory.java:879) :  Registering scope 'request' with implementation [org.springframework.web.context.request.RequestScope@19a2ac6]
[DEBUG] 2017-05-24: 21:06:22 org.springframework.beans.factory.support.AbstractBeanFactory.registerScope(AbstractBeanFactory.java:879) :  Registering scope 'session' with implementation [org.springframework.web.context.request.SessionScope@15e03d0]
[DEBUG] 2017-05-24: 21:06:22 org.springframework.beans.factory.support.AbstractBeanFactory.registerScope(AbstractBeanFactory.java:879) :  Registering scope 'globalSession' with implementation [org.springframework.web.context.request.SessionScope@10ec1e7]
[DEBUG] 2017-05-24: 21:06:22 org.springframework.beans.factory.support.AbstractBeanFactory.registerScope(AbstractBeanFactory.java:879) :  Registering scope 'application' with implementation [org.springframework.web.context.support.ServletContextScope@19997d4]
[DEBUG] 2017-05-24: 21:06:22 org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:221) :  Creating shared instance of singleton bean 'org.springframework.context.annotation.internalConfigurationAnnotationProcessor'
[DEBUG] 2017-05-24: 21:06:22 org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:448) :  Creating instance of bean 'org.springframework.context.annotation.internalConfigurationAnnotationProcessor'
[DEBUG] 2017-05-24: 21:06:22 org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:529) :  Eagerly caching bean 'org.springframework.context.annotation.internalConfigurationAnnotationProcessor' to allow for resolving potential circular references
[DEBUG] 2017-05-24: 21:06:22 org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:484) :  Finished creating instance of bean 'org.springframework.context.annotation.internalConfigurationAnnotationProcessor'
[DEBUG] 2017-05-24: 21:06:22 org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:221) :  Creating shared instance of singleton bean 'org.springframework.context.support.PropertySourcesPlaceholderConfigurer#0'
[DEBUG] 2017-05-24: 21:06:22 org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:448) :  Creating instance of bean 'org.springframework.context.support.PropertySourcesPlaceholderConfigurer#0'
[DEBUG] 2017-05-24: 21:06:22 org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:529) :  Eagerly caching bean 'org.springframework.context.support.PropertySourcesPlaceholderConfigurer#0' to allow for resolving potential circular references
[DEBUG] 2017-05-24: 21:06:23 org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:484) :  Finished creating instance of bean 'org.springframework.context.support.PropertySourcesPlaceholderConfigurer#0'
[DEBUG] 2017-05-24: 21:06:23 org.springframework.core.env.MutablePropertySources.addLast(MutablePropertySources.java:109) :  Adding [environmentProperties] PropertySource with lowest search precedence
[INFO] 2017-05-24: 21:06:23 org.springframework.core.io.support.PropertiesLoaderSupport.loadProperties(PropertiesLoaderSupport.java:172) :  Loading properties file from class path resource [jdbc.properties]
[DEBUG] 2017-05-24: 21:06:23 org.springframework.core.env.MutablePropertySources.addLast(MutablePropertySources.java:109) :  Adding [localProperties] PropertySource with lowest search precedence
[DEBUG] 2017-05-24: 21:06:23 org.springframework.jndi.JndiTemplate.lookup(JndiTemplate.java:150) :  Looking up JNDI object with name [java:comp/env/jdbc.driverClassName]
[DEBUG] 2017-05-24: 21:06:23 org.springframework.jndi.JndiLocatorSupport.lookup(JndiLocatorSupport.java:101) :  Converted JNDI name [java:comp/env/jdbc.driverClassName] not found - trying original name [jdbc.driverClassName]. javax.naming.NameNotFoundException; remaining name 'jdbc.driverClassName'
[DEBUG] 2017-05-24: 21:06:23 org.springframework.jndi.JndiTemplate.lookup(JndiTemplate.java:150) :  Looking up JNDI object with name [jdbc.driverClassName]
[DEBUG] 2017-05-24: 21:06:23 org.springframework.jndi.JndiPropertySource.getProperty(JndiPropertySource.java:99) :  JNDI lookup for name [jdbc.driverClassName] threw NamingException with message: null. Returning null.
[DEBUG] 2017-05-24: 21:06:23 org.springframework.core.env.PropertySourcesPropertyResolver.getProperty(PropertySourcesPropertyResolver.java:91) :  Could not find key 'jdbc.driverClassName' in any property source
[DEBUG] 2017-05-24: 21:06:23 org.springframework.core.env.PropertySourcesPropertyResolver.logKeyFound(PropertySourcesPropertyResolver.java:151) :  Found key 'jdbc.driverClassName' in [localProperties] with type [String]
[DEBUG] 2017-05-24: 21:06:23 org.springframework.jndi.JndiTemplate.lookup(JndiTemplate.java:150) :  Looking up JNDI object with name [java:comp/env/jdbc.url]
[DEBUG] 2017-05-24: 21:06:23 org.springframework.jndi.JndiLocatorSupport.lookup(JndiLocatorSupport.java:101) :  Converted JNDI name [java:comp/env/jdbc.url] not found - trying original name [jdbc.url]. javax.naming.NameNotFoundException; remaining name 'jdbc.url'
[DEBUG] 2017-05-24: 21:06:23 org.springframework.jndi.JndiTemplate.lookup(JndiTemplate.java:150) :  Looking up JNDI object with name [jdbc.url]
[DEBUG] 2017-05-24: 21:06:23 org.springframework.jndi.JndiPropertySource.getProperty(JndiPropertySource.java:99) :  JNDI lookup for name [jdbc.url] threw NamingException with message: null. Returning null.
[DEBUG] 2017-05-24: 21:06:23 org.springframework.core.env.PropertySourcesPropertyResolver.getProperty(PropertySourcesPropertyResolver.java:91) :  Could not find key 'jdbc.url' in any property source
[DEBUG] 2017-05-24: 21:06:23 org.springframework.core.env.PropertySourcesPropertyResolver.logKeyFound(PropertySourcesPropertyResolver.java:151) :  Found key 'jdbc.url' in [localProperties] with type [String]
[DEBUG] 2017-05-24: 21:06:23 org.springframework.jndi.JndiTemplate.lookup(JndiTemplate.java:150) :  Looking up JNDI object with name [java:comp/env/jdbc.username]
[DEBUG] 2017-05-24: 21:06:23 org.springframework.jndi.JndiLocatorSupport.lookup(JndiLocatorSupport.java:101) :  Converted JNDI name [java:comp/env/jdbc.username] not found - trying original name [jdbc.username]. javax.naming.NameNotFoundException; remaining name 'jdbc.username'
[DEBUG] 2017-05-24: 21:06:23 org.springframework.jndi.JndiTemplate.lookup(JndiTemplate.java:150) :  Looking up JNDI object with name [jdbc.username]
[DEBUG] 2017-05-24: 21:06:23 org.springframework.jndi.JndiPropertySource.getProperty(JndiPropertySource.java:99) :  JNDI lookup for name [jdbc.username] threw NamingException with message: null. Returning null.
[DEBUG] 2017-05-24: 21:06:23 org.springframework.core.env.PropertySourcesPropertyResolver.getProperty(PropertySourcesPropertyResolver.java:91) :  Could not find key 'jdbc.username' in any property source
[DEBUG] 2017-05-24: 21:06:23 org.springframework.core.env.PropertySourcesPropertyResolver.logKeyFound(PropertySourcesPropertyResolver.java:151) :  Found key 'jdbc.username' in [localProperties] with type [String]
[DEBUG] 2017-05-24: 21:06:23 org.springframework.jndi.JndiTemplate.lookup(JndiTemplate.java:150) :  Looking up JNDI object with name [java:comp/env/jdbc.password]
[DEBUG] 2017-05-24: 21:06:23 org.springframework.jndi.JndiLocatorSupport.lookup(JndiLocatorSupport.java:101) :  Converted JNDI name [java:comp/env/jdbc.password] not found - trying original name [jdbc.password]. javax.naming.NameNotFoundException; remaining name 'jdbc.password'
[DEBUG] 2017-05-24: 21:06:23 org.springframework.jndi.JndiTemplate.lookup(JndiTemplate.java:150) :  Looking up JNDI object with name [jdbc.password]
[DEBUG] 2017-05-24: 21:06:23 org.springframework.jndi.JndiPropertySource.getProperty(JndiPropertySource.java:99) :  JNDI lookup for name [jdbc.password] threw NamingException with message: null. Returning null.
[DEBUG] 2017-05-24: 21:06:23 org.springframework.core.env.PropertySourcesPropertyResolver.getProperty(PropertySourcesPropertyResolver.java:91) :  Could not find key 'jdbc.password' in any property source
[DEBUG] 2017-05-24: 21:06:23 org.springframework.core.env.PropertySourcesPropertyResolver.logKeyFound(PropertySourcesPropertyResolver.java:151) :  Found key 'jdbc.password' in [localProperties] with type [String]
[DEBUG] 2017-05-24: 21:06:23 org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:221) :  Creating shared instance of singleton bean 'org.springframework.context.annotation.internalAutowiredAnnotationProcessor'
[DEBUG] 2017-05-24: 21:06:23 org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:448) :  Creating instance of bean 'org.springframework.context.annotation.internalAutowiredAnnotationProcessor'
[INFO] 2017-05-24: 21:06:23 org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor.<init>(AutowiredAnnotationBeanPostProcessor.java:155) :  JSR-330 'javax.inject.Inject' annotation found and supported for autowiring
[DEBUG] 2017-05-24: 21:06:23 org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:529) :  Eagerly caching bean 'org.springframework.context.annotation.internalAutowiredAnnotationProcessor' to allow for resolving potential circular references
[DEBUG] 2017-05-24: 21:06:23 org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:484) :  Finished creating instance of bean 'org.springframework.context.annotation.internalAutowiredAnnotationProcessor'
[DEBUG] 2017-05-24: 21:06:23 org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:221) :  Creating shared instance of singleton bean 'org.springframework.context.annotation.internalRequiredAnnotationProcessor'
[DEBUG] 2017-05-24: 21:06:23 org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:448) :  Creating instance of bean 'org.springframework.context.annotation.internalRequiredAnnotationProcessor'
[DEBUG] 2017-05-24: 21:06:23 org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:529) :  Eagerly caching bean 'org.springframework.context.annotation.internalRequiredAnnotationProcessor' to allow for resolving potential circular references
[DEBUG] 2017-05-24: 21:06:23 org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:484) :  Finished creating instance of bean 'org.springframework.context.annotation.internalRequiredAnnotationProcessor'
[DEBUG] 2017-05-24: 21:06:23 org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:221) :  Creating shared instance of singleton bean 'org.springframework.context.annotation.internalCommonAnnotationProcessor'
[DEBUG] 2017-05-24: 21:06:23 org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:448) :  Creating instance of bean 'org.springframework.context.annotation.internalCommonAnnotationProcessor'
[DEBUG] 2017-05-24: 21:06:23 org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:529) :  Eagerly caching bean 'org.springframework.context.annotation.internalCommonAnnotationProcessor' to allow for resolving potential circular references
[DEBUG] 2017-05-24: 21:06:23 org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:484) :  Finished creating instance of bean 'org.springframework.context.annotation.internalCommonAnnotationProcessor'
[DEBUG] 2017-05-24: 21:06:23 org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:221) :  Creating shared instance of singleton bean 'org.springframework.context.annotation.internalPersistenceAnnotationProcessor'
[DEBUG] 2017-05-24: 21:06:23 org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:448) :  Creating instance of bean 'org.springframework.context.annotation.internalPersistenceAnnotationProcessor'
[DEBUG] 2017-05-24: 21:06:23 org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:529) :  Eagerly caching bean 'org.springframework.context.annotation.internalPersistenceAnnotationProcessor' to allow for resolving potential circular references
[DEBUG] 2017-05-24: 21:06:23 org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:484) :  Finished creating instance of bean 'org.springframework.context.annotation.internalPersistenceAnnotationProcessor'
[DEBUG] 2017-05-24: 21:06:23 org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:221) :  Creating shared instance of singleton bean 'org.springframework.context.annotation.ConfigurationClassPostProcessor.importAwareProcessor'
[DEBUG] 2017-05-24: 21:06:23 org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:448) :  Creating instance of bean 'org.springframework.context.annotation.ConfigurationClassPostProcessor.importAwareProcessor'
[DEBUG] 2017-05-24: 21:06:23 org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:529) :  Eagerly caching bean 'org.springframework.context.annotation.ConfigurationClassPostProcessor.importAwareProcessor' to allow for resolving potential circular references
[DEBUG] 2017-05-24: 21:06:23 org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:484) :  Finished creating instance of bean 'org.springframework.context.annotation.ConfigurationClassPostProcessor.importAwareProcessor'
[DEBUG] 2017-05-24: 21:06:23 org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:221) :  Creating shared instance of singleton bean 'org.springframework.context.annotation.ConfigurationClassPostProcessor.enhancedConfigurationProcessor'
[DEBUG] 2017-05-24: 21:06:23 org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:448) :  Creating instance of bean 'org.springframework.context.annotation.ConfigurationClassPostProcessor.enhancedConfigurationProcessor'
[DEBUG] 2017-05-24: 21:06:23 org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:529) :  Eagerly caching bean 'org.springframework.context.annotation.ConfigurationClassPostProcessor.enhancedConfigurationProcessor' to allow for resolving potential circular references
[DEBUG] 2017-05-24: 21:06:23 org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:484) :  Finished creating instance of bean 'org.springframework.context.annotation.ConfigurationClassPostProcessor.enhancedConfigurationProcessor'
[DEBUG] 2017-05-24: 21:06:23 org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:221) :  Creating shared instance of singleton bean 'org.springframework.aop.config.internalAutoProxyCreator'
[DEBUG] 2017-05-24: 21:06:23 org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:448) :  Creating instance of bean 'org.springframework.aop.config.internalAutoProxyCreator'
[DEBUG] 2017-05-24: 21:06:23 org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:529) :  Eagerly caching bean 'org.springframework.aop.config.internalAutoProxyCreator' to allow for resolving potential circular references
[DEBUG] 2017-05-24: 21:06:23 org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:484) :  Finished creating instance of bean 'org.springframework.aop.config.internalAutoProxyCreator'
[DEBUG] 2017-05-24: 21:06:23 org.springframework.context.support.AbstractApplicationContext.initMessageSource(AbstractApplicationContext.java:728) :  Unable to locate MessageSource with name 'messageSource': using default [org.springframework.context.support.DelegatingMessageSource@13e47a4]
[DEBUG] 2017-05-24: 21:06:23 org.springframework.context.support.AbstractApplicationContext.initApplicationEventMulticaster(AbstractApplicationContext.java:752) :  Unable to locate ApplicationEventMulticaster with name 'applicationEventMulticaster': using default [org.springframework.context.event.SimpleApplicationEventMulticaster@246bc1]
[DEBUG] 2017-05-24: 21:06:23 org.springframework.ui.context.support.UiApplicationContextUtils.initThemeSource(UiApplicationContextUtils.java:85) :  Unable to locate ThemeSource with name 'themeSource': using default [org.springframework.ui.context.support.ResourceBundleThemeSource@190160e]
[DEBUG] 2017-05-24: 21:06:23 org.springframework.beans.factory.support.DefaultListableBeanFactory.preInstantiateSingletons(DefaultListableBeanFactory.java:720) :  Pre-instantiating singletons in org.springframework.beans.factory.support.DefaultListableBeanFactory@61d059: defining beans [userAction,userDao,userService,org.springframework.context.annotation.internalConfigurationAnnotationProcessor,org.springframework.context.annotation.internalAutowiredAnnotationProcessor,org.springframework.context.annotation.internalRequiredAnnotationProcessor,org.springframework.context.annotation.internalCommonAnnotationProcessor,org.springframework.context.annotation.internalPersistenceAnnotationProcessor,org.springframework.context.event.internalEventListenerProcessor,org.springframework.context.event.internalEventListenerFactory,org.springframework.context.support.PropertySourcesPlaceholderConfigurer#0,dataSource,sessionFactory,transactionManager,org.springframework.transaction.config.internalTransactionalEventListenerFactory,org.springframework.aop.config.internalAutoProxyCreator,org.springframework.transaction.annotation.AnnotationTransactionAttributeSource#0,org.springframework.transaction.interceptor.TransactionInterceptor#0,org.springframework.transaction.config.internalTransactionAdvisor,org.springframework.context.annotation.ConfigurationClassPostProcessor.importAwareProcessor,org.springframework.context.annotation.ConfigurationClassPostProcessor.enhancedConfigurationProcessor]; root of factory hierarchy
[DEBUG] 2017-05-24: 21:06:23 org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:221) :  Creating shared instance of singleton bean 'userAction'
[DEBUG] 2017-05-24: 21:06:23 org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:448) :  Creating instance of bean 'userAction'
[DEBUG] 2017-05-24: 21:06:23 org.springframework.beans.factory.annotation.InjectionMetadata.checkConfigMembers(InjectionMetadata.java:72) :  Registered injected element on class [com.ittx.usermanager.action.UserAction]: AutowiredFieldElement for private com.ittx.usermanager.service.UserService com.ittx.usermanager.action.UserAction.userService
[DEBUG] 2017-05-24: 21:06:23 org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:529) :  Eagerly caching bean 'userAction' to allow for resolving potential circular references
[DEBUG] 2017-05-24: 21:06:23 org.springframework.beans.factory.annotation.InjectionMetadata.inject(InjectionMetadata.java:86) :  Processing injected element of bean 'userAction': AutowiredFieldElement for private com.ittx.usermanager.service.UserService com.ittx.usermanager.action.UserAction.userService
[DEBUG] 2017-05-24: 21:06:23 org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:221) :  Creating shared instance of singleton bean 'userService'
[DEBUG] 2017-05-24: 21:06:23 org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:448) :  Creating instance of bean 'userService'
[DEBUG] 2017-05-24: 21:06:23 org.springframework.beans.factory.annotation.InjectionMetadata.checkConfigMembers(InjectionMetadata.java:72) :  Registered injected element on class [com.ittx.usermanager.service.impl.UserServiceImpl]: AutowiredFieldElement for private com.ittx.usermanager.dao.UserDao com.ittx.usermanager.service.impl.UserServiceImpl.userDao
[DEBUG] 2017-05-24: 21:06:23 org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:529) :  Eagerly caching bean 'userService' to allow for resolving potential circular references
[DEBUG] 2017-05-24: 21:06:23 org.springframework.beans.factory.annotation.InjectionMetadata.inject(InjectionMetadata.java:86) :  Processing injected element of bean 'userService': AutowiredFieldElement for private com.ittx.usermanager.dao.UserDao com.ittx.usermanager.service.impl.UserServiceImpl.userDao
[DEBUG] 2017-05-24: 21:06:23 org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:221) :  Creating shared instance of singleton bean 'userDao'
[DEBUG] 2017-05-24: 21:06:23 org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:448) :  Creating instance of bean 'userDao'
[DEBUG] 2017-05-24: 21:06:23 org.springframework.beans.factory.annotation.InjectionMetadata.checkConfigMembers(InjectionMetadata.java:72) :  Registered injected element on class [com.ittx.usermanager.dao.impl.UserDaoImpl]: ResourceElement for public void com.ittx.usermanager.util.MyHibernateDaoSupport.setSuperSessionFactory(org.hibernate.SessionFactory)
[DEBUG] 2017-05-24: 21:06:23 org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:529) :  Eagerly caching bean 'userDao' to allow for resolving potential circular references
[DEBUG] 2017-05-24: 21:06:23 org.springframework.beans.factory.annotation.InjectionMetadata.inject(InjectionMetadata.java:86) :  Processing injected element of bean 'userDao': ResourceElement for public void com.ittx.usermanager.util.MyHibernateDaoSupport.setSuperSessionFactory(org.hibernate.SessionFactory)
[DEBUG] 2017-05-24: 21:06:23 org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:221) :  Creating shared instance of singleton bean 'sessionFactory'
[DEBUG] 2017-05-24: 21:06:23 org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:448) :  Creating instance of bean 'sessionFactory'
[DEBUG] 2017-05-24: 21:06:23 org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:529) :  Eagerly caching bean 'sessionFactory' to allow for resolving potential circular references
[DEBUG] 2017-05-24: 21:06:23 org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:221) :  Creating shared instance of singleton bean 'dataSource'
[DEBUG] 2017-05-24: 21:06:23 org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:448) :  Creating instance of bean 'dataSource'
[DEBUG] 2017-05-24: 21:06:23 org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:529) :  Eagerly caching bean 'dataSource' to allow for resolving potential circular references
[INFO] 2017-05-24: 21:06:23 org.springframework.jdbc.datasource.DriverManagerDataSource.setDriverClassName(DriverManagerDataSource.java:133) :  Loaded JDBC driver: com.mysql.jdbc.Driver
[DEBUG] 2017-05-24: 21:06:23 org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:221) :  Creating shared instance of singleton bean 'org.springframework.transaction.config.internalTransactionAdvisor'
[DEBUG] 2017-05-24: 21:06:23 org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:448) :  Creating instance of bean 'org.springframework.transaction.config.internalTransactionAdvisor'
[DEBUG] 2017-05-24: 21:06:23 org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:529) :  Eagerly caching bean 'org.springframework.transaction.config.internalTransactionAdvisor' to allow for resolving potential circular references
[DEBUG] 2017-05-24: 21:06:23 org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:221) :  Creating shared instance of singleton bean 'org.springframework.transaction.annotation.AnnotationTransactionAttributeSource#0'
[DEBUG] 2017-05-24: 21:06:23 org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:448) :  Creating instance of bean 'org.springframework.transaction.annotation.AnnotationTransactionAttributeSource#0'
[DEBUG] 2017-05-24: 21:06:23 org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:529) :  Eagerly caching bean 'org.springframework.transaction.annotation.AnnotationTransactionAttributeSource#0' to allow for resolving potential circular references
[DEBUG] 2017-05-24: 21:06:23 org.springframework.aop.framework.autoproxy.BeanFactoryAdvisorRetrievalHelper.findAdvisorBeans(BeanFactoryAdvisorRetrievalHelper.java:87) :  Skipping currently created advisor 'org.springframework.transaction.config.internalTransactionAdvisor'
[DEBUG] 2017-05-24: 21:06:23 org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:484) :  Finished creating instance of bean 'org.springframework.transaction.annotation.AnnotationTransactionAttributeSource#0'
[DEBUG] 2017-05-24: 21:06:23 org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:484) :  Finished creating instance of bean 'org.springframework.transaction.config.internalTransactionAdvisor'
[DEBUG] 2017-05-24: 21:06:23 org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:484) :  Finished creating instance of bean 'dataSource'
[DEBUG] 2017-05-24: 21:06:23 org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.invokeInitMethods(AbstractAutowireCapableBeanFactory.java:1625) :  Invoking afterPropertiesSet() on bean with name 'sessionFactory'
[DEBUG] 2017-05-24: 21:06:23 org.hibernate.cfg.Configuration.<clinit>(Configuration.java:194) :  Logging Provider: org.jboss.logging.Log4jLoggerProvider
[DEBUG] 2017-05-24: 21:06:23 org.hibernate.type.BasicTypeRegistry.register(BasicTypeRegistry.java:146) :  Adding type registration boolean -> org.hibernate.type.BooleanType@13b8a22
[DEBUG] 2017-05-24: 21:06:23 org.hibernate.type.BasicTypeRegistry.register(BasicTypeRegistry.java:146) :  Adding type registration boolean -> org.hibernate.type.BooleanType@13b8a22
[DEBUG] 2017-05-24: 21:06:23 org.hibernate.type.BasicTypeRegistry.register(BasicTypeRegistry.java:146) :  Adding type registration java.lang.Boolean -> org.hibernate.type.BooleanType@13b8a22
[DEBUG] 2017-05-24: 21:06:23 org.hibernate.type.BasicTypeRegistry.register(BasicTypeRegistry.java:146) :  Adding type registration numeric_boolean -> org.hibernate.type.NumericBooleanType@18bc506
[DEBUG] 2017-05-24: 21:06:23 org.hibernate.type.BasicTypeRegistry.register(BasicTypeRegistry.java:146) :  Adding type registration true_false -> org.hibernate.type.TrueFalseType@4cc9e
[DEBUG] 2017-05-24: 21:06:23 org.hibernate.type.BasicTypeRegistry.register(BasicTypeRegistry.java:146) :  Adding type registration yes_no -> org.hibernate.type.YesNoType@933297
[DEBUG] 2017-05-24: 21:06:23 org.hibernate.type.BasicTypeRegistry.register(BasicTypeRegistry.java:146) :  Adding type registration byte -> org.hibernate.type.ByteType@16cb2b8
[DEBUG] 2017-05-24: 21:06:23 org.hibernate.type.BasicTypeRegistry.register(BasicTypeRegistry.java:146) :  Adding type registration byte -> org.hibernate.type.ByteType@16cb2b8
[DEBUG] 2017-05-24: 21:06:23 org.hibernate.type.BasicTypeRegistry.register(BasicTypeRegistry.java:146) :  Adding type registration java.lang.Byte -> org.hibernate.type.ByteType@16cb2b8
[DEBUG] 2017-05-24: 21:06:23 org.hibernate.type.BasicTypeRegistry.register(BasicTypeRegistry.java:146) :  Adding type registration character -> org.hibernate.type.CharacterType@129ff6
[DEBUG] 2017-05-24: 21:06:23 org.hibernate.type.BasicTypeRegistry.register(BasicTypeRegistry.java:146) :  Adding type registration char -> org.hibernate.type.CharacterType@129ff6
[DEBUG] 2017-05-24: 21:06:23 org.hibernate.type.BasicTypeRegistry.register(BasicTypeRegistry.java:146) :  Adding type registration java.lang.Character -> org.hibernate.type.CharacterType@129ff6
[DEBUG] 2017-05-24: 21:06:23 org.hibernate.type.BasicTypeRegistry.register(BasicTypeRegistry.java:146) :  Adding type registration short -> org.hibernate.type.ShortType@1d536ea
[DEBUG] 2017-05-24: 21:06:23 org.hibernate.type.BasicTypeRegistry.register(BasicTypeRegistry.java:146) :  Adding type registration short -> org.hibernate.type.ShortType@1d536ea
[DEBUG] 2017-05-24: 21:06:23 org.hibernate.type.BasicTypeRegistry.register(BasicTypeRegistry.java:146) :  Adding type registration java.lang.Short -> org.hibernate.type.ShortType@1d536ea
[DEBUG] 2017-05-24: 21:06:23 org.hibernate.type.BasicTypeRegistry.register(BasicTypeRegistry.java:146) :  Adding type registration integer -> org.hibernate.type.IntegerType@b081a6
[DEBUG] 2017-05-24: 21:06:23 org.hibernate.type.BasicTypeRegistry.register(BasicTypeRegistry.java:146) :  Adding type registration int -> org.hibernate.type.IntegerType@b081a6
[DEBUG] 2017-05-24: 21:06:23 org.hibernate.type.BasicTypeRegistry.register(BasicTypeRegistry.java:146) :  Adding type registration java.lang.Integer -> org.hibernate.type.IntegerType@b081a6
[DEBUG] 2017-05-24: 21:06:23 org.hibernate.type.BasicTypeRegistry.register(BasicTypeRegistry.java:146) :  Adding type registration long -> org.hibernate.type.LongType@135f6c8
[DEBUG] 2017-05-24: 21:06:23 org.hibernate.type.BasicTypeRegistry.register(BasicTypeRegistry.java:146) :  Adding type registration long -> org.hibernate.type.LongType@135f6c8
[DEBUG] 2017-05-24: 21:06:23 org.hibernate.type.BasicTypeRegistry.register(BasicTypeRegistry.java:146) :  Adding type registration java.lang.Long -> org.hibernate.type.LongType@135f6c8
[DEBUG] 2017-05-24: 21:06:23 org.hibernate.type.BasicTypeRegistry.register(BasicTypeRegistry.java:146) :  Adding type registration float -> org.hibernate.type.FloatType@1df3b73
[DEBUG] 2017-05-24: 21:06:23 org.hibernate.type.BasicTypeRegistry.register(BasicTypeRegistry.java:146) :  Adding type registration float -> org.hibernate.type.FloatType@1df3b73
[DEBUG] 2017-05-24: 21:06:23 org.hibernate.type.BasicTypeRegistry.register(BasicTypeRegistry.java:146) :  Adding type registration java.lang.Float -> org.hibernate.type.FloatType@1df3b73
[DEBUG] 2017-05-24: 21:06:23 org.hibernate.type.BasicTypeRegistry.register(BasicTypeRegistry.java:146) :  Adding type registration double -> org.hibernate.type.DoubleType@1f26694
[DEBUG] 2017-05-24: 21:06:23 org.hibernate.type.BasicTypeRegistry.register(BasicTypeRegistry.java:146) :  Adding type registration double -> org.hibernate.type.DoubleType@1f26694
[DEBUG] 2017-05-24: 21:06:23 org.hibernate.type.BasicTypeRegistry.register(BasicTypeRegistry.java:146) :  Adding type registration java.lang.Double -> org.hibernate.type.DoubleType@1f26694
[DEBUG] 2017-05-24: 21:06:23 org.hibernate.type.BasicTypeRegistry.register(BasicTypeRegistry.java:146) :  Adding type registration big_decimal -> org.hibernate.type.BigDecimalType@10dc492
[DEBUG] 2017-05-24: 21:06:23 org.hibernate.type.BasicTypeRegistry.register(BasicTypeRegistry.java:146) :  Adding type registration java.math.BigDecimal -> org.hibernate.type.BigDecimalType@10dc492
[DEBUG] 2017-05-24: 21:06:23 org.hibernate.type.BasicTypeRegistry.register(BasicTypeRegistry.java:146) :  Adding type registration big_integer -> org.hibernate.type.BigIntegerType@1836ad7
[DEBUG] 2017-05-24: 21:06:23 org.hibernate.type.BasicTypeRegistry.register(BasicTypeRegistry.java:146) :  Adding type registration java.math.BigInteger -> org.hibernate.type.BigIntegerType@1836ad7
[DEBUG] 2017-05-24: 21:06:23 org.hibernate.type.BasicTypeRegistry.register(BasicTypeRegistry.java:146) :  Adding type registration string -> org.hibernate.type.StringType@84cb38
[DEBUG] 2017-05-24: 21:06:23 org.hibernate.type.BasicTypeRegistry.register(BasicTypeRegistry.java:146) :  Adding type registration java.lang.String -> org.hibernate.type.StringType@84cb38
[DEBUG] 2017-05-24: 21:06:23 org.hibernate.type.BasicTypeRegistry.register(BasicTypeRegistry.java:146) :  Adding type registration nstring -> org.hibernate.type.StringNVarcharType@3a08e
[DEBUG] 2017-05-24: 21:06:23 org.hibernate.type.BasicTypeRegistry.register(BasicTypeRegistry.java:146) :  Adding type registration ncharacter -> org.hibernate.type.CharacterNCharType@11a74
[DEBUG] 2017-05-24: 21:06:23 org.hibernate.type.BasicTypeRegistry.register(BasicTypeRegistry.java:146) :  Adding type registration url -> org.hibernate.type.UrlType@156130d
[DEBUG] 2017-05-24: 21:06:23 org.hibernate.type.BasicTypeRegistry.register(BasicTypeRegistry.java:146) :  Adding type registration java.net.URL -> org.hibernate.type.UrlType@156130d
[DEBUG] 2017-05-24: 21:06:23 org.hibernate.type.BasicTypeRegistry.register(BasicTypeRegistry.java:146) :  Adding type registration date -> org.hibernate.type.DateType@7d7510
[DEBUG] 2017-05-24: 21:06:23 org.hibernate.type.BasicTypeRegistry.register(BasicTypeRegistry.java:146) :  Adding type registration java.sql.Date -> org.hibernate.type.DateType@7d7510
[DEBUG] 2017-05-24: 21:06:23 org.hibernate.type.BasicTypeRegistry.register(BasicTypeRegistry.java:146) :  Adding type registration time -> org.hibernate.type.TimeType@152b44
[DEBUG] 2017-05-24: 21:06:23 org.hibernate.type.BasicTypeRegistry.register(BasicTypeRegistry.java:146) :  Adding type registration java.sql.Time -> org.hibernate.type.TimeType@152b44
[DEBUG] 2017-05-24: 21:06:23 org.hibernate.type.BasicTypeRegistry.register(BasicTypeRegistry.java:146) :  Adding type registration timestamp -> org.hibernate.type.TimestampType@55292
[DEBUG] 2017-05-24: 21:06:23 org.hibernate.type.BasicTypeRegistry.register(BasicTypeRegistry.java:146) :  Adding type registration java.sql.Timestamp -> org.hibernate.type.TimestampType@55292
[DEBUG] 2017-05-24: 21:06:23 org.hibernate.type.BasicTypeRegistry.register(BasicTypeRegistry.java:146) :  Adding type registration java.util.Date -> org.hibernate.type.TimestampType@55292
[DEBUG] 2017-05-24: 21:06:23 org.hibernate.type.BasicTypeRegistry.register(BasicTypeRegistry.java:146) :  Adding type registration dbtimestamp -> org.hibernate.type.DbTimestampType@16fe0bb
[DEBUG] 2017-05-24: 21:06:23 org.hibernate.type.BasicTypeRegistry.register(BasicTypeRegistry.java:146) :  Adding type registration calendar -> org.hibernate.type.CalendarType@1a5d13e
[DEBUG] 2017-05-24: 21:06:23 org.hibernate.type.BasicTypeRegistry.register(BasicTypeRegistry.java:146) :  Adding type registration java.util.Calendar -> org.hibernate.type.CalendarType@1a5d13e
[DEBUG] 2017-05-24: 21:06:23 org.hibernate.type.BasicTypeRegistry.register(BasicTypeRegistry.java:146) :  Adding type registration java.util.GregorianCalendar -> org.hibernate.type.CalendarType@1a5d13e
[DEBUG] 2017-05-24: 21:06:23 org.hibernate.type.BasicTypeRegistry.register(BasicTypeRegistry.java:146) :  Adding type registration calendar_date -> org.hibernate.type.CalendarDateType@19255ce
[DEBUG] 2017-05-24: 21:06:23 org.hibernate.type.BasicTypeRegistry.register(BasicTypeRegistry.java:146) :  Adding type registration locale -> org.hibernate.type.LocaleType@1a74414
[DEBUG] 2017-05-24: 21:06:23 org.hibernate.type.BasicTypeRegistry.register(BasicTypeRegistry.java:146) :  Adding type registration java.util.Locale -> org.hibernate.type.LocaleType@1a74414
[DEBUG] 2017-05-24: 21:06:23 org.hibernate.type.BasicTypeRegistry.register(BasicTypeRegistry.java:146) :  Adding type registration currency -> org.hibernate.type.CurrencyType@a64c19
[DEBUG] 2017-05-24: 21:06:23 org.hibernate.type.BasicTypeRegistry.register(BasicTypeRegistry.java:146) :  Adding type registration java.util.Currency -> org.hibernate.type.CurrencyType@a64c19
[DEBUG] 2017-05-24: 21:06:23 org.hibernate.type.BasicTypeRegistry.register(BasicTypeRegistry.java:146) :  Adding type registration timezone -> org.hibernate.type.TimeZoneType@f14d58
[DEBUG] 2017-05-24: 21:06:23 org.hibernate.type.BasicTypeRegistry.register(BasicTypeRegistry.java:146) :  Adding type registration java.util.TimeZone -> org.hibernate.type.TimeZoneType@f14d58
[DEBUG] 2017-05-24: 21:06:23 org.hibernate.type.BasicTypeRegistry.register(BasicTypeRegistry.java:146) :  Adding type registration class -> org.hibernate.type.ClassType@103e9d7
[DEBUG] 2017-05-24: 21:06:23 org.hibernate.type.BasicTypeRegistry.register(BasicTypeRegistry.java:146) :  Adding type registration java.lang.Class -> org.hibernate.type.ClassType@103e9d7
[DEBUG] 2017-05-24: 21:06:23 org.hibernate.type.BasicTypeRegistry.register(BasicTypeRegistry.java:146) :  Adding type registration uuid-binary -> org.hibernate.type.UUIDBinaryType@410c6e
[DEBUG] 2017-05-24: 21:06:23 org.hibernate.type.BasicTypeRegistry.register(BasicTypeRegistry.java:146) :  Adding type registration java.util.UUID -> org.hibernate.type.UUIDBinaryType@410c6e
[DEBUG] 2017-05-24: 21:06:23 org.hibernate.type.BasicTypeRegistry.register(BasicTypeRegistry.java:146) :  Adding type registration uuid-char -> org.hibernate.type.UUIDCharType@ffa6ea
[DEBUG] 2017-05-24: 21:06:23 org.hibernate.type.BasicTypeRegistry.register(BasicTypeRegistry.java:146) :  Adding type registration pg-uuid -> org.hibernate.type.PostgresUUIDType@4ac6da
[DEBUG] 2017-05-24: 21:06:23 org.hibernate.type.BasicTypeRegistry.register(BasicTypeRegistry.java:146) :  Adding type registration binary -> org.hibernate.type.BinaryType@10d9de
[DEBUG] 2017-05-24: 21:06:23 org.hibernate.type.BasicTypeRegistry.register(BasicTypeRegistry.java:146) :  Adding type registration byte[] -> org.hibernate.type.BinaryType@10d9de
[DEBUG] 2017-05-24: 21:06:23 org.hibernate.type.BasicTypeRegistry.register(BasicTypeRegistry.java:146) :  Adding type registration [B -> org.hibernate.type.BinaryType@10d9de
[DEBUG] 2017-05-24: 21:06:23 org.hibernate.type.BasicTypeRegistry.register(BasicTypeRegistry.java:146) :  Adding type registration wrapper-binary -> org.hibernate.type.WrapperBinaryType@14f1c27
[DEBUG] 2017-05-24: 21:06:23 org.hibernate.type.BasicTypeRegistry.register(BasicTypeRegistry.java:146) :  Adding type registration Byte[] -> org.hibernate.type.WrapperBinaryType@14f1c27
[DEBUG] 2017-05-24: 21:06:23 org.hibernate.type.BasicTypeRegistry.register(BasicTypeRegistry.java:146) :  Adding type registration [Ljava.lang.Byte; -> org.hibernate.type.WrapperBinaryType@14f1c27
[DEBUG] 2017-05-24: 21:06:23 org.hibernate.type.BasicTypeRegistry.register(BasicTypeRegistry.java:146) :  Adding type registration image -> org.hibernate.type.ImageType@cd0bda
[DEBUG] 2017-05-24: 21:06:23 org.hibernate.type.BasicTypeRegistry.register(BasicTypeRegistry.java:146) :  Adding type registration characters -> org.hibernate.type.CharArrayType@1bb2b9a
[DEBUG] 2017-05-24: 21:06:23 org.hibernate.type.BasicTypeRegistry.register(BasicTypeRegistry.java:146) :  Adding type registration char[] -> org.hibernate.type.CharArrayType@1bb2b9a
[DEBUG] 2017-05-24: 21:06:23 org.hibernate.type.BasicTypeRegistry.register(BasicTypeRegistry.java:146) :  Adding type registration [C -> org.hibernate.type.CharArrayType@1bb2b9a
[DEBUG] 2017-05-24: 21:06:23 org.hibernate.type.BasicTypeRegistry.register(BasicTypeRegistry.java:146) :  Adding type registration wrapper-characters -> org.hibernate.type.CharacterArrayType@1d19c5e
[DEBUG] 2017-05-24: 21:06:23 org.hibernate.type.BasicTypeRegistry.register(BasicTypeRegistry.java:146) :  Adding type registration [Ljava.lang.Character; -> org.hibernate.type.CharacterArrayType@1d19c5e
[DEBUG] 2017-05-24: 21:06:23 org.hibernate.type.BasicTypeRegistry.register(BasicTypeRegistry.java:146) :  Adding type registration Character[] -> org.hibernate.type.CharacterArrayType@1d19c5e
[DEBUG] 2017-05-24: 21:06:23 org.hibernate.type.BasicTypeRegistry.register(BasicTypeRegistry.java:146) :  Adding type registration text -> org.hibernate.type.TextType@1396f83
[DEBUG] 2017-05-24: 21:06:23 org.hibernate.type.BasicTypeRegistry.register(BasicTypeRegistry.java:146) :  Adding type registration ntext -> org.hibernate.type.NTextType@6819d0
[DEBUG] 2017-05-24: 21:06:23 org.hibernate.type.BasicTypeRegistry.register(BasicTypeRegistry.java:146) :  Adding type registration blob -> org.hibernate.type.BlobType@7d004a
[DEBUG] 2017-05-24: 21:06:23 org.hibernate.type.BasicTypeRegistry.register(BasicTypeRegistry.java:146) :  Adding type registration java.sql.Blob -> org.hibernate.type.BlobType@7d004a
[DEBUG] 2017-05-24: 21:06:23 org.hibernate.type.BasicTypeRegistry.register(BasicTypeRegistry.java:146) :  Adding type registration materialized_blob -> org.hibernate.type.MaterializedBlobType@57369f
[DEBUG] 2017-05-24: 21:06:23 org.hibernate.type.BasicTypeRegistry.register(BasicTypeRegistry.java:146) :  Adding type registration clob -> org.hibernate.type.ClobType@156157a
[DEBUG] 2017-05-24: 21:06:23 org.hibernate.type.BasicTypeRegistry.register(BasicTypeRegistry.java:146) :  Adding type registration java.sql.Clob -> org.hibernate.type.ClobType@156157a
[DEBUG] 2017-05-24: 21:06:23 org.hibernate.type.BasicTypeRegistry.register(BasicTypeRegistry.java:146) :  Adding type registration nclob -> org.hibernate.type.NClobType@e0386e
[DEBUG] 2017-05-24: 21:06:23 org.hibernate.type.BasicTypeRegistry.register(BasicTypeRegistry.java:146) :  Adding type registration java.sql.NClob -> org.hibernate.type.NClobType@e0386e
[DEBUG] 2017-05-24: 21:06:23 org.hibernate.type.BasicTypeRegistry.register(BasicTypeRegistry.java:146) :  Adding type registration materialized_clob -> org.hibernate.type.MaterializedClobType@e52921
[DEBUG] 2017-05-24: 21:06:23 org.hibernate.type.BasicTypeRegistry.register(BasicTypeRegistry.java:146) :  Adding type registration materialized_nclob -> org.hibernate.type.MaterializedNClobType@164720d
[DEBUG] 2017-05-24: 21:06:23 org.hibernate.type.BasicTypeRegistry.register(BasicTypeRegistry.java:146) :  Adding type registration serializable -> org.hibernate.type.SerializableType@3cfd14
[DEBUG] 2017-05-24: 21:06:23 org.hibernate.type.BasicTypeRegistry.register(BasicTypeRegistry.java:146) :  Adding type registration object -> org.hibernate.type.ObjectType@bf0d18
[DEBUG] 2017-05-24: 21:06:23 org.hibernate.type.BasicTypeRegistry.register(BasicTypeRegistry.java:146) :  Adding type registration java.lang.Object -> org.hibernate.type.ObjectType@bf0d18
[DEBUG] 2017-05-24: 21:06:23 org.hibernate.type.BasicTypeRegistry.register(BasicTypeRegistry.java:146) :  Adding type registration imm_date -> org.hibernate.type.AdaptedImmutableType@945143
[DEBUG] 2017-05-24: 21:06:23 org.hibernate.type.BasicTypeRegistry.register(BasicTypeRegistry.java:146) :  Adding type registration imm_time -> org.hibernate.type.AdaptedImmutableType@954204
[DEBUG] 2017-05-24: 21:06:23 org.hibernate.type.BasicTypeRegistry.register(BasicTypeRegistry.java:146) :  Adding type registration imm_timestamp -> org.hibernate.type.AdaptedImmutableType@b6e8fd
[DEBUG] 2017-05-24: 21:06:23 org.hibernate.type.BasicTypeRegistry.register(BasicTypeRegistry.java:146) :  Adding type registration imm_dbtimestamp -> org.hibernate.type.AdaptedImmutableType@131d32b
[DEBUG] 2017-05-24: 21:06:23 org.hibernate.type.BasicTypeRegistry.register(BasicTypeRegistry.java:146) :  Adding type registration imm_calendar -> org.hibernate.type.AdaptedImmutableType@1c19f47
[DEBUG] 2017-05-24: 21:06:23 org.hibernate.type.BasicTypeRegistry.register(BasicTypeRegistry.java:146) :  Adding type registration imm_calendar_date -> org.hibernate.type.AdaptedImmutableType@1747e99
[DEBUG] 2017-05-24: 21:06:23 org.hibernate.type.BasicTypeRegistry.register(BasicTypeRegistry.java:146) :  Adding type registration imm_binary -> org.hibernate.type.AdaptedImmutableType@9e8fca
[DEBUG] 2017-05-24: 21:06:23 org.hibernate.type.BasicTypeRegistry.register(BasicTypeRegistry.java:146) :  Adding type registration imm_serializable -> org.hibernate.type.AdaptedImmutableType@163afb9
[INFO] 2017-05-24: 21:06:23 org.hibernate.annotations.common.reflection.java.JavaReflectionManager.<clinit>(JavaReflectionManager.java:66) :  HCANN000001: Hibernate Commons Annotations {4.0.5.Final}
[INFO] 2017-05-24: 21:06:23 org.hibernate.Version.logVersion(Version.java:54) :  HHH000412: Hibernate Core {4.3.8.Final}
[INFO] 2017-05-24: 21:06:23 org.hibernate.cfg.Environment.<clinit>(Environment.java:239) :  HHH000206: hibernate.properties not found
[INFO] 2017-05-24: 21:06:23 org.hibernate.cfg.Environment.buildBytecodeProvider(Environment.java:346) :  HHH000021: Bytecode provider name : javassist
[DEBUG] 2017-05-24: 21:06:23 org.hibernate.id.factory.internal.DefaultIdentifierGeneratorFactory.register(DefaultIdentifierGeneratorFactory.java:93) :  Registering IdentifierGenerator strategy [uuid2] -> [org.hibernate.id.UUIDGenerator]
[DEBUG] 2017-05-24: 21:06:23 org.hibernate.id.factory.internal.DefaultIdentifierGeneratorFactory.register(DefaultIdentifierGeneratorFactory.java:93) :  Registering IdentifierGenerator strategy [guid] -> [org.hibernate.id.GUIDGenerator]
[DEBUG] 2017-05-24: 21:06:23 org.hibernate.id.factory.internal.DefaultIdentifierGeneratorFactory.register(DefaultIdentifierGeneratorFactory.java:93) :  Registering IdentifierGenerator strategy [uuid] -> [org.hibernate.id.UUIDHexGenerator]
[DEBUG] 2017-05-24: 21:06:23 org.hibernate.id.factory.internal.DefaultIdentifierGeneratorFactory.register(DefaultIdentifierGeneratorFactory.java:93) :  Registering IdentifierGenerator strategy [uuid.hex] -> [org.hibernate.id.UUIDHexGenerator]
[DEBUG] 2017-05-24: 21:06:23 org.hibernate.id.factory.internal.DefaultIdentifierGeneratorFactory.register(DefaultIdentifierGeneratorFactory.java:93) :  Registering IdentifierGenerator strategy [hilo] -> [org.hibernate.id.TableHiLoGenerator]
[DEBUG] 2017-05-24: 21:06:23 org.hibernate.id.factory.internal.DefaultIdentifierGeneratorFactory.register(DefaultIdentifierGeneratorFactory.java:93) :  Registering IdentifierGenerator strategy [assigned] -> [org.hibernate.id.Assigned]
[DEBUG] 2017-05-24: 21:06:23 org.hibernate.id.factory.internal.DefaultIdentifierGeneratorFactory.register(DefaultIdentifierGeneratorFactory.java:93) :  Registering IdentifierGenerator strategy [identity] -> [org.hibernate.id.IdentityGenerator]
[DEBUG] 2017-05-24: 21:06:23 org.hibernate.id.factory.internal.DefaultIdentifierGeneratorFactory.register(DefaultIdentifierGeneratorFactory.java:93) :  Registering IdentifierGenerator strategy [select] -> [org.hibernate.id.SelectGenerator]
[DEBUG] 2017-05-24: 21:06:23 org.hibernate.id.factory.internal.DefaultIdentifierGeneratorFactory.register(DefaultIdentifierGeneratorFactory.java:93) :  Registering IdentifierGenerator strategy [sequence] -> [org.hibernate.id.SequenceGenerator]
[DEBUG] 2017-05-24: 21:06:23 org.hibernate.id.factory.internal.DefaultIdentifierGeneratorFactory.register(DefaultIdentifierGeneratorFactory.java:93) :  Registering IdentifierGenerator strategy [seqhilo] -> [org.hibernate.id.SequenceHiLoGenerator]
[DEBUG] 2017-05-24: 21:06:23 org.hibernate.id.factory.internal.DefaultIdentifierGeneratorFactory.register(DefaultIdentifierGeneratorFactory.java:93) :  Registering IdentifierGenerator strategy [increment] -> [org.hibernate.id.IncrementGenerator]
[DEBUG] 2017-05-24: 21:06:23 org.hibernate.id.factory.internal.DefaultIdentifierGeneratorFactory.register(DefaultIdentifierGeneratorFactory.java:93) :  Registering IdentifierGenerator strategy [foreign] -> [org.hibernate.id.ForeignGenerator]
[DEBUG] 2017-05-24: 21:06:23 org.hibernate.id.factory.internal.DefaultIdentifierGeneratorFactory.register(DefaultIdentifierGeneratorFactory.java:93) :  Registering IdentifierGenerator strategy [sequence-identity] -> [org.hibernate.id.SequenceIdentityGenerator]
[DEBUG] 2017-05-24: 21:06:23 org.hibernate.id.factory.internal.DefaultIdentifierGeneratorFactory.register(DefaultIdentifierGeneratorFactory.java:93) :  Registering IdentifierGenerator strategy [enhanced-sequence] -> [org.hibernate.id.enhanced.SequenceStyleGenerator]
[DEBUG] 2017-05-24: 21:06:23 org.hibernate.id.factory.internal.DefaultIdentifierGeneratorFactory.register(DefaultIdentifierGeneratorFactory.java:93) :  Registering IdentifierGenerator strategy [enhanced-table] -> [org.hibernate.id.enhanced.TableGenerator]
[DEBUG] 2017-05-24: 21:06:23 org.hibernate.internal.util.xml.DTDEntityResolver.resolveEntity(DTDEntityResolver.java:69) :  Trying to resolve system-id [http://hibernate.sourceforge.net/hibernate-mapping-3.0.dtd]
[WARN] 2017-05-24: 21:06:23 org.hibernate.internal.util.xml.DTDEntityResolver.resolveEntity(DTDEntityResolver.java:75) :  HHH000223: Recognized obsolete hibernate namespace http://hibernate.sourceforge.net/. Use namespace http://www.hibernate.org/dtd/ instead. Refer to Hibernate 3.6 Migration Guide!
[DEBUG] 2017-05-24: 21:06:23 org.hibernate.internal.util.xml.DTDEntityResolver.resolveEntity(DTDEntityResolver.java:76) :  Attempting to resolve on classpath under org/hibernate/
[DEBUG] 2017-05-24: 21:06:23 org.hibernate.internal.util.xml.DTDEntityResolver.resolveOnClassPath(DTDEntityResolver.java:108) :  Located [http://hibernate.sourceforge.net/hibernate-mapping-3.0.dtd] in classpath
[DEBUG] 2017-05-24: 21:06:23 org.hibernate.integrator.internal.IntegratorServiceImpl.addIntegrator(IntegratorServiceImpl.java:63) :  Adding Integrator [org.hibernate.cfg.beanvalidation.BeanValidationIntegrator].
[DEBUG] 2017-05-24: 21:06:23 org.hibernate.integrator.internal.IntegratorServiceImpl.addIntegrator(IntegratorServiceImpl.java:63) :  Adding Integrator [org.hibernate.secure.spi.JaccIntegrator].
[DEBUG] 2017-05-24: 21:06:23 org.hibernate.integrator.internal.IntegratorServiceImpl.addIntegrator(IntegratorServiceImpl.java:63) :  Adding Integrator [org.hibernate.cache.internal.CollectionCacheInvalidator].
[DEBUG] 2017-05-24: 21:06:23 org.hibernate.boot.registry.selector.internal.StrategySelectorImpl.registerStrategyImplementor(StrategySelectorImpl.java:79) :  Registering named strategy selector [org.hibernate.dialect.Dialect] : [MySQL5] -> [org.hibernate.dialect.MySQL5Dialect] (replacing [org.hibernate.dialect.MySQL5Dialect])
[DEBUG] 2017-05-24: 21:06:23 org.hibernate.boot.registry.selector.internal.StrategySelectorImpl.registerStrategyImplementor(StrategySelectorImpl.java:79) :  Registering named strategy selector [org.hibernate.dialect.Dialect] : [MySQL5InnoDB] -> [org.hibernate.dialect.MySQL5InnoDBDialect] (replacing [org.hibernate.dialect.MySQL5InnoDBDialect])
[DEBUG] 2017-05-24: 21:06:23 org.hibernate.service.spi.ServiceBinding.setService(ServiceBinding.java:85) :  Overriding existing service binding [org.hibernate.secure.spi.JaccService]
[DEBUG] 2017-05-24: 21:06:23 org.hibernate.cfg.Configuration.buildSessionFactory(Configuration.java:1843) :  Preparing to build session factory with filters : {}
[DEBUG] 2017-05-24: 21:06:23 org.springframework.jdbc.datasource.DriverManagerDataSource.getConnectionFromDriver(DriverManagerDataSource.java:142) :  Creating new JDBC DriverManager Connection to [jdbc:mysql://localhost:3306/usermanager?characterEncoding=utf8&useSSL=true]
[DEBUG] 2017-05-24: 21:06:23 org.hibernate.engine.jdbc.internal.JdbcServicesImpl.configure(JdbcServicesImpl.java:128) :  Database ->
       name : MySQL
    version : 5.7.16
      major : 5
      minor : 7
[DEBUG] 2017-05-24: 21:06:23 org.hibernate.engine.jdbc.internal.JdbcServicesImpl.configure(JdbcServicesImpl.java:139) :  Driver ->
       name : MySQL Connector Java
    version : mysql-connector-java-5.1.38 ( Revision: fe541c166cec739c74cc727c5da96c1028b4834a )
      major : 5
      minor : 1
[DEBUG] 2017-05-24: 21:06:23 org.hibernate.engine.jdbc.internal.JdbcServicesImpl.configure(JdbcServicesImpl.java:150) :  JDBC version : 4.0
[DEBUG] 2017-05-24: 21:06:23 org.hibernate.engine.jdbc.cursor.internal.StandardRefCursorSupport.supportsRefCursors(StandardRefCursorSupport.java:187) :  Unexpected error trying to gauge level of JDBC REF_CURSOR support : null
[INFO] 2017-05-24: 21:06:23 org.hibernate.dialect.Dialect.<init>(Dialect.java:145) :  HHH000400: Using dialect: org.hibernate.dialect.MySQLDialect
[DEBUG] 2017-05-24: 21:06:24 org.hibernate.cfg.Configuration$MetadataSourceQueue.processHbmXmlQueue(Configuration.java:3805) :  Processing hbm.xml files
[DEBUG] 2017-05-24: 21:06:24 org.hibernate.cfg.HbmBinder.bindRootPersistentClassCommonValues(HbmBinder.java:355) :  Mapping class: com.ittx.usermanager.model.User -> user
[DEBUG] 2017-05-24: 21:06:24 org.hibernate.cfg.HbmBinder.bindProperty(HbmBinder.java:1374) :  Mapped property: id -> id
[DEBUG] 2017-05-24: 21:06:24 org.hibernate.cfg.HbmBinder.bindProperty(HbmBinder.java:1374) :  Mapped property: name -> name
[DEBUG] 2017-05-24: 21:06:24 org.hibernate.cfg.HbmBinder.bindProperty(HbmBinder.java:1374) :  Mapped property: age -> age
[DEBUG] 2017-05-24: 21:06:24 org.hibernate.cfg.HbmBinder.bindProperty(HbmBinder.java:1374) :  Mapped property: sex -> sex
[DEBUG] 2017-05-24: 21:06:24 org.hibernate.cfg.HbmBinder.bindProperty(HbmBinder.java:1374) :  Mapped property: headerUri -> headuri
[DEBUG] 2017-05-24: 21:06:24 org.hibernate.cfg.Configuration$MetadataSourceQueue.processAnnotatedClassesQueue(Configuration.java:3835) :  Process annotated classes
[DEBUG] 2017-05-24: 21:06:24 org.hibernate.cfg.Configuration.processFkSecondPassInOrder(Configuration.java:1484) :  Processing fk mappings (*ToOne and JoinedSubclass)
[DEBUG] 2017-05-24: 21:06:24 org.hibernate.cfg.Configuration.originalSecondPassCompile(Configuration.java:1689) :  Processing extends queue
[DEBUG] 2017-05-24: 21:06:24 org.hibernate.cfg.Configuration.processExtendsQueue(Configuration.java:1747) :  Processing extends queue
[DEBUG] 2017-05-24: 21:06:24 org.hibernate.cfg.Configuration.originalSecondPassCompile(Configuration.java:1692) :  Processing collection mappings
[DEBUG] 2017-05-24: 21:06:24 org.hibernate.cfg.Configuration.originalSecondPassCompile(Configuration.java:1702) :  Processing native query and ResultSetMapping mappings
[DEBUG] 2017-05-24: 21:06:24 org.hibernate.cfg.Configuration.originalSecondPassCompile(Configuration.java:1710) :  Processing association property references
[DEBUG] 2017-05-24: 21:06:24 org.hibernate.cfg.Configuration.originalSecondPassCompile(Configuration.java:1732) :  Creating tables' unique integer identifiers
[DEBUG] 2017-05-24: 21:06:24 org.hibernate.cfg.Configuration.originalSecondPassCompile(Configuration.java:1733) :  Processing foreign key constraints
[DEBUG] 2017-05-24: 21:06:24 org.hibernate.engine.transaction.jta.platform.internal.JtaPlatformInitiator.initiateService(JtaPlatformInitiator.java:59) :  No JtaPlatform was specified, checking resolver
[DEBUG] 2017-05-24: 21:06:24 org.hibernate.engine.transaction.jta.platform.internal.JtaPlatformResolverInitiator.initiateService(JtaPlatformResolverInitiator.java:50) :  No JtaPlatformResolver was specified, using default [org.hibernate.engine.transaction.jta.platform.internal.StandardJtaPlatformResolver]
[DEBUG] 2017-05-24: 21:06:24 org.hibernate.engine.transaction.jta.platform.internal.StandardJtaPlatformResolver.resolveJtaPlatform(StandardJtaPlatformResolver.java:118) :  Could not resolve JtaPlatform, using default [org.hibernate.engine.transaction.jta.platform.internal.NoJtaPlatform]
[DEBUG] 2017-05-24: 21:06:24 org.hibernate.cfg.SettingsFactory.buildSettings(SettingsFactory.java:122) :  Automatic flush during beforeCompletion(): disabled
[DEBUG] 2017-05-24: 21:06:24 org.hibernate.cfg.SettingsFactory.buildSettings(SettingsFactory.java:128) :  Automatic session close at end of transaction: disabled
[DEBUG] 2017-05-24: 21:06:24 org.hibernate.cfg.SettingsFactory.buildSettings(SettingsFactory.java:139) :  JDBC batch size: 15
[DEBUG] 2017-05-24: 21:06:24 org.hibernate.cfg.SettingsFactory.buildSettings(SettingsFactory.java:145) :  JDBC batch updates for versioned data: disabled
[DEBUG] 2017-05-24: 21:06:24 org.hibernate.cfg.SettingsFactory.buildSettings(SettingsFactory.java:155) :  Scrollable result sets: enabled
[DEBUG] 2017-05-24: 21:06:24 org.hibernate.cfg.SettingsFactory.buildSettings(SettingsFactory.java:161) :  Wrap result sets: disabled
[DEBUG] 2017-05-24: 21:06:24 org.hibernate.cfg.SettingsFactory.buildSettings(SettingsFactory.java:167) :  JDBC3 getGeneratedKeys(): enabled
[DEBUG] 2017-05-24: 21:06:24 org.hibernate.cfg.SettingsFactory.buildSettings(SettingsFactory.java:179) :  multi-tenancy strategy : NONE
[DEBUG] 2017-05-24: 21:06:24 org.hibernate.cfg.SettingsFactory.buildSettings(SettingsFactory.java:185) :  Connection release mode: auto
[INFO] 2017-05-24: 21:06:24 org.hibernate.engine.transaction.internal.TransactionFactoryInitiator.initiateService(TransactionFactoryInitiator.java:62) :  HHH000399: Using default transaction strategy (direct JDBC transactions)
[DEBUG] 2017-05-24: 21:06:24 org.hibernate.cfg.SettingsFactory.buildSettings(SettingsFactory.java:207) :  Using BatchFetchStyle : LEGACY
[DEBUG] 2017-05-24: 21:06:24 org.hibernate.cfg.SettingsFactory.buildSettings(SettingsFactory.java:226) :  Maximum outer join fetch depth: 2
[DEBUG] 2017-05-24: 21:06:24 org.hibernate.cfg.SettingsFactory.buildSettings(SettingsFactory.java:232) :  Default batch fetch size: 1
[DEBUG] 2017-05-24: 21:06:24 org.hibernate.cfg.SettingsFactory.buildSettings(SettingsFactory.java:238) :  Generate SQL with comments: disabled
[DEBUG] 2017-05-24: 21:06:24 org.hibernate.cfg.SettingsFactory.buildSettings(SettingsFactory.java:244) :  Order SQL updates by primary key: disabled
[DEBUG] 2017-05-24: 21:06:24 org.hibernate.cfg.SettingsFactory.buildSettings(SettingsFactory.java:250) :  Order SQL inserts for batching: disabled
[DEBUG] 2017-05-24: 21:06:24 org.hibernate.cfg.SettingsFactory.buildSettings(SettingsFactory.java:258) :  Default null ordering: none
[DEBUG] 2017-05-24: 21:06:24 org.hibernate.cfg.SettingsFactory.createQueryTranslatorFactory(SettingsFactory.java:501) :  Query translator: org.hibernate.hql.internal.ast.ASTQueryTranslatorFactory
[INFO] 2017-05-24: 21:06:24 org.hibernate.hql.internal.ast.ASTQueryTranslatorFactory.<init>(ASTQueryTranslatorFactory.java:47) :  HHH000397: Using ASTQueryTranslatorFactory
[DEBUG] 2017-05-24: 21:06:24 org.hibernate.cfg.SettingsFactory.buildSettings(SettingsFactory.java:268) :  Query language substitutions: {}
[DEBUG] 2017-05-24: 21:06:24 org.hibernate.cfg.SettingsFactory.buildSettings(SettingsFactory.java:274) :  JPA-QL strict compliance: disabled
[DEBUG] 2017-05-24: 21:06:24 org.hibernate.cfg.SettingsFactory.buildSettings(SettingsFactory.java:282) :  Second-level cache: enabled
[DEBUG] 2017-05-24: 21:06:24 org.hibernate.cfg.SettingsFactory.buildSettings(SettingsFactory.java:288) :  Query cache: disabled
[DEBUG] 2017-05-24: 21:06:24 org.hibernate.cache.internal.RegionFactoryInitiator.initiateService(RegionFactoryInitiator.java:105) :  Cache region factory : org.hibernate.cache.internal.NoCachingRegionFactory
[DEBUG] 2017-05-24: 21:06:24 org.hibernate.cfg.SettingsFactory.buildSettings(SettingsFactory.java:301) :  Optimize cache for minimal puts: disabled
[DEBUG] 2017-05-24: 21:06:24 org.hibernate.cfg.SettingsFactory.buildSettings(SettingsFactory.java:316) :  Structured second-level cache entries: disabled
[DEBUG] 2017-05-24: 21:06:24 org.hibernate.cfg.SettingsFactory.buildSettings(SettingsFactory.java:326) :  Second-level cache direct-reference entries: disabled
[DEBUG] 2017-05-24: 21:06:24 org.hibernate.cfg.SettingsFactory.buildSettings(SettingsFactory.java:332) :  Automatic eviction of collection cache: disabled
[DEBUG] 2017-05-24: 21:06:24 org.hibernate.cfg.SettingsFactory.buildSettings(SettingsFactory.java:340) :  Statistics: disabled
[DEBUG] 2017-05-24: 21:06:24 org.hibernate.cfg.SettingsFactory.buildSettings(SettingsFactory.java:346) :  Deleted entity synthetic identifier rollback: disabled
[DEBUG] 2017-05-24: 21:06:24 org.hibernate.cfg.SettingsFactory.buildSettings(SettingsFactory.java:373) :  Default entity-mode: pojo
[DEBUG] 2017-05-24: 21:06:24 org.hibernate.cfg.SettingsFactory.buildSettings(SettingsFactory.java:379) :  Named query checking : enabled
[DEBUG] 2017-05-24: 21:06:24 org.hibernate.cfg.SettingsFactory.buildSettings(SettingsFactory.java:385) :  Check Nullability in Core (should be disabled when Bean Validation is on): enabled
[DEBUG] 2017-05-24: 21:06:24 org.hibernate.cfg.SettingsFactory.buildSettings(SettingsFactory.java:403) :  Allow initialization of lazy state outside session : : disabled
[DEBUG] 2017-05-24: 21:06:24 org.hibernate.cfg.SettingsFactory.buildSettings(SettingsFactory.java:413) :  JTA Track by Thread: enabled
[DEBUG] 2017-05-24: 21:06:24 org.hibernate.internal.SessionFactoryImpl.<init>(SessionFactoryImpl.java:229) :  Building session factory
[DEBUG] 2017-05-24: 21:06:24 org.hibernate.internal.SessionFactoryImpl.<init>(SessionFactoryImpl.java:285) :  Session factory constructed with filter configurations : {}
[DEBUG] 2017-05-24: 21:06:24 org.hibernate.internal.SessionFactoryImpl.<init>(SessionFactoryImpl.java:286) :  Instantiating session factory with properties: {java.runtime.name=Java(TM) SE Runtime Environment, sun.boot.library.path=D:\Java\jdk1.8.0_11\jre\bin, java.vm.version=25.11-b03, java.vm.vendor=Oracle Corporation, maven.multiModuleProjectDirectory=D:\projects\workspace_mavens\ssh\ssh-usermanager_annotaion, java.vendor.url=http://java.oracle.com/, path.separator=;, guice.disable.misplaced.annotation.check=true, java.vm.name=Java HotSpot(TM) Client VM, file.encoding.pkg=sun.io, user.script=, user.country=CN, sun.java.launcher=SUN_STANDARD, sun.os.patch.level=Service Pack 1, java.vm.specification.name=Java Virtual Machine Specification, user.dir=D:\projects\workspace_mavens\ssh\ssh-usermanager_annotaion, java.runtime.version=1.8.0_11-b12, java.awt.graphicsenv=sun.awt.Win32GraphicsEnvironment, hibernate.current_session_context_class=org.springframework.orm.hibernate4.SpringSessionContext, java.endorsed.dirs=D:\Java\jdk1.8.0_11\jre\lib\endorsed, os.arch=x86, java.io.tmpdir=C:\Users\ADMINI~1\AppData\Local\Temp\, line.separator=
, java.vm.specification.vendor=Oracle Corporation, user.variant=, os.name=Windows 7, classworlds.conf=D:\projects\workspace_mavens\.metadata\.plugins\org.eclipse.m2e.launching\launches\m2conf6847136271574955004.tmp, sun.jnu.encoding=GBK, java.library.path=D:\Java\jdk1.8.0_11\bin;C:\Windows\Sun\Java\bin;C:\Windows\system32;C:\Windows;D:/Java/jre8/bin/client;D:/Java/jre8/bin;D:/Java/jre8/lib/i386;C:\Program Files\Common Files\NetSarang;d:\Program Files\ImageMagick-6.9.2-Q16;C:\Windows\system32;C:\Windows;C:\Windows\System32\Wbem;C:\Windows\System32\WindowsPowerShell\v1.0\;D:\Java\jdk1.8.0_11\bin;D:\Java\jdk1.8.0_11\jre\bin;D:\Program Files\TortoiseGit\bin;D:\Program Files\Android\Android Studio\gradle\gradle-2.14.1\bin;D:\android-sdk-windows\platform-tools;D:\mysql\mysql-5.7.16-win32\bin;D:\maven\apache-maven-3.3.9\bin;C:\Program Files\nodejs\;d:\Program Files\SSH Communications Security\SSH Secure Shell;C:\Users\Administrator\AppData\Roaming\npm;D:\Program Files\eclipse-jee-neon-1a-win32\eclipse;;., hibernate.connection.datasource=org.springframework.jdbc.datasource.DriverManagerDataSource@14a95bc, java.specification.name=Java Platform API Specification, java.class.version=52.0, sun.management.compiler=HotSpot Client Compiler, os.version=6.1, user.home=C:\Users\Administrator, user.timezone=Asia/Shanghai, java.awt.printerjob=sun.awt.windows.WPrinterJob, java.specification.version=1.8, file.encoding=UTF-8, hibernate.format_sql=true, user.name=Administrator, java.class.path=D:\maven\apache-maven-3.3.9\boot\plexus-classworlds-2.5.2.jar, hibernate.bytecode.use_reflection_optimizer=false, hibernate.show_sql=true, hibernate.classLoader.application=WebAppClassLoader=UserManager@9ef573, java.vm.specification.version=1.8, sun.arch.data.model=32, java.home=D:\Java\jdk1.8.0_11\jre, sun.java.command=org.codehaus.plexus.classworlds.launcher.Launcher -B package, hibernate.dialect=org.hibernate.dialect.MySQLDialect, java.specification.vendor=Oracle Corporation, user.language=zh, awt.toolkit=sun.awt.windows.WToolkit, java.vm.info=mixed mode, sharing, java.version=1.8.0_11, java.ext.dirs=D:\Java\jdk1.8.0_11\jre\lib\ext;C:\Windows\Sun\Java\lib\ext, sun.boot.class.path=D:\Java\jdk1.8.0_11\jre\lib\resources.jar;D:\Java\jdk1.8.0_11\jre\lib\rt.jar;D:\Java\jdk1.8.0_11\jre\lib\sunrsasign.jar;D:\Java\jdk1.8.0_11\jre\lib\jsse.jar;D:\Java\jdk1.8.0_11\jre\lib\jce.jar;D:\Java\jdk1.8.0_11\jre\lib\charsets.jar;D:\Java\jdk1.8.0_11\jre\lib\jfr.jar;D:\Java\jdk1.8.0_11\jre\classes, java.vendor=Oracle Corporation, maven.home=D:\maven\apache-maven-3.3.9, file.separator=\, java.vendor.url.bug=http://bugreport.sun.com/bugreport/, sun.cpu.endian=little, sun.io.unicode.encoding=UnicodeLittle, sun.desktop=windows, sun.cpu.isalist=pentium_pro+mmx pentium_pro pentium+mmx pentium i486 i386 i86}
[DEBUG] 2017-05-24: 21:06:24 org.hibernate.secure.spi.JaccIntegrator.doIntegration(JaccIntegrator.java:90) :  Skipping JACC integration as it was not enabled
[DEBUG] 2017-05-24: 21:06:24 org.hibernate.id.factory.internal.DefaultIdentifierGeneratorFactory.setDialect(DefaultIdentifierGeneratorFactory.java:107) :  Setting dialect [org.hibernate.dialect.MySQLDialect]
[DEBUG] 2017-05-24: 21:06:24 org.hibernate.persister.entity.AbstractEntityPersister.logStaticSQL(AbstractEntityPersister.java:3676) :  Static SQL for entity: com.ittx.usermanager.model.User
[DEBUG] 2017-05-24: 21:06:24 org.hibernate.persister.entity.AbstractEntityPersister.logStaticSQL(AbstractEntityPersister.java:3681) :   Version select: select id from user where id =?
[DEBUG] 2017-05-24: 21:06:24 org.hibernate.persister.entity.AbstractEntityPersister.logStaticSQL(AbstractEntityPersister.java:3684) :   Snapshot select: select user_.id, user_.name as name2_0_, user_.age as age3_0_, user_.sex as sex4_0_, user_.headuri as headuri5_0_ from user user_ where user_.id=?
[DEBUG] 2017-05-24: 21:06:24 org.hibernate.persister.entity.AbstractEntityPersister.logStaticSQL(AbstractEntityPersister.java:3687) :   Insert 0: insert into user (name, age, sex, headuri, id) values (?, ?, ?, ?, ?)
[DEBUG] 2017-05-24: 21:06:24 org.hibernate.persister.entity.AbstractEntityPersister.logStaticSQL(AbstractEntityPersister.java:3688) :   Update 0: update user set name=?, age=?, sex=?, headuri=? where id=?
[DEBUG] 2017-05-24: 21:06:24 org.hibernate.persister.entity.AbstractEntityPersister.logStaticSQL(AbstractEntityPersister.java:3689) :   Delete 0: delete from user where id=?
[DEBUG] 2017-05-24: 21:06:24 org.hibernate.persister.entity.AbstractEntityPersister.logStaticSQL(AbstractEntityPersister.java:3692) :   Identity insert: insert into user (name, age, sex, headuri) values (?, ?, ?, ?)
[DEBUG] 2017-05-24: 21:06:24 org.hibernate.loader.plan.build.internal.spaces.QuerySpacesImpl.registerQuerySpace(QuerySpacesImpl.java:192) :  Adding QuerySpace : uid = <gen:0> -> org.hibernate.loader.plan.build.internal.spaces.EntityQuerySpaceImpl@17842bd]
[DEBUG] 2017-05-24: 21:06:24 org.hibernate.persister.walking.spi.MetamodelGraphWalker.visitAttributeDefinition(MetamodelGraphWalker.java:154) :  Visiting attribute path : name
[DEBUG] 2017-05-24: 21:06:24 org.hibernate.persister.walking.spi.MetamodelGraphWalker.visitAttributeDefinition(MetamodelGraphWalker.java:154) :  Visiting attribute path : age
[DEBUG] 2017-05-24: 21:06:24 org.hibernate.persister.walking.spi.MetamodelGraphWalker.visitAttributeDefinition(MetamodelGraphWalker.java:154) :  Visiting attribute path : sex
[DEBUG] 2017-05-24: 21:06:24 org.hibernate.persister.walking.spi.MetamodelGraphWalker.visitAttributeDefinition(MetamodelGraphWalker.java:154) :  Visiting attribute path : headerUri
[DEBUG] 2017-05-24: 21:06:24 org.hibernate.loader.plan.build.internal.FetchStyleLoadPlanBuildingAssociationVisitationStrategy.buildLoadPlan(FetchStyleLoadPlanBuildingAssociationVisitationStrategy.java:94) :  Building LoadPlan...
[DEBUG] 2017-05-24: 21:06:24 org.hibernate.loader.plan.exec.internal.LoadQueryJoinAndFetchProcessor.processQuerySpaceJoins(LoadQueryJoinAndFetchProcessor.java:112) :  processing queryspace <gen:0>
[DEBUG] 2017-05-24: 21:06:24 org.hibernate.loader.plan.build.spi.LoadPlanTreePrinter.logTree(LoadPlanTreePrinter.java:72) :  LoadPlan(entity=com.ittx.usermanager.model.User)
    - Returns
       - EntityReturnImpl(entity=com.ittx.usermanager.model.User, querySpaceUid=<gen:0>, path=com.ittx.usermanager.model.User)
    - QuerySpaces
       - EntityQuerySpaceImpl(uid=<gen:0>, entity=com.ittx.usermanager.model.User)
          - SQL table alias mapping - user0_
          - alias suffix - 0_
          - suffixed key columns - {id1_0_0_}

[DEBUG] 2017-05-24: 21:06:24 org.hibernate.loader.entity.plan.EntityLoader.<init>(EntityLoader.java:146) :  Static select for entity com.ittx.usermanager.model.User [NONE]: select user0_.id as id1_0_0_, user0_.name as name2_0_0_, user0_.age as age3_0_0_, user0_.sex as sex4_0_0_, user0_.headuri as headuri5_0_0_ from user user0_ where user0_.id=?
[DEBUG] 2017-05-24: 21:06:24 org.hibernate.loader.plan.build.internal.spaces.QuerySpacesImpl.registerQuerySpace(QuerySpacesImpl.java:192) :  Adding QuerySpace : uid = <gen:0> -> org.hibernate.loader.plan.build.internal.spaces.EntityQuerySpaceImpl@1f486bf]
[DEBUG] 2017-05-24: 21:06:24 org.hibernate.persister.walking.spi.MetamodelGraphWalker.visitAttributeDefinition(MetamodelGraphWalker.java:154) :  Visiting attribute path : name
[DEBUG] 2017-05-24: 21:06:24 org.hibernate.persister.walking.spi.MetamodelGraphWalker.visitAttributeDefinition(MetamodelGraphWalker.java:154) :  Visiting attribute path : age
[DEBUG] 2017-05-24: 21:06:24 org.hibernate.persister.walking.spi.MetamodelGraphWalker.visitAttributeDefinition(MetamodelGraphWalker.java:154) :  Visiting attribute path : sex
[DEBUG] 2017-05-24: 21:06:24 org.hibernate.persister.walking.spi.MetamodelGraphWalker.visitAttributeDefinition(MetamodelGraphWalker.java:154) :  Visiting attribute path : headerUri
[DEBUG] 2017-05-24: 21:06:24 org.hibernate.loader.plan.build.internal.FetchStyleLoadPlanBuildingAssociationVisitationStrategy.buildLoadPlan(FetchStyleLoadPlanBuildingAssociationVisitationStrategy.java:94) :  Building LoadPlan...
[DEBUG] 2017-05-24: 21:06:24 org.hibernate.loader.plan.exec.internal.LoadQueryJoinAndFetchProcessor.processQuerySpaceJoins(LoadQueryJoinAndFetchProcessor.java:112) :  processing queryspace <gen:0>
[DEBUG] 2017-05-24: 21:06:24 org.hibernate.loader.plan.build.spi.LoadPlanTreePrinter.logTree(LoadPlanTreePrinter.java:72) :  LoadPlan(entity=com.ittx.usermanager.model.User)
    - Returns
       - EntityReturnImpl(entity=com.ittx.usermanager.model.User, querySpaceUid=<gen:0>, path=com.ittx.usermanager.model.User)
    - QuerySpaces
       - EntityQuerySpaceImpl(uid=<gen:0>, entity=com.ittx.usermanager.model.User)
          - SQL table alias mapping - user0_
          - alias suffix - 0_
          - suffixed key columns - {id1_0_0_}

[DEBUG] 2017-05-24: 21:06:24 org.hibernate.loader.entity.plan.EntityLoader.<init>(EntityLoader.java:146) :  Static select for entity com.ittx.usermanager.model.User [READ]: select user0_.id as id1_0_0_, user0_.name as name2_0_0_, user0_.age as age3_0_0_, user0_.sex as sex4_0_0_, user0_.headuri as headuri5_0_0_ from user user0_ where user0_.id=?
[DEBUG] 2017-05-24: 21:06:24 org.hibernate.loader.plan.build.internal.spaces.QuerySpacesImpl.registerQuerySpace(QuerySpacesImpl.java:192) :  Adding QuerySpace : uid = <gen:0> -> org.hibernate.loader.plan.build.internal.spaces.EntityQuerySpaceImpl@11a61de]
[DEBUG] 2017-05-24: 21:06:24 org.hibernate.persister.walking.spi.MetamodelGraphWalker.visitAttributeDefinition(MetamodelGraphWalker.java:154) :  Visiting attribute path : name
[DEBUG] 2017-05-24: 21:06:24 org.hibernate.persister.walking.spi.MetamodelGraphWalker.visitAttributeDefinition(MetamodelGraphWalker.java:154) :  Visiting attribute path : age
[DEBUG] 2017-05-24: 21:06:24 org.hibernate.persister.walking.spi.MetamodelGraphWalker.visitAttributeDefinition(MetamodelGraphWalker.java:154) :  Visiting attribute path : sex
[DEBUG] 2017-05-24: 21:06:24 org.hibernate.persister.walking.spi.MetamodelGraphWalker.visitAttributeDefinition(MetamodelGraphWalker.java:154) :  Visiting attribute path : headerUri
[DEBUG] 2017-05-24: 21:06:24 org.hibernate.loader.plan.build.internal.FetchStyleLoadPlanBuildingAssociationVisitationStrategy.buildLoadPlan(FetchStyleLoadPlanBuildingAssociationVisitationStrategy.java:94) :  Building LoadPlan...
[DEBUG] 2017-05-24: 21:06:24 org.hibernate.loader.plan.exec.internal.LoadQueryJoinAndFetchProcessor.processQuerySpaceJoins(LoadQueryJoinAndFetchProcessor.java:112) :  processing queryspace <gen:0>
[DEBUG] 2017-05-24: 21:06:24 org.hibernate.loader.plan.build.spi.LoadPlanTreePrinter.logTree(LoadPlanTreePrinter.java:72) :  LoadPlan(entity=com.ittx.usermanager.model.User)
    - Returns
       - EntityReturnImpl(entity=com.ittx.usermanager.model.User, querySpaceUid=<gen:0>, path=com.ittx.usermanager.model.User)
    - QuerySpaces
       - EntityQuerySpaceImpl(uid=<gen:0>, entity=com.ittx.usermanager.model.User)
          - SQL table alias mapping - user0_
          - alias suffix - 0_
          - suffixed key columns - {id1_0_0_}

[DEBUG] 2017-05-24: 21:06:24 org.hibernate.loader.entity.plan.EntityLoader.<init>(EntityLoader.java:146) :  Static select for entity com.ittx.usermanager.model.User [UPGRADE]: select user0_.id as id1_0_0_, user0_.name as name2_0_0_, user0_.age as age3_0_0_, user0_.sex as sex4_0_0_, user0_.headuri as headuri5_0_0_ from user user0_ where user0_.id=? for update
[DEBUG] 2017-05-24: 21:06:24 org.hibernate.loader.plan.build.internal.spaces.QuerySpacesImpl.registerQuerySpace(QuerySpacesImpl.java:192) :  Adding QuerySpace : uid = <gen:0> -> org.hibernate.loader.plan.build.internal.spaces.EntityQuerySpaceImpl@15a0186]
[DEBUG] 2017-05-24: 21:06:24 org.hibernate.persister.walking.spi.MetamodelGraphWalker.visitAttributeDefinition(MetamodelGraphWalker.java:154) :  Visiting attribute path : name
[DEBUG] 2017-05-24: 21:06:24 org.hibernate.persister.walking.spi.MetamodelGraphWalker.visitAttributeDefinition(MetamodelGraphWalker.java:154) :  Visiting attribute path : age
[DEBUG] 2017-05-24: 21:06:24 org.hibernate.persister.walking.spi.MetamodelGraphWalker.visitAttributeDefinition(MetamodelGraphWalker.java:154) :  Visiting attribute path : sex
[DEBUG] 2017-05-24: 21:06:24 org.hibernate.persister.walking.spi.MetamodelGraphWalker.visitAttributeDefinition(MetamodelGraphWalker.java:154) :  Visiting attribute path : headerUri
[DEBUG] 2017-05-24: 21:06:24 org.hibernate.loader.plan.build.internal.FetchStyleLoadPlanBuildingAssociationVisitationStrategy.buildLoadPlan(FetchStyleLoadPlanBuildingAssociationVisitationStrategy.java:94) :  Building LoadPlan...
[DEBUG] 2017-05-24: 21:06:24 org.hibernate.loader.plan.exec.internal.LoadQueryJoinAndFetchProcessor.processQuerySpaceJoins(LoadQueryJoinAndFetchProcessor.java:112) :  processing queryspace <gen:0>
[DEBUG] 2017-05-24: 21:06:24 org.hibernate.loader.plan.build.spi.LoadPlanTreePrinter.logTree(LoadPlanTreePrinter.java:72) :  LoadPlan(entity=com.ittx.usermanager.model.User)
    - Returns
       - EntityReturnImpl(entity=com.ittx.usermanager.model.User, querySpaceUid=<gen:0>, path=com.ittx.usermanager.model.User)
    - QuerySpaces
       - EntityQuerySpaceImpl(uid=<gen:0>, entity=com.ittx.usermanager.model.User)
          - SQL table alias mapping - user0_
          - alias suffix - 0_
          - suffixed key columns - {id1_0_0_}

[DEBUG] 2017-05-24: 21:06:24 org.hibernate.loader.entity.plan.EntityLoader.<init>(EntityLoader.java:146) :  Static select for entity com.ittx.usermanager.model.User [UPGRADE_NOWAIT]: select user0_.id as id1_0_0_, user0_.name as name2_0_0_, user0_.age as age3_0_0_, user0_.sex as sex4_0_0_, user0_.headuri as headuri5_0_0_ from user user0_ where user0_.id=? for update
[DEBUG] 2017-05-24: 21:06:24 org.hibernate.loader.plan.build.internal.spaces.QuerySpacesImpl.registerQuerySpace(QuerySpacesImpl.java:192) :  Adding QuerySpace : uid = <gen:0> -> org.hibernate.loader.plan.build.internal.spaces.EntityQuerySpaceImpl@55d9c5]
[DEBUG] 2017-05-24: 21:06:24 org.hibernate.persister.walking.spi.MetamodelGraphWalker.visitAttributeDefinition(MetamodelGraphWalker.java:154) :  Visiting attribute path : name
[DEBUG] 2017-05-24: 21:06:24 org.hibernate.persister.walking.spi.MetamodelGraphWalker.visitAttributeDefinition(MetamodelGraphWalker.java:154) :  Visiting attribute path : age
[DEBUG] 2017-05-24: 21:06:24 org.hibernate.persister.walking.spi.MetamodelGraphWalker.visitAttributeDefinition(MetamodelGraphWalker.java:154) :  Visiting attribute path : sex
[DEBUG] 2017-05-24: 21:06:24 org.hibernate.persister.walking.spi.MetamodelGraphWalker.visitAttributeDefinition(MetamodelGraphWalker.java:154) :  Visiting attribute path : headerUri
[DEBUG] 2017-05-24: 21:06:24 org.hibernate.loader.plan.build.internal.FetchStyleLoadPlanBuildingAssociationVisitationStrategy.buildLoadPlan(FetchStyleLoadPlanBuildingAssociationVisitationStrategy.java:94) :  Building LoadPlan...
[DEBUG] 2017-05-24: 21:06:24 org.hibernate.loader.plan.exec.internal.LoadQueryJoinAndFetchProcessor.processQuerySpaceJoins(LoadQueryJoinAndFetchProcessor.java:112) :  processing queryspace <gen:0>
[DEBUG] 2017-05-24: 21:06:24 org.hibernate.loader.plan.build.spi.LoadPlanTreePrinter.logTree(LoadPlanTreePrinter.java:72) :  LoadPlan(entity=com.ittx.usermanager.model.User)
    - Returns
       - EntityReturnImpl(entity=com.ittx.usermanager.model.User, querySpaceUid=<gen:0>, path=com.ittx.usermanager.model.User)
    - QuerySpaces
       - EntityQuerySpaceImpl(uid=<gen:0>, entity=com.ittx.usermanager.model.User)
          - SQL table alias mapping - user0_
          - alias suffix - 0_
          - suffixed key columns - {id1_0_0_}

[DEBUG] 2017-05-24: 21:06:24 org.hibernate.loader.entity.plan.EntityLoader.<init>(EntityLoader.java:146) :  Static select for entity com.ittx.usermanager.model.User [UPGRADE_SKIPLOCKED]: select user0_.id as id1_0_0_, user0_.name as name2_0_0_, user0_.age as age3_0_0_, user0_.sex as sex4_0_0_, user0_.headuri as headuri5_0_0_ from user user0_ where user0_.id=? for update
[DEBUG] 2017-05-24: 21:06:24 org.hibernate.loader.plan.build.internal.spaces.QuerySpacesImpl.registerQuerySpace(QuerySpacesImpl.java:192) :  Adding QuerySpace : uid = <gen:0> -> org.hibernate.loader.plan.build.internal.spaces.EntityQuerySpaceImpl@63fe4e]
[DEBUG] 2017-05-24: 21:06:24 org.hibernate.persister.walking.spi.MetamodelGraphWalker.visitAttributeDefinition(MetamodelGraphWalker.java:154) :  Visiting attribute path : name
[DEBUG] 2017-05-24: 21:06:24 org.hibernate.persister.walking.spi.MetamodelGraphWalker.visitAttributeDefinition(MetamodelGraphWalker.java:154) :  Visiting attribute path : age
[DEBUG] 2017-05-24: 21:06:24 org.hibernate.persister.walking.spi.MetamodelGraphWalker.visitAttributeDefinition(MetamodelGraphWalker.java:154) :  Visiting attribute path : sex
[DEBUG] 2017-05-24: 21:06:24 org.hibernate.persister.walking.spi.MetamodelGraphWalker.visitAttributeDefinition(MetamodelGraphWalker.java:154) :  Visiting attribute path : headerUri
[DEBUG] 2017-05-24: 21:06:24 org.hibernate.loader.plan.build.internal.FetchStyleLoadPlanBuildingAssociationVisitationStrategy.buildLoadPlan(FetchStyleLoadPlanBuildingAssociationVisitationStrategy.java:94) :  Building LoadPlan...
[DEBUG] 2017-05-24: 21:06:24 org.hibernate.loader.plan.exec.internal.LoadQueryJoinAndFetchProcessor.processQuerySpaceJoins(LoadQueryJoinAndFetchProcessor.java:112) :  processing queryspace <gen:0>
[DEBUG] 2017-05-24: 21:06:24 org.hibernate.loader.plan.build.spi.LoadPlanTreePrinter.logTree(LoadPlanTreePrinter.java:72) :  LoadPlan(entity=com.ittx.usermanager.model.User)
    - Returns
       - EntityReturnImpl(entity=com.ittx.usermanager.model.User, querySpaceUid=<gen:0>, path=com.ittx.usermanager.model.User)
    - QuerySpaces
       - EntityQuerySpaceImpl(uid=<gen:0>, entity=com.ittx.usermanager.model.User)
          - SQL table alias mapping - user0_
          - alias suffix - 0_
          - suffixed key columns - {id1_0_0_}

[DEBUG] 2017-05-24: 21:06:24 org.hibernate.loader.entity.plan.EntityLoader.<init>(EntityLoader.java:146) :  Static select for entity com.ittx.usermanager.model.User [FORCE]: select user0_.id as id1_0_0_, user0_.name as name2_0_0_, user0_.age as age3_0_0_, user0_.sex as sex4_0_0_, user0_.headuri as headuri5_0_0_ from user user0_ where user0_.id=? for update
[DEBUG] 2017-05-24: 21:06:24 org.hibernate.loader.plan.build.internal.spaces.QuerySpacesImpl.registerQuerySpace(QuerySpacesImpl.java:192) :  Adding QuerySpace : uid = <gen:0> -> org.hibernate.loader.plan.build.internal.spaces.EntityQuerySpaceImpl@5fa23d]
[DEBUG] 2017-05-24: 21:06:24 org.hibernate.persister.walking.spi.MetamodelGraphWalker.visitAttributeDefinition(MetamodelGraphWalker.java:154) :  Visiting attribute path : name
[DEBUG] 2017-05-24: 21:06:24 org.hibernate.persister.walking.spi.MetamodelGraphWalker.visitAttributeDefinition(MetamodelGraphWalker.java:154) :  Visiting attribute path : age
[DEBUG] 2017-05-24: 21:06:24 org.hibernate.persister.walking.spi.MetamodelGraphWalker.visitAttributeDefinition(MetamodelGraphWalker.java:154) :  Visiting attribute path : sex
[DEBUG] 2017-05-24: 21:06:24 org.hibernate.persister.walking.spi.MetamodelGraphWalker.visitAttributeDefinition(MetamodelGraphWalker.java:154) :  Visiting attribute path : headerUri
[DEBUG] 2017-05-24: 21:06:24 org.hibernate.loader.plan.build.internal.FetchStyleLoadPlanBuildingAssociationVisitationStrategy.buildLoadPlan(FetchStyleLoadPlanBuildingAssociationVisitationStrategy.java:94) :  Building LoadPlan...
[DEBUG] 2017-05-24: 21:06:24 org.hibernate.loader.plan.exec.internal.LoadQueryJoinAndFetchProcessor.processQuerySpaceJoins(LoadQueryJoinAndFetchProcessor.java:112) :  processing queryspace <gen:0>
[DEBUG] 2017-05-24: 21:06:24 org.hibernate.loader.plan.build.spi.LoadPlanTreePrinter.logTree(LoadPlanTreePrinter.java:72) :  LoadPlan(entity=com.ittx.usermanager.model.User)
    - Returns
       - EntityReturnImpl(entity=com.ittx.usermanager.model.User, querySpaceUid=<gen:0>, path=com.ittx.usermanager.model.User)
    - QuerySpaces
       - EntityQuerySpaceImpl(uid=<gen:0>, entity=com.ittx.usermanager.model.User)
          - SQL table alias mapping - user0_
          - alias suffix - 0_
          - suffixed key columns - {id1_0_0_}

[DEBUG] 2017-05-24: 21:06:24 org.hibernate.loader.entity.plan.EntityLoader.<init>(EntityLoader.java:146) :  Static select for entity com.ittx.usermanager.model.User [PESSIMISTIC_READ]: select user0_.id as id1_0_0_, user0_.name as name2_0_0_, user0_.age as age3_0_0_, user0_.sex as sex4_0_0_, user0_.headuri as headuri5_0_0_ from user user0_ where user0_.id=? lock in share mode
[DEBUG] 2017-05-24: 21:06:24 org.hibernate.loader.plan.build.internal.spaces.QuerySpacesImpl.registerQuerySpace(QuerySpacesImpl.java:192) :  Adding QuerySpace : uid = <gen:0> -> org.hibernate.loader.plan.build.internal.spaces.EntityQuerySpaceImpl@8eead0]
[DEBUG] 2017-05-24: 21:06:24 org.hibernate.persister.walking.spi.MetamodelGraphWalker.visitAttributeDefinition(MetamodelGraphWalker.java:154) :  Visiting attribute path : name
[DEBUG] 2017-05-24: 21:06:24 org.hibernate.persister.walking.spi.MetamodelGraphWalker.visitAttributeDefinition(MetamodelGraphWalker.java:154) :  Visiting attribute path : age
[DEBUG] 2017-05-24: 21:06:24 org.hibernate.persister.walking.spi.MetamodelGraphWalker.visitAttributeDefinition(MetamodelGraphWalker.java:154) :  Visiting attribute path : sex
[DEBUG] 2017-05-24: 21:06:24 org.hibernate.persister.walking.spi.MetamodelGraphWalker.visitAttributeDefinition(MetamodelGraphWalker.java:154) :  Visiting attribute path : headerUri
[DEBUG] 2017-05-24: 21:06:24 org.hibernate.loader.plan.build.internal.FetchStyleLoadPlanBuildingAssociationVisitationStrategy.buildLoadPlan(FetchStyleLoadPlanBuildingAssociationVisitationStrategy.java:94) :  Building LoadPlan...
[DEBUG] 2017-05-24: 21:06:24 org.hibernate.loader.plan.exec.internal.LoadQueryJoinAndFetchProcessor.processQuerySpaceJoins(LoadQueryJoinAndFetchProcessor.java:112) :  processing queryspace <gen:0>
[DEBUG] 2017-05-24: 21:06:24 org.hibernate.loader.plan.build.spi.LoadPlanTreePrinter.logTree(LoadPlanTreePrinter.java:72) :  LoadPlan(entity=com.ittx.usermanager.model.User)
    - Returns
       - EntityReturnImpl(entity=com.ittx.usermanager.model.User, querySpaceUid=<gen:0>, path=com.ittx.usermanager.model.User)
    - QuerySpaces
       - EntityQuerySpaceImpl(uid=<gen:0>, entity=com.ittx.usermanager.model.User)
          - SQL table alias mapping - user0_
          - alias suffix - 0_
          - suffixed key columns - {id1_0_0_}

[DEBUG] 2017-05-24: 21:06:24 org.hibernate.loader.entity.plan.EntityLoader.<init>(EntityLoader.java:146) :  Static select for entity com.ittx.usermanager.model.User [PESSIMISTIC_WRITE]: select user0_.id as id1_0_0_, user0_.name as name2_0_0_, user0_.age as age3_0_0_, user0_.sex as sex4_0_0_, user0_.headuri as headuri5_0_0_ from user user0_ where user0_.id=? for update
[DEBUG] 2017-05-24: 21:06:24 org.hibernate.loader.plan.build.internal.spaces.QuerySpacesImpl.registerQuerySpace(QuerySpacesImpl.java:192) :  Adding QuerySpace : uid = <gen:0> -> org.hibernate.loader.plan.build.internal.spaces.EntityQuerySpaceImpl@17b6a8e]
[DEBUG] 2017-05-24: 21:06:24 org.hibernate.persister.walking.spi.MetamodelGraphWalker.visitAttributeDefinition(MetamodelGraphWalker.java:154) :  Visiting attribute path : name
[DEBUG] 2017-05-24: 21:06:24 org.hibernate.persister.walking.spi.MetamodelGraphWalker.visitAttributeDefinition(MetamodelGraphWalker.java:154) :  Visiting attribute path : age
[DEBUG] 2017-05-24: 21:06:24 org.hibernate.persister.walking.spi.MetamodelGraphWalker.visitAttributeDefinition(MetamodelGraphWalker.java:154) :  Visiting attribute path : sex
[DEBUG] 2017-05-24: 21:06:24 org.hibernate.persister.walking.spi.MetamodelGraphWalker.visitAttributeDefinition(MetamodelGraphWalker.java:154) :  Visiting attribute path : headerUri
[DEBUG] 2017-05-24: 21:06:24 org.hibernate.loader.plan.build.internal.FetchStyleLoadPlanBuildingAssociationVisitationStrategy.buildLoadPlan(FetchStyleLoadPlanBuildingAssociationVisitationStrategy.java:94) :  Building LoadPlan...
[DEBUG] 2017-05-24: 21:06:24 org.hibernate.loader.plan.exec.internal.LoadQueryJoinAndFetchProcessor.processQuerySpaceJoins(LoadQueryJoinAndFetchProcessor.java:112) :  processing queryspace <gen:0>
[DEBUG] 2017-05-24: 21:06:24 org.hibernate.loader.plan.build.spi.LoadPlanTreePrinter.logTree(LoadPlanTreePrinter.java:72) :  LoadPlan(entity=com.ittx.usermanager.model.User)
    - Returns
       - EntityReturnImpl(entity=com.ittx.usermanager.model.User, querySpaceUid=<gen:0>, path=com.ittx.usermanager.model.User)
    - QuerySpaces
       - EntityQuerySpaceImpl(uid=<gen:0>, entity=com.ittx.usermanager.model.User)
          - SQL table alias mapping - user0_
          - alias suffix - 0_
          - suffixed key columns - {id1_0_0_}

[DEBUG] 2017-05-24: 21:06:24 org.hibernate.loader.entity.plan.EntityLoader.<init>(EntityLoader.java:146) :  Static select for entity com.ittx.usermanager.model.User [PESSIMISTIC_FORCE_INCREMENT]: select user0_.id as id1_0_0_, user0_.name as name2_0_0_, user0_.age as age3_0_0_, user0_.sex as sex4_0_0_, user0_.headuri as headuri5_0_0_ from user user0_ where user0_.id=? for update
[DEBUG] 2017-05-24: 21:06:24 org.hibernate.loader.plan.build.internal.spaces.QuerySpacesImpl.registerQuerySpace(QuerySpacesImpl.java:192) :  Adding QuerySpace : uid = <gen:0> -> org.hibernate.loader.plan.build.internal.spaces.EntityQuerySpaceImpl@e35a4c]
[DEBUG] 2017-05-24: 21:06:24 org.hibernate.persister.walking.spi.MetamodelGraphWalker.visitAttributeDefinition(MetamodelGraphWalker.java:154) :  Visiting attribute path : name
[DEBUG] 2017-05-24: 21:06:24 org.hibernate.persister.walking.spi.MetamodelGraphWalker.visitAttributeDefinition(MetamodelGraphWalker.java:154) :  Visiting attribute path : age
[DEBUG] 2017-05-24: 21:06:24 org.hibernate.persister.walking.spi.MetamodelGraphWalker.visitAttributeDefinition(MetamodelGraphWalker.java:154) :  Visiting attribute path : sex
[DEBUG] 2017-05-24: 21:06:24 org.hibernate.persister.walking.spi.MetamodelGraphWalker.visitAttributeDefinition(MetamodelGraphWalker.java:154) :  Visiting attribute path : headerUri
[DEBUG] 2017-05-24: 21:06:24 org.hibernate.loader.plan.build.internal.FetchStyleLoadPlanBuildingAssociationVisitationStrategy.buildLoadPlan(FetchStyleLoadPlanBuildingAssociationVisitationStrategy.java:94) :  Building LoadPlan...
[DEBUG] 2017-05-24: 21:06:24 org.hibernate.loader.plan.exec.internal.LoadQueryJoinAndFetchProcessor.processQuerySpaceJoins(LoadQueryJoinAndFetchProcessor.java:112) :  processing queryspace <gen:0>
[DEBUG] 2017-05-24: 21:06:24 org.hibernate.loader.plan.build.spi.LoadPlanTreePrinter.logTree(LoadPlanTreePrinter.java:72) :  LoadPlan(entity=com.ittx.usermanager.model.User)
    - Returns
       - EntityReturnImpl(entity=com.ittx.usermanager.model.User, querySpaceUid=<gen:0>, path=com.ittx.usermanager.model.User)
    - QuerySpaces
       - EntityQuerySpaceImpl(uid=<gen:0>, entity=com.ittx.usermanager.model.User)
          - SQL table alias mapping - user0_
          - alias suffix - 0_
          - suffixed key columns - {id1_0_0_}

[DEBUG] 2017-05-24: 21:06:24 org.hibernate.loader.entity.plan.EntityLoader.<init>(EntityLoader.java:146) :  Static select for entity com.ittx.usermanager.model.User [OPTIMISTIC]: select user0_.id as id1_0_0_, user0_.name as name2_0_0_, user0_.age as age3_0_0_, user0_.sex as sex4_0_0_, user0_.headuri as headuri5_0_0_ from user user0_ where user0_.id=?
[DEBUG] 2017-05-24: 21:06:24 org.hibernate.loader.plan.build.internal.spaces.QuerySpacesImpl.registerQuerySpace(QuerySpacesImpl.java:192) :  Adding QuerySpace : uid = <gen:0> -> org.hibernate.loader.plan.build.internal.spaces.EntityQuerySpaceImpl@164d4c7]
[DEBUG] 2017-05-24: 21:06:24 org.hibernate.persister.walking.spi.MetamodelGraphWalker.visitAttributeDefinition(MetamodelGraphWalker.java:154) :  Visiting attribute path : name
[DEBUG] 2017-05-24: 21:06:24 org.hibernate.persister.walking.spi.MetamodelGraphWalker.visitAttributeDefinition(MetamodelGraphWalker.java:154) :  Visiting attribute path : age
[DEBUG] 2017-05-24: 21:06:24 org.hibernate.persister.walking.spi.MetamodelGraphWalker.visitAttributeDefinition(MetamodelGraphWalker.java:154) :  Visiting attribute path : sex
[DEBUG] 2017-05-24: 21:06:24 org.hibernate.persister.walking.spi.MetamodelGraphWalker.visitAttributeDefinition(MetamodelGraphWalker.java:154) :  Visiting attribute path : headerUri
[DEBUG] 2017-05-24: 21:06:24 org.hibernate.loader.plan.build.internal.FetchStyleLoadPlanBuildingAssociationVisitationStrategy.buildLoadPlan(FetchStyleLoadPlanBuildingAssociationVisitationStrategy.java:94) :  Building LoadPlan...
[DEBUG] 2017-05-24: 21:06:24 org.hibernate.loader.plan.exec.internal.LoadQueryJoinAndFetchProcessor.processQuerySpaceJoins(LoadQueryJoinAndFetchProcessor.java:112) :  processing queryspace <gen:0>
[DEBUG] 2017-05-24: 21:06:24 org.hibernate.loader.plan.build.spi.LoadPlanTreePrinter.logTree(LoadPlanTreePrinter.java:72) :  LoadPlan(entity=com.ittx.usermanager.model.User)
    - Returns
       - EntityReturnImpl(entity=com.ittx.usermanager.model.User, querySpaceUid=<gen:0>, path=com.ittx.usermanager.model.User)
    - QuerySpaces
       - EntityQuerySpaceImpl(uid=<gen:0>, entity=com.ittx.usermanager.model.User)
          - SQL table alias mapping - user0_
          - alias suffix - 0_
          - suffixed key columns - {id1_0_0_}

[DEBUG] 2017-05-24: 21:06:24 org.hibernate.loader.entity.plan.EntityLoader.<init>(EntityLoader.java:146) :  Static select for entity com.ittx.usermanager.model.User [OPTIMISTIC_FORCE_INCREMENT]: select user0_.id as id1_0_0_, user0_.name as name2_0_0_, user0_.age as age3_0_0_, user0_.sex as sex4_0_0_, user0_.headuri as headuri5_0_0_ from user user0_ where user0_.id=?
[DEBUG] 2017-05-24: 21:06:24 org.hibernate.loader.entity.CascadeEntityLoader.<init>(CascadeEntityLoader.java:56) :  Static select for action ACTION_MERGE on entity com.ittx.usermanager.model.User: select user0_.id as id1_0_0_, user0_.name as name2_0_0_, user0_.age as age3_0_0_, user0_.sex as sex4_0_0_, user0_.headuri as headuri5_0_0_ from user user0_ where user0_.id=?
[DEBUG] 2017-05-24: 21:06:24 org.hibernate.loader.entity.CascadeEntityLoader.<init>(CascadeEntityLoader.java:56) :  Static select for action ACTION_REFRESH on entity com.ittx.usermanager.model.User: select user0_.id as id1_0_0_, user0_.name as name2_0_0_, user0_.age as age3_0_0_, user0_.sex as sex4_0_0_, user0_.headuri as headuri5_0_0_ from user user0_ where user0_.id=?
[DEBUG] 2017-05-24: 21:06:24 org.hibernate.internal.SessionFactoryRegistry.<init>(SessionFactoryRegistry.java:67) :  Initializing SessionFactoryRegistry : org.hibernate.internal.SessionFactoryRegistry@1e49503
[DEBUG] 2017-05-24: 21:06:24 org.hibernate.internal.SessionFactoryRegistry.addSessionFactory(SessionFactoryRegistry.java:89) :  Registering SessionFactory: d9f82759-8c94-47b4-a59f-feb44e2b489c (<unnamed>)
[DEBUG] 2017-05-24: 21:06:24 org.hibernate.internal.SessionFactoryRegistry.addSessionFactory(SessionFactoryRegistry.java:96) :  Not binding SessionFactory to JNDI, no JNDI name configured
[DEBUG] 2017-05-24: 21:06:24 org.hibernate.internal.SessionFactoryImpl.<init>(SessionFactoryImpl.java:505) :  Instantiated session factory
[DEBUG] 2017-05-24: 21:06:24 org.hibernate.internal.NamedQueryRepository.checkNamedQueries(NamedQueryRepository.java:155) :  Checking 0 named HQL queries
[DEBUG] 2017-05-24: 21:06:24 org.hibernate.internal.NamedQueryRepository.checkNamedQueries(NamedQueryRepository.java:171) :  Checking 0 named SQL queries
[DEBUG] 2017-05-24: 21:06:24 org.hibernate.stat.internal.StatisticsInitiator.initiateServiceInternal(StatisticsInitiator.java:110) :  Statistics initialized [enabled=false]
[DEBUG] 2017-05-24: 21:06:24 org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:251) :  Returning cached instance of singleton bean 'org.springframework.transaction.config.internalTransactionAdvisor'
[DEBUG] 2017-05-24: 21:06:24 org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:484) :  Finished creating instance of bean 'sessionFactory'
[DEBUG] 2017-05-24: 21:06:24 org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:251) :  Returning cached instance of singleton bean 'org.springframework.transaction.config.internalTransactionAdvisor'
[DEBUG] 2017-05-24: 21:06:24 org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.invokeInitMethods(AbstractAutowireCapableBeanFactory.java:1625) :  Invoking afterPropertiesSet() on bean with name 'userDao'
[DEBUG] 2017-05-24: 21:06:24 org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:251) :  Returning cached instance of singleton bean 'org.springframework.transaction.config.internalTransactionAdvisor'
[DEBUG] 2017-05-24: 21:06:24 org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:484) :  Finished creating instance of bean 'userDao'
[DEBUG] 2017-05-24: 21:06:24 org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor.registerDependentBeans(AutowiredAnnotationBeanPostProcessor.java:516) :  Autowiring by type from bean name 'userService' to bean named 'userDao'
[DEBUG] 2017-05-24: 21:06:24 org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:251) :  Returning cached instance of singleton bean 'org.springframework.transaction.config.internalTransactionAdvisor'
[DEBUG] 2017-05-24: 21:06:24 org.springframework.transaction.interceptor.AbstractFallbackTransactionAttributeSource.getTransactionAttribute(AbstractFallbackTransactionAttributeSource.java:108) :  Adding transactional method 'UserServiceImpl.getTotal' with attribute: PROPAGATION_REQUIRED,ISOLATION_DEFAULT; ''
[DEBUG] 2017-05-24: 21:06:24 org.springframework.aop.framework.autoproxy.AbstractAutoProxyCreator.buildAdvisors(AbstractAutoProxyCreator.java:528) :  Creating implicit proxy for bean 'userService' with 0 common interceptors and 1 specific interceptors
[DEBUG] 2017-05-24: 21:06:24 org.springframework.aop.framework.JdkDynamicAopProxy.getProxy(JdkDynamicAopProxy.java:118) :  Creating JDK dynamic proxy: target source is SingletonTargetSource for target object [com.ittx.usermanager.service.impl.UserServiceImpl@def655]
[DEBUG] 2017-05-24: 21:06:24 org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:484) :  Finished creating instance of bean 'userService'
[DEBUG] 2017-05-24: 21:06:24 org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor.registerDependentBeans(AutowiredAnnotationBeanPostProcessor.java:516) :  Autowiring by type from bean name 'userAction' to bean named 'userService'
[DEBUG] 2017-05-24: 21:06:24 org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:251) :  Returning cached instance of singleton bean 'org.springframework.transaction.config.internalTransactionAdvisor'
[DEBUG] 2017-05-24: 21:06:24 org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:484) :  Finished creating instance of bean 'userAction'
[DEBUG] 2017-05-24: 21:06:24 org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:251) :  Returning cached instance of singleton bean 'userDao'
[DEBUG] 2017-05-24: 21:06:24 org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:251) :  Returning cached instance of singleton bean 'userService'
[DEBUG] 2017-05-24: 21:06:24 org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:251) :  Returning cached instance of singleton bean 'org.springframework.context.annotation.internalConfigurationAnnotationProcessor'
[DEBUG] 2017-05-24: 21:06:24 org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:251) :  Returning cached instance of singleton bean 'org.springframework.context.annotation.internalAutowiredAnnotationProcessor'
[DEBUG] 2017-05-24: 21:06:24 org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:251) :  Returning cached instance of singleton bean 'org.springframework.context.annotation.internalRequiredAnnotationProcessor'
[DEBUG] 2017-05-24: 21:06:24 org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:251) :  Returning cached instance of singleton bean 'org.springframework.context.annotation.internalCommonAnnotationProcessor'
[DEBUG] 2017-05-24: 21:06:24 org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:251) :  Returning cached instance of singleton bean 'org.springframework.context.annotation.internalPersistenceAnnotationProcessor'
[DEBUG] 2017-05-24: 21:06:24 org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:221) :  Creating shared instance of singleton bean 'org.springframework.context.event.internalEventListenerProcessor'
[DEBUG] 2017-05-24: 21:06:24 org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:448) :  Creating instance of bean 'org.springframework.context.event.internalEventListenerProcessor'
[DEBUG] 2017-05-24: 21:06:24 org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:529) :  Eagerly caching bean 'org.springframework.context.event.internalEventListenerProcessor' to allow for resolving potential circular references
[DEBUG] 2017-05-24: 21:06:24 org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:251) :  Returning cached instance of singleton bean 'org.springframework.transaction.config.internalTransactionAdvisor'
[DEBUG] 2017-05-24: 21:06:24 org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:484) :  Finished creating instance of bean 'org.springframework.context.event.internalEventListenerProcessor'
[DEBUG] 2017-05-24: 21:06:24 org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:221) :  Creating shared instance of singleton bean 'org.springframework.context.event.internalEventListenerFactory'
[DEBUG] 2017-05-24: 21:06:24 org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:448) :  Creating instance of bean 'org.springframework.context.event.internalEventListenerFactory'
[DEBUG] 2017-05-24: 21:06:24 org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:529) :  Eagerly caching bean 'org.springframework.context.event.internalEventListenerFactory' to allow for resolving potential circular references
[DEBUG] 2017-05-24: 21:06:24 org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:251) :  Returning cached instance of singleton bean 'org.springframework.transaction.config.internalTransactionAdvisor'
[DEBUG] 2017-05-24: 21:06:24 org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:484) :  Finished creating instance of bean 'org.springframework.context.event.internalEventListenerFactory'
[DEBUG] 2017-05-24: 21:06:24 org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:251) :  Returning cached instance of singleton bean 'org.springframework.context.support.PropertySourcesPlaceholderConfigurer#0'
[DEBUG] 2017-05-24: 21:06:24 org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:251) :  Returning cached instance of singleton bean 'dataSource'
[DEBUG] 2017-05-24: 21:06:24 org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:251) :  Returning cached instance of singleton bean 'sessionFactory'
[DEBUG] 2017-05-24: 21:06:24 org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:221) :  Creating shared instance of singleton bean 'transactionManager'
[DEBUG] 2017-05-24: 21:06:24 org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:448) :  Creating instance of bean 'transactionManager'
[DEBUG] 2017-05-24: 21:06:24 org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:529) :  Eagerly caching bean 'transactionManager' to allow for resolving potential circular references
[DEBUG] 2017-05-24: 21:06:24 org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:251) :  Returning cached instance of singleton bean 'sessionFactory'
[DEBUG] 2017-05-24: 21:06:24 org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.invokeInitMethods(AbstractAutowireCapableBeanFactory.java:1625) :  Invoking afterPropertiesSet() on bean with name 'transactionManager'
[INFO] 2017-05-24: 21:06:24 org.springframework.orm.hibernate4.HibernateTransactionManager.afterPropertiesSet(HibernateTransactionManager.java:360) :  Using DataSource [org.springframework.jdbc.datasource.DriverManagerDataSource@14a95bc] of Hibernate SessionFactory for HibernateTransactionManager
[DEBUG] 2017-05-24: 21:06:24 org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:251) :  Returning cached instance of singleton bean 'org.springframework.transaction.config.internalTransactionAdvisor'
[DEBUG] 2017-05-24: 21:06:24 org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:484) :  Finished creating instance of bean 'transactionManager'
[DEBUG] 2017-05-24: 21:06:24 org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:221) :  Creating shared instance of singleton bean 'org.springframework.transaction.config.internalTransactionalEventListenerFactory'
[DEBUG] 2017-05-24: 21:06:24 org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:448) :  Creating instance of bean 'org.springframework.transaction.config.internalTransactionalEventListenerFactory'
[DEBUG] 2017-05-24: 21:06:24 org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:529) :  Eagerly caching bean 'org.springframework.transaction.config.internalTransactionalEventListenerFactory' to allow for resolving potential circular references
[DEBUG] 2017-05-24: 21:06:24 org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:251) :  Returning cached instance of singleton bean 'org.springframework.transaction.config.internalTransactionAdvisor'
[DEBUG] 2017-05-24: 21:06:24 org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:484) :  Finished creating instance of bean 'org.springframework.transaction.config.internalTransactionalEventListenerFactory'
[DEBUG] 2017-05-24: 21:06:24 org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:251) :  Returning cached instance of singleton bean 'org.springframework.aop.config.internalAutoProxyCreator'
[DEBUG] 2017-05-24: 21:06:24 org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:251) :  Returning cached instance of singleton bean 'org.springframework.transaction.annotation.AnnotationTransactionAttributeSource#0'
[DEBUG] 2017-05-24: 21:06:24 org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:221) :  Creating shared instance of singleton bean 'org.springframework.transaction.interceptor.TransactionInterceptor#0'
[DEBUG] 2017-05-24: 21:06:24 org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:448) :  Creating instance of bean 'org.springframework.transaction.interceptor.TransactionInterceptor#0'
[DEBUG] 2017-05-24: 21:06:24 org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:529) :  Eagerly caching bean 'org.springframework.transaction.interceptor.TransactionInterceptor#0' to allow for resolving potential circular references
[DEBUG] 2017-05-24: 21:06:24 org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:251) :  Returning cached instance of singleton bean 'org.springframework.transaction.annotation.AnnotationTransactionAttributeSource#0'
[DEBUG] 2017-05-24: 21:06:24 org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.invokeInitMethods(AbstractAutowireCapableBeanFactory.java:1625) :  Invoking afterPropertiesSet() on bean with name 'org.springframework.transaction.interceptor.TransactionInterceptor#0'
[DEBUG] 2017-05-24: 21:06:24 org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:484) :  Finished creating instance of bean 'org.springframework.transaction.interceptor.TransactionInterceptor#0'
[DEBUG] 2017-05-24: 21:06:24 org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:251) :  Returning cached instance of singleton bean 'org.springframework.transaction.config.internalTransactionAdvisor'
[DEBUG] 2017-05-24: 21:06:24 org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:251) :  Returning cached instance of singleton bean 'org.springframework.context.annotation.ConfigurationClassPostProcessor.importAwareProcessor'
[DEBUG] 2017-05-24: 21:06:24 org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:251) :  Returning cached instance of singleton bean 'org.springframework.context.annotation.ConfigurationClassPostProcessor.enhancedConfigurationProcessor'
[DEBUG] 2017-05-24: 21:06:24 org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:251) :  Returning cached instance of singleton bean 'org.springframework.context.event.internalEventListenerFactory'
[DEBUG] 2017-05-24: 21:06:24 org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:251) :  Returning cached instance of singleton bean 'org.springframework.transaction.config.internalTransactionalEventListenerFactory'
[DEBUG] 2017-05-24: 21:06:24 org.springframework.context.support.AbstractApplicationContext.initLifecycleProcessor(AbstractApplicationContext.java:779) :  Unable to locate LifecycleProcessor with name 'lifecycleProcessor': using default [org.springframework.context.support.DefaultLifecycleProcessor@112697d]
[DEBUG] 2017-05-24: 21:06:24 org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:251) :  Returning cached instance of singleton bean 'lifecycleProcessor'
[DEBUG] 2017-05-24: 21:06:24 org.springframework.jndi.JndiTemplate.lookup(JndiTemplate.java:150) :  Looking up JNDI object with name [java:comp/env/spring.liveBeansView.mbeanDomain]
[DEBUG] 2017-05-24: 21:06:24 org.springframework.jndi.JndiLocatorSupport.lookup(JndiLocatorSupport.java:101) :  Converted JNDI name [java:comp/env/spring.liveBeansView.mbeanDomain] not found - trying original name [spring.liveBeansView.mbeanDomain]. javax.naming.NameNotFoundException; remaining name 'spring.liveBeansView.mbeanDomain'
[DEBUG] 2017-05-24: 21:06:24 org.springframework.jndi.JndiTemplate.lookup(JndiTemplate.java:150) :  Looking up JNDI object with name [spring.liveBeansView.mbeanDomain]
[DEBUG] 2017-05-24: 21:06:24 org.springframework.jndi.JndiPropertySource.getProperty(JndiPropertySource.java:99) :  JNDI lookup for name [spring.liveBeansView.mbeanDomain] threw NamingException with message: null. Returning null.
[DEBUG] 2017-05-24: 21:06:24 org.springframework.core.env.PropertySourcesPropertyResolver.getProperty(PropertySourcesPropertyResolver.java:91) :  Could not find key 'spring.liveBeansView.mbeanDomain' in any property source
[DEBUG] 2017-05-24: 21:06:24 org.springframework.web.context.ContextLoader.initWebApplicationContext(ContextLoader.java:340) :  Published root WebApplicationContext as ServletContext attribute with name [org.springframework.web.context.WebApplicationContext.ROOT]
[INFO] 2017-05-24: 21:06:24 org.springframework.web.context.ContextLoader.initWebApplicationContext(ContextLoader.java:345) :  Root WebApplicationContext: initialization completed in 1980 ms
[DEBUG] 2017-05-24: 21:06:25 org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:251) :  Returning cached instance of singleton bean 'org.springframework.transaction.config.internalTransactionAdvisor'
[DEBUG] 2017-05-24: 21:06:25 org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:251) :  Returning cached instance of singleton bean 'org.springframework.transaction.config.internalTransactionAdvisor'
[DEBUG] 2017-05-24: 21:06:25 org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:251) :  Returning cached instance of singleton bean 'org.springframework.transaction.config.internalTransactionAdvisor'
[DEBUG] 2017-05-24: 21:06:25 org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:251) :  Returning cached instance of singleton bean 'org.springframework.transaction.config.internalTransactionAdvisor'
[DEBUG] 2017-05-24: 21:06:25 org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:251) :  Returning cached instance of singleton bean 'org.springframework.transaction.config.internalTransactionAdvisor'
[DEBUG] 2017-05-24: 21:06:25 org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:251) :  Returning cached instance of singleton bean 'org.springframework.transaction.config.internalTransactionAdvisor'
[DEBUG] 2017-05-24: 21:06:25 org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:251) :  Returning cached instance of singleton bean 'org.springframework.transaction.config.internalTransactionAdvisor'
[DEBUG] 2017-05-24: 21:06:25 org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:251) :  Returning cached instance of singleton bean 'org.springframework.transaction.config.internalTransactionAdvisor'
[DEBUG] 2017-05-24: 21:06:25 org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:251) :  Returning cached instance of singleton bean 'org.springframework.transaction.config.internalTransactionAdvisor'
[DEBUG] 2017-05-24: 21:06:25 org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:251) :  Returning cached instance of singleton bean 'org.springframework.transaction.config.internalTransactionAdvisor'
[DEBUG] 2017-05-24: 21:06:25 org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:251) :  Returning cached instance of singleton bean 'org.springframework.transaction.config.internalTransactionAdvisor'
[DEBUG] 2017-05-24: 21:06:25 org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:251) :  Returning cached instance of singleton bean 'org.springframework.transaction.config.internalTransactionAdvisor'
[DEBUG] 2017-05-24: 21:06:25 org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:251) :  Returning cached instance of singleton bean 'org.springframework.transaction.config.internalTransactionAdvisor'
[DEBUG] 2017-05-24: 21:06:25 org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:251) :  Returning cached instance of singleton bean 'org.springframework.transaction.config.internalTransactionAdvisor'
[DEBUG] 2017-05-24: 21:06:25 org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:251) :  Returning cached instance of singleton bean 'org.springframework.transaction.config.internalTransactionAdvisor'
[DEBUG] 2017-05-24: 21:06:25 org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:251) :  Returning cached instance of singleton bean 'org.springframework.transaction.config.internalTransactionAdvisor'
[DEBUG] 2017-05-24: 21:06:25 org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:251) :  Returning cached instance of singleton bean 'org.springframework.transaction.config.internalTransactionAdvisor'
[DEBUG] 2017-05-24: 21:06:25 org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:251) :  Returning cached instance of singleton bean 'org.springframework.transaction.config.internalTransactionAdvisor'
[DEBUG] 2017-05-24: 21:06:25 org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:251) :  Returning cached instance of singleton bean 'org.springframework.transaction.config.internalTransactionAdvisor'
[DEBUG] 2017-05-24: 21:06:25 org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:251) :  Returning cached instance of singleton bean 'org.springframework.transaction.config.internalTransactionAdvisor'
[DEBUG] 2017-05-24: 21:06:25 org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:251) :  Returning cached instance of singleton bean 'org.springframework.transaction.config.internalTransactionAdvisor'
[DEBUG] 2017-05-24: 21:06:25 org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:251) :  Returning cached instance of singleton bean 'org.springframework.transaction.config.internalTransactionAdvisor'
[DEBUG] 2017-05-24: 21:06:25 org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:251) :  Returning cached instance of singleton bean 'org.springframework.transaction.config.internalTransactionAdvisor'
[DEBUG] 2017-05-24: 21:06:25 org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:251) :  Returning cached instance of singleton bean 'org.springframework.transaction.config.internalTransactionAdvisor'
[DEBUG] 2017-05-24: 21:06:25 org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:251) :  Returning cached instance of singleton bean 'org.springframework.transaction.config.internalTransactionAdvisor'
[DEBUG] 2017-05-24: 21:06:25 org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:251) :  Returning cached instance of singleton bean 'org.springframework.transaction.config.internalTransactionAdvisor'
[DEBUG] 2017-05-24: 21:06:25 org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:251) :  Returning cached instance of singleton bean 'org.springframework.transaction.config.internalTransactionAdvisor'
[DEBUG] 2017-05-24: 21:06:25 org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:251) :  Returning cached instance of singleton bean 'org.springframework.transaction.config.internalTransactionAdvisor'
[DEBUG] 2017-05-24: 21:06:25 org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:251) :  Returning cached instance of singleton bean 'org.springframework.transaction.config.internalTransactionAdvisor'
[DEBUG] 2017-05-24: 21:06:25 org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:251) :  Returning cached instance of singleton bean 'org.springframework.transaction.config.internalTransactionAdvisor'
[DEBUG] 2017-05-24: 21:06:25 org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:251) :  Returning cached instance of singleton bean 'org.springframework.transaction.config.internalTransactionAdvisor'
[DEBUG] 2017-05-24: 21:06:25 org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:251) :  Returning cached instance of singleton bean 'org.springframework.transaction.config.internalTransactionAdvisor'
[DEBUG] 2017-05-24: 21:06:25 org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:251) :  Returning cached instance of singleton bean 'org.springframework.transaction.config.internalTransactionAdvisor'
[DEBUG] 2017-05-24: 21:06:25 org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:251) :  Returning cached instance of singleton bean 'org.springframework.transaction.config.internalTransactionAdvisor'
[DEBUG] 2017-05-24: 21:06:25 org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:251) :  Returning cached instance of singleton bean 'org.springframework.transaction.config.internalTransactionAdvisor'
[DEBUG] 2017-05-24: 21:06:25 org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:251) :  Returning cached instance of singleton bean 'org.springframework.transaction.config.internalTransactionAdvisor'
[DEBUG] 2017-05-24: 21:06:25 org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:251) :  Returning cached instance of singleton bean 'org.springframework.transaction.config.internalTransactionAdvisor'
[INFO] 2017-05-24: 21:06:49 org.springframework.web.context.ContextLoader.initWebApplicationContext(ContextLoader.java:305) :  Root WebApplicationContext: initialization started
[DEBUG] 2017-05-24: 21:06:49 org.springframework.core.env.MutablePropertySources.addLast(MutablePropertySources.java:109) :  Adding [servletConfigInitParams] PropertySource with lowest search precedence
[DEBUG] 2017-05-24: 21:06:49 org.springframework.core.env.MutablePropertySources.addLast(MutablePropertySources.java:109) :  Adding [servletContextInitParams] PropertySource with lowest search precedence
[DEBUG] 2017-05-24: 21:06:49 org.springframework.core.env.MutablePropertySources.addLast(MutablePropertySources.java:109) :  Adding [jndiProperties] PropertySource with lowest search precedence
[DEBUG] 2017-05-24: 21:06:49 org.springframework.core.env.MutablePropertySources.addLast(MutablePropertySources.java:109) :  Adding [systemProperties] PropertySource with lowest search precedence
[DEBUG] 2017-05-24: 21:06:49 org.springframework.core.env.MutablePropertySources.addLast(MutablePropertySources.java:109) :  Adding [systemEnvironment] PropertySource with lowest search precedence
[DEBUG] 2017-05-24: 21:06:49 org.springframework.core.env.AbstractEnvironment.<init>(AbstractEnvironment.java:124) :  Initialized StandardServletEnvironment with PropertySources [servletConfigInitParams,servletContextInitParams,jndiProperties,systemProperties,systemEnvironment]
[DEBUG] 2017-05-24: 21:06:49 org.springframework.core.env.MutablePropertySources.replace(MutablePropertySources.java:174) :  Replacing [servletContextInitParams] PropertySource with [servletContextInitParams]
[INFO] 2017-05-24: 21:06:49 org.springframework.context.support.AbstractApplicationContext.prepareRefresh(AbstractApplicationContext.java:581) :  Refreshing Root WebApplicationContext: startup date [Wed May 24 21:06:49 CST 2017]; root of context hierarchy
[DEBUG] 2017-05-24: 21:06:49 org.springframework.core.env.MutablePropertySources.addLast(MutablePropertySources.java:109) :  Adding [systemProperties] PropertySource with lowest search precedence
[DEBUG] 2017-05-24: 21:06:49 org.springframework.core.env.MutablePropertySources.addLast(MutablePropertySources.java:109) :  Adding [systemEnvironment] PropertySource with lowest search precedence
[DEBUG] 2017-05-24: 21:06:49 org.springframework.core.env.AbstractEnvironment.<init>(AbstractEnvironment.java:124) :  Initialized StandardEnvironment with PropertySources [systemProperties,systemEnvironment]
[INFO] 2017-05-24: 21:06:49 org.springframework.beans.factory.xml.XmlBeanDefinitionReader.loadBeanDefinitions(XmlBeanDefinitionReader.java:317) :  Loading XML bean definitions from class path resource [spring-core.xml]
[DEBUG] 2017-05-24: 21:06:49 org.springframework.beans.factory.xml.DefaultDocumentLoader.loadDocument(DefaultDocumentLoader.java:73) :  Using JAXP provider [com.sun.org.apache.xerces.internal.jaxp.DocumentBuilderFactoryImpl]
[DEBUG] 2017-05-24: 21:06:49 org.springframework.beans.factory.xml.PluggableSchemaResolver.getSchemaMappings(PluggableSchemaResolver.java:141) :  Loading schema mappings from [META-INF/spring.schemas]
[DEBUG] 2017-05-24: 21:06:49 org.springframework.beans.factory.xml.PluggableSchemaResolver.getSchemaMappings(PluggableSchemaResolver.java:147) :  Loaded schema mappings: {http://www.springframework.org/schema/tx/spring-tx-2.5.xsd=org/springframework/transaction/config/spring-tx-2.5.xsd, http://www.springframework.org/schema/tx/spring-tx-4.3.xsd=org/springframework/transaction/config/spring-tx-4.3.xsd, http://www.springframework.org/schema/cache/spring-cache-4.2.xsd=org/springframework/cache/config/spring-cache-4.2.xsd, http://www.springframework.org/schema/aop/spring-aop-4.1.xsd=org/springframework/aop/config/spring-aop-4.1.xsd, http://www.springframework.org/schema/context/spring-context-3.1.xsd=org/springframework/context/config/spring-context-3.1.xsd, http://www.springframework.org/schema/jdbc/spring-jdbc-4.1.xsd=org/springframework/jdbc/config/spring-jdbc-4.1.xsd, http://www.springframework.org/schema/util/spring-util-3.0.xsd=org/springframework/beans/factory/xml/spring-util-3.0.xsd, http://www.springframework.org/schema/tool/spring-tool.xsd=org/springframework/beans/factory/xml/spring-tool-4.3.xsd, http://www.springframework.org/schema/aop/spring-aop-3.2.xsd=org/springframework/aop/config/spring-aop-3.2.xsd, http://www.springframework.org/schema/lang/spring-lang-4.1.xsd=org/springframework/scripting/config/spring-lang-4.1.xsd, http://www.springframework.org/schema/context/spring-context-4.0.xsd=org/springframework/context/config/spring-context-4.0.xsd, http://www.springframework.org/schema/beans/spring-beans-4.2.xsd=org/springframework/beans/factory/xml/spring-beans-4.2.xsd, http://www.springframework.org/schema/tool/spring-tool-4.1.xsd=org/springframework/beans/factory/xml/spring-tool-4.1.xsd, http://www.springframework.org/schema/lang/spring-lang-3.2.xsd=org/springframework/scripting/config/spring-lang-3.2.xsd, http://www.springframework.org/schema/cache/spring-cache-3.2.xsd=org/springframework/cache/config/spring-cache-3.2.xsd, http://www.springframework.org/schema/jee/spring-jee-4.1.xsd=org/springframework/ejb/config/spring-jee-4.1.xsd, http://www.springframework.org/schema/jdbc/spring-jdbc-3.1.xsd=org/springframework/jdbc/config/spring-jdbc-3.1.xsd, http://www.springframework.org/schema/util/spring-util-2.0.xsd=org/springframework/beans/factory/xml/spring-util-2.0.xsd, http://www.springframework.org/schema/task/spring-task-4.2.xsd=org/springframework/scheduling/config/spring-task-4.2.xsd, http://www.springframework.org/schema/tool/spring-tool-3.2.xsd=org/springframework/beans/factory/xml/spring-tool-3.2.xsd, http://www.springframework.org/schema/context/spring-context.xsd=org/springframework/context/config/spring-context-4.3.xsd, http://www.springframework.org/schema/tx/spring-tx-4.2.xsd=org/springframework/transaction/config/spring-tx-4.2.xsd, http://www.springframework.org/schema/cache/spring-cache-4.1.xsd=org/springframework/cache/config/spring-cache-4.1.xsd, http://www.springframework.org/schema/aop/spring-aop-4.0.xsd=org/springframework/aop/config/spring-aop-4.0.xsd, http://www.springframework.org/schema/jee/spring-jee-3.2.xsd=org/springframework/ejb/config/spring-jee-3.2.xsd, http://www.springframework.org/schema/context/spring-context-3.0.xsd=org/springframework/context/config/spring-context-3.0.xsd, http://www.springframework.org/schema/jdbc/spring-jdbc-4.0.xsd=org/springframework/jdbc/config/spring-jdbc-4.0.xsd, http://www.springframework.org/schema/util/spring-util-4.3.xsd=org/springframework/beans/factory/xml/spring-util-4.3.xsd, http://www.springframework.org/schema/util/spring-util-2.5.xsd=org/springframework/beans/factory/xml/spring-util-2.5.xsd, http://www.springframework.org/schema/beans/spring-beans-3.2.xsd=org/springframework/beans/factory/xml/spring-beans-3.2.xsd, http://www.springframework.org/schema/aop/spring-aop-3.1.xsd=org/springframework/aop/config/spring-aop-3.1.xsd, http://www.springframework.org/schema/lang/spring-lang-4.0.xsd=org/springframework/scripting/config/spring-lang-4.0.xsd, http://www.springframework.org/schema/beans/spring-beans-4.1.xsd=org/springframework/beans/factory/xml/spring-beans-4.1.xsd, http://www.springframework.org/schema/tool/spring-tool-4.0.xsd=org/springframework/beans/factory/xml/spring-tool-4.0.xsd, http://www.springframework.org/schema/lang/spring-lang-3.1.xsd=org/springframework/scripting/config/spring-lang-3.1.xsd, http://www.springframework.org/schema/tx/spring-tx-3.2.xsd=org/springframework/transaction/config/spring-tx-3.2.xsd, http://www.springframework.org/schema/cache/spring-cache-3.1.xsd=org/springframework/cache/config/spring-cache-3.1.xsd, http://www.springframework.org/schema/jee/spring-jee-4.0.xsd=org/springframework/ejb/config/spring-jee-4.0.xsd, http://www.springframework.org/schema/jdbc/spring-jdbc-3.0.xsd=org/springframework/jdbc/config/spring-jdbc-3.0.xsd, http://www.springframework.org/schema/task/spring-task-4.1.xsd=org/springframework/scheduling/config/spring-task-4.1.xsd, http://www.springframework.org/schema/tool/spring-tool-3.1.xsd=org/springframework/beans/factory/xml/spring-tool-3.1.xsd, http://www.springframework.org/schema/jdbc/spring-jdbc.xsd=org/springframework/jdbc/config/spring-jdbc-4.3.xsd, http://www.springframework.org/schema/tx/spring-tx-4.1.xsd=org/springframework/transaction/config/spring-tx-4.1.xsd, http://www.springframework.org/schema/cache/spring-cache-4.0.xsd=org/springframework/cache/config/spring-cache-4.0.xsd, http://www.springframework.org/schema/jee/spring-jee-3.1.xsd=org/springframework/ejb/config/spring-jee-3.1.xsd, http://www.springframework.org/schema/util/spring-util-4.2.xsd=org/springframework/beans/factory/xml/spring-util-4.2.xsd, http://www.springframework.org/schema/task/spring-task-3.2.xsd=org/springframework/scheduling/config/spring-task-3.2.xsd, http://www.springframework.org/schema/beans/spring-beans-3.1.xsd=org/springframework/beans/factory/xml/spring-beans-3.1.xsd, http://www.springframework.org/schema/util/spring-util.xsd=org/springframework/beans/factory/xml/spring-util-4.3.xsd, http://www.springframework.org/schema/aop/spring-aop-3.0.xsd=org/springframework/aop/config/spring-aop-3.0.xsd, http://www.springframework.org/schema/beans/spring-beans-4.0.xsd=org/springframework/beans/factory/xml/spring-beans-4.0.xsd, http://www.springframework.org/schema/beans/spring-beans.xsd=org/springframework/beans/factory/xml/spring-beans-4.3.xsd, http://www.springframework.org/schema/lang/spring-lang-3.0.xsd=org/springframework/scripting/config/spring-lang-3.0.xsd, http://www.springframework.org/schema/tx/spring-tx-3.1.xsd=org/springframework/transaction/config/spring-tx-3.1.xsd, http://www.springframework.org/schema/context/spring-context-2.5.xsd=org/springframework/context/config/spring-context-2.5.xsd, http://www.springframework.org/schema/context/spring-context-4.3.xsd=org/springframework/context/config/spring-context-4.3.xsd, http://www.springframework.org/schema/task/spring-task-4.0.xsd=org/springframework/scheduling/config/spring-task-4.0.xsd, http://www.springframework.org/schema/tool/spring-tool-3.0.xsd=org/springframework/beans/factory/xml/spring-tool-3.0.xsd, http://www.springframework.org/schema/tx/spring-tx-4.0.xsd=org/springframework/transaction/config/spring-tx-4.0.xsd, http://www.springframework.org/schema/aop/spring-aop-2.0.xsd=org/springframework/aop/config/spring-aop-2.0.xsd, http://www.springframework.org/schema/jee/spring-jee-3.0.xsd=org/springframework/ejb/config/spring-jee-3.0.xsd, http://www.springframework.org/schema/util/spring-util-4.1.xsd=org/springframework/beans/factory/xml/spring-util-4.1.xsd, http://www.springframework.org/schema/task/spring-task-3.1.xsd=org/springframework/scheduling/config/spring-task-3.1.xsd, http://www.springframework.org/schema/beans/spring-beans-3.0.xsd=org/springframework/beans/factory/xml/spring-beans-3.0.xsd, http://www.springframework.org/schema/jee/spring-jee.xsd=org/springframework/ejb/config/spring-jee-4.3.xsd, http://www.springframework.org/schema/aop/spring-aop-2.5.xsd=org/springframework/aop/config/spring-aop-2.5.xsd, http://www.springframework.org/schema/aop/spring-aop-4.3.xsd=org/springframework/aop/config/spring-aop-4.3.xsd, http://www.springframework.org/schema/lang/spring-lang-2.0.xsd=org/springframework/scripting/config/spring-lang-2.0.xsd, http://www.springframework.org/schema/jdbc/spring-jdbc-4.3.xsd=org/springframework/jdbc/config/spring-jdbc-4.3.xsd, http://www.springframework.org/schema/util/spring-util-3.2.xsd=org/springframework/beans/factory/xml/spring-util-3.2.xsd, http://www.springframework.org/schema/task/spring-task.xsd=org/springframework/scheduling/config/spring-task-4.3.xsd, http://www.springframework.org/schema/tool/spring-tool-2.0.xsd=org/springframework/beans/factory/xml/spring-tool-2.0.xsd, http://www.springframework.org/schema/tx/spring-tx-3.0.xsd=org/springframework/transaction/config/spring-tx-3.0.xsd, http://www.springframework.org/schema/lang/spring-lang-2.5.xsd=org/springframework/scripting/config/spring-lang-2.5.xsd, http://www.springframework.org/schema/lang/spring-lang-4.3.xsd=org/springframework/scripting/config/spring-lang-4.3.xsd, http://www.springframework.org/schema/context/spring-context-4.2.xsd=org/springframework/context/config/spring-context-4.2.xsd, http://www.springframework.org/schema/jee/spring-jee-2.0.xsd=org/springframework/ejb/config/spring-jee-2.0.xsd, http://www.springframework.org/schema/tool/spring-tool-4.3.xsd=org/springframework/beans/factory/xml/spring-tool-4.3.xsd, http://www.springframework.org/schema/tool/spring-tool-2.5.xsd=org/springframework/beans/factory/xml/spring-tool-2.5.xsd, http://www.springframework.org/schema/jee/spring-jee-4.3.xsd=org/springframework/ejb/config/spring-jee-4.3.xsd, http://www.springframework.org/schema/jee/spring-jee-2.5.xsd=org/springframework/ejb/config/spring-jee-2.5.xsd, http://www.springframework.org/schema/util/spring-util-4.0.xsd=org/springframework/beans/factory/xml/spring-util-4.0.xsd, http://www.springframework.org/schema/task/spring-task-3.0.xsd=org/springframework/scheduling/config/spring-task-3.0.xsd, http://www.springframework.org/schema/cache/spring-cache-4.3.xsd=org/springframework/cache/config/spring-cache-4.3.xsd, http://www.springframework.org/schema/aop/spring-aop-4.2.xsd=org/springframework/aop/config/spring-aop-4.2.xsd, http://www.springframework.org/schema/lang/spring-lang.xsd=org/springframework/scripting/config/spring-lang-4.3.xsd, http://www.springframework.org/schema/context/spring-context-3.2.xsd=org/springframework/context/config/spring-context-3.2.xsd, http://www.springframework.org/schema/jdbc/spring-jdbc-4.2.xsd=org/springframework/jdbc/config/spring-jdbc-4.2.xsd, http://www.springframework.org/schema/util/spring-util-3.1.xsd=org/springframework/beans/factory/xml/spring-util-3.1.xsd, http://www.springframework.org/schema/beans/spring-beans-2.0.xsd=org/springframework/beans/factory/xml/spring-beans-2.0.xsd, http://www.springframework.org/schema/cache/spring-cache.xsd=org/springframework/cache/config/spring-cache-4.3.xsd, http://www.springframework.org/schema/tx/spring-tx.xsd=org/springframework/transaction/config/spring-tx-4.3.xsd, http://www.springframework.org/schema/lang/spring-lang-4.2.xsd=org/springframework/scripting/config/spring-lang-4.2.xsd, http://www.springframework.org/schema/context/spring-context-4.1.xsd=org/springframework/context/config/spring-context-4.1.xsd, http://www.springframework.org/schema/beans/spring-beans-4.3.xsd=org/springframework/beans/factory/xml/spring-beans-4.3.xsd, http://www.springframework.org/schema/beans/spring-beans-2.5.xsd=org/springframework/beans/factory/xml/spring-beans-2.5.xsd, http://www.springframework.org/schema/tool/spring-tool-4.2.xsd=org/springframework/beans/factory/xml/spring-tool-4.2.xsd, http://www.springframework.org/schema/tx/spring-tx-2.0.xsd=org/springframework/transaction/config/spring-tx-2.0.xsd, http://www.springframework.org/schema/jee/spring-jee-4.2.xsd=org/springframework/ejb/config/spring-jee-4.2.xsd, http://www.springframework.org/schema/jdbc/spring-jdbc-3.2.xsd=org/springframework/jdbc/config/spring-jdbc-3.2.xsd, http://www.springframework.org/schema/task/spring-task-4.3.xsd=org/springframework/scheduling/config/spring-task-4.3.xsd, http://www.springframework.org/schema/aop/spring-aop.xsd=org/springframework/aop/config/spring-aop-4.3.xsd}
[DEBUG] 2017-05-24: 21:06:49 org.springframework.beans.factory.xml.PluggableSchemaResolver.resolveEntity(PluggableSchemaResolver.java:119) :  Found XML schema [http://www.springframework.org/schema/beans/spring-beans.xsd] in classpath: org/springframework/beans/factory/xml/spring-beans-4.3.xsd
[DEBUG] 2017-05-24: 21:06:49 org.springframework.beans.factory.xml.PluggableSchemaResolver.resolveEntity(PluggableSchemaResolver.java:119) :  Found XML schema [http://www.springframework.org/schema/context/spring-context.xsd] in classpath: org/springframework/context/config/spring-context-4.3.xsd
[DEBUG] 2017-05-24: 21:06:49 org.springframework.beans.factory.xml.PluggableSchemaResolver.resolveEntity(PluggableSchemaResolver.java:119) :  Found XML schema [http://www.springframework.org/schema/tool/spring-tool-4.3.xsd] in classpath: org/springframework/beans/factory/xml/spring-tool-4.3.xsd
[DEBUG] 2017-05-24: 21:06:49 org.springframework.beans.factory.xml.PluggableSchemaResolver.resolveEntity(PluggableSchemaResolver.java:119) :  Found XML schema [http://www.springframework.org/schema/tx/spring-tx.xsd] in classpath: org/springframework/transaction/config/spring-tx-4.3.xsd
[DEBUG] 2017-05-24: 21:06:49 org.springframework.beans.factory.xml.DefaultBeanDefinitionDocumentReader.registerBeanDefinitions(DefaultBeanDefinitionDocumentReader.java:92) :  Loading bean definitions
[DEBUG] 2017-05-24: 21:06:49 org.springframework.beans.factory.xml.DefaultNamespaceHandlerResolver.getHandlerMappings(DefaultNamespaceHandlerResolver.java:157) :  Loaded NamespaceHandler mappings: {http://www.springframework.org/schema/p=org.springframework.beans.factory.xml.SimplePropertyNamespaceHandler, http://www.springframework.org/schema/util=org.springframework.beans.factory.xml.UtilNamespaceHandler, http://www.springframework.org/schema/jee=org.springframework.ejb.config.JeeNamespaceHandler, http://www.springframework.org/schema/aop=org.springframework.aop.config.AopNamespaceHandler, http://www.springframework.org/schema/jdbc=org.springframework.jdbc.config.JdbcNamespaceHandler, http://www.springframework.org/schema/cache=org.springframework.cache.config.CacheNamespaceHandler, http://www.springframework.org/schema/c=org.springframework.beans.factory.xml.SimpleConstructorNamespaceHandler, http://www.springframework.org/schema/tx=org.springframework.transaction.config.TxNamespaceHandler, http://www.springframework.org/schema/task=org.springframework.scheduling.config.TaskNamespaceHandler, http://www.springframework.org/schema/lang=org.springframework.scripting.config.LangNamespaceHandler, http://www.springframework.org/schema/context=org.springframework.context.config.ContextNamespaceHandler}
[DEBUG] 2017-05-24: 21:06:49 org.springframework.core.env.MutablePropertySources.addLast(MutablePropertySources.java:109) :  Adding [systemProperties] PropertySource with lowest search precedence
[DEBUG] 2017-05-24: 21:06:49 org.springframework.core.env.MutablePropertySources.addLast(MutablePropertySources.java:109) :  Adding [systemEnvironment] PropertySource with lowest search precedence
[DEBUG] 2017-05-24: 21:06:49 org.springframework.core.env.AbstractEnvironment.<init>(AbstractEnvironment.java:124) :  Initialized StandardEnvironment with PropertySources [systemProperties,systemEnvironment]
[DEBUG] 2017-05-24: 21:06:49 org.springframework.context.annotation.ClassPathScanningCandidateComponentProvider.registerDefaultFilters(ClassPathScanningCandidateComponentProvider.java:244) :  JSR-250 'javax.annotation.ManagedBean' found and supported for component scanning
[DEBUG] 2017-05-24: 21:06:49 org.springframework.context.annotation.ClassPathScanningCandidateComponentProvider.registerDefaultFilters(ClassPathScanningCandidateComponentProvider.java:252) :  JSR-330 'javax.inject.Named' annotation found and supported for component scanning
[DEBUG] 2017-05-24: 21:06:49 org.springframework.core.io.support.PathMatchingResourcePatternResolver.findAllClassPathResources(PathMatchingResourcePatternResolver.java:317) :  Resolved classpath location [com/ittx/usermanager/] to resources [URL [file:/D:/projects/workspace_mavens/ssh/ssh-usermanager_annotaion/target/classes/com/ittx/usermanager/]]
[DEBUG] 2017-05-24: 21:06:49 org.springframework.core.io.support.PathMatchingResourcePatternResolver.doFindMatchingFileSystemResources(PathMatchingResourcePatternResolver.java:711) :  Looking for matching resources in directory tree [D:\projects\workspace_mavens\ssh\ssh-usermanager_annotaion\target\classes\com\ittx\usermanager]
[DEBUG] 2017-05-24: 21:06:49 org.springframework.core.io.support.PathMatchingResourcePatternResolver.doRetrieveMatchingFiles(PathMatchingResourcePatternResolver.java:773) :  Searching directory [D:\projects\workspace_mavens\ssh\ssh-usermanager_annotaion\target\classes\com\ittx\usermanager] for files matching pattern [D:/projects/workspace_mavens/ssh/ssh-usermanager_annotaion/target/classes/com/ittx/usermanager/**/*.class]
[DEBUG] 2017-05-24: 21:06:49 org.springframework.core.io.support.PathMatchingResourcePatternResolver.doRetrieveMatchingFiles(PathMatchingResourcePatternResolver.java:773) :  Searching directory [D:\projects\workspace_mavens\ssh\ssh-usermanager_annotaion\target\classes\com\ittx\usermanager\action] for files matching pattern [D:/projects/workspace_mavens/ssh/ssh-usermanager_annotaion/target/classes/com/ittx/usermanager/**/*.class]
[DEBUG] 2017-05-24: 21:06:49 org.springframework.core.io.support.PathMatchingResourcePatternResolver.doRetrieveMatchingFiles(PathMatchingResourcePatternResolver.java:773) :  Searching directory [D:\projects\workspace_mavens\ssh\ssh-usermanager_annotaion\target\classes\com\ittx\usermanager\dao] for files matching pattern [D:/projects/workspace_mavens/ssh/ssh-usermanager_annotaion/target/classes/com/ittx/usermanager/**/*.class]
[DEBUG] 2017-05-24: 21:06:49 org.springframework.core.io.support.PathMatchingResourcePatternResolver.doRetrieveMatchingFiles(PathMatchingResourcePatternResolver.java:773) :  Searching directory [D:\projects\workspace_mavens\ssh\ssh-usermanager_annotaion\target\classes\com\ittx\usermanager\dao\impl] for files matching pattern [D:/projects/workspace_mavens/ssh/ssh-usermanager_annotaion/target/classes/com/ittx/usermanager/**/*.class]
[DEBUG] 2017-05-24: 21:06:49 org.springframework.core.io.support.PathMatchingResourcePatternResolver.doRetrieveMatchingFiles(PathMatchingResourcePatternResolver.java:773) :  Searching directory [D:\projects\workspace_mavens\ssh\ssh-usermanager_annotaion\target\classes\com\ittx\usermanager\model] for files matching pattern [D:/projects/workspace_mavens/ssh/ssh-usermanager_annotaion/target/classes/com/ittx/usermanager/**/*.class]
[DEBUG] 2017-05-24: 21:06:49 org.springframework.core.io.support.PathMatchingResourcePatternResolver.doRetrieveMatchingFiles(PathMatchingResourcePatternResolver.java:773) :  Searching directory [D:\projects\workspace_mavens\ssh\ssh-usermanager_annotaion\target\classes\com\ittx\usermanager\service] for files matching pattern [D:/projects/workspace_mavens/ssh/ssh-usermanager_annotaion/target/classes/com/ittx/usermanager/**/*.class]
[DEBUG] 2017-05-24: 21:06:49 org.springframework.core.io.support.PathMatchingResourcePatternResolver.doRetrieveMatchingFiles(PathMatchingResourcePatternResolver.java:773) :  Searching directory [D:\projects\workspace_mavens\ssh\ssh-usermanager_annotaion\target\classes\com\ittx\usermanager\service\impl] for files matching pattern [D:/projects/workspace_mavens/ssh/ssh-usermanager_annotaion/target/classes/com/ittx/usermanager/**/*.class]
[DEBUG] 2017-05-24: 21:06:49 org.springframework.core.io.support.PathMatchingResourcePatternResolver.doRetrieveMatchingFiles(PathMatchingResourcePatternResolver.java:773) :  Searching directory [D:\projects\workspace_mavens\ssh\ssh-usermanager_annotaion\target\classes\com\ittx\usermanager\util] for files matching pattern [D:/projects/workspace_mavens/ssh/ssh-usermanager_annotaion/target/classes/com/ittx/usermanager/**/*.class]
[DEBUG] 2017-05-24: 21:06:49 org.springframework.core.io.support.PathMatchingResourcePatternResolver.findPathMatchingResources(PathMatchingResourcePatternResolver.java:483) :  Resolved location pattern [classpath*:com/ittx/usermanager/**/*.class] to resources [file [D:\projects\workspace_mavens\ssh\ssh-usermanager_annotaion\target\classes\com\ittx\usermanager\action\BaseAction.class], file [D:\projects\workspace_mavens\ssh\ssh-usermanager_annotaion\target\classes\com\ittx\usermanager\action\LoginAction.class], file [D:\projects\workspace_mavens\ssh\ssh-usermanager_annotaion\target\classes\com\ittx\usermanager\action\UserAction.class], file [D:\projects\workspace_mavens\ssh\ssh-usermanager_annotaion\target\classes\com\ittx\usermanager\dao\impl\UserDaoImpl$1.class], file [D:\projects\workspace_mavens\ssh\ssh-usermanager_annotaion\target\classes\com\ittx\usermanager\dao\impl\UserDaoImpl$2.class], file [D:\projects\workspace_mavens\ssh\ssh-usermanager_annotaion\target\classes\com\ittx\usermanager\dao\impl\UserDaoImpl.class], file [D:\projects\workspace_mavens\ssh\ssh-usermanager_annotaion\target\classes\com\ittx\usermanager\dao\UserDao.class], file [D:\projects\workspace_mavens\ssh\ssh-usermanager_annotaion\target\classes\com\ittx\usermanager\model\User.class], file [D:\projects\workspace_mavens\ssh\ssh-usermanager_annotaion\target\classes\com\ittx\usermanager\service\impl\UserServiceImpl.class], file [D:\projects\workspace_mavens\ssh\ssh-usermanager_annotaion\target\classes\com\ittx\usermanager\service\UserService.class], file [D:\projects\workspace_mavens\ssh\ssh-usermanager_annotaion\target\classes\com\ittx\usermanager\util\ConnectDB.class], file [D:\projects\workspace_mavens\ssh\ssh-usermanager_annotaion\target\classes\com\ittx\usermanager\util\DBConnection.class], file [D:\projects\workspace_mavens\ssh\ssh-usermanager_annotaion\target\classes\com\ittx\usermanager\util\EncodeFilter.class], file [D:\projects\workspace_mavens\ssh\ssh-usermanager_annotaion\target\classes\com\ittx\usermanager\util\HibernateUtil.class], file [D:\projects\workspace_mavens\ssh\ssh-usermanager_annotaion\target\classes\com\ittx\usermanager\util\LoginFilter.class], file [D:\projects\workspace_mavens\ssh\ssh-usermanager_annotaion\target\classes\com\ittx\usermanager\util\MyHibernateDaoSupport.class], file [D:\projects\workspace_mavens\ssh\ssh-usermanager_annotaion\target\classes\com\ittx\usermanager\util\Pager.class], file [D:\projects\workspace_mavens\ssh\ssh-usermanager_annotaion\target\classes\com\ittx\usermanager\util\PagerUtil.class]]
[DEBUG] 2017-05-24: 21:06:49 org.springframework.context.annotation.ClassPathScanningCandidateComponentProvider.findCandidateComponents(ClassPathScanningCandidateComponentProvider.java:286) :  Identified candidate component class: file [D:\projects\workspace_mavens\ssh\ssh-usermanager_annotaion\target\classes\com\ittx\usermanager\action\UserAction.class]
[DEBUG] 2017-05-24: 21:06:49 org.springframework.context.annotation.ClassPathScanningCandidateComponentProvider.findCandidateComponents(ClassPathScanningCandidateComponentProvider.java:286) :  Identified candidate component class: file [D:\projects\workspace_mavens\ssh\ssh-usermanager_annotaion\target\classes\com\ittx\usermanager\dao\impl\UserDaoImpl.class]
[DEBUG] 2017-05-24: 21:06:49 org.springframework.context.annotation.ClassPathScanningCandidateComponentProvider.findCandidateComponents(ClassPathScanningCandidateComponentProvider.java:286) :  Identified candidate component class: file [D:\projects\workspace_mavens\ssh\ssh-usermanager_annotaion\target\classes\com\ittx\usermanager\service\impl\UserServiceImpl.class]
[DEBUG] 2017-05-24: 21:06:49 org.springframework.beans.factory.support.AbstractBeanDefinitionReader.loadBeanDefinitions(AbstractBeanDefinitionReader.java:224) :  Loaded 19 bean definitions from location pattern [classpath:spring-core.xml]
[DEBUG] 2017-05-24: 21:06:49 org.springframework.context.support.AbstractApplicationContext.obtainFreshBeanFactory(AbstractApplicationContext.java:615) :  Bean factory for Root WebApplicationContext: org.springframework.beans.factory.support.DefaultListableBeanFactory@1449f65: defining beans [userAction,userDao,userService,org.springframework.context.annotation.internalConfigurationAnnotationProcessor,org.springframework.context.annotation.internalAutowiredAnnotationProcessor,org.springframework.context.annotation.internalRequiredAnnotationProcessor,org.springframework.context.annotation.internalCommonAnnotationProcessor,org.springframework.context.annotation.internalPersistenceAnnotationProcessor,org.springframework.context.event.internalEventListenerProcessor,org.springframework.context.event.internalEventListenerFactory,org.springframework.context.support.PropertySourcesPlaceholderConfigurer#0,dataSource,sessionFactory,transactionManager,org.springframework.transaction.config.internalTransactionalEventListenerFactory,org.springframework.aop.config.internalAutoProxyCreator,org.springframework.transaction.annotation.AnnotationTransactionAttributeSource#0,org.springframework.transaction.interceptor.TransactionInterceptor#0,org.springframework.transaction.config.internalTransactionAdvisor]; root of factory hierarchy
[DEBUG] 2017-05-24: 21:06:49 org.springframework.beans.factory.support.AbstractBeanFactory.registerScope(AbstractBeanFactory.java:879) :  Registering scope 'request' with implementation [org.springframework.web.context.request.RequestScope@219104]
[DEBUG] 2017-05-24: 21:06:49 org.springframework.beans.factory.support.AbstractBeanFactory.registerScope(AbstractBeanFactory.java:879) :  Registering scope 'session' with implementation [org.springframework.web.context.request.SessionScope@10f96b7]
[DEBUG] 2017-05-24: 21:06:49 org.springframework.beans.factory.support.AbstractBeanFactory.registerScope(AbstractBeanFactory.java:879) :  Registering scope 'globalSession' with implementation [org.springframework.web.context.request.SessionScope@1ec84e3]
[DEBUG] 2017-05-24: 21:06:49 org.springframework.beans.factory.support.AbstractBeanFactory.registerScope(AbstractBeanFactory.java:879) :  Registering scope 'application' with implementation [org.springframework.web.context.support.ServletContextScope@1487147]
[DEBUG] 2017-05-24: 21:06:49 org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:221) :  Creating shared instance of singleton bean 'org.springframework.context.annotation.internalConfigurationAnnotationProcessor'
[DEBUG] 2017-05-24: 21:06:49 org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:448) :  Creating instance of bean 'org.springframework.context.annotation.internalConfigurationAnnotationProcessor'
[DEBUG] 2017-05-24: 21:06:49 org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:529) :  Eagerly caching bean 'org.springframework.context.annotation.internalConfigurationAnnotationProcessor' to allow for resolving potential circular references
[DEBUG] 2017-05-24: 21:06:49 org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:484) :  Finished creating instance of bean 'org.springframework.context.annotation.internalConfigurationAnnotationProcessor'
[DEBUG] 2017-05-24: 21:06:49 org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:221) :  Creating shared instance of singleton bean 'org.springframework.context.support.PropertySourcesPlaceholderConfigurer#0'
[DEBUG] 2017-05-24: 21:06:49 org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:448) :  Creating instance of bean 'org.springframework.context.support.PropertySourcesPlaceholderConfigurer#0'
[DEBUG] 2017-05-24: 21:06:49 org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:529) :  Eagerly caching bean 'org.springframework.context.support.PropertySourcesPlaceholderConfigurer#0' to allow for resolving potential circular references
[DEBUG] 2017-05-24: 21:06:49 org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:484) :  Finished creating instance of bean 'org.springframework.context.support.PropertySourcesPlaceholderConfigurer#0'
[DEBUG] 2017-05-24: 21:06:49 org.springframework.core.env.MutablePropertySources.addLast(MutablePropertySources.java:109) :  Adding [environmentProperties] PropertySource with lowest search precedence
[INFO] 2017-05-24: 21:06:49 org.springframework.core.io.support.PropertiesLoaderSupport.loadProperties(PropertiesLoaderSupport.java:172) :  Loading properties file from class path resource [jdbc.properties]
[DEBUG] 2017-05-24: 21:06:49 org.springframework.core.env.MutablePropertySources.addLast(MutablePropertySources.java:109) :  Adding [localProperties] PropertySource with lowest search precedence
[DEBUG] 2017-05-24: 21:06:49 org.springframework.jndi.JndiTemplate.lookup(JndiTemplate.java:150) :  Looking up JNDI object with name [java:comp/env/jdbc.driverClassName]
[DEBUG] 2017-05-24: 21:06:49 org.springframework.jndi.JndiLocatorSupport.lookup(JndiLocatorSupport.java:101) :  Converted JNDI name [java:comp/env/jdbc.driverClassName] not found - trying original name [jdbc.driverClassName]. javax.naming.NameNotFoundException; remaining name 'jdbc.driverClassName'
[DEBUG] 2017-05-24: 21:06:49 org.springframework.jndi.JndiTemplate.lookup(JndiTemplate.java:150) :  Looking up JNDI object with name [jdbc.driverClassName]
[DEBUG] 2017-05-24: 21:06:49 org.springframework.jndi.JndiPropertySource.getProperty(JndiPropertySource.java:99) :  JNDI lookup for name [jdbc.driverClassName] threw NamingException with message: null. Returning null.
[DEBUG] 2017-05-24: 21:06:49 org.springframework.core.env.PropertySourcesPropertyResolver.getProperty(PropertySourcesPropertyResolver.java:91) :  Could not find key 'jdbc.driverClassName' in any property source
[DEBUG] 2017-05-24: 21:06:49 org.springframework.core.env.PropertySourcesPropertyResolver.logKeyFound(PropertySourcesPropertyResolver.java:151) :  Found key 'jdbc.driverClassName' in [localProperties] with type [String]
[DEBUG] 2017-05-24: 21:06:49 org.springframework.jndi.JndiTemplate.lookup(JndiTemplate.java:150) :  Looking up JNDI object with name [java:comp/env/jdbc.url]
[DEBUG] 2017-05-24: 21:06:49 org.springframework.jndi.JndiLocatorSupport.lookup(JndiLocatorSupport.java:101) :  Converted JNDI name [java:comp/env/jdbc.url] not found - trying original name [jdbc.url]. javax.naming.NameNotFoundException; remaining name 'jdbc.url'
[DEBUG] 2017-05-24: 21:06:49 org.springframework.jndi.JndiTemplate.lookup(JndiTemplate.java:150) :  Looking up JNDI object with name [jdbc.url]
[DEBUG] 2017-05-24: 21:06:49 org.springframework.jndi.JndiPropertySource.getProperty(JndiPropertySource.java:99) :  JNDI lookup for name [jdbc.url] threw NamingException with message: null. Returning null.
[DEBUG] 2017-05-24: 21:06:49 org.springframework.core.env.PropertySourcesPropertyResolver.getProperty(PropertySourcesPropertyResolver.java:91) :  Could not find key 'jdbc.url' in any property source
[DEBUG] 2017-05-24: 21:06:49 org.springframework.core.env.PropertySourcesPropertyResolver.logKeyFound(PropertySourcesPropertyResolver.java:151) :  Found key 'jdbc.url' in [localProperties] with type [String]
[DEBUG] 2017-05-24: 21:06:49 org.springframework.jndi.JndiTemplate.lookup(JndiTemplate.java:150) :  Looking up JNDI object with name [java:comp/env/jdbc.username]
[DEBUG] 2017-05-24: 21:06:49 org.springframework.jndi.JndiLocatorSupport.lookup(JndiLocatorSupport.java:101) :  Converted JNDI name [java:comp/env/jdbc.username] not found - trying original name [jdbc.username]. javax.naming.NameNotFoundException; remaining name 'jdbc.username'
[DEBUG] 2017-05-24: 21:06:49 org.springframework.jndi.JndiTemplate.lookup(JndiTemplate.java:150) :  Looking up JNDI object with name [jdbc.username]
[DEBUG] 2017-05-24: 21:06:49 org.springframework.jndi.JndiPropertySource.getProperty(JndiPropertySource.java:99) :  JNDI lookup for name [jdbc.username] threw NamingException with message: null. Returning null.
[DEBUG] 2017-05-24: 21:06:49 org.springframework.core.env.PropertySourcesPropertyResolver.getProperty(PropertySourcesPropertyResolver.java:91) :  Could not find key 'jdbc.username' in any property source
[DEBUG] 2017-05-24: 21:06:49 org.springframework.core.env.PropertySourcesPropertyResolver.logKeyFound(PropertySourcesPropertyResolver.java:151) :  Found key 'jdbc.username' in [localProperties] with type [String]
[DEBUG] 2017-05-24: 21:06:49 org.springframework.jndi.JndiTemplate.lookup(JndiTemplate.java:150) :  Looking up JNDI object with name [java:comp/env/jdbc.password]
[DEBUG] 2017-05-24: 21:06:49 org.springframework.jndi.JndiLocatorSupport.lookup(JndiLocatorSupport.java:101) :  Converted JNDI name [java:comp/env/jdbc.password] not found - trying original name [jdbc.password]. javax.naming.NameNotFoundException; remaining name 'jdbc.password'
[DEBUG] 2017-05-24: 21:06:49 org.springframework.jndi.JndiTemplate.lookup(JndiTemplate.java:150) :  Looking up JNDI object with name [jdbc.password]
[DEBUG] 2017-05-24: 21:06:49 org.springframework.jndi.JndiPropertySource.getProperty(JndiPropertySource.java:99) :  JNDI lookup for name [jdbc.password] threw NamingException with message: null. Returning null.
[DEBUG] 2017-05-24: 21:06:49 org.springframework.core.env.PropertySourcesPropertyResolver.getProperty(PropertySourcesPropertyResolver.java:91) :  Could not find key 'jdbc.password' in any property source
[DEBUG] 2017-05-24: 21:06:49 org.springframework.core.env.PropertySourcesPropertyResolver.logKeyFound(PropertySourcesPropertyResolver.java:151) :  Found key 'jdbc.password' in [localProperties] with type [String]
[DEBUG] 2017-05-24: 21:06:49 org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:221) :  Creating shared instance of singleton bean 'org.springframework.context.annotation.internalAutowiredAnnotationProcessor'
[DEBUG] 2017-05-24: 21:06:49 org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:448) :  Creating instance of bean 'org.springframework.context.annotation.internalAutowiredAnnotationProcessor'
[INFO] 2017-05-24: 21:06:49 org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor.<init>(AutowiredAnnotationBeanPostProcessor.java:155) :  JSR-330 'javax.inject.Inject' annotation found and supported for autowiring
[DEBUG] 2017-05-24: 21:06:49 org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:529) :  Eagerly caching bean 'org.springframework.context.annotation.internalAutowiredAnnotationProcessor' to allow for resolving potential circular references
[DEBUG] 2017-05-24: 21:06:49 org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:484) :  Finished creating instance of bean 'org.springframework.context.annotation.internalAutowiredAnnotationProcessor'
[DEBUG] 2017-05-24: 21:06:49 org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:221) :  Creating shared instance of singleton bean 'org.springframework.context.annotation.internalRequiredAnnotationProcessor'
[DEBUG] 2017-05-24: 21:06:49 org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:448) :  Creating instance of bean 'org.springframework.context.annotation.internalRequiredAnnotationProcessor'
[DEBUG] 2017-05-24: 21:06:49 org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:529) :  Eagerly caching bean 'org.springframework.context.annotation.internalRequiredAnnotationProcessor' to allow for resolving potential circular references
[DEBUG] 2017-05-24: 21:06:49 org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:484) :  Finished creating instance of bean 'org.springframework.context.annotation.internalRequiredAnnotationProcessor'
[DEBUG] 2017-05-24: 21:06:49 org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:221) :  Creating shared instance of singleton bean 'org.springframework.context.annotation.internalCommonAnnotationProcessor'
[DEBUG] 2017-05-24: 21:06:49 org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:448) :  Creating instance of bean 'org.springframework.context.annotation.internalCommonAnnotationProcessor'
[DEBUG] 2017-05-24: 21:06:49 org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:529) :  Eagerly caching bean 'org.springframework.context.annotation.internalCommonAnnotationProcessor' to allow for resolving potential circular references
[DEBUG] 2017-05-24: 21:06:49 org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:484) :  Finished creating instance of bean 'org.springframework.context.annotation.internalCommonAnnotationProcessor'
[DEBUG] 2017-05-24: 21:06:49 org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:221) :  Creating shared instance of singleton bean 'org.springframework.context.annotation.internalPersistenceAnnotationProcessor'
[DEBUG] 2017-05-24: 21:06:49 org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:448) :  Creating instance of bean 'org.springframework.context.annotation.internalPersistenceAnnotationProcessor'
[DEBUG] 2017-05-24: 21:06:49 org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:529) :  Eagerly caching bean 'org.springframework.context.annotation.internalPersistenceAnnotationProcessor' to allow for resolving potential circular references
[DEBUG] 2017-05-24: 21:06:49 org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:484) :  Finished creating instance of bean 'org.springframework.context.annotation.internalPersistenceAnnotationProcessor'
[DEBUG] 2017-05-24: 21:06:49 org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:221) :  Creating shared instance of singleton bean 'org.springframework.context.annotation.ConfigurationClassPostProcessor.importAwareProcessor'
[DEBUG] 2017-05-24: 21:06:49 org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:448) :  Creating instance of bean 'org.springframework.context.annotation.ConfigurationClassPostProcessor.importAwareProcessor'
[DEBUG] 2017-05-24: 21:06:49 org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:529) :  Eagerly caching bean 'org.springframework.context.annotation.ConfigurationClassPostProcessor.importAwareProcessor' to allow for resolving potential circular references
[DEBUG] 2017-05-24: 21:06:49 org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:484) :  Finished creating instance of bean 'org.springframework.context.annotation.ConfigurationClassPostProcessor.importAwareProcessor'
[DEBUG] 2017-05-24: 21:06:49 org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:221) :  Creating shared instance of singleton bean 'org.springframework.context.annotation.ConfigurationClassPostProcessor.enhancedConfigurationProcessor'
[DEBUG] 2017-05-24: 21:06:49 org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:448) :  Creating instance of bean 'org.springframework.context.annotation.ConfigurationClassPostProcessor.enhancedConfigurationProcessor'
[DEBUG] 2017-05-24: 21:06:49 org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:529) :  Eagerly caching bean 'org.springframework.context.annotation.ConfigurationClassPostProcessor.enhancedConfigurationProcessor' to allow for resolving potential circular references
[DEBUG] 2017-05-24: 21:06:49 org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:484) :  Finished creating instance of bean 'org.springframework.context.annotation.ConfigurationClassPostProcessor.enhancedConfigurationProcessor'
[DEBUG] 2017-05-24: 21:06:49 org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:221) :  Creating shared instance of singleton bean 'org.springframework.aop.config.internalAutoProxyCreator'
[DEBUG] 2017-05-24: 21:06:49 org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:448) :  Creating instance of bean 'org.springframework.aop.config.internalAutoProxyCreator'
[DEBUG] 2017-05-24: 21:06:49 org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:529) :  Eagerly caching bean 'org.springframework.aop.config.internalAutoProxyCreator' to allow for resolving potential circular references
[DEBUG] 2017-05-24: 21:06:49 org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:484) :  Finished creating instance of bean 'org.springframework.aop.config.internalAutoProxyCreator'
[DEBUG] 2017-05-24: 21:06:49 org.springframework.context.support.AbstractApplicationContext.initMessageSource(AbstractApplicationContext.java:728) :  Unable to locate MessageSource with name 'messageSource': using default [org.springframework.context.support.DelegatingMessageSource@8321]
[DEBUG] 2017-05-24: 21:06:49 org.springframework.context.support.AbstractApplicationContext.initApplicationEventMulticaster(AbstractApplicationContext.java:752) :  Unable to locate ApplicationEventMulticaster with name 'applicationEventMulticaster': using default [org.springframework.context.event.SimpleApplicationEventMulticaster@c8c874]
[DEBUG] 2017-05-24: 21:06:49 org.springframework.ui.context.support.UiApplicationContextUtils.initThemeSource(UiApplicationContextUtils.java:85) :  Unable to locate ThemeSource with name 'themeSource': using default [org.springframework.ui.context.support.ResourceBundleThemeSource@5d2c27]
[DEBUG] 2017-05-24: 21:06:49 org.springframework.beans.factory.support.DefaultListableBeanFactory.preInstantiateSingletons(DefaultListableBeanFactory.java:720) :  Pre-instantiating singletons in org.springframework.beans.factory.support.DefaultListableBeanFactory@1449f65: defining beans [userAction,userDao,userService,org.springframework.context.annotation.internalConfigurationAnnotationProcessor,org.springframework.context.annotation.internalAutowiredAnnotationProcessor,org.springframework.context.annotation.internalRequiredAnnotationProcessor,org.springframework.context.annotation.internalCommonAnnotationProcessor,org.springframework.context.annotation.internalPersistenceAnnotationProcessor,org.springframework.context.event.internalEventListenerProcessor,org.springframework.context.event.internalEventListenerFactory,org.springframework.context.support.PropertySourcesPlaceholderConfigurer#0,dataSource,sessionFactory,transactionManager,org.springframework.transaction.config.internalTransactionalEventListenerFactory,org.springframework.aop.config.internalAutoProxyCreator,org.springframework.transaction.annotation.AnnotationTransactionAttributeSource#0,org.springframework.transaction.interceptor.TransactionInterceptor#0,org.springframework.transaction.config.internalTransactionAdvisor,org.springframework.context.annotation.ConfigurationClassPostProcessor.importAwareProcessor,org.springframework.context.annotation.ConfigurationClassPostProcessor.enhancedConfigurationProcessor]; root of factory hierarchy
[DEBUG] 2017-05-24: 21:06:49 org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:221) :  Creating shared instance of singleton bean 'userAction'
[DEBUG] 2017-05-24: 21:06:49 org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:448) :  Creating instance of bean 'userAction'
[DEBUG] 2017-05-24: 21:06:49 org.springframework.beans.factory.annotation.InjectionMetadata.checkConfigMembers(InjectionMetadata.java:72) :  Registered injected element on class [com.ittx.usermanager.action.UserAction]: AutowiredFieldElement for private com.ittx.usermanager.service.UserService com.ittx.usermanager.action.UserAction.userService
[DEBUG] 2017-05-24: 21:06:49 org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:529) :  Eagerly caching bean 'userAction' to allow for resolving potential circular references
[DEBUG] 2017-05-24: 21:06:49 org.springframework.beans.factory.annotation.InjectionMetadata.inject(InjectionMetadata.java:86) :  Processing injected element of bean 'userAction': AutowiredFieldElement for private com.ittx.usermanager.service.UserService com.ittx.usermanager.action.UserAction.userService
[DEBUG] 2017-05-24: 21:06:49 org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:221) :  Creating shared instance of singleton bean 'userService'
[DEBUG] 2017-05-24: 21:06:49 org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:448) :  Creating instance of bean 'userService'
[DEBUG] 2017-05-24: 21:06:49 org.springframework.beans.factory.annotation.InjectionMetadata.checkConfigMembers(InjectionMetadata.java:72) :  Registered injected element on class [com.ittx.usermanager.service.impl.UserServiceImpl]: AutowiredFieldElement for private com.ittx.usermanager.dao.UserDao com.ittx.usermanager.service.impl.UserServiceImpl.userDao
[DEBUG] 2017-05-24: 21:06:49 org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:529) :  Eagerly caching bean 'userService' to allow for resolving potential circular references
[DEBUG] 2017-05-24: 21:06:49 org.springframework.beans.factory.annotation.InjectionMetadata.inject(InjectionMetadata.java:86) :  Processing injected element of bean 'userService': AutowiredFieldElement for private com.ittx.usermanager.dao.UserDao com.ittx.usermanager.service.impl.UserServiceImpl.userDao
[DEBUG] 2017-05-24: 21:06:49 org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:221) :  Creating shared instance of singleton bean 'userDao'
[DEBUG] 2017-05-24: 21:06:49 org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:448) :  Creating instance of bean 'userDao'
[DEBUG] 2017-05-24: 21:06:49 org.springframework.beans.factory.annotation.InjectionMetadata.checkConfigMembers(InjectionMetadata.java:72) :  Registered injected element on class [com.ittx.usermanager.dao.impl.UserDaoImpl]: ResourceElement for public void com.ittx.usermanager.util.MyHibernateDaoSupport.setSuperSessionFactory(org.hibernate.SessionFactory)
[DEBUG] 2017-05-24: 21:06:49 org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:529) :  Eagerly caching bean 'userDao' to allow for resolving potential circular references
[DEBUG] 2017-05-24: 21:06:49 org.springframework.beans.factory.annotation.InjectionMetadata.inject(InjectionMetadata.java:86) :  Processing injected element of bean 'userDao': ResourceElement for public void com.ittx.usermanager.util.MyHibernateDaoSupport.setSuperSessionFactory(org.hibernate.SessionFactory)
[DEBUG] 2017-05-24: 21:06:49 org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:221) :  Creating shared instance of singleton bean 'sessionFactory'
[DEBUG] 2017-05-24: 21:06:49 org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:448) :  Creating instance of bean 'sessionFactory'
[DEBUG] 2017-05-24: 21:06:49 org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:529) :  Eagerly caching bean 'sessionFactory' to allow for resolving potential circular references
[DEBUG] 2017-05-24: 21:06:49 org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:221) :  Creating shared instance of singleton bean 'dataSource'
[DEBUG] 2017-05-24: 21:06:49 org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:448) :  Creating instance of bean 'dataSource'
[DEBUG] 2017-05-24: 21:06:49 org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:529) :  Eagerly caching bean 'dataSource' to allow for resolving potential circular references
[INFO] 2017-05-24: 21:06:49 org.springframework.jdbc.datasource.DriverManagerDataSource.setDriverClassName(DriverManagerDataSource.java:133) :  Loaded JDBC driver: com.mysql.jdbc.Driver
[DEBUG] 2017-05-24: 21:06:49 org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:221) :  Creating shared instance of singleton bean 'org.springframework.transaction.config.internalTransactionAdvisor'
[DEBUG] 2017-05-24: 21:06:49 org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:448) :  Creating instance of bean 'org.springframework.transaction.config.internalTransactionAdvisor'
[DEBUG] 2017-05-24: 21:06:49 org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:529) :  Eagerly caching bean 'org.springframework.transaction.config.internalTransactionAdvisor' to allow for resolving potential circular references
[DEBUG] 2017-05-24: 21:06:49 org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:221) :  Creating shared instance of singleton bean 'org.springframework.transaction.annotation.AnnotationTransactionAttributeSource#0'
[DEBUG] 2017-05-24: 21:06:49 org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:448) :  Creating instance of bean 'org.springframework.transaction.annotation.AnnotationTransactionAttributeSource#0'
[DEBUG] 2017-05-24: 21:06:49 org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:529) :  Eagerly caching bean 'org.springframework.transaction.annotation.AnnotationTransactionAttributeSource#0' to allow for resolving potential circular references
[DEBUG] 2017-05-24: 21:06:49 org.springframework.aop.framework.autoproxy.BeanFactoryAdvisorRetrievalHelper.findAdvisorBeans(BeanFactoryAdvisorRetrievalHelper.java:87) :  Skipping currently created advisor 'org.springframework.transaction.config.internalTransactionAdvisor'
[DEBUG] 2017-05-24: 21:06:49 org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:484) :  Finished creating instance of bean 'org.springframework.transaction.annotation.AnnotationTransactionAttributeSource#0'
[DEBUG] 2017-05-24: 21:06:49 org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:484) :  Finished creating instance of bean 'org.springframework.transaction.config.internalTransactionAdvisor'
[DEBUG] 2017-05-24: 21:06:49 org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:484) :  Finished creating instance of bean 'dataSource'
[DEBUG] 2017-05-24: 21:06:49 org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.invokeInitMethods(AbstractAutowireCapableBeanFactory.java:1625) :  Invoking afterPropertiesSet() on bean with name 'sessionFactory'
[DEBUG] 2017-05-24: 21:06:49 org.hibernate.cfg.Configuration.<clinit>(Configuration.java:194) :  Logging Provider: org.jboss.logging.Log4jLoggerProvider
[DEBUG] 2017-05-24: 21:06:49 org.hibernate.type.BasicTypeRegistry.register(BasicTypeRegistry.java:146) :  Adding type registration boolean -> org.hibernate.type.BooleanType@1dc246
[DEBUG] 2017-05-24: 21:06:49 org.hibernate.type.BasicTypeRegistry.register(BasicTypeRegistry.java:146) :  Adding type registration boolean -> org.hibernate.type.BooleanType@1dc246
[DEBUG] 2017-05-24: 21:06:49 org.hibernate.type.BasicTypeRegistry.register(BasicTypeRegistry.java:146) :  Adding type registration java.lang.Boolean -> org.hibernate.type.BooleanType@1dc246
[DEBUG] 2017-05-24: 21:06:49 org.hibernate.type.BasicTypeRegistry.register(BasicTypeRegistry.java:146) :  Adding type registration numeric_boolean -> org.hibernate.type.NumericBooleanType@4f6d5b
[DEBUG] 2017-05-24: 21:06:49 org.hibernate.type.BasicTypeRegistry.register(BasicTypeRegistry.java:146) :  Adding type registration true_false -> org.hibernate.type.TrueFalseType@f03ab0
[DEBUG] 2017-05-24: 21:06:49 org.hibernate.type.BasicTypeRegistry.register(BasicTypeRegistry.java:146) :  Adding type registration yes_no -> org.hibernate.type.YesNoType@197174b
[DEBUG] 2017-05-24: 21:06:49 org.hibernate.type.BasicTypeRegistry.register(BasicTypeRegistry.java:146) :  Adding type registration byte -> org.hibernate.type.ByteType@c2b4c6
[DEBUG] 2017-05-24: 21:06:49 org.hibernate.type.BasicTypeRegistry.register(BasicTypeRegistry.java:146) :  Adding type registration byte -> org.hibernate.type.ByteType@c2b4c6
[DEBUG] 2017-05-24: 21:06:49 org.hibernate.type.BasicTypeRegistry.register(BasicTypeRegistry.java:146) :  Adding type registration java.lang.Byte -> org.hibernate.type.ByteType@c2b4c6
[DEBUG] 2017-05-24: 21:06:49 org.hibernate.type.BasicTypeRegistry.register(BasicTypeRegistry.java:146) :  Adding type registration character -> org.hibernate.type.CharacterType@6f428e
[DEBUG] 2017-05-24: 21:06:49 org.hibernate.type.BasicTypeRegistry.register(BasicTypeRegistry.java:146) :  Adding type registration char -> org.hibernate.type.CharacterType@6f428e
[DEBUG] 2017-05-24: 21:06:49 org.hibernate.type.BasicTypeRegistry.register(BasicTypeRegistry.java:146) :  Adding type registration java.lang.Character -> org.hibernate.type.CharacterType@6f428e
[DEBUG] 2017-05-24: 21:06:49 org.hibernate.type.BasicTypeRegistry.register(BasicTypeRegistry.java:146) :  Adding type registration short -> org.hibernate.type.ShortType@4f5062
[DEBUG] 2017-05-24: 21:06:49 org.hibernate.type.BasicTypeRegistry.register(BasicTypeRegistry.java:146) :  Adding type registration short -> org.hibernate.type.ShortType@4f5062
[DEBUG] 2017-05-24: 21:06:49 org.hibernate.type.BasicTypeRegistry.register(BasicTypeRegistry.java:146) :  Adding type registration java.lang.Short -> org.hibernate.type.ShortType@4f5062
[DEBUG] 2017-05-24: 21:06:49 org.hibernate.type.BasicTypeRegistry.register(BasicTypeRegistry.java:146) :  Adding type registration integer -> org.hibernate.type.IntegerType@a0364a
[DEBUG] 2017-05-24: 21:06:49 org.hibernate.type.BasicTypeRegistry.register(BasicTypeRegistry.java:146) :  Adding type registration int -> org.hibernate.type.IntegerType@a0364a
[DEBUG] 2017-05-24: 21:06:49 org.hibernate.type.BasicTypeRegistry.register(BasicTypeRegistry.java:146) :  Adding type registration java.lang.Integer -> org.hibernate.type.IntegerType@a0364a
[DEBUG] 2017-05-24: 21:06:49 org.hibernate.type.BasicTypeRegistry.register(BasicTypeRegistry.java:146) :  Adding type registration long -> org.hibernate.type.LongType@1ea3a5f
[DEBUG] 2017-05-24: 21:06:49 org.hibernate.type.BasicTypeRegistry.register(BasicTypeRegistry.java:146) :  Adding type registration long -> org.hibernate.type.LongType@1ea3a5f
[DEBUG] 2017-05-24: 21:06:49 org.hibernate.type.BasicTypeRegistry.register(BasicTypeRegistry.java:146) :  Adding type registration java.lang.Long -> org.hibernate.type.LongType@1ea3a5f
[DEBUG] 2017-05-24: 21:06:49 org.hibernate.type.BasicTypeRegistry.register(BasicTypeRegistry.java:146) :  Adding type registration float -> org.hibernate.type.FloatType@130a229
[DEBUG] 2017-05-24: 21:06:49 org.hibernate.type.BasicTypeRegistry.register(BasicTypeRegistry.java:146) :  Adding type registration float -> org.hibernate.type.FloatType@130a229
[DEBUG] 2017-05-24: 21:06:49 org.hibernate.type.BasicTypeRegistry.register(BasicTypeRegistry.java:146) :  Adding type registration java.lang.Float -> org.hibernate.type.FloatType@130a229
[DEBUG] 2017-05-24: 21:06:49 org.hibernate.type.BasicTypeRegistry.register(BasicTypeRegistry.java:146) :  Adding type registration double -> org.hibernate.type.DoubleType@31786b
[DEBUG] 2017-05-24: 21:06:49 org.hibernate.type.BasicTypeRegistry.register(BasicTypeRegistry.java:146) :  Adding type registration double -> org.hibernate.type.DoubleType@31786b
[DEBUG] 2017-05-24: 21:06:49 org.hibernate.type.BasicTypeRegistry.register(BasicTypeRegistry.java:146) :  Adding type registration java.lang.Double -> org.hibernate.type.DoubleType@31786b
[DEBUG] 2017-05-24: 21:06:49 org.hibernate.type.BasicTypeRegistry.register(BasicTypeRegistry.java:146) :  Adding type registration big_decimal -> org.hibernate.type.BigDecimalType@2ea857
[DEBUG] 2017-05-24: 21:06:49 org.hibernate.type.BasicTypeRegistry.register(BasicTypeRegistry.java:146) :  Adding type registration java.math.BigDecimal -> org.hibernate.type.BigDecimalType@2ea857
[DEBUG] 2017-05-24: 21:06:49 org.hibernate.type.BasicTypeRegistry.register(BasicTypeRegistry.java:146) :  Adding type registration big_integer -> org.hibernate.type.BigIntegerType@1cc7d9e
[DEBUG] 2017-05-24: 21:06:49 org.hibernate.type.BasicTypeRegistry.register(BasicTypeRegistry.java:146) :  Adding type registration java.math.BigInteger -> org.hibernate.type.BigIntegerType@1cc7d9e
[DEBUG] 2017-05-24: 21:06:49 org.hibernate.type.BasicTypeRegistry.register(BasicTypeRegistry.java:146) :  Adding type registration string -> org.hibernate.type.StringType@1e323a6
[DEBUG] 2017-05-24: 21:06:49 org.hibernate.type.BasicTypeRegistry.register(BasicTypeRegistry.java:146) :  Adding type registration java.lang.String -> org.hibernate.type.StringType@1e323a6
[DEBUG] 2017-05-24: 21:06:49 org.hibernate.type.BasicTypeRegistry.register(BasicTypeRegistry.java:146) :  Adding type registration nstring -> org.hibernate.type.StringNVarcharType@1d10078
[DEBUG] 2017-05-24: 21:06:49 org.hibernate.type.BasicTypeRegistry.register(BasicTypeRegistry.java:146) :  Adding type registration ncharacter -> org.hibernate.type.CharacterNCharType@4398d
[DEBUG] 2017-05-24: 21:06:49 org.hibernate.type.BasicTypeRegistry.register(BasicTypeRegistry.java:146) :  Adding type registration url -> org.hibernate.type.UrlType@191e9c9
[DEBUG] 2017-05-24: 21:06:49 org.hibernate.type.BasicTypeRegistry.register(BasicTypeRegistry.java:146) :  Adding type registration java.net.URL -> org.hibernate.type.UrlType@191e9c9
[DEBUG] 2017-05-24: 21:06:49 org.hibernate.type.BasicTypeRegistry.register(BasicTypeRegistry.java:146) :  Adding type registration date -> org.hibernate.type.DateType@1c3bf09
[DEBUG] 2017-05-24: 21:06:49 org.hibernate.type.BasicTypeRegistry.register(BasicTypeRegistry.java:146) :  Adding type registration java.sql.Date -> org.hibernate.type.DateType@1c3bf09
[DEBUG] 2017-05-24: 21:06:49 org.hibernate.type.BasicTypeRegistry.register(BasicTypeRegistry.java:146) :  Adding type registration time -> org.hibernate.type.TimeType@bd4486
[DEBUG] 2017-05-24: 21:06:49 org.hibernate.type.BasicTypeRegistry.register(BasicTypeRegistry.java:146) :  Adding type registration java.sql.Time -> org.hibernate.type.TimeType@bd4486
[DEBUG] 2017-05-24: 21:06:49 org.hibernate.type.BasicTypeRegistry.register(BasicTypeRegistry.java:146) :  Adding type registration timestamp -> org.hibernate.type.TimestampType@11381fc
[DEBUG] 2017-05-24: 21:06:49 org.hibernate.type.BasicTypeRegistry.register(BasicTypeRegistry.java:146) :  Adding type registration java.sql.Timestamp -> org.hibernate.type.TimestampType@11381fc
[DEBUG] 2017-05-24: 21:06:49 org.hibernate.type.BasicTypeRegistry.register(BasicTypeRegistry.java:146) :  Adding type registration java.util.Date -> org.hibernate.type.TimestampType@11381fc
[DEBUG] 2017-05-24: 21:06:49 org.hibernate.type.BasicTypeRegistry.register(BasicTypeRegistry.java:146) :  Adding type registration dbtimestamp -> org.hibernate.type.DbTimestampType@1b53b76
[DEBUG] 2017-05-24: 21:06:49 org.hibernate.type.BasicTypeRegistry.register(BasicTypeRegistry.java:146) :  Adding type registration calendar -> org.hibernate.type.CalendarType@1bd0b3c
[DEBUG] 2017-05-24: 21:06:49 org.hibernate.type.BasicTypeRegistry.register(BasicTypeRegistry.java:146) :  Adding type registration java.util.Calendar -> org.hibernate.type.CalendarType@1bd0b3c
[DEBUG] 2017-05-24: 21:06:49 org.hibernate.type.BasicTypeRegistry.register(BasicTypeRegistry.java:146) :  Adding type registration java.util.GregorianCalendar -> org.hibernate.type.CalendarType@1bd0b3c
[DEBUG] 2017-05-24: 21:06:49 org.hibernate.type.BasicTypeRegistry.register(BasicTypeRegistry.java:146) :  Adding type registration calendar_date -> org.hibernate.type.CalendarDateType@1eb5ed6
[DEBUG] 2017-05-24: 21:06:49 org.hibernate.type.BasicTypeRegistry.register(BasicTypeRegistry.java:146) :  Adding type registration locale -> org.hibernate.type.LocaleType@ace68f
[DEBUG] 2017-05-24: 21:06:49 org.hibernate.type.BasicTypeRegistry.register(BasicTypeRegistry.java:146) :  Adding type registration java.util.Locale -> org.hibernate.type.LocaleType@ace68f
[DEBUG] 2017-05-24: 21:06:49 org.hibernate.type.BasicTypeRegistry.register(BasicTypeRegistry.java:146) :  Adding type registration currency -> org.hibernate.type.CurrencyType@153995c
[DEBUG] 2017-05-24: 21:06:49 org.hibernate.type.BasicTypeRegistry.register(BasicTypeRegistry.java:146) :  Adding type registration java.util.Currency -> org.hibernate.type.CurrencyType@153995c
[DEBUG] 2017-05-24: 21:06:49 org.hibernate.type.BasicTypeRegistry.register(BasicTypeRegistry.java:146) :  Adding type registration timezone -> org.hibernate.type.TimeZoneType@10635f8
[DEBUG] 2017-05-24: 21:06:49 org.hibernate.type.BasicTypeRegistry.register(BasicTypeRegistry.java:146) :  Adding type registration java.util.TimeZone -> org.hibernate.type.TimeZoneType@10635f8
[DEBUG] 2017-05-24: 21:06:49 org.hibernate.type.BasicTypeRegistry.register(BasicTypeRegistry.java:146) :  Adding type registration class -> org.hibernate.type.ClassType@192d69b
[DEBUG] 2017-05-24: 21:06:49 org.hibernate.type.BasicTypeRegistry.register(BasicTypeRegistry.java:146) :  Adding type registration java.lang.Class -> org.hibernate.type.ClassType@192d69b
[DEBUG] 2017-05-24: 21:06:49 org.hibernate.type.BasicTypeRegistry.register(BasicTypeRegistry.java:146) :  Adding type registration uuid-binary -> org.hibernate.type.UUIDBinaryType@7c5f20
[DEBUG] 2017-05-24: 21:06:49 org.hibernate.type.BasicTypeRegistry.register(BasicTypeRegistry.java:146) :  Adding type registration java.util.UUID -> org.hibernate.type.UUIDBinaryType@7c5f20
[DEBUG] 2017-05-24: 21:06:49 org.hibernate.type.BasicTypeRegistry.register(BasicTypeRegistry.java:146) :  Adding type registration uuid-char -> org.hibernate.type.UUIDCharType@11cc6fc
[DEBUG] 2017-05-24: 21:06:49 org.hibernate.type.BasicTypeRegistry.register(BasicTypeRegistry.java:146) :  Adding type registration pg-uuid -> org.hibernate.type.PostgresUUIDType@47c594
[DEBUG] 2017-05-24: 21:06:49 org.hibernate.type.BasicTypeRegistry.register(BasicTypeRegistry.java:146) :  Adding type registration binary -> org.hibernate.type.BinaryType@1976f43
[DEBUG] 2017-05-24: 21:06:49 org.hibernate.type.BasicTypeRegistry.register(BasicTypeRegistry.java:146) :  Adding type registration byte[] -> org.hibernate.type.BinaryType@1976f43
[DEBUG] 2017-05-24: 21:06:49 org.hibernate.type.BasicTypeRegistry.register(BasicTypeRegistry.java:146) :  Adding type registration [B -> org.hibernate.type.BinaryType@1976f43
[DEBUG] 2017-05-24: 21:06:49 org.hibernate.type.BasicTypeRegistry.register(BasicTypeRegistry.java:146) :  Adding type registration wrapper-binary -> org.hibernate.type.WrapperBinaryType@1bab7c7
[DEBUG] 2017-05-24: 21:06:49 org.hibernate.type.BasicTypeRegistry.register(BasicTypeRegistry.java:146) :  Adding type registration Byte[] -> org.hibernate.type.WrapperBinaryType@1bab7c7
[DEBUG] 2017-05-24: 21:06:49 org.hibernate.type.BasicTypeRegistry.register(BasicTypeRegistry.java:146) :  Adding type registration [Ljava.lang.Byte; -> org.hibernate.type.WrapperBinaryType@1bab7c7
[DEBUG] 2017-05-24: 21:06:49 org.hibernate.type.BasicTypeRegistry.register(BasicTypeRegistry.java:146) :  Adding type registration image -> org.hibernate.type.ImageType@99794d
[DEBUG] 2017-05-24: 21:06:49 org.hibernate.type.BasicTypeRegistry.register(BasicTypeRegistry.java:146) :  Adding type registration characters -> org.hibernate.type.CharArrayType@1a2e86e
[DEBUG] 2017-05-24: 21:06:49 org.hibernate.type.BasicTypeRegistry.register(BasicTypeRegistry.java:146) :  Adding type registration char[] -> org.hibernate.type.CharArrayType@1a2e86e
[DEBUG] 2017-05-24: 21:06:49 org.hibernate.type.BasicTypeRegistry.register(BasicTypeRegistry.java:146) :  Adding type registration [C -> org.hibernate.type.CharArrayType@1a2e86e
[DEBUG] 2017-05-24: 21:06:49 org.hibernate.type.BasicTypeRegistry.register(BasicTypeRegistry.java:146) :  Adding type registration wrapper-characters -> org.hibernate.type.CharacterArrayType@3372f4
[DEBUG] 2017-05-24: 21:06:49 org.hibernate.type.BasicTypeRegistry.register(BasicTypeRegistry.java:146) :  Adding type registration [Ljava.lang.Character; -> org.hibernate.type.CharacterArrayType@3372f4
[DEBUG] 2017-05-24: 21:06:49 org.hibernate.type.BasicTypeRegistry.register(BasicTypeRegistry.java:146) :  Adding type registration Character[] -> org.hibernate.type.CharacterArrayType@3372f4
[DEBUG] 2017-05-24: 21:06:49 org.hibernate.type.BasicTypeRegistry.register(BasicTypeRegistry.java:146) :  Adding type registration text -> org.hibernate.type.TextType@33bb83
[DEBUG] 2017-05-24: 21:06:49 org.hibernate.type.BasicTypeRegistry.register(BasicTypeRegistry.java:146) :  Adding type registration ntext -> org.hibernate.type.NTextType@1b2ed81
[DEBUG] 2017-05-24: 21:06:49 org.hibernate.type.BasicTypeRegistry.register(BasicTypeRegistry.java:146) :  Adding type registration blob -> org.hibernate.type.BlobType@93d628
[DEBUG] 2017-05-24: 21:06:49 org.hibernate.type.BasicTypeRegistry.register(BasicTypeRegistry.java:146) :  Adding type registration java.sql.Blob -> org.hibernate.type.BlobType@93d628
[DEBUG] 2017-05-24: 21:06:49 org.hibernate.type.BasicTypeRegistry.register(BasicTypeRegistry.java:146) :  Adding type registration materialized_blob -> org.hibernate.type.MaterializedBlobType@548e3c
[DEBUG] 2017-05-24: 21:06:49 org.hibernate.type.BasicTypeRegistry.register(BasicTypeRegistry.java:146) :  Adding type registration clob -> org.hibernate.type.ClobType@1f134a2
[DEBUG] 2017-05-24: 21:06:49 org.hibernate.type.BasicTypeRegistry.register(BasicTypeRegistry.java:146) :  Adding type registration java.sql.Clob -> org.hibernate.type.ClobType@1f134a2
[DEBUG] 2017-05-24: 21:06:49 org.hibernate.type.BasicTypeRegistry.register(BasicTypeRegistry.java:146) :  Adding type registration nclob -> org.hibernate.type.NClobType@1aadbf2
[DEBUG] 2017-05-24: 21:06:49 org.hibernate.type.BasicTypeRegistry.register(BasicTypeRegistry.java:146) :  Adding type registration java.sql.NClob -> org.hibernate.type.NClobType@1aadbf2
[DEBUG] 2017-05-24: 21:06:49 org.hibernate.type.BasicTypeRegistry.register(BasicTypeRegistry.java:146) :  Adding type registration materialized_clob -> org.hibernate.type.MaterializedClobType@1dc8aa8
[DEBUG] 2017-05-24: 21:06:49 org.hibernate.type.BasicTypeRegistry.register(BasicTypeRegistry.java:146) :  Adding type registration materialized_nclob -> org.hibernate.type.MaterializedNClobType@1668c8b
[DEBUG] 2017-05-24: 21:06:49 org.hibernate.type.BasicTypeRegistry.register(BasicTypeRegistry.java:146) :  Adding type registration serializable -> org.hibernate.type.SerializableType@acf986
[DEBUG] 2017-05-24: 21:06:49 org.hibernate.type.BasicTypeRegistry.register(BasicTypeRegistry.java:146) :  Adding type registration object -> org.hibernate.type.ObjectType@8bdfc
[DEBUG] 2017-05-24: 21:06:49 org.hibernate.type.BasicTypeRegistry.register(BasicTypeRegistry.java:146) :  Adding type registration java.lang.Object -> org.hibernate.type.ObjectType@8bdfc
[DEBUG] 2017-05-24: 21:06:49 org.hibernate.type.BasicTypeRegistry.register(BasicTypeRegistry.java:146) :  Adding type registration imm_date -> org.hibernate.type.AdaptedImmutableType@1f41593
[DEBUG] 2017-05-24: 21:06:49 org.hibernate.type.BasicTypeRegistry.register(BasicTypeRegistry.java:146) :  Adding type registration imm_time -> org.hibernate.type.AdaptedImmutableType@eeab0c
[DEBUG] 2017-05-24: 21:06:49 org.hibernate.type.BasicTypeRegistry.register(BasicTypeRegistry.java:146) :  Adding type registration imm_timestamp -> org.hibernate.type.AdaptedImmutableType@1194f5b
[DEBUG] 2017-05-24: 21:06:49 org.hibernate.type.BasicTypeRegistry.register(BasicTypeRegistry.java:146) :  Adding type registration imm_dbtimestamp -> org.hibernate.type.AdaptedImmutableType@be005
[DEBUG] 2017-05-24: 21:06:49 org.hibernate.type.BasicTypeRegistry.register(BasicTypeRegistry.java:146) :  Adding type registration imm_calendar -> org.hibernate.type.AdaptedImmutableType@1d226da
[DEBUG] 2017-05-24: 21:06:49 org.hibernate.type.BasicTypeRegistry.register(BasicTypeRegistry.java:146) :  Adding type registration imm_calendar_date -> org.hibernate.type.AdaptedImmutableType@cd58e7
[DEBUG] 2017-05-24: 21:06:49 org.hibernate.type.BasicTypeRegistry.register(BasicTypeRegistry.java:146) :  Adding type registration imm_binary -> org.hibernate.type.AdaptedImmutableType@1e3baf2
[DEBUG] 2017-05-24: 21:06:49 org.hibernate.type.BasicTypeRegistry.register(BasicTypeRegistry.java:146) :  Adding type registration imm_serializable -> org.hibernate.type.AdaptedImmutableType@296643
[INFO] 2017-05-24: 21:06:50 org.hibernate.annotations.common.reflection.java.JavaReflectionManager.<clinit>(JavaReflectionManager.java:66) :  HCANN000001: Hibernate Commons Annotations {4.0.5.Final}
[INFO] 2017-05-24: 21:06:50 org.hibernate.Version.logVersion(Version.java:54) :  HHH000412: Hibernate Core {4.3.8.Final}
[INFO] 2017-05-24: 21:06:50 org.hibernate.cfg.Environment.<clinit>(Environment.java:239) :  HHH000206: hibernate.properties not found
[INFO] 2017-05-24: 21:06:50 org.hibernate.cfg.Environment.buildBytecodeProvider(Environment.java:346) :  HHH000021: Bytecode provider name : javassist
[DEBUG] 2017-05-24: 21:06:50 org.hibernate.id.factory.internal.DefaultIdentifierGeneratorFactory.register(DefaultIdentifierGeneratorFactory.java:93) :  Registering IdentifierGenerator strategy [uuid2] -> [org.hibernate.id.UUIDGenerator]
[DEBUG] 2017-05-24: 21:06:50 org.hibernate.id.factory.internal.DefaultIdentifierGeneratorFactory.register(DefaultIdentifierGeneratorFactory.java:93) :  Registering IdentifierGenerator strategy [guid] -> [org.hibernate.id.GUIDGenerator]
[DEBUG] 2017-05-24: 21:06:50 org.hibernate.id.factory.internal.DefaultIdentifierGeneratorFactory.register(DefaultIdentifierGeneratorFactory.java:93) :  Registering IdentifierGenerator strategy [uuid] -> [org.hibernate.id.UUIDHexGenerator]
[DEBUG] 2017-05-24: 21:06:50 org.hibernate.id.factory.internal.DefaultIdentifierGeneratorFactory.register(DefaultIdentifierGeneratorFactory.java:93) :  Registering IdentifierGenerator strategy [uuid.hex] -> [org.hibernate.id.UUIDHexGenerator]
[DEBUG] 2017-05-24: 21:06:50 org.hibernate.id.factory.internal.DefaultIdentifierGeneratorFactory.register(DefaultIdentifierGeneratorFactory.java:93) :  Registering IdentifierGenerator strategy [hilo] -> [org.hibernate.id.TableHiLoGenerator]
[DEBUG] 2017-05-24: 21:06:50 org.hibernate.id.factory.internal.DefaultIdentifierGeneratorFactory.register(DefaultIdentifierGeneratorFactory.java:93) :  Registering IdentifierGenerator strategy [assigned] -> [org.hibernate.id.Assigned]
[DEBUG] 2017-05-24: 21:06:50 org.hibernate.id.factory.internal.DefaultIdentifierGeneratorFactory.register(DefaultIdentifierGeneratorFactory.java:93) :  Registering IdentifierGenerator strategy [identity] -> [org.hibernate.id.IdentityGenerator]
[DEBUG] 2017-05-24: 21:06:50 org.hibernate.id.factory.internal.DefaultIdentifierGeneratorFactory.register(DefaultIdentifierGeneratorFactory.java:93) :  Registering IdentifierGenerator strategy [select] -> [org.hibernate.id.SelectGenerator]
[DEBUG] 2017-05-24: 21:06:50 org.hibernate.id.factory.internal.DefaultIdentifierGeneratorFactory.register(DefaultIdentifierGeneratorFactory.java:93) :  Registering IdentifierGenerator strategy [sequence] -> [org.hibernate.id.SequenceGenerator]
[DEBUG] 2017-05-24: 21:06:50 org.hibernate.id.factory.internal.DefaultIdentifierGeneratorFactory.register(DefaultIdentifierGeneratorFactory.java:93) :  Registering IdentifierGenerator strategy [seqhilo] -> [org.hibernate.id.SequenceHiLoGenerator]
[DEBUG] 2017-05-24: 21:06:50 org.hibernate.id.factory.internal.DefaultIdentifierGeneratorFactory.register(DefaultIdentifierGeneratorFactory.java:93) :  Registering IdentifierGenerator strategy [increment] -> [org.hibernate.id.IncrementGenerator]
[DEBUG] 2017-05-24: 21:06:50 org.hibernate.id.factory.internal.DefaultIdentifierGeneratorFactory.register(DefaultIdentifierGeneratorFactory.java:93) :  Registering IdentifierGenerator strategy [foreign] -> [org.hibernate.id.ForeignGenerator]
[DEBUG] 2017-05-24: 21:06:50 org.hibernate.id.factory.internal.DefaultIdentifierGeneratorFactory.register(DefaultIdentifierGeneratorFactory.java:93) :  Registering IdentifierGenerator strategy [sequence-identity] -> [org.hibernate.id.SequenceIdentityGenerator]
[DEBUG] 2017-05-24: 21:06:50 org.hibernate.id.factory.internal.DefaultIdentifierGeneratorFactory.register(DefaultIdentifierGeneratorFactory.java:93) :  Registering IdentifierGenerator strategy [enhanced-sequence] -> [org.hibernate.id.enhanced.SequenceStyleGenerator]
[DEBUG] 2017-05-24: 21:06:50 org.hibernate.id.factory.internal.DefaultIdentifierGeneratorFactory.register(DefaultIdentifierGeneratorFactory.java:93) :  Registering IdentifierGenerator strategy [enhanced-table] -> [org.hibernate.id.enhanced.TableGenerator]
[DEBUG] 2017-05-24: 21:06:50 org.hibernate.internal.util.xml.DTDEntityResolver.resolveEntity(DTDEntityResolver.java:69) :  Trying to resolve system-id [http://hibernate.sourceforge.net/hibernate-mapping-3.0.dtd]
[WARN] 2017-05-24: 21:06:50 org.hibernate.internal.util.xml.DTDEntityResolver.resolveEntity(DTDEntityResolver.java:75) :  HHH000223: Recognized obsolete hibernate namespace http://hibernate.sourceforge.net/. Use namespace http://www.hibernate.org/dtd/ instead. Refer to Hibernate 3.6 Migration Guide!
[DEBUG] 2017-05-24: 21:06:50 org.hibernate.internal.util.xml.DTDEntityResolver.resolveEntity(DTDEntityResolver.java:76) :  Attempting to resolve on classpath under org/hibernate/
[DEBUG] 2017-05-24: 21:06:50 org.hibernate.internal.util.xml.DTDEntityResolver.resolveOnClassPath(DTDEntityResolver.java:108) :  Located [http://hibernate.sourceforge.net/hibernate-mapping-3.0.dtd] in classpath
[DEBUG] 2017-05-24: 21:06:50 org.hibernate.integrator.internal.IntegratorServiceImpl.addIntegrator(IntegratorServiceImpl.java:63) :  Adding Integrator [org.hibernate.cfg.beanvalidation.BeanValidationIntegrator].
[DEBUG] 2017-05-24: 21:06:50 org.hibernate.integrator.internal.IntegratorServiceImpl.addIntegrator(IntegratorServiceImpl.java:63) :  Adding Integrator [org.hibernate.secure.spi.JaccIntegrator].
[DEBUG] 2017-05-24: 21:06:50 org.hibernate.integrator.internal.IntegratorServiceImpl.addIntegrator(IntegratorServiceImpl.java:63) :  Adding Integrator [org.hibernate.cache.internal.CollectionCacheInvalidator].
[DEBUG] 2017-05-24: 21:06:50 org.hibernate.boot.registry.selector.internal.StrategySelectorImpl.registerStrategyImplementor(StrategySelectorImpl.java:79) :  Registering named strategy selector [org.hibernate.dialect.Dialect] : [MySQL5] -> [org.hibernate.dialect.MySQL5Dialect] (replacing [org.hibernate.dialect.MySQL5Dialect])
[DEBUG] 2017-05-24: 21:06:50 org.hibernate.boot.registry.selector.internal.StrategySelectorImpl.registerStrategyImplementor(StrategySelectorImpl.java:79) :  Registering named strategy selector [org.hibernate.dialect.Dialect] : [MySQL5InnoDB] -> [org.hibernate.dialect.MySQL5InnoDBDialect] (replacing [org.hibernate.dialect.MySQL5InnoDBDialect])
[DEBUG] 2017-05-24: 21:06:50 org.hibernate.service.spi.ServiceBinding.setService(ServiceBinding.java:85) :  Overriding existing service binding [org.hibernate.secure.spi.JaccService]
[DEBUG] 2017-05-24: 21:06:50 org.hibernate.cfg.Configuration.buildSessionFactory(Configuration.java:1843) :  Preparing to build session factory with filters : {}
[DEBUG] 2017-05-24: 21:06:50 org.springframework.jdbc.datasource.DriverManagerDataSource.getConnectionFromDriver(DriverManagerDataSource.java:142) :  Creating new JDBC DriverManager Connection to [jdbc:mysql://localhost:3306/usermanager?characterEncoding=utf8&useSSL=true]
[DEBUG] 2017-05-24: 21:06:50 org.hibernate.engine.jdbc.internal.JdbcServicesImpl.configure(JdbcServicesImpl.java:128) :  Database ->
       name : MySQL
    version : 5.7.16
      major : 5
      minor : 7
[DEBUG] 2017-05-24: 21:06:50 org.hibernate.engine.jdbc.internal.JdbcServicesImpl.configure(JdbcServicesImpl.java:139) :  Driver ->
       name : MySQL Connector Java
    version : mysql-connector-java-5.1.38 ( Revision: fe541c166cec739c74cc727c5da96c1028b4834a )
      major : 5
      minor : 1
[DEBUG] 2017-05-24: 21:06:50 org.hibernate.engine.jdbc.internal.JdbcServicesImpl.configure(JdbcServicesImpl.java:150) :  JDBC version : 4.0
[DEBUG] 2017-05-24: 21:06:50 org.hibernate.engine.jdbc.cursor.internal.StandardRefCursorSupport.supportsRefCursors(StandardRefCursorSupport.java:187) :  Unexpected error trying to gauge level of JDBC REF_CURSOR support : null
[INFO] 2017-05-24: 21:06:50 org.hibernate.dialect.Dialect.<init>(Dialect.java:145) :  HHH000400: Using dialect: org.hibernate.dialect.MySQLDialect
[DEBUG] 2017-05-24: 21:06:50 org.hibernate.cfg.Configuration$MetadataSourceQueue.processHbmXmlQueue(Configuration.java:3805) :  Processing hbm.xml files
[DEBUG] 2017-05-24: 21:06:50 org.hibernate.cfg.HbmBinder.bindRootPersistentClassCommonValues(HbmBinder.java:355) :  Mapping class: com.ittx.usermanager.model.User -> user
[DEBUG] 2017-05-24: 21:06:50 org.hibernate.cfg.HbmBinder.bindProperty(HbmBinder.java:1374) :  Mapped property: id -> id
[DEBUG] 2017-05-24: 21:06:50 org.hibernate.cfg.HbmBinder.bindProperty(HbmBinder.java:1374) :  Mapped property: name -> name
[DEBUG] 2017-05-24: 21:06:50 org.hibernate.cfg.HbmBinder.bindProperty(HbmBinder.java:1374) :  Mapped property: age -> age
[DEBUG] 2017-05-24: 21:06:50 org.hibernate.cfg.HbmBinder.bindProperty(HbmBinder.java:1374) :  Mapped property: sex -> sex
[DEBUG] 2017-05-24: 21:06:50 org.hibernate.cfg.HbmBinder.bindProperty(HbmBinder.java:1374) :  Mapped property: headerUri -> headuri
[DEBUG] 2017-05-24: 21:06:50 org.hibernate.cfg.Configuration$MetadataSourceQueue.processAnnotatedClassesQueue(Configuration.java:3835) :  Process annotated classes
[DEBUG] 2017-05-24: 21:06:50 org.hibernate.cfg.Configuration.processFkSecondPassInOrder(Configuration.java:1484) :  Processing fk mappings (*ToOne and JoinedSubclass)
[DEBUG] 2017-05-24: 21:06:50 org.hibernate.cfg.Configuration.originalSecondPassCompile(Configuration.java:1689) :  Processing extends queue
[DEBUG] 2017-05-24: 21:06:50 org.hibernate.cfg.Configuration.processExtendsQueue(Configuration.java:1747) :  Processing extends queue
[DEBUG] 2017-05-24: 21:06:50 org.hibernate.cfg.Configuration.originalSecondPassCompile(Configuration.java:1692) :  Processing collection mappings
[DEBUG] 2017-05-24: 21:06:50 org.hibernate.cfg.Configuration.originalSecondPassCompile(Configuration.java:1702) :  Processing native query and ResultSetMapping mappings
[DEBUG] 2017-05-24: 21:06:50 org.hibernate.cfg.Configuration.originalSecondPassCompile(Configuration.java:1710) :  Processing association property references
[DEBUG] 2017-05-24: 21:06:50 org.hibernate.cfg.Configuration.originalSecondPassCompile(Configuration.java:1732) :  Creating tables' unique integer identifiers
[DEBUG] 2017-05-24: 21:06:50 org.hibernate.cfg.Configuration.originalSecondPassCompile(Configuration.java:1733) :  Processing foreign key constraints
[DEBUG] 2017-05-24: 21:06:50 org.hibernate.engine.transaction.jta.platform.internal.JtaPlatformInitiator.initiateService(JtaPlatformInitiator.java:59) :  No JtaPlatform was specified, checking resolver
[DEBUG] 2017-05-24: 21:06:50 org.hibernate.engine.transaction.jta.platform.internal.JtaPlatformResolverInitiator.initiateService(JtaPlatformResolverInitiator.java:50) :  No JtaPlatformResolver was specified, using default [org.hibernate.engine.transaction.jta.platform.internal.StandardJtaPlatformResolver]
[DEBUG] 2017-05-24: 21:06:50 org.hibernate.engine.transaction.jta.platform.internal.StandardJtaPlatformResolver.resolveJtaPlatform(StandardJtaPlatformResolver.java:118) :  Could not resolve JtaPlatform, using default [org.hibernate.engine.transaction.jta.platform.internal.NoJtaPlatform]
[DEBUG] 2017-05-24: 21:06:50 org.hibernate.cfg.SettingsFactory.buildSettings(SettingsFactory.java:122) :  Automatic flush during beforeCompletion(): disabled
[DEBUG] 2017-05-24: 21:06:50 org.hibernate.cfg.SettingsFactory.buildSettings(SettingsFactory.java:128) :  Automatic session close at end of transaction: disabled
[DEBUG] 2017-05-24: 21:06:50 org.hibernate.cfg.SettingsFactory.buildSettings(SettingsFactory.java:139) :  JDBC batch size: 15
[DEBUG] 2017-05-24: 21:06:50 org.hibernate.cfg.SettingsFactory.buildSettings(SettingsFactory.java:145) :  JDBC batch updates for versioned data: disabled
[DEBUG] 2017-05-24: 21:06:50 org.hibernate.cfg.SettingsFactory.buildSettings(SettingsFactory.java:155) :  Scrollable result sets: enabled
[DEBUG] 2017-05-24: 21:06:50 org.hibernate.cfg.SettingsFactory.buildSettings(SettingsFactory.java:161) :  Wrap result sets: disabled
[DEBUG] 2017-05-24: 21:06:50 org.hibernate.cfg.SettingsFactory.buildSettings(SettingsFactory.java:167) :  JDBC3 getGeneratedKeys(): enabled
[DEBUG] 2017-05-24: 21:06:50 org.hibernate.cfg.SettingsFactory.buildSettings(SettingsFactory.java:179) :  multi-tenancy strategy : NONE
[DEBUG] 2017-05-24: 21:06:50 org.hibernate.cfg.SettingsFactory.buildSettings(SettingsFactory.java:185) :  Connection release mode: auto
[INFO] 2017-05-24: 21:06:50 org.hibernate.engine.transaction.internal.TransactionFactoryInitiator.initiateService(TransactionFactoryInitiator.java:62) :  HHH000399: Using default transaction strategy (direct JDBC transactions)
[DEBUG] 2017-05-24: 21:06:50 org.hibernate.cfg.SettingsFactory.buildSettings(SettingsFactory.java:207) :  Using BatchFetchStyle : LEGACY
[DEBUG] 2017-05-24: 21:06:50 org.hibernate.cfg.SettingsFactory.buildSettings(SettingsFactory.java:226) :  Maximum outer join fetch depth: 2
[DEBUG] 2017-05-24: 21:06:50 org.hibernate.cfg.SettingsFactory.buildSettings(SettingsFactory.java:232) :  Default batch fetch size: 1
[DEBUG] 2017-05-24: 21:06:50 org.hibernate.cfg.SettingsFactory.buildSettings(SettingsFactory.java:238) :  Generate SQL with comments: disabled
[DEBUG] 2017-05-24: 21:06:50 org.hibernate.cfg.SettingsFactory.buildSettings(SettingsFactory.java:244) :  Order SQL updates by primary key: disabled
[DEBUG] 2017-05-24: 21:06:50 org.hibernate.cfg.SettingsFactory.buildSettings(SettingsFactory.java:250) :  Order SQL inserts for batching: disabled
[DEBUG] 2017-05-24: 21:06:50 org.hibernate.cfg.SettingsFactory.buildSettings(SettingsFactory.java:258) :  Default null ordering: none
[DEBUG] 2017-05-24: 21:06:50 org.hibernate.cfg.SettingsFactory.createQueryTranslatorFactory(SettingsFactory.java:501) :  Query translator: org.hibernate.hql.internal.ast.ASTQueryTranslatorFactory
[INFO] 2017-05-24: 21:06:50 org.hibernate.hql.internal.ast.ASTQueryTranslatorFactory.<init>(ASTQueryTranslatorFactory.java:47) :  HHH000397: Using ASTQueryTranslatorFactory
[DEBUG] 2017-05-24: 21:06:50 org.hibernate.cfg.SettingsFactory.buildSettings(SettingsFactory.java:268) :  Query language substitutions: {}
[DEBUG] 2017-05-24: 21:06:50 org.hibernate.cfg.SettingsFactory.buildSettings(SettingsFactory.java:274) :  JPA-QL strict compliance: disabled
[DEBUG] 2017-05-24: 21:06:50 org.hibernate.cfg.SettingsFactory.buildSettings(SettingsFactory.java:282) :  Second-level cache: enabled
[DEBUG] 2017-05-24: 21:06:50 org.hibernate.cfg.SettingsFactory.buildSettings(SettingsFactory.java:288) :  Query cache: disabled
[DEBUG] 2017-05-24: 21:06:50 org.hibernate.cache.internal.RegionFactoryInitiator.initiateService(RegionFactoryInitiator.java:105) :  Cache region factory : org.hibernate.cache.internal.NoCachingRegionFactory
[DEBUG] 2017-05-24: 21:06:50 org.hibernate.cfg.SettingsFactory.buildSettings(SettingsFactory.java:301) :  Optimize cache for minimal puts: disabled
[DEBUG] 2017-05-24: 21:06:50 org.hibernate.cfg.SettingsFactory.buildSettings(SettingsFactory.java:316) :  Structured second-level cache entries: disabled
[DEBUG] 2017-05-24: 21:06:50 org.hibernate.cfg.SettingsFactory.buildSettings(SettingsFactory.java:326) :  Second-level cache direct-reference entries: disabled
[DEBUG] 2017-05-24: 21:06:50 org.hibernate.cfg.SettingsFactory.buildSettings(SettingsFactory.java:332) :  Automatic eviction of collection cache: disabled
[DEBUG] 2017-05-24: 21:06:50 org.hibernate.cfg.SettingsFactory.buildSettings(SettingsFactory.java:340) :  Statistics: disabled
[DEBUG] 2017-05-24: 21:06:50 org.hibernate.cfg.SettingsFactory.buildSettings(SettingsFactory.java:346) :  Deleted entity synthetic identifier rollback: disabled
[DEBUG] 2017-05-24: 21:06:50 org.hibernate.cfg.SettingsFactory.buildSettings(SettingsFactory.java:373) :  Default entity-mode: pojo
[DEBUG] 2017-05-24: 21:06:50 org.hibernate.cfg.SettingsFactory.buildSettings(SettingsFactory.java:379) :  Named query checking : enabled
[DEBUG] 2017-05-24: 21:06:50 org.hibernate.cfg.SettingsFactory.buildSettings(SettingsFactory.java:385) :  Check Nullability in Core (should be disabled when Bean Validation is on): enabled
[DEBUG] 2017-05-24: 21:06:50 org.hibernate.cfg.SettingsFactory.buildSettings(SettingsFactory.java:403) :  Allow initialization of lazy state outside session : : disabled
[DEBUG] 2017-05-24: 21:06:50 org.hibernate.cfg.SettingsFactory.buildSettings(SettingsFactory.java:413) :  JTA Track by Thread: enabled
[DEBUG] 2017-05-24: 21:06:50 org.hibernate.internal.SessionFactoryImpl.<init>(SessionFactoryImpl.java:229) :  Building session factory
[DEBUG] 2017-05-24: 21:06:50 org.hibernate.internal.SessionFactoryImpl.<init>(SessionFactoryImpl.java:285) :  Session factory constructed with filter configurations : {}
[DEBUG] 2017-05-24: 21:06:50 org.hibernate.internal.SessionFactoryImpl.<init>(SessionFactoryImpl.java:286) :  Instantiating session factory with properties: {java.runtime.name=Java(TM) SE Runtime Environment, sun.boot.library.path=D:\Java\jdk1.8.0_11\jre\bin, java.vm.version=25.11-b03, java.vm.vendor=Oracle Corporation, maven.multiModuleProjectDirectory=D:\projects\workspace_mavens\ssh\ssh-usermanager_annotaion, java.vendor.url=http://java.oracle.com/, path.separator=;, guice.disable.misplaced.annotation.check=true, java.vm.name=Java HotSpot(TM) Client VM, file.encoding.pkg=sun.io, user.script=, user.country=CN, sun.java.launcher=SUN_STANDARD, sun.os.patch.level=Service Pack 1, java.vm.specification.name=Java Virtual Machine Specification, user.dir=D:\projects\workspace_mavens\ssh\ssh-usermanager_annotaion, java.runtime.version=1.8.0_11-b12, java.awt.graphicsenv=sun.awt.Win32GraphicsEnvironment, hibernate.current_session_context_class=org.springframework.orm.hibernate4.SpringSessionContext, java.endorsed.dirs=D:\Java\jdk1.8.0_11\jre\lib\endorsed, os.arch=x86, java.io.tmpdir=C:\Users\ADMINI~1\AppData\Local\Temp\, line.separator=
, java.vm.specification.vendor=Oracle Corporation, user.variant=, os.name=Windows 7, classworlds.conf=D:\projects\workspace_mavens\.metadata\.plugins\org.eclipse.m2e.launching\launches\m2conf7496339913100087604.tmp, sun.jnu.encoding=GBK, java.library.path=D:\Java\jdk1.8.0_11\bin;C:\Windows\Sun\Java\bin;C:\Windows\system32;C:\Windows;D:/Java/jre8/bin/client;D:/Java/jre8/bin;D:/Java/jre8/lib/i386;C:\Program Files\Common Files\NetSarang;d:\Program Files\ImageMagick-6.9.2-Q16;C:\Windows\system32;C:\Windows;C:\Windows\System32\Wbem;C:\Windows\System32\WindowsPowerShell\v1.0\;D:\Java\jdk1.8.0_11\bin;D:\Java\jdk1.8.0_11\jre\bin;D:\Program Files\TortoiseGit\bin;D:\Program Files\Android\Android Studio\gradle\gradle-2.14.1\bin;D:\android-sdk-windows\platform-tools;D:\mysql\mysql-5.7.16-win32\bin;D:\maven\apache-maven-3.3.9\bin;C:\Program Files\nodejs\;d:\Program Files\SSH Communications Security\SSH Secure Shell;C:\Users\Administrator\AppData\Roaming\npm;D:\Program Files\eclipse-jee-neon-1a-win32\eclipse;;., hibernate.connection.datasource=org.springframework.jdbc.datasource.DriverManagerDataSource@ee32c6, java.specification.name=Java Platform API Specification, java.class.version=52.0, sun.management.compiler=HotSpot Client Compiler, os.version=6.1, user.home=C:\Users\Administrator, user.timezone=Asia/Shanghai, java.awt.printerjob=sun.awt.windows.WPrinterJob, java.specification.version=1.8, file.encoding=UTF-8, hibernate.format_sql=true, user.name=Administrator, java.class.path=D:\maven\apache-maven-3.3.9\boot\plexus-classworlds-2.5.2.jar, hibernate.bytecode.use_reflection_optimizer=false, hibernate.show_sql=true, hibernate.classLoader.application=WebAppClassLoader=UserManager@16206d8, java.vm.specification.version=1.8, sun.arch.data.model=32, java.home=D:\Java\jdk1.8.0_11\jre, sun.java.command=org.codehaus.plexus.classworlds.launcher.Launcher -B package, hibernate.dialect=org.hibernate.dialect.MySQLDialect, java.specification.vendor=Oracle Corporation, user.language=zh, awt.toolkit=sun.awt.windows.WToolkit, java.vm.info=mixed mode, java.version=1.8.0_11, java.ext.dirs=D:\Java\jdk1.8.0_11\jre\lib\ext;C:\Windows\Sun\Java\lib\ext, sun.boot.class.path=D:\Java\jdk1.8.0_11\jre\lib\resources.jar;D:\Java\jdk1.8.0_11\jre\lib\rt.jar;D:\Java\jdk1.8.0_11\jre\lib\sunrsasign.jar;D:\Java\jdk1.8.0_11\jre\lib\jsse.jar;D:\Java\jdk1.8.0_11\jre\lib\jce.jar;D:\Java\jdk1.8.0_11\jre\lib\charsets.jar;D:\Java\jdk1.8.0_11\jre\lib\jfr.jar;D:\Java\jdk1.8.0_11\jre\classes, java.vendor=Oracle Corporation, maven.home=D:\maven\apache-maven-3.3.9, file.separator=\, java.vendor.url.bug=http://bugreport.sun.com/bugreport/, sun.cpu.endian=little, sun.io.unicode.encoding=UnicodeLittle, sun.desktop=windows, sun.cpu.isalist=pentium_pro+mmx pentium_pro pentium+mmx pentium i486 i386 i86}
[DEBUG] 2017-05-24: 21:06:50 org.hibernate.secure.spi.JaccIntegrator.doIntegration(JaccIntegrator.java:90) :  Skipping JACC integration as it was not enabled
[DEBUG] 2017-05-24: 21:06:50 org.hibernate.id.factory.internal.DefaultIdentifierGeneratorFactory.setDialect(DefaultIdentifierGeneratorFactory.java:107) :  Setting dialect [org.hibernate.dialect.MySQLDialect]
[DEBUG] 2017-05-24: 21:06:50 org.hibernate.persister.entity.AbstractEntityPersister.logStaticSQL(AbstractEntityPersister.java:3676) :  Static SQL for entity: com.ittx.usermanager.model.User
[DEBUG] 2017-05-24: 21:06:50 org.hibernate.persister.entity.AbstractEntityPersister.logStaticSQL(AbstractEntityPersister.java:3681) :   Version select: select id from user where id =?
[DEBUG] 2017-05-24: 21:06:50 org.hibernate.persister.entity.AbstractEntityPersister.logStaticSQL(AbstractEntityPersister.java:3684) :   Snapshot select: select user_.id, user_.name as name2_0_, user_.age as age3_0_, user_.sex as sex4_0_, user_.headuri as headuri5_0_ from user user_ where user_.id=?
[DEBUG] 2017-05-24: 21:06:50 org.hibernate.persister.entity.AbstractEntityPersister.logStaticSQL(AbstractEntityPersister.java:3687) :   Insert 0: insert into user (name, age, sex, headuri, id) values (?, ?, ?, ?, ?)
[DEBUG] 2017-05-24: 21:06:50 org.hibernate.persister.entity.AbstractEntityPersister.logStaticSQL(AbstractEntityPersister.java:3688) :   Update 0: update user set name=?, age=?, sex=?, headuri=? where id=?
[DEBUG] 2017-05-24: 21:06:50 org.hibernate.persister.entity.AbstractEntityPersister.logStaticSQL(AbstractEntityPersister.java:3689) :   Delete 0: delete from user where id=?
[DEBUG] 2017-05-24: 21:06:50 org.hibernate.persister.entity.AbstractEntityPersister.logStaticSQL(AbstractEntityPersister.java:3692) :   Identity insert: insert into user (name, age, sex, headuri) values (?, ?, ?, ?)
[DEBUG] 2017-05-24: 21:06:50 org.hibernate.loader.plan.build.internal.spaces.QuerySpacesImpl.registerQuerySpace(QuerySpacesImpl.java:192) :  Adding QuerySpace : uid = <gen:0> -> org.hibernate.loader.plan.build.internal.spaces.EntityQuerySpaceImpl@119ddeb]
[DEBUG] 2017-05-24: 21:06:50 org.hibernate.persister.walking.spi.MetamodelGraphWalker.visitAttributeDefinition(MetamodelGraphWalker.java:154) :  Visiting attribute path : name
[DEBUG] 2017-05-24: 21:06:50 org.hibernate.persister.walking.spi.MetamodelGraphWalker.visitAttributeDefinition(MetamodelGraphWalker.java:154) :  Visiting attribute path : age
[DEBUG] 2017-05-24: 21:06:50 org.hibernate.persister.walking.spi.MetamodelGraphWalker.visitAttributeDefinition(MetamodelGraphWalker.java:154) :  Visiting attribute path : sex
[DEBUG] 2017-05-24: 21:06:50 org.hibernate.persister.walking.spi.MetamodelGraphWalker.visitAttributeDefinition(MetamodelGraphWalker.java:154) :  Visiting attribute path : headerUri
[DEBUG] 2017-05-24: 21:06:50 org.hibernate.loader.plan.build.internal.FetchStyleLoadPlanBuildingAssociationVisitationStrategy.buildLoadPlan(FetchStyleLoadPlanBuildingAssociationVisitationStrategy.java:94) :  Building LoadPlan...
[DEBUG] 2017-05-24: 21:06:50 org.hibernate.loader.plan.exec.internal.LoadQueryJoinAndFetchProcessor.processQuerySpaceJoins(LoadQueryJoinAndFetchProcessor.java:112) :  processing queryspace <gen:0>
[DEBUG] 2017-05-24: 21:06:50 org.hibernate.loader.plan.build.spi.LoadPlanTreePrinter.logTree(LoadPlanTreePrinter.java:72) :  LoadPlan(entity=com.ittx.usermanager.model.User)
    - Returns
       - EntityReturnImpl(entity=com.ittx.usermanager.model.User, querySpaceUid=<gen:0>, path=com.ittx.usermanager.model.User)
    - QuerySpaces
       - EntityQuerySpaceImpl(uid=<gen:0>, entity=com.ittx.usermanager.model.User)
          - SQL table alias mapping - user0_
          - alias suffix - 0_
          - suffixed key columns - {id1_0_0_}

[DEBUG] 2017-05-24: 21:06:50 org.hibernate.loader.entity.plan.EntityLoader.<init>(EntityLoader.java:146) :  Static select for entity com.ittx.usermanager.model.User [NONE]: select user0_.id as id1_0_0_, user0_.name as name2_0_0_, user0_.age as age3_0_0_, user0_.sex as sex4_0_0_, user0_.headuri as headuri5_0_0_ from user user0_ where user0_.id=?
[DEBUG] 2017-05-24: 21:06:50 org.hibernate.loader.plan.build.internal.spaces.QuerySpacesImpl.registerQuerySpace(QuerySpacesImpl.java:192) :  Adding QuerySpace : uid = <gen:0> -> org.hibernate.loader.plan.build.internal.spaces.EntityQuerySpaceImpl@1dc4d1a]
[DEBUG] 2017-05-24: 21:06:50 org.hibernate.persister.walking.spi.MetamodelGraphWalker.visitAttributeDefinition(MetamodelGraphWalker.java:154) :  Visiting attribute path : name
[DEBUG] 2017-05-24: 21:06:50 org.hibernate.persister.walking.spi.MetamodelGraphWalker.visitAttributeDefinition(MetamodelGraphWalker.java:154) :  Visiting attribute path : age
[DEBUG] 2017-05-24: 21:06:50 org.hibernate.persister.walking.spi.MetamodelGraphWalker.visitAttributeDefinition(MetamodelGraphWalker.java:154) :  Visiting attribute path : sex
[DEBUG] 2017-05-24: 21:06:50 org.hibernate.persister.walking.spi.MetamodelGraphWalker.visitAttributeDefinition(MetamodelGraphWalker.java:154) :  Visiting attribute path : headerUri
[DEBUG] 2017-05-24: 21:06:50 org.hibernate.loader.plan.build.internal.FetchStyleLoadPlanBuildingAssociationVisitationStrategy.buildLoadPlan(FetchStyleLoadPlanBuildingAssociationVisitationStrategy.java:94) :  Building LoadPlan...
[DEBUG] 2017-05-24: 21:06:50 org.hibernate.loader.plan.exec.internal.LoadQueryJoinAndFetchProcessor.processQuerySpaceJoins(LoadQueryJoinAndFetchProcessor.java:112) :  processing queryspace <gen:0>
[DEBUG] 2017-05-24: 21:06:50 org.hibernate.loader.plan.build.spi.LoadPlanTreePrinter.logTree(LoadPlanTreePrinter.java:72) :  LoadPlan(entity=com.ittx.usermanager.model.User)
    - Returns
       - EntityReturnImpl(entity=com.ittx.usermanager.model.User, querySpaceUid=<gen:0>, path=com.ittx.usermanager.model.User)
    - QuerySpaces
       - EntityQuerySpaceImpl(uid=<gen:0>, entity=com.ittx.usermanager.model.User)
          - SQL table alias mapping - user0_
          - alias suffix - 0_
          - suffixed key columns - {id1_0_0_}

[DEBUG] 2017-05-24: 21:06:50 org.hibernate.loader.entity.plan.EntityLoader.<init>(EntityLoader.java:146) :  Static select for entity com.ittx.usermanager.model.User [READ]: select user0_.id as id1_0_0_, user0_.name as name2_0_0_, user0_.age as age3_0_0_, user0_.sex as sex4_0_0_, user0_.headuri as headuri5_0_0_ from user user0_ where user0_.id=?
[DEBUG] 2017-05-24: 21:06:50 org.hibernate.loader.plan.build.internal.spaces.QuerySpacesImpl.registerQuerySpace(QuerySpacesImpl.java:192) :  Adding QuerySpace : uid = <gen:0> -> org.hibernate.loader.plan.build.internal.spaces.EntityQuerySpaceImpl@a98fa6]
[DEBUG] 2017-05-24: 21:06:50 org.hibernate.persister.walking.spi.MetamodelGraphWalker.visitAttributeDefinition(MetamodelGraphWalker.java:154) :  Visiting attribute path : name
[DEBUG] 2017-05-24: 21:06:50 org.hibernate.persister.walking.spi.MetamodelGraphWalker.visitAttributeDefinition(MetamodelGraphWalker.java:154) :  Visiting attribute path : age
[DEBUG] 2017-05-24: 21:06:50 org.hibernate.persister.walking.spi.MetamodelGraphWalker.visitAttributeDefinition(MetamodelGraphWalker.java:154) :  Visiting attribute path : sex
[DEBUG] 2017-05-24: 21:06:50 org.hibernate.persister.walking.spi.MetamodelGraphWalker.visitAttributeDefinition(MetamodelGraphWalker.java:154) :  Visiting attribute path : headerUri
[DEBUG] 2017-05-24: 21:06:50 org.hibernate.loader.plan.build.internal.FetchStyleLoadPlanBuildingAssociationVisitationStrategy.buildLoadPlan(FetchStyleLoadPlanBuildingAssociationVisitationStrategy.java:94) :  Building LoadPlan...
[DEBUG] 2017-05-24: 21:06:50 org.hibernate.loader.plan.exec.internal.LoadQueryJoinAndFetchProcessor.processQuerySpaceJoins(LoadQueryJoinAndFetchProcessor.java:112) :  processing queryspace <gen:0>
[DEBUG] 2017-05-24: 21:06:50 org.hibernate.loader.plan.build.spi.LoadPlanTreePrinter.logTree(LoadPlanTreePrinter.java:72) :  LoadPlan(entity=com.ittx.usermanager.model.User)
    - Returns
       - EntityReturnImpl(entity=com.ittx.usermanager.model.User, querySpaceUid=<gen:0>, path=com.ittx.usermanager.model.User)
    - QuerySpaces
       - EntityQuerySpaceImpl(uid=<gen:0>, entity=com.ittx.usermanager.model.User)
          - SQL table alias mapping - user0_
          - alias suffix - 0_
          - suffixed key columns - {id1_0_0_}

[DEBUG] 2017-05-24: 21:06:50 org.hibernate.loader.entity.plan.EntityLoader.<init>(EntityLoader.java:146) :  Static select for entity com.ittx.usermanager.model.User [UPGRADE]: select user0_.id as id1_0_0_, user0_.name as name2_0_0_, user0_.age as age3_0_0_, user0_.sex as sex4_0_0_, user0_.headuri as headuri5_0_0_ from user user0_ where user0_.id=? for update
[DEBUG] 2017-05-24: 21:06:50 org.hibernate.loader.plan.build.internal.spaces.QuerySpacesImpl.registerQuerySpace(QuerySpacesImpl.java:192) :  Adding QuerySpace : uid = <gen:0> -> org.hibernate.loader.plan.build.internal.spaces.EntityQuerySpaceImpl@1e78f97]
[DEBUG] 2017-05-24: 21:06:50 org.hibernate.persister.walking.spi.MetamodelGraphWalker.visitAttributeDefinition(MetamodelGraphWalker.java:154) :  Visiting attribute path : name
[DEBUG] 2017-05-24: 21:06:50 org.hibernate.persister.walking.spi.MetamodelGraphWalker.visitAttributeDefinition(MetamodelGraphWalker.java:154) :  Visiting attribute path : age
[DEBUG] 2017-05-24: 21:06:50 org.hibernate.persister.walking.spi.MetamodelGraphWalker.visitAttributeDefinition(MetamodelGraphWalker.java:154) :  Visiting attribute path : sex
[DEBUG] 2017-05-24: 21:06:50 org.hibernate.persister.walking.spi.MetamodelGraphWalker.visitAttributeDefinition(MetamodelGraphWalker.java:154) :  Visiting attribute path : headerUri
[DEBUG] 2017-05-24: 21:06:50 org.hibernate.loader.plan.build.internal.FetchStyleLoadPlanBuildingAssociationVisitationStrategy.buildLoadPlan(FetchStyleLoadPlanBuildingAssociationVisitationStrategy.java:94) :  Building LoadPlan...
[DEBUG] 2017-05-24: 21:06:50 org.hibernate.loader.plan.exec.internal.LoadQueryJoinAndFetchProcessor.processQuerySpaceJoins(LoadQueryJoinAndFetchProcessor.java:112) :  processing queryspace <gen:0>
[DEBUG] 2017-05-24: 21:06:50 org.hibernate.loader.plan.build.spi.LoadPlanTreePrinter.logTree(LoadPlanTreePrinter.java:72) :  LoadPlan(entity=com.ittx.usermanager.model.User)
    - Returns
       - EntityReturnImpl(entity=com.ittx.usermanager.model.User, querySpaceUid=<gen:0>, path=com.ittx.usermanager.model.User)
    - QuerySpaces
       - EntityQuerySpaceImpl(uid=<gen:0>, entity=com.ittx.usermanager.model.User)
          - SQL table alias mapping - user0_
          - alias suffix - 0_
          - suffixed key columns - {id1_0_0_}

[DEBUG] 2017-05-24: 21:06:50 org.hibernate.loader.entity.plan.EntityLoader.<init>(EntityLoader.java:146) :  Static select for entity com.ittx.usermanager.model.User [UPGRADE_NOWAIT]: select user0_.id as id1_0_0_, user0_.name as name2_0_0_, user0_.age as age3_0_0_, user0_.sex as sex4_0_0_, user0_.headuri as headuri5_0_0_ from user user0_ where user0_.id=? for update
[DEBUG] 2017-05-24: 21:06:50 org.hibernate.loader.plan.build.internal.spaces.QuerySpacesImpl.registerQuerySpace(QuerySpacesImpl.java:192) :  Adding QuerySpace : uid = <gen:0> -> org.hibernate.loader.plan.build.internal.spaces.EntityQuerySpaceImpl@4eb392]
[DEBUG] 2017-05-24: 21:06:50 org.hibernate.persister.walking.spi.MetamodelGraphWalker.visitAttributeDefinition(MetamodelGraphWalker.java:154) :  Visiting attribute path : name
[DEBUG] 2017-05-24: 21:06:50 org.hibernate.persister.walking.spi.MetamodelGraphWalker.visitAttributeDefinition(MetamodelGraphWalker.java:154) :  Visiting attribute path : age
[DEBUG] 2017-05-24: 21:06:50 org.hibernate.persister.walking.spi.MetamodelGraphWalker.visitAttributeDefinition(MetamodelGraphWalker.java:154) :  Visiting attribute path : sex
[DEBUG] 2017-05-24: 21:06:50 org.hibernate.persister.walking.spi.MetamodelGraphWalker.visitAttributeDefinition(MetamodelGraphWalker.java:154) :  Visiting attribute path : headerUri
[DEBUG] 2017-05-24: 21:06:50 org.hibernate.loader.plan.build.internal.FetchStyleLoadPlanBuildingAssociationVisitationStrategy.buildLoadPlan(FetchStyleLoadPlanBuildingAssociationVisitationStrategy.java:94) :  Building LoadPlan...
[DEBUG] 2017-05-24: 21:06:50 org.hibernate.loader.plan.exec.internal.LoadQueryJoinAndFetchProcessor.processQuerySpaceJoins(LoadQueryJoinAndFetchProcessor.java:112) :  processing queryspace <gen:0>
[DEBUG] 2017-05-24: 21:06:50 org.hibernate.loader.plan.build.spi.LoadPlanTreePrinter.logTree(LoadPlanTreePrinter.java:72) :  LoadPlan(entity=com.ittx.usermanager.model.User)
    - Returns
       - EntityReturnImpl(entity=com.ittx.usermanager.model.User, querySpaceUid=<gen:0>, path=com.ittx.usermanager.model.User)
    - QuerySpaces
       - EntityQuerySpaceImpl(uid=<gen:0>, entity=com.ittx.usermanager.model.User)
          - SQL table alias mapping - user0_
          - alias suffix - 0_
          - suffixed key columns - {id1_0_0_}

[DEBUG] 2017-05-24: 21:06:50 org.hibernate.loader.entity.plan.EntityLoader.<init>(EntityLoader.java:146) :  Static select for entity com.ittx.usermanager.model.User [UPGRADE_SKIPLOCKED]: select user0_.id as id1_0_0_, user0_.name as name2_0_0_, user0_.age as age3_0_0_, user0_.sex as sex4_0_0_, user0_.headuri as headuri5_0_0_ from user user0_ where user0_.id=? for update
[DEBUG] 2017-05-24: 21:06:50 org.hibernate.loader.plan.build.internal.spaces.QuerySpacesImpl.registerQuerySpace(QuerySpacesImpl.java:192) :  Adding QuerySpace : uid = <gen:0> -> org.hibernate.loader.plan.build.internal.spaces.EntityQuerySpaceImpl@95a351]
[DEBUG] 2017-05-24: 21:06:50 org.hibernate.persister.walking.spi.MetamodelGraphWalker.visitAttributeDefinition(MetamodelGraphWalker.java:154) :  Visiting attribute path : name
[DEBUG] 2017-05-24: 21:06:50 org.hibernate.persister.walking.spi.MetamodelGraphWalker.visitAttributeDefinition(MetamodelGraphWalker.java:154) :  Visiting attribute path : age
[DEBUG] 2017-05-24: 21:06:50 org.hibernate.persister.walking.spi.MetamodelGraphWalker.visitAttributeDefinition(MetamodelGraphWalker.java:154) :  Visiting attribute path : sex
[DEBUG] 2017-05-24: 21:06:50 org.hibernate.persister.walking.spi.MetamodelGraphWalker.visitAttributeDefinition(MetamodelGraphWalker.java:154) :  Visiting attribute path : headerUri
[DEBUG] 2017-05-24: 21:06:50 org.hibernate.loader.plan.build.internal.FetchStyleLoadPlanBuildingAssociationVisitationStrategy.buildLoadPlan(FetchStyleLoadPlanBuildingAssociationVisitationStrategy.java:94) :  Building LoadPlan...
[DEBUG] 2017-05-24: 21:06:50 org.hibernate.loader.plan.exec.internal.LoadQueryJoinAndFetchProcessor.processQuerySpaceJoins(LoadQueryJoinAndFetchProcessor.java:112) :  processing queryspace <gen:0>
[DEBUG] 2017-05-24: 21:06:50 org.hibernate.loader.plan.build.spi.LoadPlanTreePrinter.logTree(LoadPlanTreePrinter.java:72) :  LoadPlan(entity=com.ittx.usermanager.model.User)
    - Returns
       - EntityReturnImpl(entity=com.ittx.usermanager.model.User, querySpaceUid=<gen:0>, path=com.ittx.usermanager.model.User)
    - QuerySpaces
       - EntityQuerySpaceImpl(uid=<gen:0>, entity=com.ittx.usermanager.model.User)
          - SQL table alias mapping - user0_
          - alias suffix - 0_
          - suffixed key columns - {id1_0_0_}

[DEBUG] 2017-05-24: 21:06:50 org.hibernate.loader.entity.plan.EntityLoader.<init>(EntityLoader.java:146) :  Static select for entity com.ittx.usermanager.model.User [FORCE]: select user0_.id as id1_0_0_, user0_.name as name2_0_0_, user0_.age as age3_0_0_, user0_.sex as sex4_0_0_, user0_.headuri as headuri5_0_0_ from user user0_ where user0_.id=? for update
[DEBUG] 2017-05-24: 21:06:50 org.hibernate.loader.plan.build.internal.spaces.QuerySpacesImpl.registerQuerySpace(QuerySpacesImpl.java:192) :  Adding QuerySpace : uid = <gen:0> -> org.hibernate.loader.plan.build.internal.spaces.EntityQuerySpaceImpl@16cb083]
[DEBUG] 2017-05-24: 21:06:50 org.hibernate.persister.walking.spi.MetamodelGraphWalker.visitAttributeDefinition(MetamodelGraphWalker.java:154) :  Visiting attribute path : name
[DEBUG] 2017-05-24: 21:06:50 org.hibernate.persister.walking.spi.MetamodelGraphWalker.visitAttributeDefinition(MetamodelGraphWalker.java:154) :  Visiting attribute path : age
[DEBUG] 2017-05-24: 21:06:50 org.hibernate.persister.walking.spi.MetamodelGraphWalker.visitAttributeDefinition(MetamodelGraphWalker.java:154) :  Visiting attribute path : sex
[DEBUG] 2017-05-24: 21:06:50 org.hibernate.persister.walking.spi.MetamodelGraphWalker.visitAttributeDefinition(MetamodelGraphWalker.java:154) :  Visiting attribute path : headerUri
[DEBUG] 2017-05-24: 21:06:50 org.hibernate.loader.plan.build.internal.FetchStyleLoadPlanBuildingAssociationVisitationStrategy.buildLoadPlan(FetchStyleLoadPlanBuildingAssociationVisitationStrategy.java:94) :  Building LoadPlan...
[DEBUG] 2017-05-24: 21:06:50 org.hibernate.loader.plan.exec.internal.LoadQueryJoinAndFetchProcessor.processQuerySpaceJoins(LoadQueryJoinAndFetchProcessor.java:112) :  processing queryspace <gen:0>
[DEBUG] 2017-05-24: 21:06:51 org.hibernate.loader.plan.build.spi.LoadPlanTreePrinter.logTree(LoadPlanTreePrinter.java:72) :  LoadPlan(entity=com.ittx.usermanager.model.User)
    - Returns
       - EntityReturnImpl(entity=com.ittx.usermanager.model.User, querySpaceUid=<gen:0>, path=com.ittx.usermanager.model.User)
    - QuerySpaces
       - EntityQuerySpaceImpl(uid=<gen:0>, entity=com.ittx.usermanager.model.User)
          - SQL table alias mapping - user0_
          - alias suffix - 0_
          - suffixed key columns - {id1_0_0_}

[DEBUG] 2017-05-24: 21:06:51 org.hibernate.loader.entity.plan.EntityLoader.<init>(EntityLoader.java:146) :  Static select for entity com.ittx.usermanager.model.User [PESSIMISTIC_READ]: select user0_.id as id1_0_0_, user0_.name as name2_0_0_, user0_.age as age3_0_0_, user0_.sex as sex4_0_0_, user0_.headuri as headuri5_0_0_ from user user0_ where user0_.id=? lock in share mode
[DEBUG] 2017-05-24: 21:06:51 org.hibernate.loader.plan.build.internal.spaces.QuerySpacesImpl.registerQuerySpace(QuerySpacesImpl.java:192) :  Adding QuerySpace : uid = <gen:0> -> org.hibernate.loader.plan.build.internal.spaces.EntityQuerySpaceImpl@1c261b7]
[DEBUG] 2017-05-24: 21:06:51 org.hibernate.persister.walking.spi.MetamodelGraphWalker.visitAttributeDefinition(MetamodelGraphWalker.java:154) :  Visiting attribute path : name
[DEBUG] 2017-05-24: 21:06:51 org.hibernate.persister.walking.spi.MetamodelGraphWalker.visitAttributeDefinition(MetamodelGraphWalker.java:154) :  Visiting attribute path : age
[DEBUG] 2017-05-24: 21:06:51 org.hibernate.persister.walking.spi.MetamodelGraphWalker.visitAttributeDefinition(MetamodelGraphWalker.java:154) :  Visiting attribute path : sex
[DEBUG] 2017-05-24: 21:06:51 org.hibernate.persister.walking.spi.MetamodelGraphWalker.visitAttributeDefinition(MetamodelGraphWalker.java:154) :  Visiting attribute path : headerUri
[DEBUG] 2017-05-24: 21:06:51 org.hibernate.loader.plan.build.internal.FetchStyleLoadPlanBuildingAssociationVisitationStrategy.buildLoadPlan(FetchStyleLoadPlanBuildingAssociationVisitationStrategy.java:94) :  Building LoadPlan...
[DEBUG] 2017-05-24: 21:06:51 org.hibernate.loader.plan.exec.internal.LoadQueryJoinAndFetchProcessor.processQuerySpaceJoins(LoadQueryJoinAndFetchProcessor.java:112) :  processing queryspace <gen:0>
[DEBUG] 2017-05-24: 21:06:51 org.hibernate.loader.plan.build.spi.LoadPlanTreePrinter.logTree(LoadPlanTreePrinter.java:72) :  LoadPlan(entity=com.ittx.usermanager.model.User)
    - Returns
       - EntityReturnImpl(entity=com.ittx.usermanager.model.User, querySpaceUid=<gen:0>, path=com.ittx.usermanager.model.User)
    - QuerySpaces
       - EntityQuerySpaceImpl(uid=<gen:0>, entity=com.ittx.usermanager.model.User)
          - SQL table alias mapping - user0_
          - alias suffix - 0_
          - suffixed key columns - {id1_0_0_}

[DEBUG] 2017-05-24: 21:06:51 org.hibernate.loader.entity.plan.EntityLoader.<init>(EntityLoader.java:146) :  Static select for entity com.ittx.usermanager.model.User [PESSIMISTIC_WRITE]: select user0_.id as id1_0_0_, user0_.name as name2_0_0_, user0_.age as age3_0_0_, user0_.sex as sex4_0_0_, user0_.headuri as headuri5_0_0_ from user user0_ where user0_.id=? for update
[DEBUG] 2017-05-24: 21:06:51 org.hibernate.loader.plan.build.internal.spaces.QuerySpacesImpl.registerQuerySpace(QuerySpacesImpl.java:192) :  Adding QuerySpace : uid = <gen:0> -> org.hibernate.loader.plan.build.internal.spaces.EntityQuerySpaceImpl@1d64d6b]
[DEBUG] 2017-05-24: 21:06:51 org.hibernate.persister.walking.spi.MetamodelGraphWalker.visitAttributeDefinition(MetamodelGraphWalker.java:154) :  Visiting attribute path : name
[DEBUG] 2017-05-24: 21:06:51 org.hibernate.persister.walking.spi.MetamodelGraphWalker.visitAttributeDefinition(MetamodelGraphWalker.java:154) :  Visiting attribute path : age
[DEBUG] 2017-05-24: 21:06:51 org.hibernate.persister.walking.spi.MetamodelGraphWalker.visitAttributeDefinition(MetamodelGraphWalker.java:154) :  Visiting attribute path : sex
[DEBUG] 2017-05-24: 21:06:51 org.hibernate.persister.walking.spi.MetamodelGraphWalker.visitAttributeDefinition(MetamodelGraphWalker.java:154) :  Visiting attribute path : headerUri
[DEBUG] 2017-05-24: 21:06:51 org.hibernate.loader.plan.build.internal.FetchStyleLoadPlanBuildingAssociationVisitationStrategy.buildLoadPlan(FetchStyleLoadPlanBuildingAssociationVisitationStrategy.java:94) :  Building LoadPlan...
[DEBUG] 2017-05-24: 21:06:51 org.hibernate.loader.plan.exec.internal.LoadQueryJoinAndFetchProcessor.processQuerySpaceJoins(LoadQueryJoinAndFetchProcessor.java:112) :  processing queryspace <gen:0>
[DEBUG] 2017-05-24: 21:06:51 org.hibernate.loader.plan.build.spi.LoadPlanTreePrinter.logTree(LoadPlanTreePrinter.java:72) :  LoadPlan(entity=com.ittx.usermanager.model.User)
    - Returns
       - EntityReturnImpl(entity=com.ittx.usermanager.model.User, querySpaceUid=<gen:0>, path=com.ittx.usermanager.model.User)
    - QuerySpaces
       - EntityQuerySpaceImpl(uid=<gen:0>, entity=com.ittx.usermanager.model.User)
          - SQL table alias mapping - user0_
          - alias suffix - 0_
          - suffixed key columns - {id1_0_0_}

[DEBUG] 2017-05-24: 21:06:51 org.hibernate.loader.entity.plan.EntityLoader.<init>(EntityLoader.java:146) :  Static select for entity com.ittx.usermanager.model.User [PESSIMISTIC_FORCE_INCREMENT]: select user0_.id as id1_0_0_, user0_.name as name2_0_0_, user0_.age as age3_0_0_, user0_.sex as sex4_0_0_, user0_.headuri as headuri5_0_0_ from user user0_ where user0_.id=? for update
[DEBUG] 2017-05-24: 21:06:51 org.hibernate.loader.plan.build.internal.spaces.QuerySpacesImpl.registerQuerySpace(QuerySpacesImpl.java:192) :  Adding QuerySpace : uid = <gen:0> -> org.hibernate.loader.plan.build.internal.spaces.EntityQuerySpaceImpl@1f96ef2]
[DEBUG] 2017-05-24: 21:06:51 org.hibernate.persister.walking.spi.MetamodelGraphWalker.visitAttributeDefinition(MetamodelGraphWalker.java:154) :  Visiting attribute path : name
[DEBUG] 2017-05-24: 21:06:51 org.hibernate.persister.walking.spi.MetamodelGraphWalker.visitAttributeDefinition(MetamodelGraphWalker.java:154) :  Visiting attribute path : age
[DEBUG] 2017-05-24: 21:06:51 org.hibernate.persister.walking.spi.MetamodelGraphWalker.visitAttributeDefinition(MetamodelGraphWalker.java:154) :  Visiting attribute path : sex
[DEBUG] 2017-05-24: 21:06:51 org.hibernate.persister.walking.spi.MetamodelGraphWalker.visitAttributeDefinition(MetamodelGraphWalker.java:154) :  Visiting attribute path : headerUri
[DEBUG] 2017-05-24: 21:06:51 org.hibernate.loader.plan.build.internal.FetchStyleLoadPlanBuildingAssociationVisitationStrategy.buildLoadPlan(FetchStyleLoadPlanBuildingAssociationVisitationStrategy.java:94) :  Building LoadPlan...
[DEBUG] 2017-05-24: 21:06:51 org.hibernate.loader.plan.exec.internal.LoadQueryJoinAndFetchProcessor.processQuerySpaceJoins(LoadQueryJoinAndFetchProcessor.java:112) :  processing queryspace <gen:0>
[DEBUG] 2017-05-24: 21:06:51 org.hibernate.loader.plan.build.spi.LoadPlanTreePrinter.logTree(LoadPlanTreePrinter.java:72) :  LoadPlan(entity=com.ittx.usermanager.model.User)
    - Returns
       - EntityReturnImpl(entity=com.ittx.usermanager.model.User, querySpaceUid=<gen:0>, path=com.ittx.usermanager.model.User)
    - QuerySpaces
       - EntityQuerySpaceImpl(uid=<gen:0>, entity=com.ittx.usermanager.model.User)
          - SQL table alias mapping - user0_
          - alias suffix - 0_
          - suffixed key columns - {id1_0_0_}

[DEBUG] 2017-05-24: 21:06:51 org.hibernate.loader.entity.plan.EntityLoader.<init>(EntityLoader.java:146) :  Static select for entity com.ittx.usermanager.model.User [OPTIMISTIC]: select user0_.id as id1_0_0_, user0_.name as name2_0_0_, user0_.age as age3_0_0_, user0_.sex as sex4_0_0_, user0_.headuri as headuri5_0_0_ from user user0_ where user0_.id=?
[DEBUG] 2017-05-24: 21:06:51 org.hibernate.loader.plan.build.internal.spaces.QuerySpacesImpl.registerQuerySpace(QuerySpacesImpl.java:192) :  Adding QuerySpace : uid = <gen:0> -> org.hibernate.loader.plan.build.internal.spaces.EntityQuerySpaceImpl@1b320de]
[DEBUG] 2017-05-24: 21:06:51 org.hibernate.persister.walking.spi.MetamodelGraphWalker.visitAttributeDefinition(MetamodelGraphWalker.java:154) :  Visiting attribute path : name
[DEBUG] 2017-05-24: 21:06:51 org.hibernate.persister.walking.spi.MetamodelGraphWalker.visitAttributeDefinition(MetamodelGraphWalker.java:154) :  Visiting attribute path : age
[DEBUG] 2017-05-24: 21:06:51 org.hibernate.persister.walking.spi.MetamodelGraphWalker.visitAttributeDefinition(MetamodelGraphWalker.java:154) :  Visiting attribute path : sex
[DEBUG] 2017-05-24: 21:06:51 org.hibernate.persister.walking.spi.MetamodelGraphWalker.visitAttributeDefinition(MetamodelGraphWalker.java:154) :  Visiting attribute path : headerUri
[DEBUG] 2017-05-24: 21:06:51 org.hibernate.loader.plan.build.internal.FetchStyleLoadPlanBuildingAssociationVisitationStrategy.buildLoadPlan(FetchStyleLoadPlanBuildingAssociationVisitationStrategy.java:94) :  Building LoadPlan...
[DEBUG] 2017-05-24: 21:06:51 org.hibernate.loader.plan.exec.internal.LoadQueryJoinAndFetchProcessor.processQuerySpaceJoins(LoadQueryJoinAndFetchProcessor.java:112) :  processing queryspace <gen:0>
[DEBUG] 2017-05-24: 21:06:51 org.hibernate.loader.plan.build.spi.LoadPlanTreePrinter.logTree(LoadPlanTreePrinter.java:72) :  LoadPlan(entity=com.ittx.usermanager.model.User)
    - Returns
       - EntityReturnImpl(entity=com.ittx.usermanager.model.User, querySpaceUid=<gen:0>, path=com.ittx.usermanager.model.User)
    - QuerySpaces
       - EntityQuerySpaceImpl(uid=<gen:0>, entity=com.ittx.usermanager.model.User)
          - SQL table alias mapping - user0_
          - alias suffix - 0_
          - suffixed key columns - {id1_0_0_}

[DEBUG] 2017-05-24: 21:06:51 org.hibernate.loader.entity.plan.EntityLoader.<init>(EntityLoader.java:146) :  Static select for entity com.ittx.usermanager.model.User [OPTIMISTIC_FORCE_INCREMENT]: select user0_.id as id1_0_0_, user0_.name as name2_0_0_, user0_.age as age3_0_0_, user0_.sex as sex4_0_0_, user0_.headuri as headuri5_0_0_ from user user0_ where user0_.id=?
[DEBUG] 2017-05-24: 21:06:51 org.hibernate.loader.entity.CascadeEntityLoader.<init>(CascadeEntityLoader.java:56) :  Static select for action ACTION_MERGE on entity com.ittx.usermanager.model.User: select user0_.id as id1_0_0_, user0_.name as name2_0_0_, user0_.age as age3_0_0_, user0_.sex as sex4_0_0_, user0_.headuri as headuri5_0_0_ from user user0_ where user0_.id=?
[DEBUG] 2017-05-24: 21:06:51 org.hibernate.loader.entity.CascadeEntityLoader.<init>(CascadeEntityLoader.java:56) :  Static select for action ACTION_REFRESH on entity com.ittx.usermanager.model.User: select user0_.id as id1_0_0_, user0_.name as name2_0_0_, user0_.age as age3_0_0_, user0_.sex as sex4_0_0_, user0_.headuri as headuri5_0_0_ from user user0_ where user0_.id=?
[DEBUG] 2017-05-24: 21:06:51 org.hibernate.internal.SessionFactoryRegistry.<init>(SessionFactoryRegistry.java:67) :  Initializing SessionFactoryRegistry : org.hibernate.internal.SessionFactoryRegistry@1a1f55c
[DEBUG] 2017-05-24: 21:06:51 org.hibernate.internal.SessionFactoryRegistry.addSessionFactory(SessionFactoryRegistry.java:89) :  Registering SessionFactory: 8f754fed-778e-4a23-8f0d-a458b06ec864 (<unnamed>)
[DEBUG] 2017-05-24: 21:06:51 org.hibernate.internal.SessionFactoryRegistry.addSessionFactory(SessionFactoryRegistry.java:96) :  Not binding SessionFactory to JNDI, no JNDI name configured
[DEBUG] 2017-05-24: 21:06:51 org.hibernate.internal.SessionFactoryImpl.<init>(SessionFactoryImpl.java:505) :  Instantiated session factory
[DEBUG] 2017-05-24: 21:06:51 org.hibernate.internal.NamedQueryRepository.checkNamedQueries(NamedQueryRepository.java:155) :  Checking 0 named HQL queries
[DEBUG] 2017-05-24: 21:06:51 org.hibernate.internal.NamedQueryRepository.checkNamedQueries(NamedQueryRepository.java:171) :  Checking 0 named SQL queries
[DEBUG] 2017-05-24: 21:06:51 org.hibernate.stat.internal.StatisticsInitiator.initiateServiceInternal(StatisticsInitiator.java:110) :  Statistics initialized [enabled=false]
[DEBUG] 2017-05-24: 21:06:51 org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:251) :  Returning cached instance of singleton bean 'org.springframework.transaction.config.internalTransactionAdvisor'
[DEBUG] 2017-05-24: 21:06:51 org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:484) :  Finished creating instance of bean 'sessionFactory'
[DEBUG] 2017-05-24: 21:06:51 org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:251) :  Returning cached instance of singleton bean 'org.springframework.transaction.config.internalTransactionAdvisor'
[DEBUG] 2017-05-24: 21:06:51 org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.invokeInitMethods(AbstractAutowireCapableBeanFactory.java:1625) :  Invoking afterPropertiesSet() on bean with name 'userDao'
[DEBUG] 2017-05-24: 21:06:51 org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:251) :  Returning cached instance of singleton bean 'org.springframework.transaction.config.internalTransactionAdvisor'
[DEBUG] 2017-05-24: 21:06:51 org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:484) :  Finished creating instance of bean 'userDao'
[DEBUG] 2017-05-24: 21:06:51 org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor.registerDependentBeans(AutowiredAnnotationBeanPostProcessor.java:516) :  Autowiring by type from bean name 'userService' to bean named 'userDao'
[DEBUG] 2017-05-24: 21:06:51 org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:251) :  Returning cached instance of singleton bean 'org.springframework.transaction.config.internalTransactionAdvisor'
[DEBUG] 2017-05-24: 21:06:51 org.springframework.transaction.interceptor.AbstractFallbackTransactionAttributeSource.getTransactionAttribute(AbstractFallbackTransactionAttributeSource.java:108) :  Adding transactional method 'UserServiceImpl.getTotal' with attribute: PROPAGATION_REQUIRED,ISOLATION_DEFAULT; ''
[DEBUG] 2017-05-24: 21:06:51 org.springframework.aop.framework.autoproxy.AbstractAutoProxyCreator.buildAdvisors(AbstractAutoProxyCreator.java:528) :  Creating implicit proxy for bean 'userService' with 0 common interceptors and 1 specific interceptors
[DEBUG] 2017-05-24: 21:06:51 org.springframework.aop.framework.JdkDynamicAopProxy.getProxy(JdkDynamicAopProxy.java:118) :  Creating JDK dynamic proxy: target source is SingletonTargetSource for target object [com.ittx.usermanager.service.impl.UserServiceImpl@94d976]
[DEBUG] 2017-05-24: 21:06:51 org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:484) :  Finished creating instance of bean 'userService'
[DEBUG] 2017-05-24: 21:06:51 org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor.registerDependentBeans(AutowiredAnnotationBeanPostProcessor.java:516) :  Autowiring by type from bean name 'userAction' to bean named 'userService'
[DEBUG] 2017-05-24: 21:06:51 org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:251) :  Returning cached instance of singleton bean 'org.springframework.transaction.config.internalTransactionAdvisor'
[DEBUG] 2017-05-24: 21:06:51 org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:484) :  Finished creating instance of bean 'userAction'
[DEBUG] 2017-05-24: 21:06:51 org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:251) :  Returning cached instance of singleton bean 'userDao'
[DEBUG] 2017-05-24: 21:06:51 org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:251) :  Returning cached instance of singleton bean 'userService'
[DEBUG] 2017-05-24: 21:06:51 org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:251) :  Returning cached instance of singleton bean 'org.springframework.context.annotation.internalConfigurationAnnotationProcessor'
[DEBUG] 2017-05-24: 21:06:51 org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:251) :  Returning cached instance of singleton bean 'org.springframework.context.annotation.internalAutowiredAnnotationProcessor'
[DEBUG] 2017-05-24: 21:06:51 org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:251) :  Returning cached instance of singleton bean 'org.springframework.context.annotation.internalRequiredAnnotationProcessor'
[DEBUG] 2017-05-24: 21:06:51 org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:251) :  Returning cached instance of singleton bean 'org.springframework.context.annotation.internalCommonAnnotationProcessor'
[DEBUG] 2017-05-24: 21:06:51 org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:251) :  Returning cached instance of singleton bean 'org.springframework.context.annotation.internalPersistenceAnnotationProcessor'
[DEBUG] 2017-05-24: 21:06:51 org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:221) :  Creating shared instance of singleton bean 'org.springframework.context.event.internalEventListenerProcessor'
[DEBUG] 2017-05-24: 21:06:51 org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:448) :  Creating instance of bean 'org.springframework.context.event.internalEventListenerProcessor'
[DEBUG] 2017-05-24: 21:06:51 org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:529) :  Eagerly caching bean 'org.springframework.context.event.internalEventListenerProcessor' to allow for resolving potential circular references
[DEBUG] 2017-05-24: 21:06:51 org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:251) :  Returning cached instance of singleton bean 'org.springframework.transaction.config.internalTransactionAdvisor'
[DEBUG] 2017-05-24: 21:06:51 org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:484) :  Finished creating instance of bean 'org.springframework.context.event.internalEventListenerProcessor'
[DEBUG] 2017-05-24: 21:06:51 org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:221) :  Creating shared instance of singleton bean 'org.springframework.context.event.internalEventListenerFactory'
[DEBUG] 2017-05-24: 21:06:51 org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:448) :  Creating instance of bean 'org.springframework.context.event.internalEventListenerFactory'
[DEBUG] 2017-05-24: 21:06:51 org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:529) :  Eagerly caching bean 'org.springframework.context.event.internalEventListenerFactory' to allow for resolving potential circular references
[DEBUG] 2017-05-24: 21:06:51 org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:251) :  Returning cached instance of singleton bean 'org.springframework.transaction.config.internalTransactionAdvisor'
[DEBUG] 2017-05-24: 21:06:51 org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:484) :  Finished creating instance of bean 'org.springframework.context.event.internalEventListenerFactory'
[DEBUG] 2017-05-24: 21:06:51 org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:251) :  Returning cached instance of singleton bean 'org.springframework.context.support.PropertySourcesPlaceholderConfigurer#0'
[DEBUG] 2017-05-24: 21:06:51 org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:251) :  Returning cached instance of singleton bean 'dataSource'
[DEBUG] 2017-05-24: 21:06:51 org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:251) :  Returning cached instance of singleton bean 'sessionFactory'
[DEBUG] 2017-05-24: 21:06:51 org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:221) :  Creating shared instance of singleton bean 'transactionManager'
[DEBUG] 2017-05-24: 21:06:51 org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:448) :  Creating instance of bean 'transactionManager'
[DEBUG] 2017-05-24: 21:06:51 org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:529) :  Eagerly caching bean 'transactionManager' to allow for resolving potential circular references
[DEBUG] 2017-05-24: 21:06:51 org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:251) :  Returning cached instance of singleton bean 'sessionFactory'
[DEBUG] 2017-05-24: 21:06:51 org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.invokeInitMethods(AbstractAutowireCapableBeanFactory.java:1625) :  Invoking afterPropertiesSet() on bean with name 'transactionManager'
[INFO] 2017-05-24: 21:06:51 org.springframework.orm.hibernate4.HibernateTransactionManager.afterPropertiesSet(HibernateTransactionManager.java:360) :  Using DataSource [org.springframework.jdbc.datasource.DriverManagerDataSource@ee32c6] of Hibernate SessionFactory for HibernateTransactionManager
[DEBUG] 2017-05-24: 21:06:51 org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:251) :  Returning cached instance of singleton bean 'org.springframework.transaction.config.internalTransactionAdvisor'
[DEBUG] 2017-05-24: 21:06:51 org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:484) :  Finished creating instance of bean 'transactionManager'
[DEBUG] 2017-05-24: 21:06:51 org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:221) :  Creating shared instance of singleton bean 'org.springframework.transaction.config.internalTransactionalEventListenerFactory'
[DEBUG] 2017-05-24: 21:06:51 org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:448) :  Creating instance of bean 'org.springframework.transaction.config.internalTransactionalEventListenerFactory'
[DEBUG] 2017-05-24: 21:06:51 org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:529) :  Eagerly caching bean 'org.springframework.transaction.config.internalTransactionalEventListenerFactory' to allow for resolving potential circular references
[DEBUG] 2017-05-24: 21:06:51 org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:251) :  Returning cached instance of singleton bean 'org.springframework.transaction.config.internalTransactionAdvisor'
[DEBUG] 2017-05-24: 21:06:51 org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:484) :  Finished creating instance of bean 'org.springframework.transaction.config.internalTransactionalEventListenerFactory'
[DEBUG] 2017-05-24: 21:06:51 org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:251) :  Returning cached instance of singleton bean 'org.springframework.aop.config.internalAutoProxyCreator'
[DEBUG] 2017-05-24: 21:06:51 org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:251) :  Returning cached instance of singleton bean 'org.springframework.transaction.annotation.AnnotationTransactionAttributeSource#0'
[DEBUG] 2017-05-24: 21:06:51 org.springframework.beans.factory.support.DefaultSingletonBeanRegistry.getSingleton(DefaultSingletonBeanRegistry.java:221) :  Creating shared instance of singleton bean 'org.springframework.transaction.interceptor.TransactionInterceptor#0'
[DEBUG] 2017-05-24: 21:06:51 org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:448) :  Creating instance of bean 'org.springframework.transaction.interceptor.TransactionInterceptor#0'
[DEBUG] 2017-05-24: 21:06:51 org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.doCreateBean(AbstractAutowireCapableBeanFactory.java:529) :  Eagerly caching bean 'org.springframework.transaction.interceptor.TransactionInterceptor#0' to allow for resolving potential circular references
[DEBUG] 2017-05-24: 21:06:51 org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:251) :  Returning cached instance of singleton bean 'org.springframework.transaction.annotation.AnnotationTransactionAttributeSource#0'
[DEBUG] 2017-05-24: 21:06:51 org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.invokeInitMethods(AbstractAutowireCapableBeanFactory.java:1625) :  Invoking afterPropertiesSet() on bean with name 'org.springframework.transaction.interceptor.TransactionInterceptor#0'
[DEBUG] 2017-05-24: 21:06:51 org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.createBean(AbstractAutowireCapableBeanFactory.java:484) :  Finished creating instance of bean 'org.springframework.transaction.interceptor.TransactionInterceptor#0'
[DEBUG] 2017-05-24: 21:06:51 org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:251) :  Returning cached instance of singleton bean 'org.springframework.transaction.config.internalTransactionAdvisor'
[DEBUG] 2017-05-24: 21:06:51 org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:251) :  Returning cached instance of singleton bean 'org.springframework.context.annotation.ConfigurationClassPostProcessor.importAwareProcessor'
[DEBUG] 2017-05-24: 21:06:51 org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:251) :  Returning cached instance of singleton bean 'org.springframework.context.annotation.ConfigurationClassPostProcessor.enhancedConfigurationProcessor'
[DEBUG] 2017-05-24: 21:06:51 org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:251) :  Returning cached instance of singleton bean 'org.springframework.context.event.internalEventListenerFactory'
[DEBUG] 2017-05-24: 21:06:51 org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:251) :  Returning cached instance of singleton bean 'org.springframework.transaction.config.internalTransactionalEventListenerFactory'
[DEBUG] 2017-05-24: 21:06:51 org.springframework.context.support.AbstractApplicationContext.initLifecycleProcessor(AbstractApplicationContext.java:779) :  Unable to locate LifecycleProcessor with name 'lifecycleProcessor': using default [org.springframework.context.support.DefaultLifecycleProcessor@1bf351e]
[DEBUG] 2017-05-24: 21:06:51 org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:251) :  Returning cached instance of singleton bean 'lifecycleProcessor'
[DEBUG] 2017-05-24: 21:06:51 org.springframework.jndi.JndiTemplate.lookup(JndiTemplate.java:150) :  Looking up JNDI object with name [java:comp/env/spring.liveBeansView.mbeanDomain]
[DEBUG] 2017-05-24: 21:06:51 org.springframework.jndi.JndiLocatorSupport.lookup(JndiLocatorSupport.java:101) :  Converted JNDI name [java:comp/env/spring.liveBeansView.mbeanDomain] not found - trying original name [spring.liveBeansView.mbeanDomain]. javax.naming.NameNotFoundException; remaining name 'spring.liveBeansView.mbeanDomain'
[DEBUG] 2017-05-24: 21:06:51 org.springframework.jndi.JndiTemplate.lookup(JndiTemplate.java:150) :  Looking up JNDI object with name [spring.liveBeansView.mbeanDomain]
[DEBUG] 2017-05-24: 21:06:51 org.springframework.jndi.JndiPropertySource.getProperty(JndiPropertySource.java:99) :  JNDI lookup for name [spring.liveBeansView.mbeanDomain] threw NamingException with message: null. Returning null.
[DEBUG] 2017-05-24: 21:06:51 org.springframework.core.env.PropertySourcesPropertyResolver.getProperty(PropertySourcesPropertyResolver.java:91) :  Could not find key 'spring.liveBeansView.mbeanDomain' in any property source
[DEBUG] 2017-05-24: 21:06:51 org.springframework.web.context.ContextLoader.initWebApplicationContext(ContextLoader.java:340) :  Published root WebApplicationContext as ServletContext attribute with name [org.springframework.web.context.WebApplicationContext.ROOT]
[INFO] 2017-05-24: 21:06:51 org.springframework.web.context.ContextLoader.initWebApplicationContext(ContextLoader.java:345) :  Root WebApplicationContext: initialization completed in 2646 ms
[DEBUG] 2017-05-24: 21:06:52 org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:251) :  Returning cached instance of singleton bean 'org.springframework.transaction.config.internalTransactionAdvisor'
[DEBUG] 2017-05-24: 21:06:52 org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:251) :  Returning cached instance of singleton bean 'org.springframework.transaction.config.internalTransactionAdvisor'
[DEBUG] 2017-05-24: 21:06:52 org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:251) :  Returning cached instance of singleton bean 'org.springframework.transaction.config.internalTransactionAdvisor'
[DEBUG] 2017-05-24: 21:06:52 org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:251) :  Returning cached instance of singleton bean 'org.springframework.transaction.config.internalTransactionAdvisor'
[DEBUG] 2017-05-24: 21:06:52 org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:251) :  Returning cached instance of singleton bean 'org.springframework.transaction.config.internalTransactionAdvisor'
[DEBUG] 2017-05-24: 21:06:52 org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:251) :  Returning cached instance of singleton bean 'org.springframework.transaction.config.internalTransactionAdvisor'
[DEBUG] 2017-05-24: 21:06:52 org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:251) :  Returning cached instance of singleton bean 'org.springframework.transaction.config.internalTransactionAdvisor'
[DEBUG] 2017-05-24: 21:06:52 org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:251) :  Returning cached instance of singleton bean 'org.springframework.transaction.config.internalTransactionAdvisor'
[DEBUG] 2017-05-24: 21:06:52 org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:251) :  Returning cached instance of singleton bean 'org.springframework.transaction.config.internalTransactionAdvisor'
[DEBUG] 2017-05-24: 21:06:52 org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:251) :  Returning cached instance of singleton bean 'org.springframework.transaction.config.internalTransactionAdvisor'
[DEBUG] 2017-05-24: 21:06:52 org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:251) :  Returning cached instance of singleton bean 'org.springframework.transaction.config.internalTransactionAdvisor'
[DEBUG] 2017-05-24: 21:06:52 org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:251) :  Returning cached instance of singleton bean 'org.springframework.transaction.config.internalTransactionAdvisor'
[DEBUG] 2017-05-24: 21:06:52 org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:251) :  Returning cached instance of singleton bean 'org.springframework.transaction.config.internalTransactionAdvisor'
[DEBUG] 2017-05-24: 21:06:52 org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:251) :  Returning cached instance of singleton bean 'org.springframework.transaction.config.internalTransactionAdvisor'
[DEBUG] 2017-05-24: 21:06:52 org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:251) :  Returning cached instance of singleton bean 'org.springframework.transaction.config.internalTransactionAdvisor'
[DEBUG] 2017-05-24: 21:06:52 org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:251) :  Returning cached instance of singleton bean 'org.springframework.transaction.config.internalTransactionAdvisor'
[DEBUG] 2017-05-24: 21:06:52 org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:251) :  Returning cached instance of singleton bean 'org.springframework.transaction.config.internalTransactionAdvisor'
[DEBUG] 2017-05-24: 21:06:52 org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:251) :  Returning cached instance of singleton bean 'org.springframework.transaction.config.internalTransactionAdvisor'
[DEBUG] 2017-05-24: 21:06:52 org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:251) :  Returning cached instance of singleton bean 'org.springframework.transaction.config.internalTransactionAdvisor'
[DEBUG] 2017-05-24: 21:06:52 org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:251) :  Returning cached instance of singleton bean 'org.springframework.transaction.config.internalTransactionAdvisor'
[DEBUG] 2017-05-24: 21:06:52 org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:251) :  Returning cached instance of singleton bean 'org.springframework.transaction.config.internalTransactionAdvisor'
[DEBUG] 2017-05-24: 21:06:52 org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:251) :  Returning cached instance of singleton bean 'org.springframework.transaction.config.internalTransactionAdvisor'
[DEBUG] 2017-05-24: 21:06:52 org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:251) :  Returning cached instance of singleton bean 'org.springframework.transaction.config.internalTransactionAdvisor'
[DEBUG] 2017-05-24: 21:06:52 org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:251) :  Returning cached instance of singleton bean 'org.springframework.transaction.config.internalTransactionAdvisor'
[DEBUG] 2017-05-24: 21:06:52 org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:251) :  Returning cached instance of singleton bean 'org.springframework.transaction.config.internalTransactionAdvisor'
[DEBUG] 2017-05-24: 21:06:52 org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:251) :  Returning cached instance of singleton bean 'org.springframework.transaction.config.internalTransactionAdvisor'
[DEBUG] 2017-05-24: 21:06:52 org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:251) :  Returning cached instance of singleton bean 'org.springframework.transaction.config.internalTransactionAdvisor'
[DEBUG] 2017-05-24: 21:06:52 org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:251) :  Returning cached instance of singleton bean 'org.springframework.transaction.config.internalTransactionAdvisor'
[DEBUG] 2017-05-24: 21:06:52 org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:251) :  Returning cached instance of singleton bean 'org.springframework.transaction.config.internalTransactionAdvisor'
[DEBUG] 2017-05-24: 21:06:52 org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:251) :  Returning cached instance of singleton bean 'org.springframework.transaction.config.internalTransactionAdvisor'
[DEBUG] 2017-05-24: 21:06:52 org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:251) :  Returning cached instance of singleton bean 'org.springframework.transaction.config.internalTransactionAdvisor'
[DEBUG] 2017-05-24: 21:06:52 org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:251) :  Returning cached instance of singleton bean 'org.springframework.transaction.config.internalTransactionAdvisor'
[DEBUG] 2017-05-24: 21:06:52 org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:251) :  Returning cached instance of singleton bean 'org.springframework.transaction.config.internalTransactionAdvisor'
[DEBUG] 2017-05-24: 21:06:52 org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:251) :  Returning cached instance of singleton bean 'org.springframework.transaction.config.internalTransactionAdvisor'
[DEBUG] 2017-05-24: 21:06:52 org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:251) :  Returning cached instance of singleton bean 'org.springframework.transaction.config.internalTransactionAdvisor'
[DEBUG] 2017-05-24: 21:06:52 org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:251) :  Returning cached instance of singleton bean 'org.springframework.transaction.config.internalTransactionAdvisor'
[DEBUG] 2017-05-24: 21:06:52 org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:251) :  Returning cached instance of singleton bean 'org.springframework.transaction.config.internalTransactionAdvisor'
[DEBUG] 2017-05-24: 21:06:56 org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:251) :  Returning cached instance of singleton bean 'org.springframework.transaction.config.internalTransactionAdvisor'
[DEBUG] 2017-05-24: 21:06:56 org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:251) :  Returning cached instance of singleton bean 'servletContext'
[DEBUG] 2017-05-24: 21:06:56 org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory.autowireByName(AbstractAutowireCapableBeanFactory.java:1253) :  Added autowiring by name from bean name 'com.ittx.usermanager.action.LoginAction' via property 'servletContext' to bean named 'servletContext'
[DEBUG] 2017-05-24: 21:06:56 com.ittx.usermanager.action.LoginAction.validate(LoginAction.java:39) :  validte >>>>
[DEBUG] 2017-05-24: 21:06:56 org.springframework.beans.factory.support.AbstractBeanFactory.doGetBean(AbstractBeanFactory.java:251) :  Returning cached instance of singleton bean 'org.springframework.transaction.config.internalTransactionAdvisor'
